--- GENERATED CODE - DO NOT MODIFY
-- Amazon Elastic Compute Cloud (ec2-2016-11-15)

local M = {}

M.metadata = {
	api_version = "2016-11-15",
	json_version = "",
	protocol = "ec2",
	checksum_format = "",
	endpoint_prefix = "ec2",
	service_abbreviation = "Amazon EC2",
	service_full_name = "Amazon Elastic Compute Cloud",
	signature_version = "v4",
	target_prefix = "",
	timestamp_format = "",
	global_endpoint = "",
	uid = "ec2-2016-11-15",
}

local keys = {}
local asserts = {}

keys.NetworkAcl = { ["Associations"] = true, ["NetworkAclId"] = true, ["VpcId"] = true, ["Tags"] = true, ["Entries"] = true, ["IsDefault"] = true, nil }

function asserts.AssertNetworkAcl(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAcl to be of type 'table'")
	if struct["Associations"] then asserts.AssertNetworkAclAssociationList(struct["Associations"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Entries"] then asserts.AssertNetworkAclEntryList(struct["Entries"]) end
	if struct["IsDefault"] then asserts.AssertBoolean(struct["IsDefault"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkAcl[k], "NetworkAcl contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAcl
-- <p>Describes a network ACL.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Associations [NetworkAclAssociationList] <p>Any associations between the network ACL and one or more subnets</p>
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * VpcId [String] <p>The ID of the VPC for the network ACL.</p>
-- * Tags [TagList] <p>Any tags assigned to the network ACL.</p>
-- * Entries [NetworkAclEntryList] <p>One or more entries (rules) in the network ACL.</p>
-- * IsDefault [Boolean] <p>Indicates whether this is the default network ACL for the VPC.</p>
-- @return NetworkAcl structure as a key-value pair table
function M.NetworkAcl(args)
	assert(args, "You must provdide an argument table when creating NetworkAcl")
	local t = { 
		["Associations"] = args["Associations"],
		["NetworkAclId"] = args["NetworkAclId"],
		["VpcId"] = args["VpcId"],
		["Tags"] = args["Tags"],
		["Entries"] = args["Entries"],
		["IsDefault"] = args["IsDefault"],
	}
	asserts.AssertNetworkAcl(t)
	return t
end

keys.CreateSecurityGroupResult = { ["GroupId"] = true, nil }

function asserts.AssertCreateSecurityGroupResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityGroupResult to be of type 'table'")
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSecurityGroupResult[k], "CreateSecurityGroupResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityGroupResult
-- <p>Contains the output of CreateSecurityGroup.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupId [String] <p>The ID of the security group.</p>
-- @return CreateSecurityGroupResult structure as a key-value pair table
function M.CreateSecurityGroupResult(args)
	assert(args, "You must provdide an argument table when creating CreateSecurityGroupResult")
	local t = { 
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertCreateSecurityGroupResult(t)
	return t
end

keys.CreateFpgaImageResult = { ["FpgaImageId"] = true, ["FpgaImageGlobalId"] = true, nil }

function asserts.AssertCreateFpgaImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFpgaImageResult to be of type 'table'")
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["FpgaImageGlobalId"] then asserts.AssertString(struct["FpgaImageGlobalId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFpgaImageResult[k], "CreateFpgaImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFpgaImageResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImageId [String] <p>The FPGA image identifier (AFI ID).</p>
-- * FpgaImageGlobalId [String] <p>The global FPGA image identifier (AGFI ID).</p>
-- @return CreateFpgaImageResult structure as a key-value pair table
function M.CreateFpgaImageResult(args)
	assert(args, "You must provdide an argument table when creating CreateFpgaImageResult")
	local t = { 
		["FpgaImageId"] = args["FpgaImageId"],
		["FpgaImageGlobalId"] = args["FpgaImageGlobalId"],
	}
	asserts.AssertCreateFpgaImageResult(t)
	return t
end

keys.VpcCidrBlockState = { ["State"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertVpcCidrBlockState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcCidrBlockState to be of type 'table'")
	if struct["State"] then asserts.AssertVpcCidrBlockStateCode(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcCidrBlockState[k], "VpcCidrBlockState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcCidrBlockState
-- <p>Describes the state of a CIDR block.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [VpcCidrBlockStateCode] <p>The state of the CIDR block.</p>
-- * StatusMessage [String] <p>A message about the status of the CIDR block, if applicable.</p>
-- @return VpcCidrBlockState structure as a key-value pair table
function M.VpcCidrBlockState(args)
	assert(args, "You must provdide an argument table when creating VpcCidrBlockState")
	local t = { 
		["State"] = args["State"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertVpcCidrBlockState(t)
	return t
end

keys.InstanceBlockDeviceMapping = { ["DeviceName"] = true, ["Ebs"] = true, nil }

function asserts.AssertInstanceBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceBlockDeviceMapping to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["Ebs"] then asserts.AssertEbsInstanceBlockDevice(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceBlockDeviceMapping[k], "InstanceBlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceBlockDeviceMapping
-- <p>Describes a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * Ebs [EbsInstanceBlockDevice] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
-- @return InstanceBlockDeviceMapping structure as a key-value pair table
function M.InstanceBlockDeviceMapping(args)
	assert(args, "You must provdide an argument table when creating InstanceBlockDeviceMapping")
	local t = { 
		["DeviceName"] = args["DeviceName"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertInstanceBlockDeviceMapping(t)
	return t
end

keys.ImportInstanceTaskDetails = { ["InstanceId"] = true, ["Platform"] = true, ["Description"] = true, ["Volumes"] = true, nil }

function asserts.AssertImportInstanceTaskDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceTaskDetails to be of type 'table'")
	assert(struct["Volumes"], "Expected key Volumes to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Volumes"] then asserts.AssertImportInstanceVolumeDetailSet(struct["Volumes"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceTaskDetails[k], "ImportInstanceTaskDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceTaskDetails
-- <p>Describes an import instance task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Platform [PlatformValues] <p>The instance operating system.</p>
-- * Description [String] <p>A description of the task.</p>
-- * Volumes [ImportInstanceVolumeDetailSet] <p>One or more volumes.</p>
-- Required key: Volumes
-- @return ImportInstanceTaskDetails structure as a key-value pair table
function M.ImportInstanceTaskDetails(args)
	assert(args, "You must provdide an argument table when creating ImportInstanceTaskDetails")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["Platform"] = args["Platform"],
		["Description"] = args["Description"],
		["Volumes"] = args["Volumes"],
	}
	asserts.AssertImportInstanceTaskDetails(t)
	return t
end

keys.DescribeVpnConnectionsResult = { ["VpnConnections"] = true, nil }

function asserts.AssertDescribeVpnConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnConnectionsResult to be of type 'table'")
	if struct["VpnConnections"] then asserts.AssertVpnConnectionList(struct["VpnConnections"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnConnectionsResult[k], "DescribeVpnConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnConnectionsResult
-- <p>Contains the output of DescribeVpnConnections.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnections [VpnConnectionList] <p>Information about one or more VPN connections.</p>
-- @return DescribeVpnConnectionsResult structure as a key-value pair table
function M.DescribeVpnConnectionsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVpnConnectionsResult")
	local t = { 
		["VpnConnections"] = args["VpnConnections"],
	}
	asserts.AssertDescribeVpnConnectionsResult(t)
	return t
end

keys.ReservedInstancesConfiguration = { ["Platform"] = true, ["AvailabilityZone"] = true, ["Scope"] = true, ["InstanceType"] = true, ["InstanceCount"] = true, nil }

function asserts.AssertReservedInstancesConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesConfiguration to be of type 'table'")
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Scope"] then asserts.Assertscope(struct["Scope"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesConfiguration[k], "ReservedInstancesConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesConfiguration
-- <p>Describes the configuration settings for the modified Reserved Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Platform [String] <p>The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the modified Reserved Instances.</p>
-- * Scope [scope] <p>Whether the Reserved Instance is applied to instances in a region or instances in a specific Availability Zone.</p>
-- * InstanceType [InstanceType] <p>The instance type for the modified Reserved Instances.</p>
-- * InstanceCount [Integer] <p>The number of modified Reserved Instances.</p>
-- @return ReservedInstancesConfiguration structure as a key-value pair table
function M.ReservedInstancesConfiguration(args)
	assert(args, "You must provdide an argument table when creating ReservedInstancesConfiguration")
	local t = { 
		["Platform"] = args["Platform"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Scope"] = args["Scope"],
		["InstanceType"] = args["InstanceType"],
		["InstanceCount"] = args["InstanceCount"],
	}
	asserts.AssertReservedInstancesConfiguration(t)
	return t
end

keys.CreateVpcPeeringConnectionRequest = { ["VpcId"] = true, ["PeerOwnerId"] = true, ["PeerVpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcPeeringConnectionRequest to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PeerOwnerId"] then asserts.AssertString(struct["PeerOwnerId"]) end
	if struct["PeerVpcId"] then asserts.AssertString(struct["PeerVpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcPeeringConnectionRequest[k], "CreateVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcPeeringConnectionRequest
-- <p>Contains the parameters for CreateVpcPeeringConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the requester VPC.</p>
-- * PeerOwnerId [String] <p>The AWS account ID of the owner of the peer VPC.</p> <p>Default: Your AWS account ID</p>
-- * PeerVpcId [String] <p>The ID of the VPC with which you are creating the VPC peering connection.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return CreateVpcPeeringConnectionRequest structure as a key-value pair table
function M.CreateVpcPeeringConnectionRequest(args)
	assert(args, "You must provdide an argument table when creating CreateVpcPeeringConnectionRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["PeerOwnerId"] = args["PeerOwnerId"],
		["PeerVpcId"] = args["PeerVpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateVpcPeeringConnectionRequest(t)
	return t
end

keys.DeleteVpnConnectionRouteRequest = { ["VpnConnectionId"] = true, ["DestinationCidrBlock"] = true, nil }

function asserts.AssertDeleteVpnConnectionRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnConnectionRouteRequest to be of type 'table'")
	assert(struct["DestinationCidrBlock"], "Expected key DestinationCidrBlock to exist in table")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpnConnectionRouteRequest[k], "DeleteVpnConnectionRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnConnectionRouteRequest
-- <p>Contains the parameters for DeleteVpnConnectionRoute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- * DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer network.</p>
-- Required key: DestinationCidrBlock
-- Required key: VpnConnectionId
-- @return DeleteVpnConnectionRouteRequest structure as a key-value pair table
function M.DeleteVpnConnectionRouteRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteVpnConnectionRouteRequest")
	local t = { 
		["VpnConnectionId"] = args["VpnConnectionId"],
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
	}
	asserts.AssertDeleteVpnConnectionRouteRequest(t)
	return t
end

keys.ScheduledInstancesNetworkInterface = { ["PrivateIpAddressConfigs"] = true, ["DeviceIndex"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["SubnetId"] = true, ["DeleteOnTermination"] = true, ["PrivateIpAddress"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, ["AssociatePublicIpAddress"] = true, ["SecondaryPrivateIpAddressCount"] = true, nil }

function asserts.AssertScheduledInstancesNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesNetworkInterface to be of type 'table'")
	if struct["PrivateIpAddressConfigs"] then asserts.AssertPrivateIpAddressConfigSet(struct["PrivateIpAddressConfigs"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then asserts.AssertScheduledInstancesSecurityGroupIdSet(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertScheduledInstancesIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then asserts.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesNetworkInterface[k], "ScheduledInstancesNetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesNetworkInterface
-- <p>Describes a network interface for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrivateIpAddressConfigs [PrivateIpAddressConfigSet] <p>The private IPv4 addresses.</p>
-- * DeviceIndex [Integer] <p>The index of the device for the network interface attachment.</p>
-- * Description [String] <p>The description.</p>
-- * Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.</p>
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether to delete the interface when the instance is terminated.</p>
-- * PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- * Groups [ScheduledInstancesSecurityGroupIdSet] <p>The IDs of one or more security groups.</p>
-- * Ipv6Addresses [ScheduledInstancesIpv6AddressList] <p>One or more specific IPv6 addresses from the subnet range.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * AssociatePublicIpAddress [Boolean] <p>Indicates whether to assign a public IPv4 address to instances launched in a VPC. The public IPv4 address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses.</p>
-- @return ScheduledInstancesNetworkInterface structure as a key-value pair table
function M.ScheduledInstancesNetworkInterface(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstancesNetworkInterface")
	local t = { 
		["PrivateIpAddressConfigs"] = args["PrivateIpAddressConfigs"],
		["DeviceIndex"] = args["DeviceIndex"],
		["Description"] = args["Description"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["SubnetId"] = args["SubnetId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AssociatePublicIpAddress"] = args["AssociatePublicIpAddress"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
	}
	asserts.AssertScheduledInstancesNetworkInterface(t)
	return t
end

keys.GetPasswordDataRequest = { ["InstanceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertGetPasswordDataRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPasswordDataRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPasswordDataRequest[k], "GetPasswordDataRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPasswordDataRequest
-- <p>Contains the parameters for GetPasswordData.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the Windows instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- @return GetPasswordDataRequest structure as a key-value pair table
function M.GetPasswordDataRequest(args)
	assert(args, "You must provdide an argument table when creating GetPasswordDataRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertGetPasswordDataRequest(t)
	return t
end

keys.DescribeImagesResult = { ["Images"] = true, nil }

function asserts.AssertDescribeImagesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImagesResult to be of type 'table'")
	if struct["Images"] then asserts.AssertImageList(struct["Images"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImagesResult[k], "DescribeImagesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImagesResult
-- <p>Contains the output of DescribeImages.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Images [ImageList] <p>Information about one or more images.</p>
-- @return DescribeImagesResult structure as a key-value pair table
function M.DescribeImagesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeImagesResult")
	local t = { 
		["Images"] = args["Images"],
	}
	asserts.AssertDescribeImagesResult(t)
	return t
end

keys.PurchaseScheduledInstancesResult = { ["ScheduledInstanceSet"] = true, nil }

function asserts.AssertPurchaseScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseScheduledInstancesResult to be of type 'table'")
	if struct["ScheduledInstanceSet"] then asserts.AssertPurchasedScheduledInstanceSet(struct["ScheduledInstanceSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseScheduledInstancesResult[k], "PurchaseScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseScheduledInstancesResult
-- <p>Contains the output of PurchaseScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ScheduledInstanceSet [PurchasedScheduledInstanceSet] <p>Information about the Scheduled Instances.</p>
-- @return PurchaseScheduledInstancesResult structure as a key-value pair table
function M.PurchaseScheduledInstancesResult(args)
	assert(args, "You must provdide an argument table when creating PurchaseScheduledInstancesResult")
	local t = { 
		["ScheduledInstanceSet"] = args["ScheduledInstanceSet"],
	}
	asserts.AssertPurchaseScheduledInstancesResult(t)
	return t
end

keys.Host = { ["HostId"] = true, ["HostProperties"] = true, ["State"] = true, ["Instances"] = true, ["HostReservationId"] = true, ["AvailabilityZone"] = true, ["AvailableCapacity"] = true, ["ClientToken"] = true, ["AutoPlacement"] = true, nil }

function asserts.AssertHost(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Host to be of type 'table'")
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["HostProperties"] then asserts.AssertHostProperties(struct["HostProperties"]) end
	if struct["State"] then asserts.AssertAllocationState(struct["State"]) end
	if struct["Instances"] then asserts.AssertHostInstanceList(struct["Instances"]) end
	if struct["HostReservationId"] then asserts.AssertString(struct["HostReservationId"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["AvailableCapacity"] then asserts.AssertAvailableCapacity(struct["AvailableCapacity"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["AutoPlacement"] then asserts.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(keys.Host[k], "Host contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Host
-- <p>Describes the properties of the Dedicated Host.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostId [String] <p>The ID of the Dedicated Host.</p>
-- * HostProperties [HostProperties] <p>The hardware specifications of the Dedicated Host.</p>
-- * State [AllocationState] <p>The Dedicated Host's state.</p>
-- * Instances [HostInstanceList] <p>The IDs and instance type that are currently running on the Dedicated Host.</p>
-- * HostReservationId [String] <p>The reservation ID of the Dedicated Host. This returns a <code>null</code> response if the Dedicated Host doesn't have an associated reservation.</p>
-- * AvailabilityZone [String] <p>The Availability Zone of the Dedicated Host.</p>
-- * AvailableCapacity [AvailableCapacity] <p>The number of new instances that can be launched onto the Dedicated Host.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. </p>
-- * AutoPlacement [AutoPlacement] <p>Whether auto-placement is on or off.</p>
-- @return Host structure as a key-value pair table
function M.Host(args)
	assert(args, "You must provdide an argument table when creating Host")
	local t = { 
		["HostId"] = args["HostId"],
		["HostProperties"] = args["HostProperties"],
		["State"] = args["State"],
		["Instances"] = args["Instances"],
		["HostReservationId"] = args["HostReservationId"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["AvailableCapacity"] = args["AvailableCapacity"],
		["ClientToken"] = args["ClientToken"],
		["AutoPlacement"] = args["AutoPlacement"],
	}
	asserts.AssertHost(t)
	return t
end

keys.CancelReservedInstancesListingRequest = { ["ReservedInstancesListingId"] = true, nil }

function asserts.AssertCancelReservedInstancesListingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelReservedInstancesListingRequest to be of type 'table'")
	assert(struct["ReservedInstancesListingId"], "Expected key ReservedInstancesListingId to exist in table")
	if struct["ReservedInstancesListingId"] then asserts.AssertString(struct["ReservedInstancesListingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelReservedInstancesListingRequest[k], "CancelReservedInstancesListingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelReservedInstancesListingRequest
-- <p>Contains the parameters for CancelReservedInstancesListing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesListingId [String] <p>The ID of the Reserved Instance listing.</p>
-- Required key: ReservedInstancesListingId
-- @return CancelReservedInstancesListingRequest structure as a key-value pair table
function M.CancelReservedInstancesListingRequest(args)
	assert(args, "You must provdide an argument table when creating CancelReservedInstancesListingRequest")
	local t = { 
		["ReservedInstancesListingId"] = args["ReservedInstancesListingId"],
	}
	asserts.AssertCancelReservedInstancesListingRequest(t)
	return t
end

keys.CreateSubnetResult = { ["Subnet"] = true, nil }

function asserts.AssertCreateSubnetResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSubnetResult to be of type 'table'")
	if struct["Subnet"] then asserts.AssertSubnet(struct["Subnet"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSubnetResult[k], "CreateSubnetResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSubnetResult
-- <p>Contains the output of CreateSubnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Subnet [Subnet] <p>Information about the subnet.</p>
-- @return CreateSubnetResult structure as a key-value pair table
function M.CreateSubnetResult(args)
	assert(args, "You must provdide an argument table when creating CreateSubnetResult")
	local t = { 
		["Subnet"] = args["Subnet"],
	}
	asserts.AssertCreateSubnetResult(t)
	return t
end

keys.DescribeTagsRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeTagsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeTagsRequest[k], "DescribeTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeTagsRequest
-- <p>Contains the parameters for DescribeTags.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>key</code> - The tag key.</p> </li> <li> <p> <code>resource-id</code> - The resource ID.</p> </li> <li> <p> <code>resource-type</code> - The resource type (<code>customer-gateway</code> | <code>dhcp-options</code> | <code>image</code> | <code>instance</code> | <code>internet-gateway</code> | <code>network-acl</code> | <code>network-interface</code> | <code>reserved-instances</code> | <code>route-table</code> | <code>security-group</code> | <code>snapshot</code> | <code>spot-instances-request</code> | <code>subnet</code> | <code>volume</code> | <code>vpc</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>).</p> </li> <li> <p> <code>value</code> - The tag value.</p> </li> </ul>
-- @return DescribeTagsRequest structure as a key-value pair table
function M.DescribeTagsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeTagsRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeTagsRequest(t)
	return t
end

keys.InstancePrivateIpAddress = { ["PrivateDnsName"] = true, ["PrivateIpAddress"] = true, ["Primary"] = true, ["Association"] = true, nil }

function asserts.AssertInstancePrivateIpAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstancePrivateIpAddress to be of type 'table'")
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["Association"] then asserts.AssertInstanceNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstancePrivateIpAddress[k], "InstancePrivateIpAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstancePrivateIpAddress
-- <p>Describes a private IPv4 address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrivateDnsName [String] <p>The private IPv4 DNS name.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 address of the network interface.</p>
-- * Primary [Boolean] <p>Indicates whether this IPv4 address is the primary private IP address of the network interface.</p>
-- * Association [InstanceNetworkInterfaceAssociation] <p>The association information for an Elastic IP address for the network interface.</p>
-- @return InstancePrivateIpAddress structure as a key-value pair table
function M.InstancePrivateIpAddress(args)
	assert(args, "You must provdide an argument table when creating InstancePrivateIpAddress")
	local t = { 
		["PrivateDnsName"] = args["PrivateDnsName"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Primary"] = args["Primary"],
		["Association"] = args["Association"],
	}
	asserts.AssertInstancePrivateIpAddress(t)
	return t
end

keys.CreateInstanceExportTaskRequest = { ["InstanceId"] = true, ["TargetEnvironment"] = true, ["Description"] = true, ["ExportToS3Task"] = true, nil }

function asserts.AssertCreateInstanceExportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInstanceExportTaskRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["TargetEnvironment"] then asserts.AssertExportEnvironment(struct["TargetEnvironment"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ExportToS3Task"] then asserts.AssertExportToS3TaskSpecification(struct["ExportToS3Task"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInstanceExportTaskRequest[k], "CreateInstanceExportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInstanceExportTaskRequest
-- <p>Contains the parameters for CreateInstanceExportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * TargetEnvironment [ExportEnvironment] <p>The target virtualization environment.</p>
-- * Description [String] <p>A description for the conversion task or the resource being exported. The maximum length is 255 bytes.</p>
-- * ExportToS3Task [ExportToS3TaskSpecification] <p>The format and location for an instance export task.</p>
-- Required key: InstanceId
-- @return CreateInstanceExportTaskRequest structure as a key-value pair table
function M.CreateInstanceExportTaskRequest(args)
	assert(args, "You must provdide an argument table when creating CreateInstanceExportTaskRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["TargetEnvironment"] = args["TargetEnvironment"],
		["Description"] = args["Description"],
		["ExportToS3Task"] = args["ExportToS3Task"],
	}
	asserts.AssertCreateInstanceExportTaskRequest(t)
	return t
end

keys.CreateInstanceExportTaskResult = { ["ExportTask"] = true, nil }

function asserts.AssertCreateInstanceExportTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInstanceExportTaskResult to be of type 'table'")
	if struct["ExportTask"] then asserts.AssertExportTask(struct["ExportTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInstanceExportTaskResult[k], "CreateInstanceExportTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInstanceExportTaskResult
-- <p>Contains the output for CreateInstanceExportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExportTask [ExportTask] <p>Information about the instance export task.</p>
-- @return CreateInstanceExportTaskResult structure as a key-value pair table
function M.CreateInstanceExportTaskResult(args)
	assert(args, "You must provdide an argument table when creating CreateInstanceExportTaskResult")
	local t = { 
		["ExportTask"] = args["ExportTask"],
	}
	asserts.AssertCreateInstanceExportTaskResult(t)
	return t
end

keys.RejectVpcPeeringConnectionRequest = { ["DryRun"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertRejectVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcPeeringConnectionRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RejectVpcPeeringConnectionRequest[k], "RejectVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcPeeringConnectionRequest
-- <p>Contains the parameters for RejectVpcPeeringConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required key: VpcPeeringConnectionId
-- @return RejectVpcPeeringConnectionRequest structure as a key-value pair table
function M.RejectVpcPeeringConnectionRequest(args)
	assert(args, "You must provdide an argument table when creating RejectVpcPeeringConnectionRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
	}
	asserts.AssertRejectVpcPeeringConnectionRequest(t)
	return t
end

keys.CopyImageResult = { ["ImageId"] = true, nil }

function asserts.AssertCopyImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyImageResult to be of type 'table'")
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopyImageResult[k], "CopyImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyImageResult
-- <p>Contains the output of CopyImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ImageId [String] <p>The ID of the new AMI.</p>
-- @return CopyImageResult structure as a key-value pair table
function M.CopyImageResult(args)
	assert(args, "You must provdide an argument table when creating CopyImageResult")
	local t = { 
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertCopyImageResult(t)
	return t
end

keys.Region = { ["Endpoint"] = true, ["RegionName"] = true, nil }

function asserts.AssertRegion(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Region to be of type 'table'")
	if struct["Endpoint"] then asserts.AssertString(struct["Endpoint"]) end
	if struct["RegionName"] then asserts.AssertString(struct["RegionName"]) end
	for k,_ in pairs(struct) do
		assert(keys.Region[k], "Region contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Region
-- <p>Describes a region.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Endpoint [String] <p>The region service endpoint.</p>
-- * RegionName [String] <p>The name of the region.</p>
-- @return Region structure as a key-value pair table
function M.Region(args)
	assert(args, "You must provdide an argument table when creating Region")
	local t = { 
		["Endpoint"] = args["Endpoint"],
		["RegionName"] = args["RegionName"],
	}
	asserts.AssertRegion(t)
	return t
end

keys.AllocateHostsRequest = { ["ClientToken"] = true, ["Quantity"] = true, ["AvailabilityZone"] = true, ["InstanceType"] = true, ["AutoPlacement"] = true, nil }

function asserts.AssertAllocateHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateHostsRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["InstanceType"], "Expected key InstanceType to exist in table")
	assert(struct["Quantity"], "Expected key Quantity to exist in table")
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["Quantity"] then asserts.AssertInteger(struct["Quantity"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["AutoPlacement"] then asserts.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateHostsRequest[k], "AllocateHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateHostsRequest
-- <p>Contains the parameters for AllocateHosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. </p>
-- * Quantity [Integer] <p>The number of Dedicated Hosts you want to allocate to your account with these parameters.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the Dedicated Hosts.</p>
-- * InstanceType [String] <p>Specify the instance type that you want your Dedicated Hosts to be configured for. When you specify the instance type, that is the only instance type that you can launch onto that host.</p>
-- * AutoPlacement [AutoPlacement] <p>This is enabled by default. This property allows instances to be automatically placed onto available Dedicated Hosts, when you are launching instances without specifying a host ID.</p> <p>Default: Enabled</p>
-- Required key: AvailabilityZone
-- Required key: InstanceType
-- Required key: Quantity
-- @return AllocateHostsRequest structure as a key-value pair table
function M.AllocateHostsRequest(args)
	assert(args, "You must provdide an argument table when creating AllocateHostsRequest")
	local t = { 
		["ClientToken"] = args["ClientToken"],
		["Quantity"] = args["Quantity"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["InstanceType"] = args["InstanceType"],
		["AutoPlacement"] = args["AutoPlacement"],
	}
	asserts.AssertAllocateHostsRequest(t)
	return t
end

keys.DescribeSpotFleetRequestHistoryResponse = { ["HistoryRecords"] = true, ["SpotFleetRequestId"] = true, ["NextToken"] = true, ["LastEvaluatedTime"] = true, ["StartTime"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestHistoryResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestHistoryResponse to be of type 'table'")
	assert(struct["HistoryRecords"], "Expected key HistoryRecords to exist in table")
	assert(struct["LastEvaluatedTime"], "Expected key LastEvaluatedTime to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["StartTime"], "Expected key StartTime to exist in table")
	if struct["HistoryRecords"] then asserts.AssertHistoryRecords(struct["HistoryRecords"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["LastEvaluatedTime"] then asserts.AssertDateTime(struct["LastEvaluatedTime"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestHistoryResponse[k], "DescribeSpotFleetRequestHistoryResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestHistoryResponse
-- <p>Contains the output of DescribeSpotFleetRequestHistory.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HistoryRecords [HistoryRecords] <p>Information about the events in the history of the Spot fleet request.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- * LastEvaluatedTime [DateTime] <p>The last date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). All records up to this time were retrieved.</p> <p>If <code>nextToken</code> indicates that there are more results, this value is not present.</p>
-- * StartTime [DateTime] <p>The starting date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- Required key: HistoryRecords
-- Required key: LastEvaluatedTime
-- Required key: SpotFleetRequestId
-- Required key: StartTime
-- @return DescribeSpotFleetRequestHistoryResponse structure as a key-value pair table
function M.DescribeSpotFleetRequestHistoryResponse(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotFleetRequestHistoryResponse")
	local t = { 
		["HistoryRecords"] = args["HistoryRecords"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["NextToken"] = args["NextToken"],
		["LastEvaluatedTime"] = args["LastEvaluatedTime"],
		["StartTime"] = args["StartTime"],
	}
	asserts.AssertDescribeSpotFleetRequestHistoryResponse(t)
	return t
end

keys.PurchaseReservedInstancesOfferingRequest = { ["ReservedInstancesOfferingId"] = true, ["InstanceCount"] = true, ["DryRun"] = true, ["LimitPrice"] = true, nil }

function asserts.AssertPurchaseReservedInstancesOfferingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseReservedInstancesOfferingRequest to be of type 'table'")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["ReservedInstancesOfferingId"], "Expected key ReservedInstancesOfferingId to exist in table")
	if struct["ReservedInstancesOfferingId"] then asserts.AssertString(struct["ReservedInstancesOfferingId"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["LimitPrice"] then asserts.AssertReservedInstanceLimitPrice(struct["LimitPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseReservedInstancesOfferingRequest[k], "PurchaseReservedInstancesOfferingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseReservedInstancesOfferingRequest
-- <p>Contains the parameters for PurchaseReservedInstancesOffering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesOfferingId [String] <p>The ID of the Reserved Instance offering to purchase.</p>
-- * InstanceCount [Integer] <p>The number of Reserved Instances to purchase.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * LimitPrice [ReservedInstanceLimitPrice] <p>Specified for Reserved Instance Marketplace offerings to limit the total order and ensure that the Reserved Instances are not purchased at unexpected prices.</p>
-- Required key: InstanceCount
-- Required key: ReservedInstancesOfferingId
-- @return PurchaseReservedInstancesOfferingRequest structure as a key-value pair table
function M.PurchaseReservedInstancesOfferingRequest(args)
	assert(args, "You must provdide an argument table when creating PurchaseReservedInstancesOfferingRequest")
	local t = { 
		["ReservedInstancesOfferingId"] = args["ReservedInstancesOfferingId"],
		["InstanceCount"] = args["InstanceCount"],
		["DryRun"] = args["DryRun"],
		["LimitPrice"] = args["LimitPrice"],
	}
	asserts.AssertPurchaseReservedInstancesOfferingRequest(t)
	return t
end

keys.FlowLog = { ["ResourceId"] = true, ["CreationTime"] = true, ["LogGroupName"] = true, ["TrafficType"] = true, ["FlowLogStatus"] = true, ["FlowLogId"] = true, ["DeliverLogsPermissionArn"] = true, ["DeliverLogsStatus"] = true, ["DeliverLogsErrorMessage"] = true, nil }

function asserts.AssertFlowLog(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FlowLog to be of type 'table'")
	if struct["ResourceId"] then asserts.AssertString(struct["ResourceId"]) end
	if struct["CreationTime"] then asserts.AssertDateTime(struct["CreationTime"]) end
	if struct["LogGroupName"] then asserts.AssertString(struct["LogGroupName"]) end
	if struct["TrafficType"] then asserts.AssertTrafficType(struct["TrafficType"]) end
	if struct["FlowLogStatus"] then asserts.AssertString(struct["FlowLogStatus"]) end
	if struct["FlowLogId"] then asserts.AssertString(struct["FlowLogId"]) end
	if struct["DeliverLogsPermissionArn"] then asserts.AssertString(struct["DeliverLogsPermissionArn"]) end
	if struct["DeliverLogsStatus"] then asserts.AssertString(struct["DeliverLogsStatus"]) end
	if struct["DeliverLogsErrorMessage"] then asserts.AssertString(struct["DeliverLogsErrorMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.FlowLog[k], "FlowLog contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FlowLog
-- <p>Describes a flow log.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceId [String] <p>The ID of the resource on which the flow log was created.</p>
-- * CreationTime [DateTime] <p>The date and time the flow log was created.</p>
-- * LogGroupName [String] <p>The name of the flow log group.</p>
-- * TrafficType [TrafficType] <p>The type of traffic captured for the flow log.</p>
-- * FlowLogStatus [String] <p>The status of the flow log (<code>ACTIVE</code>).</p>
-- * FlowLogId [String] <p>The flow log ID.</p>
-- * DeliverLogsPermissionArn [String] <p>The ARN of the IAM role that posts logs to CloudWatch Logs.</p>
-- * DeliverLogsStatus [String] <p>The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p>
-- * DeliverLogsErrorMessage [String] <p>Information about the error that occurred. <code>Rate limited</code> indicates that CloudWatch logs throttling has been applied for one or more network interfaces, or that you've reached the limit on the number of CloudWatch Logs log groups that you can create. <code>Access error</code> indicates that the IAM role associated with the flow log does not have sufficient permissions to publish to CloudWatch Logs. <code>Unknown error</code> indicates an internal error.</p>
-- @return FlowLog structure as a key-value pair table
function M.FlowLog(args)
	assert(args, "You must provdide an argument table when creating FlowLog")
	local t = { 
		["ResourceId"] = args["ResourceId"],
		["CreationTime"] = args["CreationTime"],
		["LogGroupName"] = args["LogGroupName"],
		["TrafficType"] = args["TrafficType"],
		["FlowLogStatus"] = args["FlowLogStatus"],
		["FlowLogId"] = args["FlowLogId"],
		["DeliverLogsPermissionArn"] = args["DeliverLogsPermissionArn"],
		["DeliverLogsStatus"] = args["DeliverLogsStatus"],
		["DeliverLogsErrorMessage"] = args["DeliverLogsErrorMessage"],
	}
	asserts.AssertFlowLog(t)
	return t
end

keys.RequestSpotInstancesRequest = { ["InstanceCount"] = true, ["DryRun"] = true, ["LaunchGroup"] = true, ["BlockDurationMinutes"] = true, ["LaunchSpecification"] = true, ["AvailabilityZoneGroup"] = true, ["ClientToken"] = true, ["ValidUntil"] = true, ["ValidFrom"] = true, ["Type"] = true, ["SpotPrice"] = true, nil }

function asserts.AssertRequestSpotInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotInstancesRequest to be of type 'table'")
	assert(struct["SpotPrice"], "Expected key SpotPrice to exist in table")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["LaunchGroup"] then asserts.AssertString(struct["LaunchGroup"]) end
	if struct["BlockDurationMinutes"] then asserts.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["LaunchSpecification"] then asserts.AssertRequestSpotLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["AvailabilityZoneGroup"] then asserts.AssertString(struct["AvailabilityZoneGroup"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["Type"] then asserts.AssertSpotInstanceType(struct["Type"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotInstancesRequest[k], "RequestSpotInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotInstancesRequest
-- <p>Contains the parameters for RequestSpotInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceCount [Integer] <p>The maximum number of Spot instances to launch.</p> <p>Default: 1</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * LaunchGroup [String] <p>The instance launch group. Launch groups are Spot instances that launch together and terminate together.</p> <p>Default: Instances are launched and terminated individually</p>
-- * BlockDurationMinutes [Integer] <p>The required duration for the Spot instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p> <p>The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.</p> <p>Note that you can't specify an Availability Zone group or a launch group if you specify a duration.</p>
-- * LaunchSpecification [RequestSpotLaunchSpecification] <p>The launch specification.</p>
-- * AvailabilityZoneGroup [String] <p>The user-specified name for a logical grouping of bids.</p> <p>When you specify an Availability Zone group in a Spot Instance request, all Spot instances in the request are launched in the same Availability Zone. Instance proximity is maintained with this parameter, but the choice of Availability Zone is not. The group applies only to bids for Spot Instances of the same instance type. Any additional Spot instance requests that are specified with the same Availability Zone group name are launched in that same Availability Zone, as long as at least one instance from the group is still active.</p> <p>If there is no active instance running in the Availability Zone group that you specify for a new Spot instance request (all instances are terminated, the bid is expired, or the bid falls below current market), then Amazon EC2 launches the instance in any Availability Zone where the constraint can be met. Consequently, the subsequent set of Spot instances could be placed in a different zone from the original request, even if you specified the same Availability Zone group.</p> <p>Default: Instances are launched in any available Availability Zone.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * ValidUntil [DateTime] <p>The end date of the request. If this is a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached.</p> <p>Default: The request is effective indefinitely.</p>
-- * ValidFrom [DateTime] <p>The start date of the request. If this is a one-time request, the request becomes active at this date and time and remains active until all instances launch, the request expires, or the request is canceled. If the request is persistent, the request becomes active at this date and time and remains active until it expires or is canceled.</p> <p>Default: The request is effective indefinitely.</p>
-- * Type [SpotInstanceType] <p>The Spot instance request type.</p> <p>Default: <code>one-time</code> </p>
-- * SpotPrice [String] <p>The maximum hourly price (bid) for any Spot instance launched to fulfill the request.</p>
-- Required key: SpotPrice
-- @return RequestSpotInstancesRequest structure as a key-value pair table
function M.RequestSpotInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating RequestSpotInstancesRequest")
	local t = { 
		["InstanceCount"] = args["InstanceCount"],
		["DryRun"] = args["DryRun"],
		["LaunchGroup"] = args["LaunchGroup"],
		["BlockDurationMinutes"] = args["BlockDurationMinutes"],
		["LaunchSpecification"] = args["LaunchSpecification"],
		["AvailabilityZoneGroup"] = args["AvailabilityZoneGroup"],
		["ClientToken"] = args["ClientToken"],
		["ValidUntil"] = args["ValidUntil"],
		["ValidFrom"] = args["ValidFrom"],
		["Type"] = args["Type"],
		["SpotPrice"] = args["SpotPrice"],
	}
	asserts.AssertRequestSpotInstancesRequest(t)
	return t
end

keys.DisableVpcClassicLinkDnsSupportRequest = { ["VpcId"] = true, nil }

function asserts.AssertDisableVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkDnsSupportRequest[k], "DisableVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkDnsSupportRequest
-- <p>Contains the parameters for DisableVpcClassicLinkDnsSupport.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return DisableVpcClassicLinkDnsSupportRequest structure as a key-value pair table
function M.DisableVpcClassicLinkDnsSupportRequest(args)
	assert(args, "You must provdide an argument table when creating DisableVpcClassicLinkDnsSupportRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertDisableVpcClassicLinkDnsSupportRequest(t)
	return t
end

keys.BlobAttributeValue = { ["Value"] = true, nil }

function asserts.AssertBlobAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BlobAttributeValue to be of type 'table'")
	if struct["Value"] then asserts.AssertBlob(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(keys.BlobAttributeValue[k], "BlobAttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BlobAttributeValue
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [Blob] 
-- @return BlobAttributeValue structure as a key-value pair table
function M.BlobAttributeValue(args)
	assert(args, "You must provdide an argument table when creating BlobAttributeValue")
	local t = { 
		["Value"] = args["Value"],
	}
	asserts.AssertBlobAttributeValue(t)
	return t
end

keys.CancelSpotInstanceRequestsRequest = { ["SpotInstanceRequestIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertCancelSpotInstanceRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotInstanceRequestsRequest to be of type 'table'")
	assert(struct["SpotInstanceRequestIds"], "Expected key SpotInstanceRequestIds to exist in table")
	if struct["SpotInstanceRequestIds"] then asserts.AssertSpotInstanceRequestIdList(struct["SpotInstanceRequestIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotInstanceRequestsRequest[k], "CancelSpotInstanceRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotInstanceRequestsRequest
-- <p>Contains the parameters for CancelSpotInstanceRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceRequestIds [SpotInstanceRequestIdList] <p>One or more Spot instance request IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: SpotInstanceRequestIds
-- @return CancelSpotInstanceRequestsRequest structure as a key-value pair table
function M.CancelSpotInstanceRequestsRequest(args)
	assert(args, "You must provdide an argument table when creating CancelSpotInstanceRequestsRequest")
	local t = { 
		["SpotInstanceRequestIds"] = args["SpotInstanceRequestIds"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCancelSpotInstanceRequestsRequest(t)
	return t
end

keys.DeleteSnapshotRequest = { ["SnapshotId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSnapshotRequest to be of type 'table'")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSnapshotRequest[k], "DeleteSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSnapshotRequest
-- <p>Contains the parameters for DeleteSnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: SnapshotId
-- @return DeleteSnapshotRequest structure as a key-value pair table
function M.DeleteSnapshotRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteSnapshotRequest")
	local t = { 
		["SnapshotId"] = args["SnapshotId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteSnapshotRequest(t)
	return t
end

keys.DetachClassicLinkVpcRequest = { ["InstanceId"] = true, ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDetachClassicLinkVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachClassicLinkVpcRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachClassicLinkVpcRequest[k], "DetachClassicLinkVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachClassicLinkVpcRequest
-- <p>Contains the parameters for DetachClassicLinkVpc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance to unlink from the VPC.</p>
-- * VpcId [String] <p>The ID of the VPC to which the instance is linked.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- Required key: VpcId
-- @return DetachClassicLinkVpcRequest structure as a key-value pair table
function M.DetachClassicLinkVpcRequest(args)
	assert(args, "You must provdide an argument table when creating DetachClassicLinkVpcRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDetachClassicLinkVpcRequest(t)
	return t
end

keys.SnapshotTaskDetail = { ["Status"] = true, ["Description"] = true, ["Format"] = true, ["Url"] = true, ["DiskImageSize"] = true, ["SnapshotId"] = true, ["Progress"] = true, ["StatusMessage"] = true, ["UserBucket"] = true, nil }

function asserts.AssertSnapshotTaskDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotTaskDetail to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["DiskImageSize"] then asserts.AssertDouble(struct["DiskImageSize"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["UserBucket"] then asserts.AssertUserBucketDetails(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnapshotTaskDetail[k], "SnapshotTaskDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotTaskDetail
-- <p>Details about the import snapshot task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>A brief status for the import snapshot task.</p>
-- * Description [String] <p>The description of the snapshot.</p>
-- * Format [String] <p>The format of the disk image from which the snapshot is created.</p>
-- * Url [String] <p>The URL of the disk image from which the snapshot is created.</p>
-- * DiskImageSize [Double] <p>The size of the disk in the snapshot, in GiB.</p>
-- * SnapshotId [String] <p>The snapshot ID of the disk being imported.</p>
-- * Progress [String] <p>The percentage of completion for the import snapshot task.</p>
-- * StatusMessage [String] <p>A detailed status message for the import snapshot task.</p>
-- * UserBucket [UserBucketDetails] <p>The S3 bucket for the disk image.</p>
-- @return SnapshotTaskDetail structure as a key-value pair table
function M.SnapshotTaskDetail(args)
	assert(args, "You must provdide an argument table when creating SnapshotTaskDetail")
	local t = { 
		["Status"] = args["Status"],
		["Description"] = args["Description"],
		["Format"] = args["Format"],
		["Url"] = args["Url"],
		["DiskImageSize"] = args["DiskImageSize"],
		["SnapshotId"] = args["SnapshotId"],
		["Progress"] = args["Progress"],
		["StatusMessage"] = args["StatusMessage"],
		["UserBucket"] = args["UserBucket"],
	}
	asserts.AssertSnapshotTaskDetail(t)
	return t
end

keys.Tag = { ["Value"] = true, ["Key"] = true, nil }

function asserts.AssertTag(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Tag to be of type 'table'")
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.Tag[k], "Tag contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Tag
-- <p>Describes a tag.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [String] <p>The value of the tag.</p> <p>Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.</p>
-- * Key [String] <p>The key of the tag.</p> <p>Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with <code>aws:</code> </p>
-- @return Tag structure as a key-value pair table
function M.Tag(args)
	assert(args, "You must provdide an argument table when creating Tag")
	local t = { 
		["Value"] = args["Value"],
		["Key"] = args["Key"],
	}
	asserts.AssertTag(t)
	return t
end

keys.ScheduledInstancesPlacement = { ["GroupName"] = true, ["AvailabilityZone"] = true, nil }

function asserts.AssertScheduledInstancesPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesPlacement to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesPlacement[k], "ScheduledInstancesPlacement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesPlacement
-- <p>Describes the placement for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the placement group.</p>
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- @return ScheduledInstancesPlacement structure as a key-value pair table
function M.ScheduledInstancesPlacement(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstancesPlacement")
	local t = { 
		["GroupName"] = args["GroupName"],
		["AvailabilityZone"] = args["AvailabilityZone"],
	}
	asserts.AssertScheduledInstancesPlacement(t)
	return t
end

keys.DescribeFpgaImagesResult = { ["FpgaImages"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFpgaImagesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImagesResult to be of type 'table'")
	if struct["FpgaImages"] then asserts.AssertFpgaImageList(struct["FpgaImages"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFpgaImagesResult[k], "DescribeFpgaImagesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImagesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImages [FpgaImageList] <p>Information about one or more FPGA images.</p>
-- * NextToken [NextToken] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeFpgaImagesResult structure as a key-value pair table
function M.DescribeFpgaImagesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeFpgaImagesResult")
	local t = { 
		["FpgaImages"] = args["FpgaImages"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeFpgaImagesResult(t)
	return t
end

keys.ModifyInstancePlacementResult = { ["Return"] = true, nil }

function asserts.AssertModifyInstancePlacementResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstancePlacementResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstancePlacementResult[k], "ModifyInstancePlacementResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstancePlacementResult
-- <p>Contains the output of ModifyInstancePlacement.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
-- @return ModifyInstancePlacementResult structure as a key-value pair table
function M.ModifyInstancePlacementResult(args)
	assert(args, "You must provdide an argument table when creating ModifyInstancePlacementResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifyInstancePlacementResult(t)
	return t
end

keys.DescribeSecurityGroupReferencesResult = { ["SecurityGroupReferenceSet"] = true, nil }

function asserts.AssertDescribeSecurityGroupReferencesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupReferencesResult to be of type 'table'")
	if struct["SecurityGroupReferenceSet"] then asserts.AssertSecurityGroupReferences(struct["SecurityGroupReferenceSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupReferencesResult[k], "DescribeSecurityGroupReferencesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupReferencesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SecurityGroupReferenceSet [SecurityGroupReferences] <p>Information about the VPCs with the referencing security groups.</p>
-- @return DescribeSecurityGroupReferencesResult structure as a key-value pair table
function M.DescribeSecurityGroupReferencesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeSecurityGroupReferencesResult")
	local t = { 
		["SecurityGroupReferenceSet"] = args["SecurityGroupReferenceSet"],
	}
	asserts.AssertDescribeSecurityGroupReferencesResult(t)
	return t
end

keys.DescribeDhcpOptionsRequest = { ["DhcpOptionsIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDhcpOptionsRequest to be of type 'table'")
	if struct["DhcpOptionsIds"] then asserts.AssertDhcpOptionsIdStringList(struct["DhcpOptionsIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDhcpOptionsRequest[k], "DescribeDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDhcpOptionsRequest
-- <p>Contains the parameters for DescribeDhcpOptions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DhcpOptionsIds [DhcpOptionsIdStringList] <p>The IDs of one or more DHCP options sets.</p> <p>Default: Describes all your DHCP options sets.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>dhcp-options-id</code> - The ID of a set of DHCP options.</p> </li> <li> <p> <code>key</code> - The key for one of the options (for example, <code>domain-name</code>).</p> </li> <li> <p> <code>value</code> - The value for one of the options.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
-- @return DescribeDhcpOptionsRequest structure as a key-value pair table
function M.DescribeDhcpOptionsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeDhcpOptionsRequest")
	local t = { 
		["DhcpOptionsIds"] = args["DhcpOptionsIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeDhcpOptionsRequest(t)
	return t
end

keys.ScheduledInstanceRecurrence = { ["OccurrenceDaySet"] = true, ["Interval"] = true, ["Frequency"] = true, ["OccurrenceRelativeToEnd"] = true, ["OccurrenceUnit"] = true, nil }

function asserts.AssertScheduledInstanceRecurrence(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceRecurrence to be of type 'table'")
	if struct["OccurrenceDaySet"] then asserts.AssertOccurrenceDaySet(struct["OccurrenceDaySet"]) end
	if struct["Interval"] then asserts.AssertInteger(struct["Interval"]) end
	if struct["Frequency"] then asserts.AssertString(struct["Frequency"]) end
	if struct["OccurrenceRelativeToEnd"] then asserts.AssertBoolean(struct["OccurrenceRelativeToEnd"]) end
	if struct["OccurrenceUnit"] then asserts.AssertString(struct["OccurrenceUnit"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstanceRecurrence[k], "ScheduledInstanceRecurrence contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceRecurrence
-- <p>Describes the recurring schedule for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OccurrenceDaySet [OccurrenceDaySet] <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday).</p>
-- * Interval [Integer] <p>The interval quantity. The interval unit depends on the value of <code>frequency</code>. For example, every 2 weeks or every 2 months.</p>
-- * Frequency [String] <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
-- * OccurrenceRelativeToEnd [Boolean] <p>Indicates whether the occurrence is relative to the end of the specified week or month.</p>
-- * OccurrenceUnit [String] <p>The unit for <code>occurrenceDaySet</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>).</p>
-- @return ScheduledInstanceRecurrence structure as a key-value pair table
function M.ScheduledInstanceRecurrence(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstanceRecurrence")
	local t = { 
		["OccurrenceDaySet"] = args["OccurrenceDaySet"],
		["Interval"] = args["Interval"],
		["Frequency"] = args["Frequency"],
		["OccurrenceRelativeToEnd"] = args["OccurrenceRelativeToEnd"],
		["OccurrenceUnit"] = args["OccurrenceUnit"],
	}
	asserts.AssertScheduledInstanceRecurrence(t)
	return t
end

keys.DescribeSecurityGroupsResult = { ["SecurityGroups"] = true, nil }

function asserts.AssertDescribeSecurityGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupsResult to be of type 'table'")
	if struct["SecurityGroups"] then asserts.AssertSecurityGroupList(struct["SecurityGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupsResult[k], "DescribeSecurityGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupsResult
-- <p>Contains the output of DescribeSecurityGroups.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SecurityGroups [SecurityGroupList] <p>Information about one or more security groups.</p>
-- @return DescribeSecurityGroupsResult structure as a key-value pair table
function M.DescribeSecurityGroupsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeSecurityGroupsResult")
	local t = { 
		["SecurityGroups"] = args["SecurityGroups"],
	}
	asserts.AssertDescribeSecurityGroupsResult(t)
	return t
end

keys.CancelExportTaskRequest = { ["ExportTaskId"] = true, nil }

function asserts.AssertCancelExportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelExportTaskRequest to be of type 'table'")
	assert(struct["ExportTaskId"], "Expected key ExportTaskId to exist in table")
	if struct["ExportTaskId"] then asserts.AssertString(struct["ExportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelExportTaskRequest[k], "CancelExportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelExportTaskRequest
-- <p>Contains the parameters for CancelExportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExportTaskId [String] <p>The ID of the export task. This is the ID returned by <code>CreateInstanceExportTask</code>.</p>
-- Required key: ExportTaskId
-- @return CancelExportTaskRequest structure as a key-value pair table
function M.CancelExportTaskRequest(args)
	assert(args, "You must provdide an argument table when creating CancelExportTaskRequest")
	local t = { 
		["ExportTaskId"] = args["ExportTaskId"],
	}
	asserts.AssertCancelExportTaskRequest(t)
	return t
end

keys.ModifyReservedInstancesResult = { ["ReservedInstancesModificationId"] = true, nil }

function asserts.AssertModifyReservedInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyReservedInstancesResult to be of type 'table'")
	if struct["ReservedInstancesModificationId"] then asserts.AssertString(struct["ReservedInstancesModificationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyReservedInstancesResult[k], "ModifyReservedInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyReservedInstancesResult
-- <p>Contains the output of ModifyReservedInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesModificationId [String] <p>The ID for the modification.</p>
-- @return ModifyReservedInstancesResult structure as a key-value pair table
function M.ModifyReservedInstancesResult(args)
	assert(args, "You must provdide an argument table when creating ModifyReservedInstancesResult")
	local t = { 
		["ReservedInstancesModificationId"] = args["ReservedInstancesModificationId"],
	}
	asserts.AssertModifyReservedInstancesResult(t)
	return t
end

keys.DeleteDhcpOptionsRequest = { ["DryRun"] = true, ["DhcpOptionsId"] = true, nil }

function asserts.AssertDeleteDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpOptionsId"], "Expected key DhcpOptionsId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteDhcpOptionsRequest[k], "DeleteDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteDhcpOptionsRequest
-- <p>Contains the parameters for DeleteDhcpOptions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * DhcpOptionsId [String] <p>The ID of the DHCP options set.</p>
-- Required key: DhcpOptionsId
-- @return DeleteDhcpOptionsRequest structure as a key-value pair table
function M.DeleteDhcpOptionsRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteDhcpOptionsRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["DhcpOptionsId"] = args["DhcpOptionsId"],
	}
	asserts.AssertDeleteDhcpOptionsRequest(t)
	return t
end

keys.CreateEgressOnlyInternetGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateEgressOnlyInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateEgressOnlyInternetGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateEgressOnlyInternetGatewayRequest[k], "CreateEgressOnlyInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateEgressOnlyInternetGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC for which to create the egress-only Internet gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required key: VpcId
-- @return CreateEgressOnlyInternetGatewayRequest structure as a key-value pair table
function M.CreateEgressOnlyInternetGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating CreateEgressOnlyInternetGatewayRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateEgressOnlyInternetGatewayRequest(t)
	return t
end

keys.DescribeInstancesResult = { ["Reservations"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancesResult to be of type 'table'")
	if struct["Reservations"] then asserts.AssertReservationList(struct["Reservations"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancesResult[k], "DescribeInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancesResult
-- <p>Contains the output of DescribeInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Reservations [ReservationList] <p>Zero or more reservations.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeInstancesResult structure as a key-value pair table
function M.DescribeInstancesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeInstancesResult")
	local t = { 
		["Reservations"] = args["Reservations"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeInstancesResult(t)
	return t
end

keys.SnapshotDetail = { ["Status"] = true, ["DeviceName"] = true, ["Description"] = true, ["Format"] = true, ["Url"] = true, ["DiskImageSize"] = true, ["Progress"] = true, ["SnapshotId"] = true, ["StatusMessage"] = true, ["UserBucket"] = true, nil }

function asserts.AssertSnapshotDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotDetail to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["DiskImageSize"] then asserts.AssertDouble(struct["DiskImageSize"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["UserBucket"] then asserts.AssertUserBucketDetails(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnapshotDetail[k], "SnapshotDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotDetail
-- <p>Describes the snapshot created from the imported disk.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>A brief status of the snapshot creation.</p>
-- * DeviceName [String] <p>The block device mapping for the snapshot.</p>
-- * Description [String] <p>A description for the snapshot.</p>
-- * Format [String] <p>The format of the disk image from which the snapshot is created.</p>
-- * Url [String] <p>The URL used to access the disk image.</p>
-- * DiskImageSize [Double] <p>The size of the disk in the snapshot, in GiB.</p>
-- * Progress [String] <p>The percentage of progress for the task.</p>
-- * SnapshotId [String] <p>The snapshot ID of the disk being imported.</p>
-- * StatusMessage [String] <p>A detailed status message for the snapshot creation.</p>
-- * UserBucket [UserBucketDetails] <p>The S3 bucket for the disk image.</p>
-- @return SnapshotDetail structure as a key-value pair table
function M.SnapshotDetail(args)
	assert(args, "You must provdide an argument table when creating SnapshotDetail")
	local t = { 
		["Status"] = args["Status"],
		["DeviceName"] = args["DeviceName"],
		["Description"] = args["Description"],
		["Format"] = args["Format"],
		["Url"] = args["Url"],
		["DiskImageSize"] = args["DiskImageSize"],
		["Progress"] = args["Progress"],
		["SnapshotId"] = args["SnapshotId"],
		["StatusMessage"] = args["StatusMessage"],
		["UserBucket"] = args["UserBucket"],
	}
	asserts.AssertSnapshotDetail(t)
	return t
end

keys.RequestSpotFleetResponse = { ["SpotFleetRequestId"] = true, nil }

function asserts.AssertRequestSpotFleetResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotFleetResponse to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotFleetResponse[k], "RequestSpotFleetResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotFleetResponse
-- <p>Contains the output of RequestSpotFleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- Required key: SpotFleetRequestId
-- @return RequestSpotFleetResponse structure as a key-value pair table
function M.RequestSpotFleetResponse(args)
	assert(args, "You must provdide an argument table when creating RequestSpotFleetResponse")
	local t = { 
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
	}
	asserts.AssertRequestSpotFleetResponse(t)
	return t
end

keys.AssociateRouteTableRequest = { ["SubnetId"] = true, ["RouteTableId"] = true, ["DryRun"] = true, nil }

function asserts.AssertAssociateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateRouteTableRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateRouteTableRequest[k], "AssociateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateRouteTableRequest
-- <p>Contains the parameters for AssociateRouteTable.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: RouteTableId
-- Required key: SubnetId
-- @return AssociateRouteTableRequest structure as a key-value pair table
function M.AssociateRouteTableRequest(args)
	assert(args, "You must provdide an argument table when creating AssociateRouteTableRequest")
	local t = { 
		["SubnetId"] = args["SubnetId"],
		["RouteTableId"] = args["RouteTableId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertAssociateRouteTableRequest(t)
	return t
end

keys.HostReservation = { ["Count"] = true, ["End"] = true, ["HourlyPrice"] = true, ["InstanceFamily"] = true, ["CurrencyCode"] = true, ["OfferingId"] = true, ["PaymentOption"] = true, ["State"] = true, ["HostIdSet"] = true, ["Start"] = true, ["HostReservationId"] = true, ["UpfrontPrice"] = true, ["Duration"] = true, nil }

function asserts.AssertHostReservation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostReservation to be of type 'table'")
	if struct["Count"] then asserts.AssertInteger(struct["Count"]) end
	if struct["End"] then asserts.AssertDateTime(struct["End"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["InstanceFamily"] then asserts.AssertString(struct["InstanceFamily"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["PaymentOption"] then asserts.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["State"] then asserts.AssertReservationState(struct["State"]) end
	if struct["HostIdSet"] then asserts.AssertResponseHostIdSet(struct["HostIdSet"]) end
	if struct["Start"] then asserts.AssertDateTime(struct["Start"]) end
	if struct["HostReservationId"] then asserts.AssertString(struct["HostReservationId"]) end
	if struct["UpfrontPrice"] then asserts.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then asserts.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostReservation[k], "HostReservation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostReservation
-- <p>Details about the Dedicated Host Reservation and associated Dedicated Hosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Count [Integer] <p>The number of Dedicated Hosts the reservation is associated with.</p>
-- * End [DateTime] <p>The date and time that the reservation ends.</p>
-- * HourlyPrice [String] <p>The hourly price of the reservation.</p>
-- * InstanceFamily [String] <p>The instance family of the Dedicated Host Reservation. The instance family on the Dedicated Host must be the same in order for it to benefit from the reservation.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>upfrontPrice</code> and <code>hourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * OfferingId [String] <p>The ID of the reservation. This remains the same regardless of which Dedicated Hosts are associated with it.</p>
-- * PaymentOption [PaymentOption] <p>The payment option selected for this reservation.</p>
-- * State [ReservationState] <p>The state of the reservation.</p>
-- * HostIdSet [ResponseHostIdSet] <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
-- * Start [DateTime] <p>The date and time that the reservation started.</p>
-- * HostReservationId [String] <p>The ID of the reservation that specifies the associated Dedicated Hosts.</p>
-- * UpfrontPrice [String] <p>The upfront price of the reservation.</p>
-- * Duration [Integer] <p>The length of the reservation's term, specified in seconds. Can be <code>31536000 (1 year)</code> | <code>94608000 (3 years)</code>.</p>
-- @return HostReservation structure as a key-value pair table
function M.HostReservation(args)
	assert(args, "You must provdide an argument table when creating HostReservation")
	local t = { 
		["Count"] = args["Count"],
		["End"] = args["End"],
		["HourlyPrice"] = args["HourlyPrice"],
		["InstanceFamily"] = args["InstanceFamily"],
		["CurrencyCode"] = args["CurrencyCode"],
		["OfferingId"] = args["OfferingId"],
		["PaymentOption"] = args["PaymentOption"],
		["State"] = args["State"],
		["HostIdSet"] = args["HostIdSet"],
		["Start"] = args["Start"],
		["HostReservationId"] = args["HostReservationId"],
		["UpfrontPrice"] = args["UpfrontPrice"],
		["Duration"] = args["Duration"],
	}
	asserts.AssertHostReservation(t)
	return t
end

keys.ResetNetworkInterfaceAttributeRequest = { ["NetworkInterfaceId"] = true, ["DryRun"] = true, ["SourceDestCheck"] = true, nil }

function asserts.AssertResetNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SourceDestCheck"] then asserts.AssertString(struct["SourceDestCheck"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetNetworkInterfaceAttributeRequest[k], "ResetNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for ResetNetworkInterfaceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * SourceDestCheck [String] <p>The source/destination checking attribute. Resets the value to <code>true</code>.</p>
-- Required key: NetworkInterfaceId
-- @return ResetNetworkInterfaceAttributeRequest structure as a key-value pair table
function M.ResetNetworkInterfaceAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ResetNetworkInterfaceAttributeRequest")
	local t = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["DryRun"] = args["DryRun"],
		["SourceDestCheck"] = args["SourceDestCheck"],
	}
	asserts.AssertResetNetworkInterfaceAttributeRequest(t)
	return t
end

keys.NetworkInterfacePrivateIpAddress = { ["PrivateDnsName"] = true, ["PrivateIpAddress"] = true, ["Primary"] = true, ["Association"] = true, nil }

function asserts.AssertNetworkInterfacePrivateIpAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfacePrivateIpAddress to be of type 'table'")
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["Association"] then asserts.AssertNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfacePrivateIpAddress[k], "NetworkInterfacePrivateIpAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfacePrivateIpAddress
-- <p>Describes the private IPv4 address of a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrivateDnsName [String] <p>The private DNS name.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 address.</p>
-- * Primary [Boolean] <p>Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.</p>
-- * Association [NetworkInterfaceAssociation] <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
-- @return NetworkInterfacePrivateIpAddress structure as a key-value pair table
function M.NetworkInterfacePrivateIpAddress(args)
	assert(args, "You must provdide an argument table when creating NetworkInterfacePrivateIpAddress")
	local t = { 
		["PrivateDnsName"] = args["PrivateDnsName"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Primary"] = args["Primary"],
		["Association"] = args["Association"],
	}
	asserts.AssertNetworkInterfacePrivateIpAddress(t)
	return t
end

keys.DescribeFlowLogsRequest = { ["Filter"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["FlowLogIds"] = true, nil }

function asserts.AssertDescribeFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFlowLogsRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["FlowLogIds"] then asserts.AssertValueStringList(struct["FlowLogIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFlowLogsRequest[k], "DescribeFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFlowLogsRequest
-- <p>Contains the parameters for DescribeFlowLogs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>deliver-log-status</code> - The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p> </li> <li> <p> <code>flow-log-id</code> - The ID of the flow log.</p> </li> <li> <p> <code>log-group-name</code> - The name of the log group.</p> </li> <li> <p> <code>resource-id</code> - The ID of the VPC, subnet, or network interface.</p> </li> <li> <p> <code>traffic-type</code> - The type of traffic (<code>ACCEPT</code> | <code>REJECT</code> | <code>ALL</code>)</p> </li> </ul>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the flow log IDs parameter in the same request.</p>
-- * FlowLogIds [ValueStringList] <p>One or more flow log IDs.</p>
-- @return DescribeFlowLogsRequest structure as a key-value pair table
function M.DescribeFlowLogsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeFlowLogsRequest")
	local t = { 
		["Filter"] = args["Filter"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["FlowLogIds"] = args["FlowLogIds"],
	}
	asserts.AssertDescribeFlowLogsRequest(t)
	return t
end

keys.SpotInstanceStatus = { ["Message"] = true, ["Code"] = true, ["UpdateTime"] = true, nil }

function asserts.AssertSpotInstanceStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceStatus to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	if struct["UpdateTime"] then asserts.AssertDateTime(struct["UpdateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotInstanceStatus[k], "SpotInstanceStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceStatus
-- <p>Describes the status of a Spot instance request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The description for the status code.</p>
-- * Code [String] <p>The status code. For a list of status codes, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html#spot-instance-bid-status-understand">Spot Bid Status Codes</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * UpdateTime [DateTime] <p>The date and time of the most recent status update, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @return SpotInstanceStatus structure as a key-value pair table
function M.SpotInstanceStatus(args)
	assert(args, "You must provdide an argument table when creating SpotInstanceStatus")
	local t = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
		["UpdateTime"] = args["UpdateTime"],
	}
	asserts.AssertSpotInstanceStatus(t)
	return t
end

keys.CreateFpgaImageRequest = { ["DryRun"] = true, ["Name"] = true, ["LogsStorageLocation"] = true, ["InputStorageLocation"] = true, ["ClientToken"] = true, ["Description"] = true, nil }

function asserts.AssertCreateFpgaImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFpgaImageRequest to be of type 'table'")
	assert(struct["InputStorageLocation"], "Expected key InputStorageLocation to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["LogsStorageLocation"] then asserts.AssertStorageLocation(struct["LogsStorageLocation"]) end
	if struct["InputStorageLocation"] then asserts.AssertStorageLocation(struct["InputStorageLocation"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFpgaImageRequest[k], "CreateFpgaImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFpgaImageRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Name [String] <p>A name for the AFI.</p>
-- * LogsStorageLocation [StorageLocation] <p>The location in Amazon S3 for the output logs.</p>
-- * InputStorageLocation [StorageLocation] <p>The location of the encrypted design checkpoint in Amazon S3. The input must be a tarball.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * Description [String] <p>A description for the AFI.</p>
-- Required key: InputStorageLocation
-- @return CreateFpgaImageRequest structure as a key-value pair table
function M.CreateFpgaImageRequest(args)
	assert(args, "You must provdide an argument table when creating CreateFpgaImageRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Name"] = args["Name"],
		["LogsStorageLocation"] = args["LogsStorageLocation"],
		["InputStorageLocation"] = args["InputStorageLocation"],
		["ClientToken"] = args["ClientToken"],
		["Description"] = args["Description"],
	}
	asserts.AssertCreateFpgaImageRequest(t)
	return t
end

keys.LaunchPermission = { ["UserId"] = true, ["Group"] = true, nil }

function asserts.AssertLaunchPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchPermission to be of type 'table'")
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["Group"] then asserts.AssertPermissionGroup(struct["Group"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchPermission[k], "LaunchPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchPermission
-- <p>Describes a launch permission.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserId [String] <p>The AWS account ID.</p>
-- * Group [PermissionGroup] <p>The name of the group.</p>
-- @return LaunchPermission structure as a key-value pair table
function M.LaunchPermission(args)
	assert(args, "You must provdide an argument table when creating LaunchPermission")
	local t = { 
		["UserId"] = args["UserId"],
		["Group"] = args["Group"],
	}
	asserts.AssertLaunchPermission(t)
	return t
end

keys.DescribeInstanceStatusRequest = { ["DryRun"] = true, ["IncludeAllInstances"] = true, ["MaxResults"] = true, ["Filters"] = true, ["NextToken"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertDescribeInstanceStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceStatusRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["IncludeAllInstances"] then asserts.AssertBoolean(struct["IncludeAllInstances"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceStatusRequest[k], "DescribeInstanceStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceStatusRequest
-- <p>Contains the parameters for DescribeInstanceStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * IncludeAllInstances [Boolean] <p>When <code>true</code>, includes the health status for all instances. When <code>false</code>, includes the health status for running instances only.</p> <p>Default: <code>false</code> </p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter in the same call.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>event.code</code> - The code for the scheduled event (<code>instance-reboot</code> | <code>system-reboot</code> | <code>system-maintenance</code> | <code>instance-retirement</code> | <code>instance-stop</code>).</p> </li> <li> <p> <code>event.description</code> - A description of the event.</p> </li> <li> <p> <code>event.not-after</code> - The latest end time for the scheduled event (for example, <code>2014-09-15T17:15:20.000Z</code>).</p> </li> <li> <p> <code>event.not-before</code> - The earliest start time for the scheduled event (for example, <code>2014-09-15T17:15:20.000Z</code>).</p> </li> <li> <p> <code>instance-state-code</code> - The code for the instance state, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).</p> </li> <li> <p> <code>instance-state-name</code> - The state of the instance (<code>pending</code> | <code>running</code> | <code>shutting-down</code> | <code>terminated</code> | <code>stopping</code> | <code>stopped</code>).</p> </li> <li> <p> <code>instance-status.reachability</code> - Filters on instance status where the name is <code>reachability</code> (<code>passed</code> | <code>failed</code> | <code>initializing</code> | <code>insufficient-data</code>).</p> </li> <li> <p> <code>instance-status.status</code> - The status of the instance (<code>ok</code> | <code>impaired</code> | <code>initializing</code> | <code>insufficient-data</code> | <code>not-applicable</code>).</p> </li> <li> <p> <code>system-status.reachability</code> - Filters on system status where the name is <code>reachability</code> (<code>passed</code> | <code>failed</code> | <code>initializing</code> | <code>insufficient-data</code>).</p> </li> <li> <p> <code>system-status.status</code> - The system status of the instance (<code>ok</code> | <code>impaired</code> | <code>initializing</code> | <code>insufficient-data</code> | <code>not-applicable</code>).</p> </li> </ul>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Default: Describes all your instances.</p> <p>Constraints: Maximum 100 explicitly specified instance IDs.</p>
-- @return DescribeInstanceStatusRequest structure as a key-value pair table
function M.DescribeInstanceStatusRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeInstanceStatusRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["IncludeAllInstances"] = args["IncludeAllInstances"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertDescribeInstanceStatusRequest(t)
	return t
end

keys.ImportSnapshotTask = { ["SnapshotTaskDetail"] = true, ["Description"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportSnapshotTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotTask to be of type 'table'")
	if struct["SnapshotTaskDetail"] then asserts.AssertSnapshotTaskDetail(struct["SnapshotTaskDetail"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportSnapshotTask[k], "ImportSnapshotTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotTask
-- <p>Describes an import snapshot task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SnapshotTaskDetail [SnapshotTaskDetail] <p>Describes an import snapshot task.</p>
-- * Description [String] <p>A description of the import snapshot task.</p>
-- * ImportTaskId [String] <p>The ID of the import snapshot task.</p>
-- @return ImportSnapshotTask structure as a key-value pair table
function M.ImportSnapshotTask(args)
	assert(args, "You must provdide an argument table when creating ImportSnapshotTask")
	local t = { 
		["SnapshotTaskDetail"] = args["SnapshotTaskDetail"],
		["Description"] = args["Description"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertImportSnapshotTask(t)
	return t
end

keys.GetHostReservationPurchasePreviewResult = { ["TotalHourlyPrice"] = true, ["Purchase"] = true, ["CurrencyCode"] = true, ["TotalUpfrontPrice"] = true, nil }

function asserts.AssertGetHostReservationPurchasePreviewResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetHostReservationPurchasePreviewResult to be of type 'table'")
	if struct["TotalHourlyPrice"] then asserts.AssertString(struct["TotalHourlyPrice"]) end
	if struct["Purchase"] then asserts.AssertPurchaseSet(struct["Purchase"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["TotalUpfrontPrice"] then asserts.AssertString(struct["TotalUpfrontPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetHostReservationPurchasePreviewResult[k], "GetHostReservationPurchasePreviewResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetHostReservationPurchasePreviewResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TotalHourlyPrice [String] <p>The potential total hourly price of the reservation per hour.</p>
-- * Purchase [PurchaseSet] <p>The purchase information of the Dedicated Host Reservation and the Dedicated Hosts associated with it.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * TotalUpfrontPrice [String] <p>The potential total upfront price. This is billed immediately.</p>
-- @return GetHostReservationPurchasePreviewResult structure as a key-value pair table
function M.GetHostReservationPurchasePreviewResult(args)
	assert(args, "You must provdide an argument table when creating GetHostReservationPurchasePreviewResult")
	local t = { 
		["TotalHourlyPrice"] = args["TotalHourlyPrice"],
		["Purchase"] = args["Purchase"],
		["CurrencyCode"] = args["CurrencyCode"],
		["TotalUpfrontPrice"] = args["TotalUpfrontPrice"],
	}
	asserts.AssertGetHostReservationPurchasePreviewResult(t)
	return t
end

keys.UnsuccessfulItem = { ["ResourceId"] = true, ["Error"] = true, nil }

function asserts.AssertUnsuccessfulItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulItem to be of type 'table'")
	assert(struct["Error"], "Expected key Error to exist in table")
	if struct["ResourceId"] then asserts.AssertString(struct["ResourceId"]) end
	if struct["Error"] then asserts.AssertUnsuccessfulItemError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnsuccessfulItem[k], "UnsuccessfulItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulItem
-- <p>Information about items that were not successfully processed in a batch call.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceId [String] <p>The ID of the resource.</p>
-- * Error [UnsuccessfulItemError] <p>Information about the error.</p>
-- Required key: Error
-- @return UnsuccessfulItem structure as a key-value pair table
function M.UnsuccessfulItem(args)
	assert(args, "You must provdide an argument table when creating UnsuccessfulItem")
	local t = { 
		["ResourceId"] = args["ResourceId"],
		["Error"] = args["Error"],
	}
	asserts.AssertUnsuccessfulItem(t)
	return t
end

keys.PeeringConnectionOptionsRequest = { ["AllowEgressFromLocalVpcToRemoteClassicLink"] = true, ["AllowDnsResolutionFromRemoteVpc"] = true, ["AllowEgressFromLocalClassicLinkToRemoteVpc"] = true, nil }

function asserts.AssertPeeringConnectionOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PeeringConnectionOptionsRequest to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then asserts.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then asserts.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then asserts.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.PeeringConnectionOptionsRequest[k], "PeeringConnectionOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PeeringConnectionOptionsRequest
-- <p>The VPC peering connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.</p>
-- * AllowDnsResolutionFromRemoteVpc [Boolean] <p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>
-- * AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.</p>
-- @return PeeringConnectionOptionsRequest structure as a key-value pair table
function M.PeeringConnectionOptionsRequest(args)
	assert(args, "You must provdide an argument table when creating PeeringConnectionOptionsRequest")
	local t = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = args["AllowEgressFromLocalVpcToRemoteClassicLink"],
		["AllowDnsResolutionFromRemoteVpc"] = args["AllowDnsResolutionFromRemoteVpc"],
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = args["AllowEgressFromLocalClassicLinkToRemoteVpc"],
	}
	asserts.AssertPeeringConnectionOptionsRequest(t)
	return t
end

keys.DescribeInstanceAttributeRequest = { ["InstanceId"] = true, ["Attribute"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then asserts.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceAttributeRequest[k], "DescribeInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceAttributeRequest
-- <p>Contains the parameters for DescribeInstanceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Attribute [InstanceAttributeName] <p>The instance attribute.</p> <p>Note: The <code>enaSupport</code> attribute is not supported at this time.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: Attribute
-- Required key: InstanceId
-- @return DescribeInstanceAttributeRequest structure as a key-value pair table
function M.DescribeInstanceAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeInstanceAttributeRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeInstanceAttributeRequest(t)
	return t
end

keys.DiskImageDetail = { ["Bytes"] = true, ["ImportManifestUrl"] = true, ["Format"] = true, nil }

function asserts.AssertDiskImageDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageDetail to be of type 'table'")
	assert(struct["Bytes"], "Expected key Bytes to exist in table")
	assert(struct["Format"], "Expected key Format to exist in table")
	assert(struct["ImportManifestUrl"], "Expected key ImportManifestUrl to exist in table")
	if struct["Bytes"] then asserts.AssertLong(struct["Bytes"]) end
	if struct["ImportManifestUrl"] then asserts.AssertString(struct["ImportManifestUrl"]) end
	if struct["Format"] then asserts.AssertDiskImageFormat(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImageDetail[k], "DiskImageDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageDetail
-- <p>Describes a disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Bytes [Long] <p>The size of the disk image, in GiB.</p>
-- * ImportManifestUrl [String] <p>A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
-- * Format [DiskImageFormat] <p>The disk image format.</p>
-- Required key: Bytes
-- Required key: Format
-- Required key: ImportManifestUrl
-- @return DiskImageDetail structure as a key-value pair table
function M.DiskImageDetail(args)
	assert(args, "You must provdide an argument table when creating DiskImageDetail")
	local t = { 
		["Bytes"] = args["Bytes"],
		["ImportManifestUrl"] = args["ImportManifestUrl"],
		["Format"] = args["Format"],
	}
	asserts.AssertDiskImageDetail(t)
	return t
end

keys.AvailabilityZone = { ["State"] = true, ["ZoneName"] = true, ["Messages"] = true, ["RegionName"] = true, nil }

function asserts.AssertAvailabilityZone(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailabilityZone to be of type 'table'")
	if struct["State"] then asserts.AssertAvailabilityZoneState(struct["State"]) end
	if struct["ZoneName"] then asserts.AssertString(struct["ZoneName"]) end
	if struct["Messages"] then asserts.AssertAvailabilityZoneMessageList(struct["Messages"]) end
	if struct["RegionName"] then asserts.AssertString(struct["RegionName"]) end
	for k,_ in pairs(struct) do
		assert(keys.AvailabilityZone[k], "AvailabilityZone contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailabilityZone
-- <p>Describes an Availability Zone.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [AvailabilityZoneState] <p>The state of the Availability Zone.</p>
-- * ZoneName [String] <p>The name of the Availability Zone.</p>
-- * Messages [AvailabilityZoneMessageList] <p>Any messages about the Availability Zone.</p>
-- * RegionName [String] <p>The name of the region.</p>
-- @return AvailabilityZone structure as a key-value pair table
function M.AvailabilityZone(args)
	assert(args, "You must provdide an argument table when creating AvailabilityZone")
	local t = { 
		["State"] = args["State"],
		["ZoneName"] = args["ZoneName"],
		["Messages"] = args["Messages"],
		["RegionName"] = args["RegionName"],
	}
	asserts.AssertAvailabilityZone(t)
	return t
end

keys.DescribeNetworkInterfacesRequest = { ["NetworkInterfaceIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeNetworkInterfacesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacesRequest to be of type 'table'")
	if struct["NetworkInterfaceIds"] then asserts.AssertNetworkInterfaceIdList(struct["NetworkInterfaceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfacesRequest[k], "DescribeNetworkInterfacesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacesRequest
-- <p>Contains the parameters for DescribeNetworkInterfaces.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceIds [NetworkInterfaceIdList] <p>One or more network interface IDs.</p> <p>Default: Describes all your network interfaces.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>addresses.private-ip-address</code> - The private IPv4 addresses associated with the network interface.</p> </li> <li> <p> <code>addresses.primary</code> - Whether the private IPv4 address is the primary IP address associated with the network interface. </p> </li> <li> <p> <code>addresses.association.public-ip</code> - The association ID returned when the network interface was associated with the Elastic IP address (IPv4).</p> </li> <li> <p> <code>addresses.association.owner-id</code> - The owner ID of the addresses associated with the network interface.</p> </li> <li> <p> <code>association.association-id</code> - The association ID returned when the network interface was associated with an IPv4 address.</p> </li> <li> <p> <code>association.allocation-id</code> - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.</p> </li> <li> <p> <code>association.ip-owner-id</code> - The owner of the Elastic IP address (IPv4) associated with the network interface.</p> </li> <li> <p> <code>association.public-ip</code> - The address of the Elastic IP address (IPv4) bound to the network interface.</p> </li> <li> <p> <code>association.public-dns-name</code> - The public DNS name for the network interface (IPv4).</p> </li> <li> <p> <code>attachment.attachment-id</code> - The ID of the interface attachment.</p> </li> <li> <p> <code>attachment.attach.time</code> - The time that the network interface was attached to an instance.</p> </li> <li> <p> <code>attachment.delete-on-termination</code> - Indicates whether the attachment is deleted when an instance is terminated.</p> </li> <li> <p> <code>attachment.device-index</code> - The device index to which the network interface is attached.</p> </li> <li> <p> <code>attachment.instance-id</code> - The ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>attachment.instance-owner-id</code> - The owner ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>attachment.nat-gateway-id</code> - The ID of the NAT gateway to which the network interface is attached.</p> </li> <li> <p> <code>attachment.status</code> - The status of the attachment (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the network interface.</p> </li> <li> <p> <code>description</code> - The description of the network interface.</p> </li> <li> <p> <code>group-id</code> - The ID of a security group associated with the network interface.</p> </li> <li> <p> <code>group-name</code> - The name of a security group associated with the network interface.</p> </li> <li> <p> <code>ipv6-addresses.ipv6-address</code> - An IPv6 address associated with the network interface.</p> </li> <li> <p> <code>mac-address</code> - The MAC address of the network interface.</p> </li> <li> <p> <code>network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the network interface owner.</p> </li> <li> <p> <code>private-ip-address</code> - The private IPv4 address or addresses of the network interface.</p> </li> <li> <p> <code>private-dns-name</code> - The private DNS name of the network interface (IPv4).</p> </li> <li> <p> <code>requester-id</code> - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>requester-managed</code> - Indicates whether the network interface is being managed by an AWS service (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>source-desk-check</code> - Indicates whether the network interface performs source/destination checking. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the network interface to perform network address translation (NAT) in your VPC. </p> </li> <li> <p> <code>status</code> - The status of the network interface. If the network interface is not attached to an instance, the status is <code>available</code>; if a network interface is attached to an instance the status is <code>in-use</code>.</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet for the network interface.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the network interface.</p> </li> </ul>
-- @return DescribeNetworkInterfacesRequest structure as a key-value pair table
function M.DescribeNetworkInterfacesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeNetworkInterfacesRequest")
	local t = { 
		["NetworkInterfaceIds"] = args["NetworkInterfaceIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeNetworkInterfacesRequest(t)
	return t
end

keys.GroupIdentifier = { ["GroupName"] = true, ["GroupId"] = true, nil }

function asserts.AssertGroupIdentifier(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GroupIdentifier to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GroupIdentifier[k], "GroupIdentifier contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GroupIdentifier
-- <p>Describes a security group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the security group.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- @return GroupIdentifier structure as a key-value pair table
function M.GroupIdentifier(args)
	assert(args, "You must provdide an argument table when creating GroupIdentifier")
	local t = { 
		["GroupName"] = args["GroupName"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertGroupIdentifier(t)
	return t
end

keys.RunScheduledInstancesRequest = { ["ScheduledInstanceId"] = true, ["LaunchSpecification"] = true, ["InstanceCount"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertRunScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunScheduledInstancesRequest to be of type 'table'")
	assert(struct["LaunchSpecification"], "Expected key LaunchSpecification to exist in table")
	assert(struct["ScheduledInstanceId"], "Expected key ScheduledInstanceId to exist in table")
	if struct["ScheduledInstanceId"] then asserts.AssertString(struct["ScheduledInstanceId"]) end
	if struct["LaunchSpecification"] then asserts.AssertScheduledInstancesLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunScheduledInstancesRequest[k], "RunScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunScheduledInstancesRequest
-- <p>Contains the parameters for RunScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ScheduledInstanceId [String] <p>The Scheduled Instance ID.</p>
-- * LaunchSpecification [ScheduledInstancesLaunchSpecification] <p>The launch specification. You must match the instance type, Availability Zone, network, and platform of the schedule that you purchased.</p>
-- * InstanceCount [Integer] <p>The number of instances.</p> <p>Default: 1</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: LaunchSpecification
-- Required key: ScheduledInstanceId
-- @return RunScheduledInstancesRequest structure as a key-value pair table
function M.RunScheduledInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating RunScheduledInstancesRequest")
	local t = { 
		["ScheduledInstanceId"] = args["ScheduledInstanceId"],
		["LaunchSpecification"] = args["LaunchSpecification"],
		["InstanceCount"] = args["InstanceCount"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertRunScheduledInstancesRequest(t)
	return t
end

keys.DiskImageDescription = { ["Checksum"] = true, ["Size"] = true, ["ImportManifestUrl"] = true, ["Format"] = true, nil }

function asserts.AssertDiskImageDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageDescription to be of type 'table'")
	assert(struct["Format"], "Expected key Format to exist in table")
	assert(struct["ImportManifestUrl"], "Expected key ImportManifestUrl to exist in table")
	assert(struct["Size"], "Expected key Size to exist in table")
	if struct["Checksum"] then asserts.AssertString(struct["Checksum"]) end
	if struct["Size"] then asserts.AssertLong(struct["Size"]) end
	if struct["ImportManifestUrl"] then asserts.AssertString(struct["ImportManifestUrl"]) end
	if struct["Format"] then asserts.AssertDiskImageFormat(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImageDescription[k], "DiskImageDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageDescription
-- <p>Describes a disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Checksum [String] <p>The checksum computed for the disk image.</p>
-- * Size [Long] <p>The size of the disk image, in GiB.</p>
-- * ImportManifestUrl [String] <p>A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
-- * Format [DiskImageFormat] <p>The disk image format.</p>
-- Required key: Format
-- Required key: ImportManifestUrl
-- Required key: Size
-- @return DiskImageDescription structure as a key-value pair table
function M.DiskImageDescription(args)
	assert(args, "You must provdide an argument table when creating DiskImageDescription")
	local t = { 
		["Checksum"] = args["Checksum"],
		["Size"] = args["Size"],
		["ImportManifestUrl"] = args["ImportManifestUrl"],
		["Format"] = args["Format"],
	}
	asserts.AssertDiskImageDescription(t)
	return t
end

keys.RouteTableAssociation = { ["SubnetId"] = true, ["RouteTableAssociationId"] = true, ["Main"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertRouteTableAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RouteTableAssociation to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["RouteTableAssociationId"] then asserts.AssertString(struct["RouteTableAssociationId"]) end
	if struct["Main"] then asserts.AssertBoolean(struct["Main"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RouteTableAssociation[k], "RouteTableAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RouteTableAssociation
-- <p>Describes an association between a route table and a subnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet. A subnet ID is not returned for an implicit association.</p>
-- * RouteTableAssociationId [String] <p>The ID of the association between a route table and a subnet.</p>
-- * Main [Boolean] <p>Indicates whether this is the main route table.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- @return RouteTableAssociation structure as a key-value pair table
function M.RouteTableAssociation(args)
	assert(args, "You must provdide an argument table when creating RouteTableAssociation")
	local t = { 
		["SubnetId"] = args["SubnetId"],
		["RouteTableAssociationId"] = args["RouteTableAssociationId"],
		["Main"] = args["Main"],
		["RouteTableId"] = args["RouteTableId"],
	}
	asserts.AssertRouteTableAssociation(t)
	return t
end

keys.CancelImportTaskRequest = { ["DryRun"] = true, ["CancelReason"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertCancelImportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelImportTaskRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["CancelReason"] then asserts.AssertString(struct["CancelReason"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelImportTaskRequest[k], "CancelImportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelImportTaskRequest
-- <p>Contains the parameters for CancelImportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * CancelReason [String] <p>The reason for canceling the task.</p>
-- * ImportTaskId [String] <p>The ID of the import image or import snapshot task to be canceled.</p>
-- @return CancelImportTaskRequest structure as a key-value pair table
function M.CancelImportTaskRequest(args)
	assert(args, "You must provdide an argument table when creating CancelImportTaskRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["CancelReason"] = args["CancelReason"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertCancelImportTaskRequest(t)
	return t
end

keys.ImportInstanceRequest = { ["Platform"] = true, ["DiskImages"] = true, ["DryRun"] = true, ["Description"] = true, ["LaunchSpecification"] = true, nil }

function asserts.AssertImportInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceRequest to be of type 'table'")
	assert(struct["Platform"], "Expected key Platform to exist in table")
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["DiskImages"] then asserts.AssertDiskImageList(struct["DiskImages"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["LaunchSpecification"] then asserts.AssertImportInstanceLaunchSpecification(struct["LaunchSpecification"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceRequest[k], "ImportInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceRequest
-- <p>Contains the parameters for ImportInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Platform [PlatformValues] <p>The instance operating system.</p>
-- * DiskImages [DiskImageList] <p>The disk image.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the instance being imported.</p>
-- * LaunchSpecification [ImportInstanceLaunchSpecification] <p>The launch specification.</p>
-- Required key: Platform
-- @return ImportInstanceRequest structure as a key-value pair table
function M.ImportInstanceRequest(args)
	assert(args, "You must provdide an argument table when creating ImportInstanceRequest")
	local t = { 
		["Platform"] = args["Platform"],
		["DiskImages"] = args["DiskImages"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["LaunchSpecification"] = args["LaunchSpecification"],
	}
	asserts.AssertImportInstanceRequest(t)
	return t
end

keys.SubnetCidrBlockState = { ["State"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertSubnetCidrBlockState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SubnetCidrBlockState to be of type 'table'")
	if struct["State"] then asserts.AssertSubnetCidrBlockStateCode(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.SubnetCidrBlockState[k], "SubnetCidrBlockState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SubnetCidrBlockState
-- <p>Describes the state of a CIDR block.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [SubnetCidrBlockStateCode] <p>The state of a CIDR block.</p>
-- * StatusMessage [String] <p>A message about the status of the CIDR block, if applicable.</p>
-- @return SubnetCidrBlockState structure as a key-value pair table
function M.SubnetCidrBlockState(args)
	assert(args, "You must provdide an argument table when creating SubnetCidrBlockState")
	local t = { 
		["State"] = args["State"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertSubnetCidrBlockState(t)
	return t
end

keys.CreateVolumeRequest = { ["AvailabilityZone"] = true, ["DryRun"] = true, ["TagSpecifications"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["KmsKeyId"] = true, ["SnapshotId"] = true, ["Iops"] = true, ["Size"] = true, nil }

function asserts.AssertCreateVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumeRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["Size"] then asserts.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVolumeRequest[k], "CreateVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumeRequest
-- <p>Contains the parameters for CreateVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone in which to create the volume. Use <a>DescribeAvailabilityZones</a> to list the Availability Zones that are currently available to you.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TagSpecifications [TagSpecificationList] <p>The tags to apply to the volume during creation.</p>
-- * Encrypted [Boolean] <p>Specifies whether the volume should be encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption. Volumes that are created from encrypted snapshots are automatically encrypted. There is no way to create an encrypted volume from an unencrypted snapshot or vice versa. If your AMI uses encrypted volumes, you can only launch it on supported instance types. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * VolumeType [VolumeType] <p>The volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p> <p>Default: <code>standard</code> </p>
-- * KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set.</p>
-- * SnapshotId [String] <p>The snapshot from which to create the volume.</p>
-- * Iops [Integer] <p>Only valid for Provisioned IOPS SSD volumes. The number of I/O operations per second (IOPS) to provision for the volume, with a maximum ratio of 50 IOPS/GiB.</p> <p>Constraint: Range is 100 to 20000 for Provisioned IOPS SSD volumes </p>
-- * Size [Integer] <p>The size of the volume, in GiBs.</p> <p>Constraints: 1-16384 for <code>gp2</code>, 4-16384 for <code>io1</code>, 500-16384 for <code>st1</code>, 500-16384 for <code>sc1</code>, and 1-1024 for <code>standard</code>. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- Required key: AvailabilityZone
-- @return CreateVolumeRequest structure as a key-value pair table
function M.CreateVolumeRequest(args)
	assert(args, "You must provdide an argument table when creating CreateVolumeRequest")
	local t = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["DryRun"] = args["DryRun"],
		["TagSpecifications"] = args["TagSpecifications"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["KmsKeyId"] = args["KmsKeyId"],
		["SnapshotId"] = args["SnapshotId"],
		["Iops"] = args["Iops"],
		["Size"] = args["Size"],
	}
	asserts.AssertCreateVolumeRequest(t)
	return t
end

keys.DescribeHostsResult = { ["NextToken"] = true, ["Hosts"] = true, nil }

function asserts.AssertDescribeHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Hosts"] then asserts.AssertHostList(struct["Hosts"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostsResult[k], "DescribeHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostsResult
-- <p>Contains the output of DescribeHosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * Hosts [HostList] <p>Information about the Dedicated Hosts.</p>
-- @return DescribeHostsResult structure as a key-value pair table
function M.DescribeHostsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeHostsResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["Hosts"] = args["Hosts"],
	}
	asserts.AssertDescribeHostsResult(t)
	return t
end

keys.DescribeVolumesResult = { ["NextToken"] = true, ["Volumes"] = true, nil }

function asserts.AssertDescribeVolumesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Volumes"] then asserts.AssertVolumeList(struct["Volumes"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesResult[k], "DescribeVolumesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesResult
-- <p>Contains the output of DescribeVolumes.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeVolumes</code> request. When the results of a <code>DescribeVolumes</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * Volumes [VolumeList] <p>Information about the volumes.</p>
-- @return DescribeVolumesResult structure as a key-value pair table
function M.DescribeVolumesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVolumesResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["Volumes"] = args["Volumes"],
	}
	asserts.AssertDescribeVolumesResult(t)
	return t
end

keys.DescribeNatGatewaysRequest = { ["Filter"] = true, ["NextToken"] = true, ["NatGatewayIds"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeNatGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNatGatewaysRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["NatGatewayIds"] then asserts.AssertValueStringList(struct["NatGatewayIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNatGatewaysRequest[k], "DescribeNatGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNatGatewaysRequest
-- <p>Contains the parameters for DescribeNatGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>nat-gateway-id</code> - The ID of the NAT gateway.</p> </li> <li> <p> <code>state</code> - The state of the NAT gateway (<code>pending</code> | <code>failed</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet in which the NAT gateway resides.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC in which the NAT gateway resides.</p> </li> </ul>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * NatGatewayIds [ValueStringList] <p>One or more NAT gateway IDs.</p>
-- * MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value specified is greater than 1000, we return only 1000 items.</p>
-- @return DescribeNatGatewaysRequest structure as a key-value pair table
function M.DescribeNatGatewaysRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeNatGatewaysRequest")
	local t = { 
		["Filter"] = args["Filter"],
		["NextToken"] = args["NextToken"],
		["NatGatewayIds"] = args["NatGatewayIds"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeNatGatewaysRequest(t)
	return t
end

keys.DetachInternetGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertDetachInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachInternetGatewayRequest[k], "DetachInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachInternetGatewayRequest
-- <p>Contains the parameters for DetachInternetGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- Required key: InternetGatewayId
-- Required key: VpcId
-- @return DetachInternetGatewayRequest structure as a key-value pair table
function M.DetachInternetGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating DetachInternetGatewayRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["InternetGatewayId"] = args["InternetGatewayId"],
	}
	asserts.AssertDetachInternetGatewayRequest(t)
	return t
end

keys.ScheduledInstancesEbs = { ["VolumeSize"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["DeleteOnTermination"] = true, ["SnapshotId"] = true, ["Iops"] = true, nil }

function asserts.AssertScheduledInstancesEbs(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesEbs to be of type 'table'")
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertString(struct["VolumeType"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesEbs[k], "ScheduledInstancesEbs contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesEbs
-- <p>Describes an EBS volume for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeSize [Integer] <p>The size of the volume, in GiB.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- * Encrypted [Boolean] <p>Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.</p>
-- * VolumeType [String] <p>The volume type. <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, Throughput Optimized HDD for <code>st1</code>, Cold HDD for <code>sc1</code>, or <code>standard</code> for Magnetic.</p> <p>Default: <code>standard</code> </p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- * Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about <code>gp2</code> baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for <code>io1</code> volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code>volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
-- @return ScheduledInstancesEbs structure as a key-value pair table
function M.ScheduledInstancesEbs(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstancesEbs")
	local t = { 
		["VolumeSize"] = args["VolumeSize"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["SnapshotId"] = args["SnapshotId"],
		["Iops"] = args["Iops"],
	}
	asserts.AssertScheduledInstancesEbs(t)
	return t
end

keys.CreateImageRequest = { ["DryRun"] = true, ["Description"] = true, ["InstanceId"] = true, ["BlockDeviceMappings"] = true, ["NoReboot"] = true, ["Name"] = true, nil }

function asserts.AssertCreateImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateImageRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["NoReboot"] then asserts.AssertBoolean(struct["NoReboot"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateImageRequest[k], "CreateImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateImageRequest
-- <p>Contains the parameters for CreateImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the new image.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * BlockDeviceMappings [BlockDeviceMappingRequestList] <p>Information about one or more block device mappings.</p>
-- * NoReboot [Boolean] <p>By default, Amazon EC2 attempts to shut down and reboot the instance before creating the image. If the 'No Reboot' option is set, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed.</p>
-- * Name [String] <p>A name for the new image.</p> <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
-- Required key: InstanceId
-- Required key: Name
-- @return CreateImageRequest structure as a key-value pair table
function M.CreateImageRequest(args)
	assert(args, "You must provdide an argument table when creating CreateImageRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["InstanceId"] = args["InstanceId"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["NoReboot"] = args["NoReboot"],
		["Name"] = args["Name"],
	}
	asserts.AssertCreateImageRequest(t)
	return t
end

keys.DisableVpcClassicLinkDnsSupportResult = { ["Return"] = true, nil }

function asserts.AssertDisableVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkDnsSupportResult[k], "DisableVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkDnsSupportResult
-- <p>Contains the output of DisableVpcClassicLinkDnsSupport.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DisableVpcClassicLinkDnsSupportResult structure as a key-value pair table
function M.DisableVpcClassicLinkDnsSupportResult(args)
	assert(args, "You must provdide an argument table when creating DisableVpcClassicLinkDnsSupportResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDisableVpcClassicLinkDnsSupportResult(t)
	return t
end

keys.DescribePrefixListsResult = { ["NextToken"] = true, ["PrefixLists"] = true, nil }

function asserts.AssertDescribePrefixListsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrefixListsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["PrefixLists"] then asserts.AssertPrefixListSet(struct["PrefixLists"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePrefixListsResult[k], "DescribePrefixListsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrefixListsResult
-- <p>Contains the output of DescribePrefixLists.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * PrefixLists [PrefixListSet] <p>All available prefix lists.</p>
-- @return DescribePrefixListsResult structure as a key-value pair table
function M.DescribePrefixListsResult(args)
	assert(args, "You must provdide an argument table when creating DescribePrefixListsResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["PrefixLists"] = args["PrefixLists"],
	}
	asserts.AssertDescribePrefixListsResult(t)
	return t
end

keys.DescribeMovingAddressesResult = { ["MovingAddressStatuses"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeMovingAddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMovingAddressesResult to be of type 'table'")
	if struct["MovingAddressStatuses"] then asserts.AssertMovingAddressStatusSet(struct["MovingAddressStatuses"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMovingAddressesResult[k], "DescribeMovingAddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMovingAddressesResult
-- <p>Contains the output of DescribeMovingAddresses.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MovingAddressStatuses [MovingAddressStatusSet] <p>The status for each Elastic IP address.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeMovingAddressesResult structure as a key-value pair table
function M.DescribeMovingAddressesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeMovingAddressesResult")
	local t = { 
		["MovingAddressStatuses"] = args["MovingAddressStatuses"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeMovingAddressesResult(t)
	return t
end

keys.VolumeModification = { ["TargetSize"] = true, ["TargetVolumeType"] = true, ["ModificationState"] = true, ["VolumeId"] = true, ["TargetIops"] = true, ["OriginalSize"] = true, ["StartTime"] = true, ["Progress"] = true, ["OriginalVolumeType"] = true, ["OriginalIops"] = true, ["EndTime"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertVolumeModification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeModification to be of type 'table'")
	if struct["TargetSize"] then asserts.AssertInteger(struct["TargetSize"]) end
	if struct["TargetVolumeType"] then asserts.AssertVolumeType(struct["TargetVolumeType"]) end
	if struct["ModificationState"] then asserts.AssertVolumeModificationState(struct["ModificationState"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["TargetIops"] then asserts.AssertInteger(struct["TargetIops"]) end
	if struct["OriginalSize"] then asserts.AssertInteger(struct["OriginalSize"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["Progress"] then asserts.AssertLong(struct["Progress"]) end
	if struct["OriginalVolumeType"] then asserts.AssertVolumeType(struct["OriginalVolumeType"]) end
	if struct["OriginalIops"] then asserts.AssertInteger(struct["OriginalIops"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeModification[k], "VolumeModification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeModification
-- <p>Describes the modification status of an EBS volume.</p> <p>If the volume has never been modified, some element values will be null.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetSize [Integer] <p>Target size of the volume being modified.</p>
-- * TargetVolumeType [VolumeType] <p>Target EBS volume type of the volume being modified.</p>
-- * ModificationState [VolumeModificationState] <p>Current state of modification. Modification state is null for unmodified volumes. </p>
-- * VolumeId [String] <p>ID of the volume being modified.</p>
-- * TargetIops [Integer] <p>Target IOPS rate of the volume being modified.</p>
-- * OriginalSize [Integer] <p>Original size of the volume being modified.</p>
-- * StartTime [DateTime] <p>Modification start time </p>
-- * Progress [Long] <p>Modification progress from 0 to 100%.</p>
-- * OriginalVolumeType [VolumeType] <p>Original EBS volume type of the volume being modified.</p>
-- * OriginalIops [Integer] <p>Original IOPS rate of the volume being modified.</p>
-- * EndTime [DateTime] <p>Modification completion or failure time.</p>
-- * StatusMessage [String] <p>Generic status message on modification progress or failure.</p>
-- @return VolumeModification structure as a key-value pair table
function M.VolumeModification(args)
	assert(args, "You must provdide an argument table when creating VolumeModification")
	local t = { 
		["TargetSize"] = args["TargetSize"],
		["TargetVolumeType"] = args["TargetVolumeType"],
		["ModificationState"] = args["ModificationState"],
		["VolumeId"] = args["VolumeId"],
		["TargetIops"] = args["TargetIops"],
		["OriginalSize"] = args["OriginalSize"],
		["StartTime"] = args["StartTime"],
		["Progress"] = args["Progress"],
		["OriginalVolumeType"] = args["OriginalVolumeType"],
		["OriginalIops"] = args["OriginalIops"],
		["EndTime"] = args["EndTime"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertVolumeModification(t)
	return t
end

keys.ModifySnapshotAttributeRequest = { ["DryRun"] = true, ["Attribute"] = true, ["UserIds"] = true, ["GroupNames"] = true, ["CreateVolumePermission"] = true, ["OperationType"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertModifySnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySnapshotAttributeRequest to be of type 'table'")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Attribute"] then asserts.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["UserIds"] then asserts.AssertUserIdStringList(struct["UserIds"]) end
	if struct["GroupNames"] then asserts.AssertGroupNameStringList(struct["GroupNames"]) end
	if struct["CreateVolumePermission"] then asserts.AssertCreateVolumePermissionModifications(struct["CreateVolumePermission"]) end
	if struct["OperationType"] then asserts.AssertOperationType(struct["OperationType"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySnapshotAttributeRequest[k], "ModifySnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySnapshotAttributeRequest
-- <p>Contains the parameters for ModifySnapshotAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Attribute [SnapshotAttributeName] <p>The snapshot attribute to modify.</p> <note> <p>Only volume creation permissions may be modified at the customer level.</p> </note>
-- * UserIds [UserIdStringList] <p>The account ID to modify for the snapshot.</p>
-- * GroupNames [GroupNameStringList] <p>The group to modify for the snapshot.</p>
-- * CreateVolumePermission [CreateVolumePermissionModifications] <p>A JSON representation of the snapshot attribute modification.</p>
-- * OperationType [OperationType] <p>The type of operation to perform to the attribute.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- Required key: SnapshotId
-- @return ModifySnapshotAttributeRequest structure as a key-value pair table
function M.ModifySnapshotAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ModifySnapshotAttributeRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Attribute"] = args["Attribute"],
		["UserIds"] = args["UserIds"],
		["GroupNames"] = args["GroupNames"],
		["CreateVolumePermission"] = args["CreateVolumePermission"],
		["OperationType"] = args["OperationType"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertModifySnapshotAttributeRequest(t)
	return t
end

keys.DescribeAddressesResult = { ["Addresses"] = true, nil }

function asserts.AssertDescribeAddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAddressesResult to be of type 'table'")
	if struct["Addresses"] then asserts.AssertAddressList(struct["Addresses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAddressesResult[k], "DescribeAddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAddressesResult
-- <p>Contains the output of DescribeAddresses.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Addresses [AddressList] <p>Information about one or more Elastic IP addresses.</p>
-- @return DescribeAddressesResult structure as a key-value pair table
function M.DescribeAddressesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeAddressesResult")
	local t = { 
		["Addresses"] = args["Addresses"],
	}
	asserts.AssertDescribeAddressesResult(t)
	return t
end

keys.RunInstancesMonitoringEnabled = { ["Enabled"] = true, nil }

function asserts.AssertRunInstancesMonitoringEnabled(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunInstancesMonitoringEnabled to be of type 'table'")
	assert(struct["Enabled"], "Expected key Enabled to exist in table")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunInstancesMonitoringEnabled[k], "RunInstancesMonitoringEnabled contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunInstancesMonitoringEnabled
-- <p>Describes the monitoring of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Enabled [Boolean] <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
-- Required key: Enabled
-- @return RunInstancesMonitoringEnabled structure as a key-value pair table
function M.RunInstancesMonitoringEnabled(args)
	assert(args, "You must provdide an argument table when creating RunInstancesMonitoringEnabled")
	local t = { 
		["Enabled"] = args["Enabled"],
	}
	asserts.AssertRunInstancesMonitoringEnabled(t)
	return t
end

keys.HostProperties = { ["Cores"] = true, ["TotalVCpus"] = true, ["InstanceType"] = true, ["Sockets"] = true, nil }

function asserts.AssertHostProperties(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostProperties to be of type 'table'")
	if struct["Cores"] then asserts.AssertInteger(struct["Cores"]) end
	if struct["TotalVCpus"] then asserts.AssertInteger(struct["TotalVCpus"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["Sockets"] then asserts.AssertInteger(struct["Sockets"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostProperties[k], "HostProperties contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostProperties
-- <p>Describes properties of a Dedicated Host.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Cores [Integer] <p>The number of cores on the Dedicated Host.</p>
-- * TotalVCpus [Integer] <p>The number of vCPUs on the Dedicated Host.</p>
-- * InstanceType [String] <p>The instance type size that the Dedicated Host supports (for example, <code>m3.medium</code>).</p>
-- * Sockets [Integer] <p>The number of sockets on the Dedicated Host.</p>
-- @return HostProperties structure as a key-value pair table
function M.HostProperties(args)
	assert(args, "You must provdide an argument table when creating HostProperties")
	local t = { 
		["Cores"] = args["Cores"],
		["TotalVCpus"] = args["TotalVCpus"],
		["InstanceType"] = args["InstanceType"],
		["Sockets"] = args["Sockets"],
	}
	asserts.AssertHostProperties(t)
	return t
end

keys.InstanceStatusSummary = { ["Status"] = true, ["Details"] = true, nil }

function asserts.AssertInstanceStatusSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusSummary to be of type 'table'")
	if struct["Status"] then asserts.AssertSummaryStatus(struct["Status"]) end
	if struct["Details"] then asserts.AssertInstanceStatusDetailsList(struct["Details"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatusSummary[k], "InstanceStatusSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusSummary
-- <p>Describes the status of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [SummaryStatus] <p>The status.</p>
-- * Details [InstanceStatusDetailsList] <p>The system instance health or application instance health.</p>
-- @return InstanceStatusSummary structure as a key-value pair table
function M.InstanceStatusSummary(args)
	assert(args, "You must provdide an argument table when creating InstanceStatusSummary")
	local t = { 
		["Status"] = args["Status"],
		["Details"] = args["Details"],
	}
	asserts.AssertInstanceStatusSummary(t)
	return t
end

keys.DescribeVpcsRequest = { ["DryRun"] = true, ["Filters"] = true, ["VpcIds"] = true, nil }

function asserts.AssertDescribeVpcsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["VpcIds"] then asserts.AssertVpcIdStringList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcsRequest[k], "DescribeVpcsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcsRequest
-- <p>Contains the parameters for DescribeVpcs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>cidr</code> - The IPv4 CIDR block of the VPC. The CIDR block you specify must exactly match the VPC's CIDR block for information to be returned for the VPC. Must contain the slash followed by one or two digits (for example, <code>/28</code>).</p> </li> <li> <p> <code>dhcp-options-id</code> - The ID of a set of DHCP options.</p> </li> <li> <p> <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>ipv6-cidr-block-association.association-id</code> - The association ID for an IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>isDefault</code> - Indicates whether the VPC is the default VPC.</p> </li> <li> <p> <code>state</code> - The state of the VPC (<code>pending</code> | <code>available</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC.</p> </li> </ul>
-- * VpcIds [VpcIdStringList] <p>One or more VPC IDs.</p> <p>Default: Describes all your VPCs.</p>
-- @return DescribeVpcsRequest structure as a key-value pair table
function M.DescribeVpcsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcsRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["VpcIds"] = args["VpcIds"],
	}
	asserts.AssertDescribeVpcsRequest(t)
	return t
end

keys.SubnetIpv6CidrBlockAssociation = { ["Ipv6CidrBlock"] = true, ["AssociationId"] = true, ["Ipv6CidrBlockState"] = true, nil }

function asserts.AssertSubnetIpv6CidrBlockAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SubnetIpv6CidrBlockAssociation to be of type 'table'")
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["Ipv6CidrBlockState"] then asserts.AssertSubnetCidrBlockState(struct["Ipv6CidrBlockState"]) end
	for k,_ in pairs(struct) do
		assert(keys.SubnetIpv6CidrBlockAssociation[k], "SubnetIpv6CidrBlockAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SubnetIpv6CidrBlockAssociation
-- <p>Describes an IPv6 CIDR block associated with a subnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- * AssociationId [String] <p>The association ID for the CIDR block.</p>
-- * Ipv6CidrBlockState [SubnetCidrBlockState] <p>Information about the state of the CIDR block.</p>
-- @return SubnetIpv6CidrBlockAssociation structure as a key-value pair table
function M.SubnetIpv6CidrBlockAssociation(args)
	assert(args, "You must provdide an argument table when creating SubnetIpv6CidrBlockAssociation")
	local t = { 
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["AssociationId"] = args["AssociationId"],
		["Ipv6CidrBlockState"] = args["Ipv6CidrBlockState"],
	}
	asserts.AssertSubnetIpv6CidrBlockAssociation(t)
	return t
end

keys.CreateRouteTableResult = { ["RouteTable"] = true, nil }

function asserts.AssertCreateRouteTableResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteTableResult to be of type 'table'")
	if struct["RouteTable"] then asserts.AssertRouteTable(struct["RouteTable"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteTableResult[k], "CreateRouteTableResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteTableResult
-- <p>Contains the output of CreateRouteTable.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RouteTable [RouteTable] <p>Information about the route table.</p>
-- @return CreateRouteTableResult structure as a key-value pair table
function M.CreateRouteTableResult(args)
	assert(args, "You must provdide an argument table when creating CreateRouteTableResult")
	local t = { 
		["RouteTable"] = args["RouteTable"],
	}
	asserts.AssertCreateRouteTableResult(t)
	return t
end

keys.ModifyVpcEndpointResult = { ["Return"] = true, nil }

function asserts.AssertModifyVpcEndpointResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointResult[k], "ModifyVpcEndpointResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointResult
-- <p>Contains the output of ModifyVpcEndpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return ModifyVpcEndpointResult structure as a key-value pair table
function M.ModifyVpcEndpointResult(args)
	assert(args, "You must provdide an argument table when creating ModifyVpcEndpointResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifyVpcEndpointResult(t)
	return t
end

keys.DescribeTagsResult = { ["NextToken"] = true, ["Tags"] = true, nil }

function asserts.AssertDescribeTagsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeTagsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Tags"] then asserts.AssertTagDescriptionList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeTagsResult[k], "DescribeTagsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeTagsResult
-- <p>Contains the output of DescribeTags.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return..</p>
-- * Tags [TagDescriptionList] <p>A list of tags.</p>
-- @return DescribeTagsResult structure as a key-value pair table
function M.DescribeTagsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeTagsResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertDescribeTagsResult(t)
	return t
end

keys.DeleteVpcPeeringConnectionResult = { ["Return"] = true, nil }

function asserts.AssertDeleteVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcPeeringConnectionResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcPeeringConnectionResult[k], "DeleteVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcPeeringConnectionResult
-- <p>Contains the output of DeleteVpcPeeringConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DeleteVpcPeeringConnectionResult structure as a key-value pair table
function M.DeleteVpcPeeringConnectionResult(args)
	assert(args, "You must provdide an argument table when creating DeleteVpcPeeringConnectionResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDeleteVpcPeeringConnectionResult(t)
	return t
end

keys.BlockDeviceMapping = { ["DeviceName"] = true, ["VirtualName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BlockDeviceMapping to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertEbsBlockDevice(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.BlockDeviceMapping[k], "BlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BlockDeviceMapping
-- <p>Describes a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * VirtualName [String] <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
-- * NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- * Ebs [EbsBlockDevice] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
-- @return BlockDeviceMapping structure as a key-value pair table
function M.BlockDeviceMapping(args)
	assert(args, "You must provdide an argument table when creating BlockDeviceMapping")
	local t = { 
		["DeviceName"] = args["DeviceName"],
		["VirtualName"] = args["VirtualName"],
		["NoDevice"] = args["NoDevice"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertBlockDeviceMapping(t)
	return t
end

keys.ImportInstanceResult = { ["ConversionTask"] = true, nil }

function asserts.AssertImportInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceResult to be of type 'table'")
	if struct["ConversionTask"] then asserts.AssertConversionTask(struct["ConversionTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceResult[k], "ImportInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceResult
-- <p>Contains the output for ImportInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTask [ConversionTask] <p>Information about the conversion task.</p>
-- @return ImportInstanceResult structure as a key-value pair table
function M.ImportInstanceResult(args)
	assert(args, "You must provdide an argument table when creating ImportInstanceResult")
	local t = { 
		["ConversionTask"] = args["ConversionTask"],
	}
	asserts.AssertImportInstanceResult(t)
	return t
end

keys.AssociateRouteTableResult = { ["AssociationId"] = true, nil }

function asserts.AssertAssociateRouteTableResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateRouteTableResult to be of type 'table'")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateRouteTableResult[k], "AssociateRouteTableResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateRouteTableResult
-- <p>Contains the output of AssociateRouteTable.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The route table association ID (needed to disassociate the route table).</p>
-- @return AssociateRouteTableResult structure as a key-value pair table
function M.AssociateRouteTableResult(args)
	assert(args, "You must provdide an argument table when creating AssociateRouteTableResult")
	local t = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertAssociateRouteTableResult(t)
	return t
end

keys.DiskImageVolumeDescription = { ["Id"] = true, ["Size"] = true, nil }

function asserts.AssertDiskImageVolumeDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageVolumeDescription to be of type 'table'")
	assert(struct["Id"], "Expected key Id to exist in table")
	if struct["Id"] then asserts.AssertString(struct["Id"]) end
	if struct["Size"] then asserts.AssertLong(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImageVolumeDescription[k], "DiskImageVolumeDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageVolumeDescription
-- <p>Describes a disk image volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Id [String] <p>The volume identifier.</p>
-- * Size [Long] <p>The size of the volume, in GiB.</p>
-- Required key: Id
-- @return DiskImageVolumeDescription structure as a key-value pair table
function M.DiskImageVolumeDescription(args)
	assert(args, "You must provdide an argument table when creating DiskImageVolumeDescription")
	local t = { 
		["Id"] = args["Id"],
		["Size"] = args["Size"],
	}
	asserts.AssertDiskImageVolumeDescription(t)
	return t
end

keys.VpcAttachment = { ["State"] = true, ["VpcId"] = true, nil }

function asserts.AssertVpcAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcAttachment to be of type 'table'")
	if struct["State"] then asserts.AssertAttachmentStatus(struct["State"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcAttachment[k], "VpcAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcAttachment
-- <p>Describes an attachment between a virtual private gateway and a VPC.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [AttachmentStatus] <p>The current state of the attachment.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return VpcAttachment structure as a key-value pair table
function M.VpcAttachment(args)
	assert(args, "You must provdide an argument table when creating VpcAttachment")
	local t = { 
		["State"] = args["State"],
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertVpcAttachment(t)
	return t
end

keys.Snapshot = { ["OwnerAlias"] = true, ["DataEncryptionKeyId"] = true, ["Description"] = true, ["VolumeSize"] = true, ["Tags"] = true, ["Encrypted"] = true, ["SnapshotId"] = true, ["VolumeId"] = true, ["StateMessage"] = true, ["State"] = true, ["KmsKeyId"] = true, ["StartTime"] = true, ["OwnerId"] = true, ["Progress"] = true, nil }

function asserts.AssertSnapshot(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Snapshot to be of type 'table'")
	if struct["OwnerAlias"] then asserts.AssertString(struct["OwnerAlias"]) end
	if struct["DataEncryptionKeyId"] then asserts.AssertString(struct["DataEncryptionKeyId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["StateMessage"] then asserts.AssertString(struct["StateMessage"]) end
	if struct["State"] then asserts.AssertSnapshotState(struct["State"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	for k,_ in pairs(struct) do
		assert(keys.Snapshot[k], "Snapshot contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Snapshot
-- <p>Describes a snapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OwnerAlias [String] <p> Value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console. </p>
-- * DataEncryptionKeyId [String] <p>The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by the <a>DescribeSnapshots</a> API operation.</p>
-- * Description [String] <p>The description for the snapshot.</p>
-- * VolumeSize [Integer] <p>The size of the volume, in GiB.</p>
-- * Tags [TagList] <p>Any tags assigned to the snapshot.</p>
-- * Encrypted [Boolean] <p>Indicates whether the snapshot is encrypted.</p>
-- * SnapshotId [String] <p>The ID of the snapshot. Each snapshot receives a unique identifier when it is created.</p>
-- * VolumeId [String] <p>The ID of the volume that was used to create the snapshot. Snapshots created by the <a>CopySnapshot</a> action have an arbitrary volume ID that should not be used for any purpose.</p>
-- * StateMessage [String] <p>Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper AWS Key Management Service (AWS KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by the <a>DescribeSnapshots</a> API operation.</p>
-- * State [SnapshotState] <p>The snapshot state.</p>
-- * KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the parent volume.</p>
-- * StartTime [DateTime] <p>The time stamp when the snapshot was initiated.</p>
-- * OwnerId [String] <p>The AWS account ID of the EBS snapshot owner.</p>
-- * Progress [String] <p>The progress of the snapshot, as a percentage.</p>
-- @return Snapshot structure as a key-value pair table
function M.Snapshot(args)
	assert(args, "You must provdide an argument table when creating Snapshot")
	local t = { 
		["OwnerAlias"] = args["OwnerAlias"],
		["DataEncryptionKeyId"] = args["DataEncryptionKeyId"],
		["Description"] = args["Description"],
		["VolumeSize"] = args["VolumeSize"],
		["Tags"] = args["Tags"],
		["Encrypted"] = args["Encrypted"],
		["SnapshotId"] = args["SnapshotId"],
		["VolumeId"] = args["VolumeId"],
		["StateMessage"] = args["StateMessage"],
		["State"] = args["State"],
		["KmsKeyId"] = args["KmsKeyId"],
		["StartTime"] = args["StartTime"],
		["OwnerId"] = args["OwnerId"],
		["Progress"] = args["Progress"],
	}
	asserts.AssertSnapshot(t)
	return t
end

keys.DescribeVpcsResult = { ["Vpcs"] = true, nil }

function asserts.AssertDescribeVpcsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcsResult to be of type 'table'")
	if struct["Vpcs"] then asserts.AssertVpcList(struct["Vpcs"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcsResult[k], "DescribeVpcsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcsResult
-- <p>Contains the output of DescribeVpcs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Vpcs [VpcList] <p>Information about one or more VPCs.</p>
-- @return DescribeVpcsResult structure as a key-value pair table
function M.DescribeVpcsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcsResult")
	local t = { 
		["Vpcs"] = args["Vpcs"],
	}
	asserts.AssertDescribeVpcsResult(t)
	return t
end

keys.CancelSpotFleetRequestsErrorItem = { ["SpotFleetRequestId"] = true, ["Error"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsErrorItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsErrorItem to be of type 'table'")
	assert(struct["Error"], "Expected key Error to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["Error"] then asserts.AssertCancelSpotFleetRequestsError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsErrorItem[k], "CancelSpotFleetRequestsErrorItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsErrorItem
-- <p>Describes a Spot fleet request that was not successfully canceled.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- * Error [CancelSpotFleetRequestsError] <p>The error.</p>
-- Required key: Error
-- Required key: SpotFleetRequestId
-- @return CancelSpotFleetRequestsErrorItem structure as a key-value pair table
function M.CancelSpotFleetRequestsErrorItem(args)
	assert(args, "You must provdide an argument table when creating CancelSpotFleetRequestsErrorItem")
	local t = { 
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["Error"] = args["Error"],
	}
	asserts.AssertCancelSpotFleetRequestsErrorItem(t)
	return t
end

keys.DeleteRouteRequest = { ["DestinationCidrBlock"] = true, ["DryRun"] = true, ["DestinationIpv6CidrBlock"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertDeleteRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteRouteRequest[k], "DeleteRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRouteRequest
-- <p>Contains the parameters for DeleteRoute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DestinationCidrBlock [String] <p>The IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- Required key: RouteTableId
-- @return DeleteRouteRequest structure as a key-value pair table
function M.DeleteRouteRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteRouteRequest")
	local t = { 
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["DryRun"] = args["DryRun"],
		["DestinationIpv6CidrBlock"] = args["DestinationIpv6CidrBlock"],
		["RouteTableId"] = args["RouteTableId"],
	}
	asserts.AssertDeleteRouteRequest(t)
	return t
end

keys.ReplaceRouteRequest = { ["DestinationCidrBlock"] = true, ["EgressOnlyInternetGatewayId"] = true, ["DryRun"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["RouteTableId"] = true, ["NatGatewayId"] = true, ["VpcPeeringConnectionId"] = true, ["GatewayId"] = true, ["DestinationIpv6CidrBlock"] = true, nil }

function asserts.AssertReplaceRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceRouteRequest[k], "ReplaceRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteRequest
-- <p>Contains the parameters for ReplaceRoute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DestinationCidrBlock [String] <p>The IPv4 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.</p>
-- * EgressOnlyInternetGatewayId [String] <p>[IPv6 traffic only] The ID of an egress-only Internet gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceId [String] <p>The ID of a NAT instance in your VPC.</p>
-- * NetworkInterfaceId [String] <p>The ID of a network interface.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- * NatGatewayId [String] <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of a VPC peering connection.</p>
-- * GatewayId [String] <p>The ID of an Internet gateway or virtual private gateway.</p>
-- * DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.</p>
-- Required key: RouteTableId
-- @return ReplaceRouteRequest structure as a key-value pair table
function M.ReplaceRouteRequest(args)
	assert(args, "You must provdide an argument table when creating ReplaceRouteRequest")
	local t = { 
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["DryRun"] = args["DryRun"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["RouteTableId"] = args["RouteTableId"],
		["NatGatewayId"] = args["NatGatewayId"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["GatewayId"] = args["GatewayId"],
		["DestinationIpv6CidrBlock"] = args["DestinationIpv6CidrBlock"],
	}
	asserts.AssertReplaceRouteRequest(t)
	return t
end

keys.SecurityGroupReference = { ["ReferencingVpcId"] = true, ["GroupId"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertSecurityGroupReference(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityGroupReference to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	assert(struct["ReferencingVpcId"], "Expected key ReferencingVpcId to exist in table")
	if struct["ReferencingVpcId"] then asserts.AssertString(struct["ReferencingVpcId"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityGroupReference[k], "SecurityGroupReference contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityGroupReference
-- <p>Describes a VPC with a security group that references your security group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReferencingVpcId [String] <p>The ID of the VPC with the referencing security group.</p>
-- * GroupId [String] <p>The ID of your security group.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required key: GroupId
-- Required key: ReferencingVpcId
-- @return SecurityGroupReference structure as a key-value pair table
function M.SecurityGroupReference(args)
	assert(args, "You must provdide an argument table when creating SecurityGroupReference")
	local t = { 
		["ReferencingVpcId"] = args["ReferencingVpcId"],
		["GroupId"] = args["GroupId"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
	}
	asserts.AssertSecurityGroupReference(t)
	return t
end

keys.DescribeConversionTasksResult = { ["ConversionTasks"] = true, nil }

function asserts.AssertDescribeConversionTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeConversionTasksResult to be of type 'table'")
	if struct["ConversionTasks"] then asserts.AssertDescribeConversionTaskList(struct["ConversionTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeConversionTasksResult[k], "DescribeConversionTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeConversionTasksResult
-- <p>Contains the output for DescribeConversionTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTasks [DescribeConversionTaskList] <p>Information about the conversion tasks.</p>
-- @return DescribeConversionTasksResult structure as a key-value pair table
function M.DescribeConversionTasksResult(args)
	assert(args, "You must provdide an argument table when creating DescribeConversionTasksResult")
	local t = { 
		["ConversionTasks"] = args["ConversionTasks"],
	}
	asserts.AssertDescribeConversionTasksResult(t)
	return t
end

keys.CreateSnapshotRequest = { ["DryRun"] = true, ["Description"] = true, ["VolumeId"] = true, nil }

function asserts.AssertCreateSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSnapshotRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSnapshotRequest[k], "CreateSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSnapshotRequest
-- <p>Contains the parameters for CreateSnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the snapshot.</p>
-- * VolumeId [String] <p>The ID of the EBS volume.</p>
-- Required key: VolumeId
-- @return CreateSnapshotRequest structure as a key-value pair table
function M.CreateSnapshotRequest(args)
	assert(args, "You must provdide an argument table when creating CreateSnapshotRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertCreateSnapshotRequest(t)
	return t
end

keys.AssociateSubnetCidrBlockRequest = { ["SubnetId"] = true, ["Ipv6CidrBlock"] = true, nil }

function asserts.AssertAssociateSubnetCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateSubnetCidrBlockRequest to be of type 'table'")
	assert(struct["Ipv6CidrBlock"], "Expected key Ipv6CidrBlock to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateSubnetCidrBlockRequest[k], "AssociateSubnetCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateSubnetCidrBlockRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of your subnet.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 CIDR block for your subnet. The subnet must have a /64 prefix length.</p>
-- Required key: Ipv6CidrBlock
-- Required key: SubnetId
-- @return AssociateSubnetCidrBlockRequest structure as a key-value pair table
function M.AssociateSubnetCidrBlockRequest(args)
	assert(args, "You must provdide an argument table when creating AssociateSubnetCidrBlockRequest")
	local t = { 
		["SubnetId"] = args["SubnetId"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
	}
	asserts.AssertAssociateSubnetCidrBlockRequest(t)
	return t
end

keys.ImageAttribute = { ["ProductCodes"] = true, ["Description"] = true, ["LaunchPermissions"] = true, ["SriovNetSupport"] = true, ["ImageId"] = true, ["BlockDeviceMappings"] = true, ["KernelId"] = true, ["RamdiskId"] = true, nil }

function asserts.AssertImageAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImageAttribute to be of type 'table'")
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	if struct["LaunchPermissions"] then asserts.AssertLaunchPermissionList(struct["LaunchPermissions"]) end
	if struct["SriovNetSupport"] then asserts.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then asserts.AssertAttributeValue(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertAttributeValue(struct["RamdiskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImageAttribute[k], "ImageAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImageAttribute
-- <p>Describes an image attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodes [ProductCodeList] <p>One or more product codes.</p>
-- * Description [AttributeValue] <p>A description for the AMI.</p>
-- * LaunchPermissions [LaunchPermissionList] <p>One or more launch permissions.</p>
-- * SriovNetSupport [AttributeValue] <p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p>
-- * KernelId [AttributeValue] <p>The kernel ID.</p>
-- * RamdiskId [AttributeValue] <p>The RAM disk ID.</p>
-- @return ImageAttribute structure as a key-value pair table
function M.ImageAttribute(args)
	assert(args, "You must provdide an argument table when creating ImageAttribute")
	local t = { 
		["ProductCodes"] = args["ProductCodes"],
		["Description"] = args["Description"],
		["LaunchPermissions"] = args["LaunchPermissions"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["ImageId"] = args["ImageId"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["KernelId"] = args["KernelId"],
		["RamdiskId"] = args["RamdiskId"],
	}
	asserts.AssertImageAttribute(t)
	return t
end

keys.DeleteEgressOnlyInternetGatewayRequest = { ["EgressOnlyInternetGatewayId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteEgressOnlyInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteEgressOnlyInternetGatewayRequest to be of type 'table'")
	assert(struct["EgressOnlyInternetGatewayId"], "Expected key EgressOnlyInternetGatewayId to exist in table")
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertEgressOnlyInternetGatewayId(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteEgressOnlyInternetGatewayRequest[k], "DeleteEgressOnlyInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteEgressOnlyInternetGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EgressOnlyInternetGatewayId [EgressOnlyInternetGatewayId] <p>The ID of the egress-only Internet gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: EgressOnlyInternetGatewayId
-- @return DeleteEgressOnlyInternetGatewayRequest structure as a key-value pair table
function M.DeleteEgressOnlyInternetGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteEgressOnlyInternetGatewayRequest")
	local t = { 
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteEgressOnlyInternetGatewayRequest(t)
	return t
end

keys.DescribeVolumesRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["VolumeIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVolumesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeIds"] then asserts.AssertVolumeIdStringList(struct["VolumeIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesRequest[k], "DescribeVolumesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesRequest
-- <p>Contains the parameters for DescribeVolumes.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of volume results returned by <code>DescribeVolumes</code> in paginated output. When this parameter is used, <code>DescribeVolumes</code> only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>DescribeVolumes</code> request with the returned <code>NextToken</code> value. This value can be between 5 and 500; if <code>MaxResults</code> is given a value larger than 500, only 500 results are returned. If this parameter is not used, then <code>DescribeVolumes</code> returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.</p>
-- * NextToken [String] <p>The <code>NextToken</code> value returned from a previous paginated <code>DescribeVolumes</code> request where <code>MaxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>NextToken</code> value. This value is <code>null</code> when there are no more results to return.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeIds [VolumeIdStringList] <p>One or more volume IDs.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.attach-time</code> - The time stamp when the attachment initiated.</p> </li> <li> <p> <code>attachment.delete-on-termination</code> - Whether the volume is deleted on instance termination.</p> </li> <li> <p> <code>attachment.device</code> - The device name that is exposed to the instance (for example, <code>/dev/sda1</code>).</p> </li> <li> <p> <code>attachment.instance-id</code> - The ID of the instance the volume is attached to.</p> </li> <li> <p> <code>attachment.status</code> - The attachment state (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone in which the volume was created.</p> </li> <li> <p> <code>create-time</code> - The time stamp when the volume was created.</p> </li> <li> <p> <code>encrypted</code> - The encryption status of the volume.</p> </li> <li> <p> <code>size</code> - The size of the volume, in GiB.</p> </li> <li> <p> <code>snapshot-id</code> - The snapshot from which the volume was created.</p> </li> <li> <p> <code>status</code> - The status of the volume (<code>creating</code> | <code>available</code> | <code>in-use</code> | <code>deleting</code> | <code>deleted</code> | <code>error</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>volume-id</code> - The volume ID.</p> </li> <li> <p> <code>volume-type</code> - The Amazon EBS volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p> </li> </ul>
-- @return DescribeVolumesRequest structure as a key-value pair table
function M.DescribeVolumesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVolumesRequest")
	local t = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["VolumeIds"] = args["VolumeIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVolumesRequest(t)
	return t
end

keys.DescribeHostsRequest = { ["Filter"] = true, ["HostIds"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostsRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["HostIds"] then asserts.AssertRequestHostIdList(struct["HostIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostsRequest[k], "DescribeHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostsRequest
-- <p>Contains the parameters for DescribeHosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-type</code> - The instance type size that the Dedicated Host is configured to support.</p> </li> <li> <p> <code>auto-placement</code> - Whether auto-placement is enabled or disabled (<code>on</code> | <code>off</code>).</p> </li> <li> <p> <code>host-reservation-id</code> - The ID of the reservation assigned to this host.</p> </li> <li> <p> <code>client-token</code> - The idempotency token you provided when you launched the instance</p> </li> <li> <p> <code>state</code>- The allocation state of the Dedicated Host (<code>available</code> | <code>under-assessment</code> | <code>permanent-failure</code> | <code>released</code> | <code>released-permanent-failure</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the host.</p> </li> </ul>
-- * HostIds [RequestHostIdList] <p>The IDs of the Dedicated Hosts. The IDs are used for targeted instance launches.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500; if <code>maxResults</code> is given a larger value than 500, you will receive an error. You cannot specify this parameter and the host IDs parameter in the same request.</p>
-- @return DescribeHostsRequest structure as a key-value pair table
function M.DescribeHostsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeHostsRequest")
	local t = { 
		["Filter"] = args["Filter"],
		["HostIds"] = args["HostIds"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeHostsRequest(t)
	return t
end

keys.DescribeImportImageTasksResult = { ["NextToken"] = true, ["ImportImageTasks"] = true, nil }

function asserts.AssertDescribeImportImageTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportImageTasksResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ImportImageTasks"] then asserts.AssertImportImageTaskList(struct["ImportImageTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportImageTasksResult[k], "DescribeImportImageTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportImageTasksResult
-- <p>Contains the output for DescribeImportImageTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ImportImageTasks [ImportImageTaskList] <p>A list of zero or more import image tasks that are currently active or were completed or canceled in the previous 7 days.</p>
-- @return DescribeImportImageTasksResult structure as a key-value pair table
function M.DescribeImportImageTasksResult(args)
	assert(args, "You must provdide an argument table when creating DescribeImportImageTasksResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["ImportImageTasks"] = args["ImportImageTasks"],
	}
	asserts.AssertDescribeImportImageTasksResult(t)
	return t
end

keys.CreatePlacementGroupRequest = { ["GroupName"] = true, ["DryRun"] = true, ["Strategy"] = true, nil }

function asserts.AssertCreatePlacementGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePlacementGroupRequest to be of type 'table'")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	assert(struct["Strategy"], "Expected key Strategy to exist in table")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Strategy"] then asserts.AssertPlacementStrategy(struct["Strategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreatePlacementGroupRequest[k], "CreatePlacementGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePlacementGroupRequest
-- <p>Contains the parameters for CreatePlacementGroup.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>A name for the placement group.</p> <p>Constraints: Up to 255 ASCII characters</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Strategy [PlacementStrategy] <p>The placement strategy.</p>
-- Required key: GroupName
-- Required key: Strategy
-- @return CreatePlacementGroupRequest structure as a key-value pair table
function M.CreatePlacementGroupRequest(args)
	assert(args, "You must provdide an argument table when creating CreatePlacementGroupRequest")
	local t = { 
		["GroupName"] = args["GroupName"],
		["DryRun"] = args["DryRun"],
		["Strategy"] = args["Strategy"],
	}
	asserts.AssertCreatePlacementGroupRequest(t)
	return t
end

keys.DisassociateIamInstanceProfileResult = { ["IamInstanceProfileAssociation"] = true, nil }

function asserts.AssertDisassociateIamInstanceProfileResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateIamInstanceProfileResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then asserts.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateIamInstanceProfileResult[k], "DisassociateIamInstanceProfileResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateIamInstanceProfileResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
-- @return DisassociateIamInstanceProfileResult structure as a key-value pair table
function M.DisassociateIamInstanceProfileResult(args)
	assert(args, "You must provdide an argument table when creating DisassociateIamInstanceProfileResult")
	local t = { 
		["IamInstanceProfileAssociation"] = args["IamInstanceProfileAssociation"],
	}
	asserts.AssertDisassociateIamInstanceProfileResult(t)
	return t
end

keys.AssignIpv6AddressesResult = { ["AssignedIpv6Addresses"] = true, ["NetworkInterfaceId"] = true, nil }

function asserts.AssertAssignIpv6AddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignIpv6AddressesResult to be of type 'table'")
	if struct["AssignedIpv6Addresses"] then asserts.AssertIpv6AddressList(struct["AssignedIpv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssignIpv6AddressesResult[k], "AssignIpv6AddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignIpv6AddressesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssignedIpv6Addresses [Ipv6AddressList] <p>The IPv6 addresses assigned to the network interface.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @return AssignIpv6AddressesResult structure as a key-value pair table
function M.AssignIpv6AddressesResult(args)
	assert(args, "You must provdide an argument table when creating AssignIpv6AddressesResult")
	local t = { 
		["AssignedIpv6Addresses"] = args["AssignedIpv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
	}
	asserts.AssertAssignIpv6AddressesResult(t)
	return t
end

keys.StaleSecurityGroup = { ["VpcId"] = true, ["StaleIpPermissionsEgress"] = true, ["GroupName"] = true, ["StaleIpPermissions"] = true, ["GroupId"] = true, ["Description"] = true, nil }

function asserts.AssertStaleSecurityGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StaleSecurityGroup to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["StaleIpPermissionsEgress"] then asserts.AssertStaleIpPermissionSet(struct["StaleIpPermissionsEgress"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["StaleIpPermissions"] then asserts.AssertStaleIpPermissionSet(struct["StaleIpPermissions"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.StaleSecurityGroup[k], "StaleSecurityGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StaleSecurityGroup
-- <p>Describes a stale security group (a security group that contains stale rules).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC for the security group.</p>
-- * StaleIpPermissionsEgress [StaleIpPermissionSet] <p>Information about the stale outbound rules in the security group.</p>
-- * GroupName [String] <p>The name of the security group.</p>
-- * StaleIpPermissions [StaleIpPermissionSet] <p>Information about the stale inbound rules in the security group.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- * Description [String] <p>The description of the security group.</p>
-- Required key: GroupId
-- @return StaleSecurityGroup structure as a key-value pair table
function M.StaleSecurityGroup(args)
	assert(args, "You must provdide an argument table when creating StaleSecurityGroup")
	local t = { 
		["VpcId"] = args["VpcId"],
		["StaleIpPermissionsEgress"] = args["StaleIpPermissionsEgress"],
		["GroupName"] = args["GroupName"],
		["StaleIpPermissions"] = args["StaleIpPermissions"],
		["GroupId"] = args["GroupId"],
		["Description"] = args["Description"],
	}
	asserts.AssertStaleSecurityGroup(t)
	return t
end

keys.IamInstanceProfileSpecification = { ["Name"] = true, ["Arn"] = true, nil }

function asserts.AssertIamInstanceProfileSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfileSpecification to be of type 'table'")
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.IamInstanceProfileSpecification[k], "IamInstanceProfileSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfileSpecification
-- <p>Describes an IAM instance profile.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [String] <p>The name of the instance profile.</p>
-- * Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
-- @return IamInstanceProfileSpecification structure as a key-value pair table
function M.IamInstanceProfileSpecification(args)
	assert(args, "You must provdide an argument table when creating IamInstanceProfileSpecification")
	local t = { 
		["Name"] = args["Name"],
		["Arn"] = args["Arn"],
	}
	asserts.AssertIamInstanceProfileSpecification(t)
	return t
end

keys.DescribeVolumeAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDescribeVolumeAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeAttributeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Attribute"] then asserts.AssertVolumeAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeAttributeRequest[k], "DescribeVolumeAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeAttributeRequest
-- <p>Contains the parameters for DescribeVolumeAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [VolumeAttributeName] <p>The attribute of the volume. This parameter is required.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: VolumeId
-- @return DescribeVolumeAttributeRequest structure as a key-value pair table
function M.DescribeVolumeAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVolumeAttributeRequest")
	local t = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertDescribeVolumeAttributeRequest(t)
	return t
end

keys.DescribeSecurityGroupsRequest = { ["GroupNames"] = true, ["DryRun"] = true, ["GroupIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeSecurityGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupsRequest to be of type 'table'")
	if struct["GroupNames"] then asserts.AssertGroupNameStringList(struct["GroupNames"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupIds"] then asserts.AssertGroupIdStringList(struct["GroupIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupsRequest[k], "DescribeSecurityGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupsRequest
-- <p>Contains the parameters for DescribeSecurityGroups.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupNames [GroupNameStringList] <p>[EC2-Classic and default VPC only] One or more security group names. You can specify either the security group name or the security group ID. For security groups in a nondefault VPC, use the <code>group-name</code> filter to describe security groups by name.</p> <p>Default: Describes all your security groups.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupIds [GroupIdStringList] <p>One or more security group IDs. Required for security groups in a nondefault VPC.</p> <p>Default: Describes all your security groups.</p>
-- * Filters [FilterList] <p>One or more filters. If using multiple filters for rules, the results include security groups for which any combination of rules - not necessarily a single rule - match all filters.</p> <ul> <li> <p> <code>description</code> - The description of the security group.</p> </li> <li> <p> <code>egress.ip-permission.prefix-list-id</code> - The ID (prefix) of the AWS service to which the security group allows access.</p> </li> <li> <p> <code>group-id</code> - The ID of the security group. </p> </li> <li> <p> <code>group-name</code> - The name of the security group.</p> </li> <li> <p> <code>ip-permission.cidr</code> - An IPv4 CIDR range that has been granted permission in a security group rule.</p> </li> <li> <p> <code>ip-permission.from-port</code> - The start of port range for the TCP and UDP protocols, or an ICMP type number.</p> </li> <li> <p> <code>ip-permission.group-id</code> - The ID of a security group that has been granted permission.</p> </li> <li> <p> <code>ip-permission.group-name</code> - The name of a security group that has been granted permission.</p> </li> <li> <p> <code>ip-permission.ipv6-cidr</code> - An IPv6 CIDR range that has been granted permission in a security group rule.</p> </li> <li> <p> <code>ip-permission.protocol</code> - The IP protocol for the permission (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p> </li> <li> <p> <code>ip-permission.to-port</code> - The end of port range for the TCP and UDP protocols, or an ICMP code.</p> </li> <li> <p> <code>ip-permission.user-id</code> - The ID of an AWS account that has been granted permission.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the owner of the security group.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the security group.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the security group.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC specified when the security group was created.</p> </li> </ul>
-- @return DescribeSecurityGroupsRequest structure as a key-value pair table
function M.DescribeSecurityGroupsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSecurityGroupsRequest")
	local t = { 
		["GroupNames"] = args["GroupNames"],
		["DryRun"] = args["DryRun"],
		["GroupIds"] = args["GroupIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeSecurityGroupsRequest(t)
	return t
end

keys.NetworkAclEntry = { ["IcmpTypeCode"] = true, ["RuleNumber"] = true, ["Protocol"] = true, ["Ipv6CidrBlock"] = true, ["Egress"] = true, ["RuleAction"] = true, ["PortRange"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertNetworkAclEntry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAclEntry to be of type 'table'")
	if struct["IcmpTypeCode"] then asserts.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	if struct["Protocol"] then asserts.AssertString(struct["Protocol"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then asserts.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then asserts.AssertPortRange(struct["PortRange"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkAclEntry[k], "NetworkAclEntry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAclEntry
-- <p>Describes an entry in a network ACL.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP type and code.</p>
-- * RuleNumber [Integer] <p>The rule number for the entry. ACL entries are processed in ascending order by rule number.</p>
-- * Protocol [String] <p>The protocol. A value of <code>-1</code> means all protocols.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
-- * Egress [Boolean] <p>Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).</p>
-- * RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- * PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
-- * CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
-- @return NetworkAclEntry structure as a key-value pair table
function M.NetworkAclEntry(args)
	assert(args, "You must provdide an argument table when creating NetworkAclEntry")
	local t = { 
		["IcmpTypeCode"] = args["IcmpTypeCode"],
		["RuleNumber"] = args["RuleNumber"],
		["Protocol"] = args["Protocol"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["Egress"] = args["Egress"],
		["RuleAction"] = args["RuleAction"],
		["PortRange"] = args["PortRange"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertNetworkAclEntry(t)
	return t
end

keys.UserBucketDetails = { ["S3Bucket"] = true, ["S3Key"] = true, nil }

function asserts.AssertUserBucketDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserBucketDetails to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then asserts.AssertString(struct["S3Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserBucketDetails[k], "UserBucketDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserBucketDetails
-- <p>Describes the S3 bucket for the disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3Bucket [String] <p>The S3 bucket from which the disk image was created.</p>
-- * S3Key [String] <p>The file name of the disk image.</p>
-- @return UserBucketDetails structure as a key-value pair table
function M.UserBucketDetails(args)
	assert(args, "You must provdide an argument table when creating UserBucketDetails")
	local t = { 
		["S3Bucket"] = args["S3Bucket"],
		["S3Key"] = args["S3Key"],
	}
	asserts.AssertUserBucketDetails(t)
	return t
end

keys.CancelImportTaskResult = { ["State"] = true, ["PreviousState"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertCancelImportTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelImportTaskResult to be of type 'table'")
	if struct["State"] then asserts.AssertString(struct["State"]) end
	if struct["PreviousState"] then asserts.AssertString(struct["PreviousState"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelImportTaskResult[k], "CancelImportTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelImportTaskResult
-- <p>Contains the output for CancelImportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [String] <p>The current state of the task being canceled.</p>
-- * PreviousState [String] <p>The current state of the task being canceled.</p>
-- * ImportTaskId [String] <p>The ID of the task being canceled.</p>
-- @return CancelImportTaskResult structure as a key-value pair table
function M.CancelImportTaskResult(args)
	assert(args, "You must provdide an argument table when creating CancelImportTaskResult")
	local t = { 
		["State"] = args["State"],
		["PreviousState"] = args["PreviousState"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertCancelImportTaskResult(t)
	return t
end

keys.RegisterImageResult = { ["ImageId"] = true, nil }

function asserts.AssertRegisterImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterImageResult to be of type 'table'")
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterImageResult[k], "RegisterImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterImageResult
-- <p>Contains the output of RegisterImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ImageId [String] <p>The ID of the newly registered AMI.</p>
-- @return RegisterImageResult structure as a key-value pair table
function M.RegisterImageResult(args)
	assert(args, "You must provdide an argument table when creating RegisterImageResult")
	local t = { 
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertRegisterImageResult(t)
	return t
end

keys.CreateNetworkAclResult = { ["NetworkAcl"] = true, nil }

function asserts.AssertCreateNetworkAclResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclResult to be of type 'table'")
	if struct["NetworkAcl"] then asserts.AssertNetworkAcl(struct["NetworkAcl"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkAclResult[k], "CreateNetworkAclResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclResult
-- <p>Contains the output of CreateNetworkAcl.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAcl [NetworkAcl] <p>Information about the network ACL.</p>
-- @return CreateNetworkAclResult structure as a key-value pair table
function M.CreateNetworkAclResult(args)
	assert(args, "You must provdide an argument table when creating CreateNetworkAclResult")
	local t = { 
		["NetworkAcl"] = args["NetworkAcl"],
	}
	asserts.AssertCreateNetworkAclResult(t)
	return t
end

keys.DescribeVolumeStatusResult = { ["NextToken"] = true, ["VolumeStatuses"] = true, nil }

function asserts.AssertDescribeVolumeStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeStatusResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["VolumeStatuses"] then asserts.AssertVolumeStatusList(struct["VolumeStatuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeStatusResult[k], "DescribeVolumeStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeStatusResult
-- <p>Contains the output of DescribeVolumeStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * VolumeStatuses [VolumeStatusList] <p>A list of volumes.</p>
-- @return DescribeVolumeStatusResult structure as a key-value pair table
function M.DescribeVolumeStatusResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVolumeStatusResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["VolumeStatuses"] = args["VolumeStatuses"],
	}
	asserts.AssertDescribeVolumeStatusResult(t)
	return t
end

keys.ModifyVolumeResult = { ["VolumeModification"] = true, nil }

function asserts.AssertModifyVolumeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeResult to be of type 'table'")
	if struct["VolumeModification"] then asserts.AssertVolumeModification(struct["VolumeModification"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVolumeResult[k], "ModifyVolumeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeModification [VolumeModification] <p>A <a>VolumeModification</a> object.</p>
-- @return ModifyVolumeResult structure as a key-value pair table
function M.ModifyVolumeResult(args)
	assert(args, "You must provdide an argument table when creating ModifyVolumeResult")
	local t = { 
		["VolumeModification"] = args["VolumeModification"],
	}
	asserts.AssertModifyVolumeResult(t)
	return t
end

keys.CancelConversionRequest = { ["ConversionTaskId"] = true, ["ReasonMessage"] = true, ["DryRun"] = true, nil }

function asserts.AssertCancelConversionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelConversionRequest to be of type 'table'")
	assert(struct["ConversionTaskId"], "Expected key ConversionTaskId to exist in table")
	if struct["ConversionTaskId"] then asserts.AssertString(struct["ConversionTaskId"]) end
	if struct["ReasonMessage"] then asserts.AssertString(struct["ReasonMessage"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelConversionRequest[k], "CancelConversionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelConversionRequest
-- <p>Contains the parameters for CancelConversionTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTaskId [String] <p>The ID of the conversion task.</p>
-- * ReasonMessage [String] <p>The reason for canceling the conversion task.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: ConversionTaskId
-- @return CancelConversionRequest structure as a key-value pair table
function M.CancelConversionRequest(args)
	assert(args, "You must provdide an argument table when creating CancelConversionRequest")
	local t = { 
		["ConversionTaskId"] = args["ConversionTaskId"],
		["ReasonMessage"] = args["ReasonMessage"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCancelConversionRequest(t)
	return t
end

keys.ConfirmProductInstanceResult = { ["OwnerId"] = true, ["Return"] = true, nil }

function asserts.AssertConfirmProductInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConfirmProductInstanceResult to be of type 'table'")
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConfirmProductInstanceResult[k], "ConfirmProductInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConfirmProductInstanceResult
-- <p>Contains the output of ConfirmProductInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OwnerId [String] <p>The AWS account ID of the instance owner. This is only present if the product code is attached to the instance.</p>
-- * Return [Boolean] <p>The return value of the request. Returns <code>true</code> if the specified product code is owned by the requester and associated with the specified instance.</p>
-- @return ConfirmProductInstanceResult structure as a key-value pair table
function M.ConfirmProductInstanceResult(args)
	assert(args, "You must provdide an argument table when creating ConfirmProductInstanceResult")
	local t = { 
		["OwnerId"] = args["OwnerId"],
		["Return"] = args["Return"],
	}
	asserts.AssertConfirmProductInstanceResult(t)
	return t
end

keys.CreateReservedInstancesListingResult = { ["ReservedInstancesListings"] = true, nil }

function asserts.AssertCreateReservedInstancesListingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateReservedInstancesListingResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then asserts.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateReservedInstancesListingResult[k], "CreateReservedInstancesListingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateReservedInstancesListingResult
-- <p>Contains the output of CreateReservedInstancesListing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesListings [ReservedInstancesListingList] <p>Information about the Standard Reserved Instance listing.</p>
-- @return CreateReservedInstancesListingResult structure as a key-value pair table
function M.CreateReservedInstancesListingResult(args)
	assert(args, "You must provdide an argument table when creating CreateReservedInstancesListingResult")
	local t = { 
		["ReservedInstancesListings"] = args["ReservedInstancesListings"],
	}
	asserts.AssertCreateReservedInstancesListingResult(t)
	return t
end

keys.ReplaceNetworkAclEntryRequest = { ["IcmpTypeCode"] = true, ["NetworkAclId"] = true, ["RuleNumber"] = true, ["DryRun"] = true, ["Ipv6CidrBlock"] = true, ["Egress"] = true, ["RuleAction"] = true, ["PortRange"] = true, ["Protocol"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertReplaceNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["Protocol"], "Expected key Protocol to exist in table")
	assert(struct["RuleAction"], "Expected key RuleAction to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["IcmpTypeCode"] then asserts.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then asserts.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then asserts.AssertPortRange(struct["PortRange"]) end
	if struct["Protocol"] then asserts.AssertString(struct["Protocol"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceNetworkAclEntryRequest[k], "ReplaceNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclEntryRequest
-- <p>Contains the parameters for ReplaceNetworkAclEntry.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP (1) protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
-- * NetworkAclId [String] <p>The ID of the ACL.</p>
-- * RuleNumber [Integer] <p>The rule number of the entry to replace.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation (for example <code>2001:bd8:1234:1a00::/64</code>).</p>
-- * Egress [Boolean] <p>Indicates whether to replace the egress rule.</p> <p>Default: If no value is specified, we replace the ingress rule.</p>
-- * RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- * PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to. Required if specifying TCP (6) or UDP (17) for the protocol.</p>
-- * Protocol [String] <p>The IP protocol. You can specify <code>all</code> or <code>-1</code> to mean all protocols. If you specify <code>all</code>, <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, or <code>icmp</code>, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
-- * CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation (for example <code>172.16.0.0/24</code>).</p>
-- Required key: Egress
-- Required key: NetworkAclId
-- Required key: Protocol
-- Required key: RuleAction
-- Required key: RuleNumber
-- @return ReplaceNetworkAclEntryRequest structure as a key-value pair table
function M.ReplaceNetworkAclEntryRequest(args)
	assert(args, "You must provdide an argument table when creating ReplaceNetworkAclEntryRequest")
	local t = { 
		["IcmpTypeCode"] = args["IcmpTypeCode"],
		["NetworkAclId"] = args["NetworkAclId"],
		["RuleNumber"] = args["RuleNumber"],
		["DryRun"] = args["DryRun"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["Egress"] = args["Egress"],
		["RuleAction"] = args["RuleAction"],
		["PortRange"] = args["PortRange"],
		["Protocol"] = args["Protocol"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertReplaceNetworkAclEntryRequest(t)
	return t
end

keys.ImportSnapshotRequest = { ["DryRun"] = true, ["Description"] = true, ["ClientData"] = true, ["ClientToken"] = true, ["RoleName"] = true, ["DiskContainer"] = true, nil }

function asserts.AssertImportSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ClientData"] then asserts.AssertClientData(struct["ClientData"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["RoleName"] then asserts.AssertString(struct["RoleName"]) end
	if struct["DiskContainer"] then asserts.AssertSnapshotDiskContainer(struct["DiskContainer"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportSnapshotRequest[k], "ImportSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotRequest
-- <p>Contains the parameters for ImportSnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>The description string for the import snapshot task.</p>
-- * ClientData [ClientData] <p>The client-specific data.</p>
-- * ClientToken [String] <p>Token to enable idempotency for VM import requests.</p>
-- * RoleName [String] <p>The name of the role to use when not using the default role, 'vmimport'.</p>
-- * DiskContainer [SnapshotDiskContainer] <p>Information about the disk container.</p>
-- @return ImportSnapshotRequest structure as a key-value pair table
function M.ImportSnapshotRequest(args)
	assert(args, "You must provdide an argument table when creating ImportSnapshotRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["ClientData"] = args["ClientData"],
		["ClientToken"] = args["ClientToken"],
		["RoleName"] = args["RoleName"],
		["DiskContainer"] = args["DiskContainer"],
	}
	asserts.AssertImportSnapshotRequest(t)
	return t
end

keys.PortRange = { ["To"] = true, ["From"] = true, nil }

function asserts.AssertPortRange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PortRange to be of type 'table'")
	if struct["To"] then asserts.AssertInteger(struct["To"]) end
	if struct["From"] then asserts.AssertInteger(struct["From"]) end
	for k,_ in pairs(struct) do
		assert(keys.PortRange[k], "PortRange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PortRange
-- <p>Describes a range of ports.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * To [Integer] <p>The last port in the range.</p>
-- * From [Integer] <p>The first port in the range.</p>
-- @return PortRange structure as a key-value pair table
function M.PortRange(args)
	assert(args, "You must provdide an argument table when creating PortRange")
	local t = { 
		["To"] = args["To"],
		["From"] = args["From"],
	}
	asserts.AssertPortRange(t)
	return t
end

keys.Reservation = { ["Instances"] = true, ["ReservationId"] = true, ["RequesterId"] = true, ["Groups"] = true, ["OwnerId"] = true, nil }

function asserts.AssertReservation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Reservation to be of type 'table'")
	if struct["Instances"] then asserts.AssertInstanceList(struct["Instances"]) end
	if struct["ReservationId"] then asserts.AssertString(struct["ReservationId"]) end
	if struct["RequesterId"] then asserts.AssertString(struct["RequesterId"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.Reservation[k], "Reservation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Reservation
-- <p>Describes a reservation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Instances [InstanceList] <p>One or more instances.</p>
-- * ReservationId [String] <p>The ID of the reservation.</p>
-- * RequesterId [String] <p>The ID of the requester that launched the instances on your behalf (for example, AWS Management Console or Auto Scaling).</p>
-- * Groups [GroupIdentifierList] <p>[EC2-Classic only] One or more security groups.</p>
-- * OwnerId [String] <p>The ID of the AWS account that owns the reservation.</p>
-- @return Reservation structure as a key-value pair table
function M.Reservation(args)
	assert(args, "You must provdide an argument table when creating Reservation")
	local t = { 
		["Instances"] = args["Instances"],
		["ReservationId"] = args["ReservationId"],
		["RequesterId"] = args["RequesterId"],
		["Groups"] = args["Groups"],
		["OwnerId"] = args["OwnerId"],
	}
	asserts.AssertReservation(t)
	return t
end

keys.DescribeConversionTasksRequest = { ["ConversionTaskIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeConversionTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeConversionTasksRequest to be of type 'table'")
	if struct["ConversionTaskIds"] then asserts.AssertConversionIdStringList(struct["ConversionTaskIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeConversionTasksRequest[k], "DescribeConversionTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeConversionTasksRequest
-- <p>Contains the parameters for DescribeConversionTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTaskIds [ConversionIdStringList] <p>One or more conversion task IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DescribeConversionTasksRequest structure as a key-value pair table
function M.DescribeConversionTasksRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeConversionTasksRequest")
	local t = { 
		["ConversionTaskIds"] = args["ConversionTaskIds"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeConversionTasksRequest(t)
	return t
end

keys.DescribeImagesRequest = { ["Owners"] = true, ["ImageIds"] = true, ["DryRun"] = true, ["Filters"] = true, ["ExecutableUsers"] = true, nil }

function asserts.AssertDescribeImagesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImagesRequest to be of type 'table'")
	if struct["Owners"] then asserts.AssertOwnerStringList(struct["Owners"]) end
	if struct["ImageIds"] then asserts.AssertImageIdStringList(struct["ImageIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ExecutableUsers"] then asserts.AssertExecutableByStringList(struct["ExecutableUsers"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImagesRequest[k], "DescribeImagesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImagesRequest
-- <p>Contains the parameters for DescribeImages.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Owners [OwnerStringList] <p>Filters the images by the owner. Specify an AWS account ID, <code>self</code> (owner is the sender of the request), or an AWS owner alias (valid values are <code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>). Omitting this option returns all images for which you have launch permissions, regardless of ownership.</p>
-- * ImageIds [ImageIdStringList] <p>One or more image IDs.</p> <p>Default: Describes all images available to you.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>architecture</code> - The image architecture (<code>i386</code> | <code>x86_64</code>).</p> </li> <li> <p> <code>block-device-mapping.delete-on-termination</code> - A Boolean value that indicates whether the Amazon EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>block-device-mapping.device-name</code> - The device name for the EBS volume (for example, <code>/dev/sdh</code>).</p> </li> <li> <p> <code>block-device-mapping.snapshot-id</code> - The ID of the snapshot used for the EBS volume.</p> </li> <li> <p> <code>block-device-mapping.volume-size</code> - The volume size of the EBS volume, in GiB.</p> </li> <li> <p> <code>block-device-mapping.volume-type</code> - The volume type of the EBS volume (<code>gp2</code> | <code>io1</code> | <code>st1 </code>| <code>sc1</code> | <code>standard</code>).</p> </li> <li> <p> <code>description</code> - The description of the image (provided during image creation).</p> </li> <li> <p> <code>ena-support</code> - A Boolean that indicates whether enhanced networking with ENA is enabled.</p> </li> <li> <p> <code>hypervisor</code> - The hypervisor type (<code>ovm</code> | <code>xen</code>).</p> </li> <li> <p> <code>image-id</code> - The ID of the image.</p> </li> <li> <p> <code>image-type</code> - The image type (<code>machine</code> | <code>kernel</code> | <code>ramdisk</code>).</p> </li> <li> <p> <code>is-public</code> - A Boolean that indicates whether the image is public.</p> </li> <li> <p> <code>kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>manifest-location</code> - The location of the image manifest.</p> </li> <li> <p> <code>name</code> - The name of the AMI (provided during image creation).</p> </li> <li> <p> <code>owner-alias</code> - String value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the image owner.</p> </li> <li> <p> <code>platform</code> - The platform. To only list Windows-based AMIs, use <code>windows</code>.</p> </li> <li> <p> <code>product-code</code> - The product code.</p> </li> <li> <p> <code>product-code.type</code> - The type of the product code (<code>devpay</code> | <code>marketplace</code>).</p> </li> <li> <p> <code>ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>root-device-name</code> - The name of the root device volume (for example, <code>/dev/sda1</code>).</p> </li> <li> <p> <code>root-device-type</code> - The type of the root device volume (<code>ebs</code> | <code>instance-store</code>).</p> </li> <li> <p> <code>state</code> - The state of the image (<code>available</code> | <code>pending</code> | <code>failed</code>).</p> </li> <li> <p> <code>state-reason-code</code> - The reason code for the state change.</p> </li> <li> <p> <code>state-reason-message</code> - The message for the state change.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>virtualization-type</code> - The virtualization type (<code>paravirtual</code> | <code>hvm</code>).</p> </li> </ul>
-- * ExecutableUsers [ExecutableByStringList] <p>Scopes the images by users with explicit launch permissions. Specify an AWS account ID, <code>self</code> (the sender of the request), or <code>all</code> (public AMIs).</p>
-- @return DescribeImagesRequest structure as a key-value pair table
function M.DescribeImagesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeImagesRequest")
	local t = { 
		["Owners"] = args["Owners"],
		["ImageIds"] = args["ImageIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["ExecutableUsers"] = args["ExecutableUsers"],
	}
	asserts.AssertDescribeImagesRequest(t)
	return t
end

keys.TagSpecification = { ["ResourceType"] = true, ["Tags"] = true, nil }

function asserts.AssertTagSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TagSpecification to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.TagSpecification[k], "TagSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TagSpecification
-- <p>The tags to apply to a resource when the resource is being created.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceType] <p>The type of resource to tag. Currently, the resource types that support tagging on creation are <code>instance</code> and <code>volume</code>. </p>
-- * Tags [TagList] <p>The tags to apply to the resource.</p>
-- @return TagSpecification structure as a key-value pair table
function M.TagSpecification(args)
	assert(args, "You must provdide an argument table when creating TagSpecification")
	local t = { 
		["ResourceType"] = args["ResourceType"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertTagSpecification(t)
	return t
end

keys.DescribeIdentityIdFormatRequest = { ["PrincipalArn"] = true, ["Resource"] = true, nil }

function asserts.AssertDescribeIdentityIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdentityIdFormatRequest to be of type 'table'")
	assert(struct["PrincipalArn"], "Expected key PrincipalArn to exist in table")
	if struct["PrincipalArn"] then asserts.AssertString(struct["PrincipalArn"]) end
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdentityIdFormatRequest[k], "DescribeIdentityIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdentityIdFormatRequest
-- <p>Contains the parameters for DescribeIdentityIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrincipalArn [String] <p>The ARN of the principal, which can be an IAM role, IAM user, or the root user.</p>
-- * Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- Required key: PrincipalArn
-- @return DescribeIdentityIdFormatRequest structure as a key-value pair table
function M.DescribeIdentityIdFormatRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeIdentityIdFormatRequest")
	local t = { 
		["PrincipalArn"] = args["PrincipalArn"],
		["Resource"] = args["Resource"],
	}
	asserts.AssertDescribeIdentityIdFormatRequest(t)
	return t
end

keys.DescribeFpgaImagesRequest = { ["Owners"] = true, ["DryRun"] = true, ["FpgaImageIds"] = true, ["MaxResults"] = true, ["Filters"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFpgaImagesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImagesRequest to be of type 'table'")
	if struct["Owners"] then asserts.AssertOwnerStringList(struct["Owners"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["FpgaImageIds"] then asserts.AssertFpgaImageIdList(struct["FpgaImageIds"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFpgaImagesRequest[k], "DescribeFpgaImagesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImagesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Owners [OwnerStringList] <p>Filters the AFI by owner. Specify an AWS account ID, <code>self</code> (owner is the sender of the request), or an AWS owner alias (valid values are <code>amazon</code> | <code>aws-marketplace</code>).</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * FpgaImageIds [FpgaImageIdList] <p>One or more AFI IDs.</p>
-- * MaxResults [MaxResults] <p>The maximum number of results to return in a single call.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>create-time</code> - The creation time of the AFI.</p> </li> <li> <p> <code>fpga-image-id</code> - The FPGA image identifier (AFI ID).</p> </li> <li> <p> <code>fpga-image-global-id</code> - The global FPGA image identifier (AGFI ID).</p> </li> <li> <p> <code>name</code> - The name of the AFI.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the AFI owner.</p> </li> <li> <p> <code>product-code</code> - The product code.</p> </li> <li> <p> <code>shell-version</code> - The version of the AWS Shell that was used to create the bitstream.</p> </li> <li> <p> <code>state</code> - The state of the AFI (<code>pending</code> | <code>failed</code> | <code>available</code> | <code>unavailable</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>update-time</code> - The time of the most recent update.</p> </li> </ul>
-- * NextToken [NextToken] <p>The token to retrieve the next page of results.</p>
-- @return DescribeFpgaImagesRequest structure as a key-value pair table
function M.DescribeFpgaImagesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeFpgaImagesRequest")
	local t = { 
		["Owners"] = args["Owners"],
		["DryRun"] = args["DryRun"],
		["FpgaImageIds"] = args["FpgaImageIds"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeFpgaImagesRequest(t)
	return t
end

keys.NetworkInterface = { ["Status"] = true, ["MacAddress"] = true, ["SourceDestCheck"] = true, ["AvailabilityZone"] = true, ["Description"] = true, ["NetworkInterfaceId"] = true, ["VpcId"] = true, ["PrivateIpAddresses"] = true, ["RequesterManaged"] = true, ["PrivateDnsName"] = true, ["RequesterId"] = true, ["InterfaceType"] = true, ["Attachment"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["OwnerId"] = true, ["PrivateIpAddress"] = true, ["SubnetId"] = true, ["TagSet"] = true, ["Association"] = true, nil }

function asserts.AssertNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterface to be of type 'table'")
	if struct["Status"] then asserts.AssertNetworkInterfaceStatus(struct["Status"]) end
	if struct["MacAddress"] then asserts.AssertString(struct["MacAddress"]) end
	if struct["SourceDestCheck"] then asserts.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertNetworkInterfacePrivateIpAddressList(struct["PrivateIpAddresses"]) end
	if struct["RequesterManaged"] then asserts.AssertBoolean(struct["RequesterManaged"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["RequesterId"] then asserts.AssertString(struct["RequesterId"]) end
	if struct["InterfaceType"] then asserts.AssertNetworkInterfaceType(struct["InterfaceType"]) end
	if struct["Attachment"] then asserts.AssertNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertNetworkInterfaceIpv6AddressesList(struct["Ipv6Addresses"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["TagSet"] then asserts.AssertTagList(struct["TagSet"]) end
	if struct["Association"] then asserts.AssertNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterface[k], "NetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterface
-- <p>Describes a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [NetworkInterfaceStatus] <p>The status of the network interface.</p>
-- * MacAddress [String] <p>The MAC address.</p>
-- * SourceDestCheck [Boolean] <p>Indicates whether traffic to or from the instance is validated.</p>
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- * Description [String] <p>A description.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * PrivateIpAddresses [NetworkInterfacePrivateIpAddressList] <p>The private IPv4 addresses associated with the network interface.</p>
-- * RequesterManaged [Boolean] <p>Indicates whether the network interface is being managed by AWS.</p>
-- * PrivateDnsName [String] <p>The private DNS name.</p>
-- * RequesterId [String] <p>The ID of the entity that launched the instance on your behalf (for example, AWS Management Console or Auto Scaling).</p>
-- * InterfaceType [NetworkInterfaceType] <p>The type of interface.</p>
-- * Attachment [NetworkInterfaceAttachment] <p>The network interface attachment.</p>
-- * Groups [GroupIdentifierList] <p>Any security groups for the network interface.</p>
-- * Ipv6Addresses [NetworkInterfaceIpv6AddressesList] <p>The IPv6 addresses associated with the network interface.</p>
-- * OwnerId [String] <p>The AWS account ID of the owner of the network interface.</p>
-- * PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * TagSet [TagList] <p>Any tags assigned to the network interface.</p>
-- * Association [NetworkInterfaceAssociation] <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
-- @return NetworkInterface structure as a key-value pair table
function M.NetworkInterface(args)
	assert(args, "You must provdide an argument table when creating NetworkInterface")
	local t = { 
		["Status"] = args["Status"],
		["MacAddress"] = args["MacAddress"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Description"] = args["Description"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["VpcId"] = args["VpcId"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["RequesterManaged"] = args["RequesterManaged"],
		["PrivateDnsName"] = args["PrivateDnsName"],
		["RequesterId"] = args["RequesterId"],
		["InterfaceType"] = args["InterfaceType"],
		["Attachment"] = args["Attachment"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["OwnerId"] = args["OwnerId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["SubnetId"] = args["SubnetId"],
		["TagSet"] = args["TagSet"],
		["Association"] = args["Association"],
	}
	asserts.AssertNetworkInterface(t)
	return t
end

keys.KeyPair = { ["KeyMaterial"] = true, ["KeyName"] = true, ["KeyFingerprint"] = true, nil }

function asserts.AssertKeyPair(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KeyPair to be of type 'table'")
	if struct["KeyMaterial"] then asserts.AssertString(struct["KeyMaterial"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then asserts.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(keys.KeyPair[k], "KeyPair contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KeyPair
-- <p>Describes a key pair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyMaterial [String] <p>An unencrypted PEM encoded RSA private key.</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * KeyFingerprint [String] <p>The SHA-1 digest of the DER encoded private key.</p>
-- @return KeyPair structure as a key-value pair table
function M.KeyPair(args)
	assert(args, "You must provdide an argument table when creating KeyPair")
	local t = { 
		["KeyMaterial"] = args["KeyMaterial"],
		["KeyName"] = args["KeyName"],
		["KeyFingerprint"] = args["KeyFingerprint"],
	}
	asserts.AssertKeyPair(t)
	return t
end

keys.PropagatingVgw = { ["GatewayId"] = true, nil }

function asserts.AssertPropagatingVgw(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PropagatingVgw to be of type 'table'")
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PropagatingVgw[k], "PropagatingVgw contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PropagatingVgw
-- <p>Describes a virtual private gateway propagating route.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GatewayId [String] <p>The ID of the virtual private gateway (VGW).</p>
-- @return PropagatingVgw structure as a key-value pair table
function M.PropagatingVgw(args)
	assert(args, "You must provdide an argument table when creating PropagatingVgw")
	local t = { 
		["GatewayId"] = args["GatewayId"],
	}
	asserts.AssertPropagatingVgw(t)
	return t
end

keys.DescribePrefixListsRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["PrefixListIds"] = true, nil }

function asserts.AssertDescribePrefixListsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrefixListsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["PrefixListIds"] then asserts.AssertValueStringList(struct["PrefixListIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePrefixListsRequest[k], "DescribePrefixListsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrefixListsRequest
-- <p>Contains the parameters for DescribePrefixLists.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value specified is greater than 1000, we return only 1000 items.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>prefix-list-id</code>: The ID of a prefix list.</p> </li> <li> <p> <code>prefix-list-name</code>: The name of a prefix list.</p> </li> </ul>
-- * PrefixListIds [ValueStringList] <p>One or more prefix list IDs.</p>
-- @return DescribePrefixListsRequest structure as a key-value pair table
function M.DescribePrefixListsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribePrefixListsRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["PrefixListIds"] = args["PrefixListIds"],
	}
	asserts.AssertDescribePrefixListsRequest(t)
	return t
end

keys.PriceSchedule = { ["Active"] = true, ["CurrencyCode"] = true, ["Term"] = true, ["Price"] = true, nil }

function asserts.AssertPriceSchedule(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PriceSchedule to be of type 'table'")
	if struct["Active"] then asserts.AssertBoolean(struct["Active"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Term"] then asserts.AssertLong(struct["Term"]) end
	if struct["Price"] then asserts.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(keys.PriceSchedule[k], "PriceSchedule contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PriceSchedule
-- <p>Describes the price for a Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Active [Boolean] <p>The current price schedule, as determined by the term remaining for the Reserved Instance in the listing.</p> <p>A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>
-- * Term [Long] <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
-- * Price [Double] <p>The fixed price for the term.</p>
-- @return PriceSchedule structure as a key-value pair table
function M.PriceSchedule(args)
	assert(args, "You must provdide an argument table when creating PriceSchedule")
	local t = { 
		["Active"] = args["Active"],
		["CurrencyCode"] = args["CurrencyCode"],
		["Term"] = args["Term"],
		["Price"] = args["Price"],
	}
	asserts.AssertPriceSchedule(t)
	return t
end

keys.InstanceNetworkInterfaceSpecification = { ["DeviceIndex"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["PrivateIpAddresses"] = true, ["SubnetId"] = true, ["DeleteOnTermination"] = true, ["PrivateIpAddress"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, ["AssociatePublicIpAddress"] = true, ["SecondaryPrivateIpAddressCount"] = true, nil }

function asserts.AssertInstanceNetworkInterfaceSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceSpecification to be of type 'table'")
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then asserts.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterfaceSpecification[k], "InstanceNetworkInterfaceSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceSpecification
-- <p>Describes a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceIndex [Integer] <p>The index of the device on the instance for the network interface attachment. If you are specifying a network interface in a <a>RunInstances</a> request, you must provide the device index.</p>
-- * Description [String] <p>The description of the network interface. Applies only if creating a network interface when launching an instance.</p>
-- * Ipv6AddressCount [Integer] <p>A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.</p>
-- * PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- * SubnetId [String] <p>The ID of the subnet associated with the network string. Applies only if creating a network interface when launching an instance.</p>
-- * DeleteOnTermination [Boolean] <p>If set to <code>true</code>, the interface is deleted when the instance is terminated. You can specify <code>true</code> only if creating a new network interface when launching an instance.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- * Groups [SecurityGroupIdStringList] <p>The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.</p>
-- * Ipv6Addresses [InstanceIpv6AddressList] <p>One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * AssociatePublicIpAddress [Boolean] <p>Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- @return InstanceNetworkInterfaceSpecification structure as a key-value pair table
function M.InstanceNetworkInterfaceSpecification(args)
	assert(args, "You must provdide an argument table when creating InstanceNetworkInterfaceSpecification")
	local t = { 
		["DeviceIndex"] = args["DeviceIndex"],
		["Description"] = args["Description"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["SubnetId"] = args["SubnetId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AssociatePublicIpAddress"] = args["AssociatePublicIpAddress"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
	}
	asserts.AssertInstanceNetworkInterfaceSpecification(t)
	return t
end

keys.ReplaceNetworkAclAssociationResult = { ["NewAssociationId"] = true, nil }

function asserts.AssertReplaceNetworkAclAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclAssociationResult to be of type 'table'")
	if struct["NewAssociationId"] then asserts.AssertString(struct["NewAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceNetworkAclAssociationResult[k], "ReplaceNetworkAclAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclAssociationResult
-- <p>Contains the output of ReplaceNetworkAclAssociation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NewAssociationId [String] <p>The ID of the new association.</p>
-- @return ReplaceNetworkAclAssociationResult structure as a key-value pair table
function M.ReplaceNetworkAclAssociationResult(args)
	assert(args, "You must provdide an argument table when creating ReplaceNetworkAclAssociationResult")
	local t = { 
		["NewAssociationId"] = args["NewAssociationId"],
	}
	asserts.AssertReplaceNetworkAclAssociationResult(t)
	return t
end

keys.UnsuccessfulItemError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertUnsuccessfulItemError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulItemError to be of type 'table'")
	assert(struct["Code"], "Expected key Code to exist in table")
	assert(struct["Message"], "Expected key Message to exist in table")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnsuccessfulItemError[k], "UnsuccessfulItemError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulItemError
-- <p>Information about the error that occurred. For more information about errors, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html">Error Codes</a>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The error message accompanying the error code.</p>
-- * Code [String] <p>The error code.</p>
-- Required key: Code
-- Required key: Message
-- @return UnsuccessfulItemError structure as a key-value pair table
function M.UnsuccessfulItemError(args)
	assert(args, "You must provdide an argument table when creating UnsuccessfulItemError")
	local t = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertUnsuccessfulItemError(t)
	return t
end

keys.ReplaceRouteTableAssociationResult = { ["NewAssociationId"] = true, nil }

function asserts.AssertReplaceRouteTableAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteTableAssociationResult to be of type 'table'")
	if struct["NewAssociationId"] then asserts.AssertString(struct["NewAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceRouteTableAssociationResult[k], "ReplaceRouteTableAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteTableAssociationResult
-- <p>Contains the output of ReplaceRouteTableAssociation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NewAssociationId [String] <p>The ID of the new association.</p>
-- @return ReplaceRouteTableAssociationResult structure as a key-value pair table
function M.ReplaceRouteTableAssociationResult(args)
	assert(args, "You must provdide an argument table when creating ReplaceRouteTableAssociationResult")
	local t = { 
		["NewAssociationId"] = args["NewAssociationId"],
	}
	asserts.AssertReplaceRouteTableAssociationResult(t)
	return t
end

keys.AllocateHostsResult = { ["HostIds"] = true, nil }

function asserts.AssertAllocateHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateHostsResult to be of type 'table'")
	if struct["HostIds"] then asserts.AssertResponseHostIdList(struct["HostIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateHostsResult[k], "AllocateHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateHostsResult
-- <p>Contains the output of AllocateHosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostIds [ResponseHostIdList] <p>The ID of the allocated Dedicated Host. This is used when you want to launch an instance onto a specific host.</p>
-- @return AllocateHostsResult structure as a key-value pair table
function M.AllocateHostsResult(args)
	assert(args, "You must provdide an argument table when creating AllocateHostsResult")
	local t = { 
		["HostIds"] = args["HostIds"],
	}
	asserts.AssertAllocateHostsResult(t)
	return t
end

keys.CreateCustomerGatewayResult = { ["CustomerGateway"] = true, nil }

function asserts.AssertCreateCustomerGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCustomerGatewayResult to be of type 'table'")
	if struct["CustomerGateway"] then asserts.AssertCustomerGateway(struct["CustomerGateway"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCustomerGatewayResult[k], "CreateCustomerGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCustomerGatewayResult
-- <p>Contains the output of CreateCustomerGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGateway [CustomerGateway] <p>Information about the customer gateway.</p>
-- @return CreateCustomerGatewayResult structure as a key-value pair table
function M.CreateCustomerGatewayResult(args)
	assert(args, "You must provdide an argument table when creating CreateCustomerGatewayResult")
	local t = { 
		["CustomerGateway"] = args["CustomerGateway"],
	}
	asserts.AssertCreateCustomerGatewayResult(t)
	return t
end

keys.DescribeVpcClassicLinkRequest = { ["DryRun"] = true, ["Filters"] = true, ["VpcIds"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["VpcIds"] then asserts.AssertVpcClassicLinkIdList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkRequest[k], "DescribeVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkRequest
-- <p>Contains the parameters for DescribeVpcClassicLink.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>is-classic-link-enabled</code> - Whether the VPC is enabled for ClassicLink (<code>true</code> | <code>false</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
-- * VpcIds [VpcClassicLinkIdList] <p>One or more VPCs for which you want to describe the ClassicLink status.</p>
-- @return DescribeVpcClassicLinkRequest structure as a key-value pair table
function M.DescribeVpcClassicLinkRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcClassicLinkRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["VpcIds"] = args["VpcIds"],
	}
	asserts.AssertDescribeVpcClassicLinkRequest(t)
	return t
end

keys.ModifySpotFleetRequestResponse = { ["Return"] = true, nil }

function asserts.AssertModifySpotFleetRequestResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySpotFleetRequestResponse to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySpotFleetRequestResponse[k], "ModifySpotFleetRequestResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySpotFleetRequestResponse
-- <p>Contains the output of ModifySpotFleetRequest.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
-- @return ModifySpotFleetRequestResponse structure as a key-value pair table
function M.ModifySpotFleetRequestResponse(args)
	assert(args, "You must provdide an argument table when creating ModifySpotFleetRequestResponse")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifySpotFleetRequestResponse(t)
	return t
end

keys.ModifySpotFleetRequestRequest = { ["TargetCapacity"] = true, ["SpotFleetRequestId"] = true, ["ExcessCapacityTerminationPolicy"] = true, nil }

function asserts.AssertModifySpotFleetRequestRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySpotFleetRequestRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["TargetCapacity"] then asserts.AssertInteger(struct["TargetCapacity"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["ExcessCapacityTerminationPolicy"] then asserts.AssertExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySpotFleetRequestRequest[k], "ModifySpotFleetRequestRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySpotFleetRequestRequest
-- <p>Contains the parameters for ModifySpotFleetRequest.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetCapacity [Integer] <p>The size of the fleet.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- * ExcessCapacityTerminationPolicy [ExcessCapacityTerminationPolicy] <p>Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.</p>
-- Required key: SpotFleetRequestId
-- @return ModifySpotFleetRequestRequest structure as a key-value pair table
function M.ModifySpotFleetRequestRequest(args)
	assert(args, "You must provdide an argument table when creating ModifySpotFleetRequestRequest")
	local t = { 
		["TargetCapacity"] = args["TargetCapacity"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["ExcessCapacityTerminationPolicy"] = args["ExcessCapacityTerminationPolicy"],
	}
	asserts.AssertModifySpotFleetRequestRequest(t)
	return t
end

keys.Subnet = { ["AvailabilityZone"] = true, ["Tags"] = true, ["AvailableIpAddressCount"] = true, ["DefaultForAz"] = true, ["Ipv6CidrBlockAssociationSet"] = true, ["VpcId"] = true, ["State"] = true, ["MapPublicIpOnLaunch"] = true, ["SubnetId"] = true, ["CidrBlock"] = true, ["AssignIpv6AddressOnCreation"] = true, nil }

function asserts.AssertSubnet(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Subnet to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["AvailableIpAddressCount"] then asserts.AssertInteger(struct["AvailableIpAddressCount"]) end
	if struct["DefaultForAz"] then asserts.AssertBoolean(struct["DefaultForAz"]) end
	if struct["Ipv6CidrBlockAssociationSet"] then asserts.AssertSubnetIpv6CidrBlockAssociationSet(struct["Ipv6CidrBlockAssociationSet"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["State"] then asserts.AssertSubnetState(struct["State"]) end
	if struct["MapPublicIpOnLaunch"] then asserts.AssertBoolean(struct["MapPublicIpOnLaunch"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["AssignIpv6AddressOnCreation"] then asserts.AssertBoolean(struct["AssignIpv6AddressOnCreation"]) end
	for k,_ in pairs(struct) do
		assert(keys.Subnet[k], "Subnet contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Subnet
-- <p>Describes a subnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone of the subnet.</p>
-- * Tags [TagList] <p>Any tags assigned to the subnet.</p>
-- * AvailableIpAddressCount [Integer] <p>The number of unused private IPv4 addresses in the subnet. Note that the IPv4 addresses for any stopped instances are considered unavailable.</p>
-- * DefaultForAz [Boolean] <p>Indicates whether this is the default subnet for the Availability Zone.</p>
-- * Ipv6CidrBlockAssociationSet [SubnetIpv6CidrBlockAssociationSet] <p>Information about the IPv6 CIDR blocks associated with the subnet.</p>
-- * VpcId [String] <p>The ID of the VPC the subnet is in.</p>
-- * State [SubnetState] <p>The current state of the subnet.</p>
-- * MapPublicIpOnLaunch [Boolean] <p>Indicates whether instances launched in this subnet receive a public IPv4 address.</p>
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * CidrBlock [String] <p>The IPv4 CIDR block assigned to the subnet.</p>
-- * AssignIpv6AddressOnCreation [Boolean] <p>Indicates whether a network interface created in this subnet (including a network interface created by <a>RunInstances</a>) receives an IPv6 address.</p>
-- @return Subnet structure as a key-value pair table
function M.Subnet(args)
	assert(args, "You must provdide an argument table when creating Subnet")
	local t = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Tags"] = args["Tags"],
		["AvailableIpAddressCount"] = args["AvailableIpAddressCount"],
		["DefaultForAz"] = args["DefaultForAz"],
		["Ipv6CidrBlockAssociationSet"] = args["Ipv6CidrBlockAssociationSet"],
		["VpcId"] = args["VpcId"],
		["State"] = args["State"],
		["MapPublicIpOnLaunch"] = args["MapPublicIpOnLaunch"],
		["SubnetId"] = args["SubnetId"],
		["CidrBlock"] = args["CidrBlock"],
		["AssignIpv6AddressOnCreation"] = args["AssignIpv6AddressOnCreation"],
	}
	asserts.AssertSubnet(t)
	return t
end

keys.DisableVgwRoutePropagationRequest = { ["GatewayId"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertDisableVgwRoutePropagationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVgwRoutePropagationRequest to be of type 'table'")
	assert(struct["GatewayId"], "Expected key GatewayId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVgwRoutePropagationRequest[k], "DisableVgwRoutePropagationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVgwRoutePropagationRequest
-- <p>Contains the parameters for DisableVgwRoutePropagation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GatewayId [String] <p>The ID of the virtual private gateway.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- Required key: GatewayId
-- Required key: RouteTableId
-- @return DisableVgwRoutePropagationRequest structure as a key-value pair table
function M.DisableVgwRoutePropagationRequest(args)
	assert(args, "You must provdide an argument table when creating DisableVgwRoutePropagationRequest")
	local t = { 
		["GatewayId"] = args["GatewayId"],
		["RouteTableId"] = args["RouteTableId"],
	}
	asserts.AssertDisableVgwRoutePropagationRequest(t)
	return t
end

keys.DescribeHostReservationsResult = { ["NextToken"] = true, ["HostReservationSet"] = true, nil }

function asserts.AssertDescribeHostReservationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["HostReservationSet"] then asserts.AssertHostReservationSet(struct["HostReservationSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationsResult[k], "DescribeHostReservationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * HostReservationSet [HostReservationSet] <p>Details about the reservation's configuration.</p>
-- @return DescribeHostReservationsResult structure as a key-value pair table
function M.DescribeHostReservationsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeHostReservationsResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["HostReservationSet"] = args["HostReservationSet"],
	}
	asserts.AssertDescribeHostReservationsResult(t)
	return t
end

keys.CancelSpotInstanceRequestsResult = { ["CancelledSpotInstanceRequests"] = true, nil }

function asserts.AssertCancelSpotInstanceRequestsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotInstanceRequestsResult to be of type 'table'")
	if struct["CancelledSpotInstanceRequests"] then asserts.AssertCancelledSpotInstanceRequestList(struct["CancelledSpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotInstanceRequestsResult[k], "CancelSpotInstanceRequestsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotInstanceRequestsResult
-- <p>Contains the output of CancelSpotInstanceRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CancelledSpotInstanceRequests [CancelledSpotInstanceRequestList] <p>One or more Spot instance requests.</p>
-- @return CancelSpotInstanceRequestsResult structure as a key-value pair table
function M.CancelSpotInstanceRequestsResult(args)
	assert(args, "You must provdide an argument table when creating CancelSpotInstanceRequestsResult")
	local t = { 
		["CancelledSpotInstanceRequests"] = args["CancelledSpotInstanceRequests"],
	}
	asserts.AssertCancelSpotInstanceRequestsResult(t)
	return t
end

keys.RunInstancesRequest = { ["DryRun"] = true, ["TagSpecifications"] = true, ["MinCount"] = true, ["EbsOptimized"] = true, ["RamdiskId"] = true, ["Monitoring"] = true, ["PrivateIpAddress"] = true, ["ImageId"] = true, ["KeyName"] = true, ["SecurityGroups"] = true, ["ClientToken"] = true, ["SubnetId"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, ["AdditionalInfo"] = true, ["Placement"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["SecurityGroupIds"] = true, ["BlockDeviceMappings"] = true, ["KernelId"] = true, ["IamInstanceProfile"] = true, ["UserData"] = true, ["Ipv6AddressCount"] = true, ["MaxCount"] = true, ["Ipv6Addresses"] = true, ["DisableApiTermination"] = true, nil }

function asserts.AssertRunInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunInstancesRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	assert(struct["MaxCount"], "Expected key MaxCount to exist in table")
	assert(struct["MinCount"], "Expected key MinCount to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["MinCount"] then asserts.AssertInteger(struct["MinCount"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["Monitoring"] then asserts.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then asserts.AssertSecurityGroupStringList(struct["SecurityGroups"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	if struct["AdditionalInfo"] then asserts.AssertString(struct["AdditionalInfo"]) end
	if struct["Placement"] then asserts.AssertPlacement(struct["Placement"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["SecurityGroupIds"] then asserts.AssertSecurityGroupIdStringList(struct["SecurityGroupIds"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["MaxCount"] then asserts.AssertInteger(struct["MaxCount"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["DisableApiTermination"] then asserts.AssertBoolean(struct["DisableApiTermination"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunInstancesRequest[k], "RunInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunInstancesRequest
-- <p>Contains the parameters for RunInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TagSpecifications [TagSpecificationList] <p>The tags to apply to the resources during launch. You can tag instances and volumes. The specified tags are applied to all instances or volumes that are created during launch.</p>
-- * MinCount [Integer] <p>The minimum number of instances to launch. If you specify a minimum that is more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches no instances.</p> <p>Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I run in Amazon EC2</a> in the Amazon EC2 General FAQ.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p> <p>Default: <code>false</code> </p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- * Monitoring [RunInstancesMonitoringEnabled] <p>The monitoring for the instance.</p>
-- * PrivateIpAddress [String] <p>[EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.</p> <p>Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.</p>
-- * ImageId [String] <p>The ID of the AMI, which you can get by calling <a>DescribeImages</a>.</p>
-- * KeyName [String] <p>The name of the key pair. You can create a key pair using <a>CreateKeyPair</a> or <a>ImportKeyPair</a>.</p> <important> <p>If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.</p> </important>
-- * SecurityGroups [SecurityGroupStringList] <p>[EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead.</p> <p>Default: Amazon EC2 uses the default security group.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p> <p>Constraints: Maximum 64 ASCII characters</p>
-- * SubnetId [String] <p>[EC2-VPC] The ID of the subnet to launch the instance into.</p>
-- * InstanceType [InstanceType] <p>The instance type. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Default: <code>m1.small</code> </p>
-- * NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces.</p>
-- * AdditionalInfo [String] <p>Reserved.</p>
-- * Placement [Placement] <p>The placement for the instance.</p>
-- * InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p> <p>Default: <code>stop</code> </p>
-- * SecurityGroupIds [SecurityGroupIdStringList] <p>One or more security group IDs. You can create a security group using <a>CreateSecurityGroup</a>.</p> <p>Default: Amazon EC2 uses the default security group.</p>
-- * BlockDeviceMappings [BlockDeviceMappingRequestList] <p>The block device mapping.</p> <important> <p>Supplying both a snapshot ID and an encryption value as arguments for block-device mapping results in an error. This is because only blank volumes can be encrypted on start, and these are not created from a snapshot. If a snapshot is the basis for the volume, it contains data by definition and its encryption status cannot be changed using this action.</p> </important>
-- * KernelId [String] <p>The ID of the kernel.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- * UserData [String] <p>The user data to make available to the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html">Running Commands on Your Linux Instance at Launch</a> (Linux) and <a href="http://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data">Adding User Data</a> (Windows). If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- * Ipv6AddressCount [Integer] <p>[EC2-VPC] A number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.</p>
-- * MaxCount [Integer] <p>The maximum number of instances to launch. If you specify more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches the largest possible number of instances above <code>MinCount</code>.</p> <p>Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I run in Amazon EC2</a> in the Amazon EC2 FAQ.</p>
-- * Ipv6Addresses [InstanceIpv6AddressList] <p>[EC2-VPC] Specify one or more IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.</p>
-- * DisableApiTermination [Boolean] <p>If you set this parameter to <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute to <code>false</code> after launch, use <a>ModifyInstanceAttribute</a>. Alternatively, if you set <code>InstanceInitiatedShutdownBehavior</code> to <code>terminate</code>, you can terminate the instance by running the shutdown command from the instance.</p> <p>Default: <code>false</code> </p>
-- Required key: ImageId
-- Required key: MaxCount
-- Required key: MinCount
-- @return RunInstancesRequest structure as a key-value pair table
function M.RunInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating RunInstancesRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["TagSpecifications"] = args["TagSpecifications"],
		["MinCount"] = args["MinCount"],
		["EbsOptimized"] = args["EbsOptimized"],
		["RamdiskId"] = args["RamdiskId"],
		["Monitoring"] = args["Monitoring"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["SecurityGroups"] = args["SecurityGroups"],
		["ClientToken"] = args["ClientToken"],
		["SubnetId"] = args["SubnetId"],
		["InstanceType"] = args["InstanceType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
		["AdditionalInfo"] = args["AdditionalInfo"],
		["Placement"] = args["Placement"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["SecurityGroupIds"] = args["SecurityGroupIds"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["KernelId"] = args["KernelId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["UserData"] = args["UserData"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["MaxCount"] = args["MaxCount"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["DisableApiTermination"] = args["DisableApiTermination"],
	}
	asserts.AssertRunInstancesRequest(t)
	return t
end

keys.CreateVpnConnectionRequest = { ["CustomerGatewayId"] = true, ["DryRun"] = true, ["Type"] = true, ["VpnGatewayId"] = true, ["Options"] = true, nil }

function asserts.AssertCreateVpnConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionRequest to be of type 'table'")
	assert(struct["CustomerGatewayId"], "Expected key CustomerGatewayId to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Type"] then asserts.AssertString(struct["Type"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	if struct["Options"] then asserts.AssertVpnConnectionOptionsSpecification(struct["Options"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnConnectionRequest[k], "CreateVpnConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionRequest
-- <p>Contains the parameters for CreateVpnConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Type [String] <p>The type of VPN connection (<code>ipsec.1</code>).</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- * Options [VpnConnectionOptionsSpecification] <p>Indicates whether the VPN connection requires static routes. If you are creating a VPN connection for a device that does not support BGP, you must specify <code>true</code>.</p> <p>Default: <code>false</code> </p>
-- Required key: CustomerGatewayId
-- Required key: Type
-- Required key: VpnGatewayId
-- @return CreateVpnConnectionRequest structure as a key-value pair table
function M.CreateVpnConnectionRequest(args)
	assert(args, "You must provdide an argument table when creating CreateVpnConnectionRequest")
	local t = { 
		["CustomerGatewayId"] = args["CustomerGatewayId"],
		["DryRun"] = args["DryRun"],
		["Type"] = args["Type"],
		["VpnGatewayId"] = args["VpnGatewayId"],
		["Options"] = args["Options"],
	}
	asserts.AssertCreateVpnConnectionRequest(t)
	return t
end

keys.VpcIpv6CidrBlockAssociation = { ["Ipv6CidrBlock"] = true, ["AssociationId"] = true, ["Ipv6CidrBlockState"] = true, nil }

function asserts.AssertVpcIpv6CidrBlockAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcIpv6CidrBlockAssociation to be of type 'table'")
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["Ipv6CidrBlockState"] then asserts.AssertVpcCidrBlockState(struct["Ipv6CidrBlockState"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcIpv6CidrBlockAssociation[k], "VpcIpv6CidrBlockAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcIpv6CidrBlockAssociation
-- <p>Describes an IPv6 CIDR block associated with a VPC.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- * AssociationId [String] <p>The association ID for the IPv6 CIDR block.</p>
-- * Ipv6CidrBlockState [VpcCidrBlockState] <p>Information about the state of the CIDR block.</p>
-- @return VpcIpv6CidrBlockAssociation structure as a key-value pair table
function M.VpcIpv6CidrBlockAssociation(args)
	assert(args, "You must provdide an argument table when creating VpcIpv6CidrBlockAssociation")
	local t = { 
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["AssociationId"] = args["AssociationId"],
		["Ipv6CidrBlockState"] = args["Ipv6CidrBlockState"],
	}
	asserts.AssertVpcIpv6CidrBlockAssociation(t)
	return t
end

keys.DescribeSpotFleetInstancesResponse = { ["ActiveInstances"] = true, ["SpotFleetRequestId"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSpotFleetInstancesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetInstancesResponse to be of type 'table'")
	assert(struct["ActiveInstances"], "Expected key ActiveInstances to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["ActiveInstances"] then asserts.AssertActiveInstanceSet(struct["ActiveInstances"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetInstancesResponse[k], "DescribeSpotFleetInstancesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetInstancesResponse
-- <p>Contains the output of DescribeSpotFleetInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ActiveInstances [ActiveInstanceSet] <p>The running instances. Note that this list is refreshed periodically and might be out of date.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- Required key: ActiveInstances
-- Required key: SpotFleetRequestId
-- @return DescribeSpotFleetInstancesResponse structure as a key-value pair table
function M.DescribeSpotFleetInstancesResponse(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotFleetInstancesResponse")
	local t = { 
		["ActiveInstances"] = args["ActiveInstances"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeSpotFleetInstancesResponse(t)
	return t
end

keys.VpnConnection = { ["VpnConnectionId"] = true, ["Tags"] = true, ["CustomerGatewayConfiguration"] = true, ["Routes"] = true, ["State"] = true, ["VpnGatewayId"] = true, ["CustomerGatewayId"] = true, ["Type"] = true, ["Options"] = true, ["VgwTelemetry"] = true, nil }

function asserts.AssertVpnConnection(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnection to be of type 'table'")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["CustomerGatewayConfiguration"] then asserts.AssertString(struct["CustomerGatewayConfiguration"]) end
	if struct["Routes"] then asserts.AssertVpnStaticRouteList(struct["Routes"]) end
	if struct["State"] then asserts.AssertVpnState(struct["State"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	if struct["Options"] then asserts.AssertVpnConnectionOptions(struct["Options"]) end
	if struct["VgwTelemetry"] then asserts.AssertVgwTelemetryList(struct["VgwTelemetry"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnConnection[k], "VpnConnection contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnection
-- <p>Describes a VPN connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- * Tags [TagList] <p>Any tags assigned to the VPN connection.</p>
-- * CustomerGatewayConfiguration [String] <p>The configuration information for the VPN connection's customer gateway (in the native XML format). This element is always present in the <a>CreateVpnConnection</a> response; however, it's present in the <a>DescribeVpnConnections</a> response only if the VPN connection is in the <code>pending</code> or <code>available</code> state.</p>
-- * Routes [VpnStaticRouteList] <p>The static routes associated with the VPN connection.</p>
-- * State [VpnState] <p>The current state of the VPN connection.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway at the AWS side of the VPN connection.</p>
-- * CustomerGatewayId [String] <p>The ID of the customer gateway at your end of the VPN connection.</p>
-- * Type [GatewayType] <p>The type of VPN connection.</p>
-- * Options [VpnConnectionOptions] <p>The VPN connection options.</p>
-- * VgwTelemetry [VgwTelemetryList] <p>Information about the VPN tunnel.</p>
-- @return VpnConnection structure as a key-value pair table
function M.VpnConnection(args)
	assert(args, "You must provdide an argument table when creating VpnConnection")
	local t = { 
		["VpnConnectionId"] = args["VpnConnectionId"],
		["Tags"] = args["Tags"],
		["CustomerGatewayConfiguration"] = args["CustomerGatewayConfiguration"],
		["Routes"] = args["Routes"],
		["State"] = args["State"],
		["VpnGatewayId"] = args["VpnGatewayId"],
		["CustomerGatewayId"] = args["CustomerGatewayId"],
		["Type"] = args["Type"],
		["Options"] = args["Options"],
		["VgwTelemetry"] = args["VgwTelemetry"],
	}
	asserts.AssertVpnConnection(t)
	return t
end

keys.ScheduledInstancesPrivateIpAddressConfig = { ["Primary"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertScheduledInstancesPrivateIpAddressConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesPrivateIpAddressConfig to be of type 'table'")
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesPrivateIpAddressConfig[k], "ScheduledInstancesPrivateIpAddressConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesPrivateIpAddressConfig
-- <p>Describes a private IPv4 address for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Primary [Boolean] <p>Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.</p>
-- * PrivateIpAddress [String] <p>The IPv4 address.</p>
-- @return ScheduledInstancesPrivateIpAddressConfig structure as a key-value pair table
function M.ScheduledInstancesPrivateIpAddressConfig(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstancesPrivateIpAddressConfig")
	local t = { 
		["Primary"] = args["Primary"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertScheduledInstancesPrivateIpAddressConfig(t)
	return t
end

keys.DescribeSubnetsResult = { ["Subnets"] = true, nil }

function asserts.AssertDescribeSubnetsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSubnetsResult to be of type 'table'")
	if struct["Subnets"] then asserts.AssertSubnetList(struct["Subnets"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSubnetsResult[k], "DescribeSubnetsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSubnetsResult
-- <p>Contains the output of DescribeSubnets.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Subnets [SubnetList] <p>Information about one or more subnets.</p>
-- @return DescribeSubnetsResult structure as a key-value pair table
function M.DescribeSubnetsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeSubnetsResult")
	local t = { 
		["Subnets"] = args["Subnets"],
	}
	asserts.AssertDescribeSubnetsResult(t)
	return t
end

keys.DisableVpcClassicLinkResult = { ["Return"] = true, nil }

function asserts.AssertDisableVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkResult[k], "DisableVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkResult
-- <p>Contains the output of DisableVpcClassicLink.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DisableVpcClassicLinkResult structure as a key-value pair table
function M.DisableVpcClassicLinkResult(args)
	assert(args, "You must provdide an argument table when creating DisableVpcClassicLinkResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDisableVpcClassicLinkResult(t)
	return t
end

keys.AcceptVpcPeeringConnectionResult = { ["VpcPeeringConnection"] = true, nil }

function asserts.AssertAcceptVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcPeeringConnectionResult to be of type 'table'")
	if struct["VpcPeeringConnection"] then asserts.AssertVpcPeeringConnection(struct["VpcPeeringConnection"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptVpcPeeringConnectionResult[k], "AcceptVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcPeeringConnectionResult
-- <p>Contains the output of AcceptVpcPeeringConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcPeeringConnection [VpcPeeringConnection] <p>Information about the VPC peering connection.</p>
-- @return AcceptVpcPeeringConnectionResult structure as a key-value pair table
function M.AcceptVpcPeeringConnectionResult(args)
	assert(args, "You must provdide an argument table when creating AcceptVpcPeeringConnectionResult")
	local t = { 
		["VpcPeeringConnection"] = args["VpcPeeringConnection"],
	}
	asserts.AssertAcceptVpcPeeringConnectionResult(t)
	return t
end

keys.ModifyReservedInstancesRequest = { ["TargetConfigurations"] = true, ["ReservedInstancesIds"] = true, ["ClientToken"] = true, nil }

function asserts.AssertModifyReservedInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyReservedInstancesRequest to be of type 'table'")
	assert(struct["ReservedInstancesIds"], "Expected key ReservedInstancesIds to exist in table")
	assert(struct["TargetConfigurations"], "Expected key TargetConfigurations to exist in table")
	if struct["TargetConfigurations"] then asserts.AssertReservedInstancesConfigurationList(struct["TargetConfigurations"]) end
	if struct["ReservedInstancesIds"] then asserts.AssertReservedInstancesIdStringList(struct["ReservedInstancesIds"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyReservedInstancesRequest[k], "ModifyReservedInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyReservedInstancesRequest
-- <p>Contains the parameters for ModifyReservedInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetConfigurations [ReservedInstancesConfigurationList] <p>The configuration settings for the Reserved Instances to modify.</p>
-- * ReservedInstancesIds [ReservedInstancesIdStringList] <p>The IDs of the Reserved Instances to modify.</p>
-- * ClientToken [String] <p>A unique, case-sensitive token you provide to ensure idempotency of your modification request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: ReservedInstancesIds
-- Required key: TargetConfigurations
-- @return ModifyReservedInstancesRequest structure as a key-value pair table
function M.ModifyReservedInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyReservedInstancesRequest")
	local t = { 
		["TargetConfigurations"] = args["TargetConfigurations"],
		["ReservedInstancesIds"] = args["ReservedInstancesIds"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertModifyReservedInstancesRequest(t)
	return t
end

keys.ReservedInstanceReservationValue = { ["ReservedInstanceId"] = true, ["ReservationValue"] = true, nil }

function asserts.AssertReservedInstanceReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstanceReservationValue to be of type 'table'")
	if struct["ReservedInstanceId"] then asserts.AssertString(struct["ReservedInstanceId"]) end
	if struct["ReservationValue"] then asserts.AssertReservationValue(struct["ReservationValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstanceReservationValue[k], "ReservedInstanceReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstanceReservationValue
-- <p>The total value of the Convertible Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstanceId [String] <p>The ID of the Convertible Reserved Instance that you are exchanging.</p>
-- * ReservationValue [ReservationValue] <p>The total value of the Convertible Reserved Instance that you are exchanging.</p>
-- @return ReservedInstanceReservationValue structure as a key-value pair table
function M.ReservedInstanceReservationValue(args)
	assert(args, "You must provdide an argument table when creating ReservedInstanceReservationValue")
	local t = { 
		["ReservedInstanceId"] = args["ReservedInstanceId"],
		["ReservationValue"] = args["ReservationValue"],
	}
	asserts.AssertReservedInstanceReservationValue(t)
	return t
end

keys.CreateVolumePermission = { ["UserId"] = true, ["Group"] = true, nil }

function asserts.AssertCreateVolumePermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumePermission to be of type 'table'")
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["Group"] then asserts.AssertPermissionGroup(struct["Group"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVolumePermission[k], "CreateVolumePermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumePermission
-- <p>Describes the user or group to be added or removed from the permissions for a volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserId [String] <p>The specific AWS account ID that is to be added or removed from a volume's list of create volume permissions.</p>
-- * Group [PermissionGroup] <p>The specific group that is to be added or removed from a volume's list of create volume permissions.</p>
-- @return CreateVolumePermission structure as a key-value pair table
function M.CreateVolumePermission(args)
	assert(args, "You must provdide an argument table when creating CreateVolumePermission")
	local t = { 
		["UserId"] = args["UserId"],
		["Group"] = args["Group"],
	}
	asserts.AssertCreateVolumePermission(t)
	return t
end

keys.DescribeSpotFleetRequestsRequest = { ["SpotFleetRequestIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestsRequest to be of type 'table'")
	if struct["SpotFleetRequestIds"] then asserts.AssertValueStringList(struct["SpotFleetRequestIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestsRequest[k], "DescribeSpotFleetRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestsRequest
-- <p>Contains the parameters for DescribeSpotFleetRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestIds [ValueStringList] <p>The IDs of the Spot fleet requests.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @return DescribeSpotFleetRequestsRequest structure as a key-value pair table
function M.DescribeSpotFleetRequestsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotFleetRequestsRequest")
	local t = { 
		["SpotFleetRequestIds"] = args["SpotFleetRequestIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeSpotFleetRequestsRequest(t)
	return t
end

keys.GetConsoleOutputRequest = { ["InstanceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertGetConsoleOutputRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleOutputRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleOutputRequest[k], "GetConsoleOutputRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleOutputRequest
-- <p>Contains the parameters for GetConsoleOutput.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- @return GetConsoleOutputRequest structure as a key-value pair table
function M.GetConsoleOutputRequest(args)
	assert(args, "You must provdide an argument table when creating GetConsoleOutputRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertGetConsoleOutputRequest(t)
	return t
end

keys.DescribeFlowLogsResult = { ["FlowLogs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFlowLogsResult to be of type 'table'")
	if struct["FlowLogs"] then asserts.AssertFlowLogSet(struct["FlowLogs"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFlowLogsResult[k], "DescribeFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFlowLogsResult
-- <p>Contains the output of DescribeFlowLogs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FlowLogs [FlowLogSet] <p>Information about the flow logs.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeFlowLogsResult structure as a key-value pair table
function M.DescribeFlowLogsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeFlowLogsResult")
	local t = { 
		["FlowLogs"] = args["FlowLogs"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeFlowLogsResult(t)
	return t
end

keys.VolumeStatusInfo = { ["Status"] = true, ["Details"] = true, nil }

function asserts.AssertVolumeStatusInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusInfo to be of type 'table'")
	if struct["Status"] then asserts.AssertVolumeStatusInfoStatus(struct["Status"]) end
	if struct["Details"] then asserts.AssertVolumeStatusDetailsList(struct["Details"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusInfo[k], "VolumeStatusInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusInfo
-- <p>Describes the status of a volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [VolumeStatusInfoStatus] <p>The status of the volume.</p>
-- * Details [VolumeStatusDetailsList] <p>The details of the volume status.</p>
-- @return VolumeStatusInfo structure as a key-value pair table
function M.VolumeStatusInfo(args)
	assert(args, "You must provdide an argument table when creating VolumeStatusInfo")
	local t = { 
		["Status"] = args["Status"],
		["Details"] = args["Details"],
	}
	asserts.AssertVolumeStatusInfo(t)
	return t
end

keys.Purchase = { ["HourlyPrice"] = true, ["InstanceFamily"] = true, ["CurrencyCode"] = true, ["PaymentOption"] = true, ["HostIdSet"] = true, ["HostReservationId"] = true, ["UpfrontPrice"] = true, ["Duration"] = true, nil }

function asserts.AssertPurchase(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Purchase to be of type 'table'")
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["InstanceFamily"] then asserts.AssertString(struct["InstanceFamily"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["PaymentOption"] then asserts.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["HostIdSet"] then asserts.AssertResponseHostIdSet(struct["HostIdSet"]) end
	if struct["HostReservationId"] then asserts.AssertString(struct["HostReservationId"]) end
	if struct["UpfrontPrice"] then asserts.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then asserts.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(keys.Purchase[k], "Purchase contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Purchase
-- <p>Describes the result of the purchase.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HourlyPrice [String] <p>The hourly price of the reservation per hour.</p>
-- * InstanceFamily [String] <p>The instance family on the Dedicated Host that the reservation can be associated with.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>UpfrontPrice</code> and <code>HourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * PaymentOption [PaymentOption] <p>The payment option for the reservation.</p>
-- * HostIdSet [ResponseHostIdSet] <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
-- * HostReservationId [String] <p>The ID of the reservation.</p>
-- * UpfrontPrice [String] <p>The upfront price of the reservation.</p>
-- * Duration [Integer] <p>The duration of the reservation's term in seconds.</p>
-- @return Purchase structure as a key-value pair table
function M.Purchase(args)
	assert(args, "You must provdide an argument table when creating Purchase")
	local t = { 
		["HourlyPrice"] = args["HourlyPrice"],
		["InstanceFamily"] = args["InstanceFamily"],
		["CurrencyCode"] = args["CurrencyCode"],
		["PaymentOption"] = args["PaymentOption"],
		["HostIdSet"] = args["HostIdSet"],
		["HostReservationId"] = args["HostReservationId"],
		["UpfrontPrice"] = args["UpfrontPrice"],
		["Duration"] = args["Duration"],
	}
	asserts.AssertPurchase(t)
	return t
end

keys.PeeringConnectionOptions = { ["AllowEgressFromLocalVpcToRemoteClassicLink"] = true, ["AllowDnsResolutionFromRemoteVpc"] = true, ["AllowEgressFromLocalClassicLinkToRemoteVpc"] = true, nil }

function asserts.AssertPeeringConnectionOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PeeringConnectionOptions to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then asserts.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then asserts.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then asserts.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.PeeringConnectionOptions[k], "PeeringConnectionOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PeeringConnectionOptions
-- <p>Describes the VPC peering connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.</p>
-- * AllowDnsResolutionFromRemoteVpc [Boolean] <p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>
-- * AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.</p>
-- @return PeeringConnectionOptions structure as a key-value pair table
function M.PeeringConnectionOptions(args)
	assert(args, "You must provdide an argument table when creating PeeringConnectionOptions")
	local t = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = args["AllowEgressFromLocalVpcToRemoteClassicLink"],
		["AllowDnsResolutionFromRemoteVpc"] = args["AllowDnsResolutionFromRemoteVpc"],
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = args["AllowEgressFromLocalClassicLinkToRemoteVpc"],
	}
	asserts.AssertPeeringConnectionOptions(t)
	return t
end

keys.Vpc = { ["VpcId"] = true, ["InstanceTenancy"] = true, ["Tags"] = true, ["Ipv6CidrBlockAssociationSet"] = true, ["State"] = true, ["DhcpOptionsId"] = true, ["CidrBlock"] = true, ["IsDefault"] = true, nil }

function asserts.AssertVpc(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Vpc to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Ipv6CidrBlockAssociationSet"] then asserts.AssertVpcIpv6CidrBlockAssociationSet(struct["Ipv6CidrBlockAssociationSet"]) end
	if struct["State"] then asserts.AssertVpcState(struct["State"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["IsDefault"] then asserts.AssertBoolean(struct["IsDefault"]) end
	for k,_ in pairs(struct) do
		assert(keys.Vpc[k], "Vpc contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Vpc
-- <p>Describes a VPC.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * InstanceTenancy [Tenancy] <p>The allowed tenancy of instances launched into the VPC.</p>
-- * Tags [TagList] <p>Any tags assigned to the VPC.</p>
-- * Ipv6CidrBlockAssociationSet [VpcIpv6CidrBlockAssociationSet] <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
-- * State [VpcState] <p>The current state of the VPC.</p>
-- * DhcpOptionsId [String] <p>The ID of the set of DHCP options you've associated with the VPC (or <code>default</code> if the default options are associated with the VPC).</p>
-- * CidrBlock [String] <p>The IPv4 CIDR block for the VPC.</p>
-- * IsDefault [Boolean] <p>Indicates whether the VPC is the default VPC.</p>
-- @return Vpc structure as a key-value pair table
function M.Vpc(args)
	assert(args, "You must provdide an argument table when creating Vpc")
	local t = { 
		["VpcId"] = args["VpcId"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["Tags"] = args["Tags"],
		["Ipv6CidrBlockAssociationSet"] = args["Ipv6CidrBlockAssociationSet"],
		["State"] = args["State"],
		["DhcpOptionsId"] = args["DhcpOptionsId"],
		["CidrBlock"] = args["CidrBlock"],
		["IsDefault"] = args["IsDefault"],
	}
	asserts.AssertVpc(t)
	return t
end

keys.DescribeVpcEndpointServicesResult = { ["NextToken"] = true, ["ServiceNames"] = true, nil }

function asserts.AssertDescribeVpcEndpointServicesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ServiceNames"] then asserts.AssertValueStringList(struct["ServiceNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServicesResult[k], "DescribeVpcEndpointServicesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicesResult
-- <p>Contains the output of DescribeVpcEndpointServices.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * ServiceNames [ValueStringList] <p>A list of supported AWS services.</p>
-- @return DescribeVpcEndpointServicesResult structure as a key-value pair table
function M.DescribeVpcEndpointServicesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcEndpointServicesResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["ServiceNames"] = args["ServiceNames"],
	}
	asserts.AssertDescribeVpcEndpointServicesResult(t)
	return t
end

keys.ReplaceRouteTableAssociationRequest = { ["RouteTableId"] = true, ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertReplaceRouteTableAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteTableAssociationRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceRouteTableAssociationRequest[k], "ReplaceRouteTableAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteTableAssociationRequest
-- <p>Contains the parameters for ReplaceRouteTableAssociation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RouteTableId [String] <p>The ID of the new route table to associate with the subnet.</p>
-- * AssociationId [String] <p>The association ID.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: AssociationId
-- Required key: RouteTableId
-- @return ReplaceRouteTableAssociationRequest structure as a key-value pair table
function M.ReplaceRouteTableAssociationRequest(args)
	assert(args, "You must provdide an argument table when creating ReplaceRouteTableAssociationRequest")
	local t = { 
		["RouteTableId"] = args["RouteTableId"],
		["AssociationId"] = args["AssociationId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertReplaceRouteTableAssociationRequest(t)
	return t
end

keys.CancelBundleTaskResult = { ["BundleTask"] = true, nil }

function asserts.AssertCancelBundleTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelBundleTaskResult to be of type 'table'")
	if struct["BundleTask"] then asserts.AssertBundleTask(struct["BundleTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelBundleTaskResult[k], "CancelBundleTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelBundleTaskResult
-- <p>Contains the output of CancelBundleTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BundleTask [BundleTask] <p>Information about the bundle task.</p>
-- @return CancelBundleTaskResult structure as a key-value pair table
function M.CancelBundleTaskResult(args)
	assert(args, "You must provdide an argument table when creating CancelBundleTaskResult")
	local t = { 
		["BundleTask"] = args["BundleTask"],
	}
	asserts.AssertCancelBundleTaskResult(t)
	return t
end

keys.SecurityGroup = { ["IpPermissionsEgress"] = true, ["Description"] = true, ["Tags"] = true, ["IpPermissions"] = true, ["GroupName"] = true, ["VpcId"] = true, ["OwnerId"] = true, ["GroupId"] = true, nil }

function asserts.AssertSecurityGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityGroup to be of type 'table'")
	if struct["IpPermissionsEgress"] then asserts.AssertIpPermissionList(struct["IpPermissionsEgress"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityGroup[k], "SecurityGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityGroup
-- <p>Describes a security group</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IpPermissionsEgress [IpPermissionList] <p>[EC2-VPC] One or more outbound rules associated with the security group.</p>
-- * Description [String] <p>A description of the security group.</p>
-- * Tags [TagList] <p>Any tags assigned to the security group.</p>
-- * IpPermissions [IpPermissionList] <p>One or more inbound rules associated with the security group.</p>
-- * GroupName [String] <p>The name of the security group.</p>
-- * VpcId [String] <p>[EC2-VPC] The ID of the VPC for the security group.</p>
-- * OwnerId [String] <p>The AWS account ID of the owner of the security group.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- @return SecurityGroup structure as a key-value pair table
function M.SecurityGroup(args)
	assert(args, "You must provdide an argument table when creating SecurityGroup")
	local t = { 
		["IpPermissionsEgress"] = args["IpPermissionsEgress"],
		["Description"] = args["Description"],
		["Tags"] = args["Tags"],
		["IpPermissions"] = args["IpPermissions"],
		["GroupName"] = args["GroupName"],
		["VpcId"] = args["VpcId"],
		["OwnerId"] = args["OwnerId"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertSecurityGroup(t)
	return t
end

keys.EnableVpcClassicLinkDnsSupportRequest = { ["VpcId"] = true, nil }

function asserts.AssertEnableVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkDnsSupportRequest[k], "EnableVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkDnsSupportRequest
-- <p>Contains the parameters for EnableVpcClassicLinkDnsSupport.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return EnableVpcClassicLinkDnsSupportRequest structure as a key-value pair table
function M.EnableVpcClassicLinkDnsSupportRequest(args)
	assert(args, "You must provdide an argument table when creating EnableVpcClassicLinkDnsSupportRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertEnableVpcClassicLinkDnsSupportRequest(t)
	return t
end

keys.ReportInstanceStatusRequest = { ["Status"] = true, ["ReasonCodes"] = true, ["DryRun"] = true, ["Description"] = true, ["Instances"] = true, ["StartTime"] = true, ["EndTime"] = true, nil }

function asserts.AssertReportInstanceStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReportInstanceStatusRequest to be of type 'table'")
	assert(struct["Instances"], "Expected key Instances to exist in table")
	assert(struct["ReasonCodes"], "Expected key ReasonCodes to exist in table")
	assert(struct["Status"], "Expected key Status to exist in table")
	if struct["Status"] then asserts.AssertReportStatusType(struct["Status"]) end
	if struct["ReasonCodes"] then asserts.AssertReasonCodesList(struct["ReasonCodes"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Instances"] then asserts.AssertInstanceIdStringList(struct["Instances"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReportInstanceStatusRequest[k], "ReportInstanceStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReportInstanceStatusRequest
-- <p>Contains the parameters for ReportInstanceStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [ReportStatusType] <p>The status of all instances listed.</p>
-- * ReasonCodes [ReasonCodesList] <p>One or more reason codes that describes the health state of your instance.</p> <ul> <li> <p> <code>instance-stuck-in-state</code>: My instance is stuck in a state.</p> </li> <li> <p> <code>unresponsive</code>: My instance is unresponsive.</p> </li> <li> <p> <code>not-accepting-credentials</code>: My instance is not accepting my credentials.</p> </li> <li> <p> <code>password-not-available</code>: A password is not available for my instance.</p> </li> <li> <p> <code>performance-network</code>: My instance is experiencing performance problems which I believe are network related.</p> </li> <li> <p> <code>performance-instance-store</code>: My instance is experiencing performance problems which I believe are related to the instance stores.</p> </li> <li> <p> <code>performance-ebs-volume</code>: My instance is experiencing performance problems which I believe are related to an EBS volume.</p> </li> <li> <p> <code>performance-other</code>: My instance is experiencing performance problems.</p> </li> <li> <p> <code>other</code>: [explain using the description parameter]</p> </li> </ul>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>Descriptive text about the health state of your instance.</p>
-- * Instances [InstanceIdStringList] <p>One or more instances.</p>
-- * StartTime [DateTime] <p>The time at which the reported instance health state began.</p>
-- * EndTime [DateTime] <p>The time at which the reported instance health state ended.</p>
-- Required key: Instances
-- Required key: ReasonCodes
-- Required key: Status
-- @return ReportInstanceStatusRequest structure as a key-value pair table
function M.ReportInstanceStatusRequest(args)
	assert(args, "You must provdide an argument table when creating ReportInstanceStatusRequest")
	local t = { 
		["Status"] = args["Status"],
		["ReasonCodes"] = args["ReasonCodes"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["Instances"] = args["Instances"],
		["StartTime"] = args["StartTime"],
		["EndTime"] = args["EndTime"],
	}
	asserts.AssertReportInstanceStatusRequest(t)
	return t
end

keys.DescribeVolumeAttributeResult = { ["AutoEnableIO"] = true, ["ProductCodes"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDescribeVolumeAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeAttributeResult to be of type 'table'")
	if struct["AutoEnableIO"] then asserts.AssertAttributeBooleanValue(struct["AutoEnableIO"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeAttributeResult[k], "DescribeVolumeAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeAttributeResult
-- <p>Contains the output of DescribeVolumeAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutoEnableIO [AttributeBooleanValue] <p>The state of <code>autoEnableIO</code> attribute.</p>
-- * ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- @return DescribeVolumeAttributeResult structure as a key-value pair table
function M.DescribeVolumeAttributeResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVolumeAttributeResult")
	local t = { 
		["AutoEnableIO"] = args["AutoEnableIO"],
		["ProductCodes"] = args["ProductCodes"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertDescribeVolumeAttributeResult(t)
	return t
end

keys.ReservedInstancesId = { ["ReservedInstancesId"] = true, nil }

function asserts.AssertReservedInstancesId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesId to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesId[k], "ReservedInstancesId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesId
-- <p>Describes the ID of a Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- @return ReservedInstancesId structure as a key-value pair table
function M.ReservedInstancesId(args)
	assert(args, "You must provdide an argument table when creating ReservedInstancesId")
	local t = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
	}
	asserts.AssertReservedInstancesId(t)
	return t
end

keys.AttributeValue = { ["Value"] = true, nil }

function asserts.AssertAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttributeValue to be of type 'table'")
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttributeValue[k], "AttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttributeValue
-- <p>Describes a value for a resource attribute that is a String.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [String] <p>The attribute value. Note that the value is case-sensitive.</p>
-- @return AttributeValue structure as a key-value pair table
function M.AttributeValue(args)
	assert(args, "You must provdide an argument table when creating AttributeValue")
	local t = { 
		["Value"] = args["Value"],
	}
	asserts.AssertAttributeValue(t)
	return t
end

keys.DescribeVpcEndpointsRequest = { ["VpcEndpointIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpcEndpointsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointsRequest to be of type 'table'")
	if struct["VpcEndpointIds"] then asserts.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointsRequest[k], "DescribeVpcEndpointsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointsRequest
-- <p>Contains the parameters for DescribeVpcEndpoints.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpointIds [ValueStringList] <p>One or more endpoint IDs.</p>
-- * NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>service-name</code>: The name of the AWS service.</p> </li> <li> <p> <code>vpc-id</code>: The ID of the VPC in which the endpoint resides.</p> </li> <li> <p> <code>vpc-endpoint-id</code>: The ID of the endpoint.</p> </li> <li> <p> <code>vpc-endpoint-state</code>: The state of the endpoint. (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>)</p> </li> </ul>
-- @return DescribeVpcEndpointsRequest structure as a key-value pair table
function M.DescribeVpcEndpointsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcEndpointsRequest")
	local t = { 
		["VpcEndpointIds"] = args["VpcEndpointIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpcEndpointsRequest(t)
	return t
end

keys.TagDescription = { ["ResourceType"] = true, ["ResourceId"] = true, ["Value"] = true, ["Key"] = true, nil }

function asserts.AssertTagDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TagDescription to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertString(struct["ResourceId"]) end
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.TagDescription[k], "TagDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TagDescription
-- <p>Describes a tag.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceType] <p>The resource type.</p>
-- * ResourceId [String] <p>The ID of the resource. For example, <code>ami-1a2b3c4d</code>.</p>
-- * Value [String] <p>The tag value.</p>
-- * Key [String] <p>The tag key.</p>
-- @return TagDescription structure as a key-value pair table
function M.TagDescription(args)
	assert(args, "You must provdide an argument table when creating TagDescription")
	local t = { 
		["ResourceType"] = args["ResourceType"],
		["ResourceId"] = args["ResourceId"],
		["Value"] = args["Value"],
		["Key"] = args["Key"],
	}
	asserts.AssertTagDescription(t)
	return t
end

keys.DeleteVpcRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcRequest[k], "DeleteVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcRequest
-- <p>Contains the parameters for DeleteVpc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return DeleteVpcRequest structure as a key-value pair table
function M.DeleteVpcRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteVpcRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteVpcRequest(t)
	return t
end

keys.DescribeSnapshotsRequest = { ["OwnerIds"] = true, ["DryRun"] = true, ["SnapshotIds"] = true, ["MaxResults"] = true, ["Filters"] = true, ["RestorableByUserIds"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSnapshotsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotsRequest to be of type 'table'")
	if struct["OwnerIds"] then asserts.AssertOwnerStringList(struct["OwnerIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotIds"] then asserts.AssertSnapshotIdStringList(struct["SnapshotIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["RestorableByUserIds"] then asserts.AssertRestorableByStringList(struct["RestorableByUserIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotsRequest[k], "DescribeSnapshotsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotsRequest
-- <p>Contains the parameters for DescribeSnapshots.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OwnerIds [OwnerStringList] <p>Returns the snapshots owned by the specified owner. Multiple owners can be specified.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * SnapshotIds [SnapshotIdStringList] <p>One or more snapshot IDs.</p> <p>Default: Describes snapshots for which you have launch permissions.</p>
-- * MaxResults [Integer] <p>The maximum number of snapshot results returned by <code>DescribeSnapshots</code> in paginated output. When this parameter is used, <code>DescribeSnapshots</code> only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>DescribeSnapshots</code> request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then <code>DescribeSnapshots</code> returns all results. You cannot specify this parameter and the snapshot IDs parameter in the same request.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>description</code> - A description of the snapshot.</p> </li> <li> <p> <code>owner-alias</code> - Value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM consolew.</p> </li> <li> <p> <code>owner-id</code> - The ID of the AWS account that owns the snapshot.</p> </li> <li> <p> <code>progress</code> - The progress of the snapshot, as a percentage (for example, 80%).</p> </li> <li> <p> <code>snapshot-id</code> - The snapshot ID.</p> </li> <li> <p> <code>start-time</code> - The time stamp when the snapshot was initiated.</p> </li> <li> <p> <code>status</code> - The status of the snapshot (<code>pending</code> | <code>completed</code> | <code>error</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>volume-id</code> - The ID of the volume the snapshot is for.</p> </li> <li> <p> <code>volume-size</code> - The size of the volume, in GiB.</p> </li> </ul>
-- * RestorableByUserIds [RestorableByStringList] <p>One or more AWS accounts IDs that can create volumes from the snapshot.</p>
-- * NextToken [String] <p>The <code>NextToken</code> value returned from a previous paginated <code>DescribeSnapshots</code> request where <code>MaxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>NextToken</code> value. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeSnapshotsRequest structure as a key-value pair table
function M.DescribeSnapshotsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSnapshotsRequest")
	local t = { 
		["OwnerIds"] = args["OwnerIds"],
		["DryRun"] = args["DryRun"],
		["SnapshotIds"] = args["SnapshotIds"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["RestorableByUserIds"] = args["RestorableByUserIds"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeSnapshotsRequest(t)
	return t
end

keys.VpnConnectionOptions = { ["StaticRoutesOnly"] = true, nil }

function asserts.AssertVpnConnectionOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnectionOptions to be of type 'table'")
	if struct["StaticRoutesOnly"] then asserts.AssertBoolean(struct["StaticRoutesOnly"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnConnectionOptions[k], "VpnConnectionOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnectionOptions
-- <p>Describes VPN connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StaticRoutesOnly [Boolean] <p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>
-- @return VpnConnectionOptions structure as a key-value pair table
function M.VpnConnectionOptions(args)
	assert(args, "You must provdide an argument table when creating VpnConnectionOptions")
	local t = { 
		["StaticRoutesOnly"] = args["StaticRoutesOnly"],
	}
	asserts.AssertVpnConnectionOptions(t)
	return t
end

keys.BundleInstanceRequest = { ["InstanceId"] = true, ["DryRun"] = true, ["Storage"] = true, nil }

function asserts.AssertBundleInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["Storage"], "Expected key Storage to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Storage"] then asserts.AssertStorage(struct["Storage"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleInstanceRequest[k], "BundleInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleInstanceRequest
-- <p>Contains the parameters for BundleInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance to bundle.</p> <p>Type: String</p> <p>Default: None</p> <p>Required: Yes</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Storage [Storage] <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
-- Required key: InstanceId
-- Required key: Storage
-- @return BundleInstanceRequest structure as a key-value pair table
function M.BundleInstanceRequest(args)
	assert(args, "You must provdide an argument table when creating BundleInstanceRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
		["Storage"] = args["Storage"],
	}
	asserts.AssertBundleInstanceRequest(t)
	return t
end

keys.ImportVolumeTaskDetails = { ["BytesConverted"] = true, ["Volume"] = true, ["Image"] = true, ["AvailabilityZone"] = true, ["Description"] = true, nil }

function asserts.AssertImportVolumeTaskDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeTaskDetails to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["BytesConverted"], "Expected key BytesConverted to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["BytesConverted"] then asserts.AssertLong(struct["BytesConverted"]) end
	if struct["Volume"] then asserts.AssertDiskImageVolumeDescription(struct["Volume"]) end
	if struct["Image"] then asserts.AssertDiskImageDescription(struct["Image"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportVolumeTaskDetails[k], "ImportVolumeTaskDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeTaskDetails
-- <p>Describes an import volume task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BytesConverted [Long] <p>The number of bytes converted so far.</p>
-- * Volume [DiskImageVolumeDescription] <p>The volume.</p>
-- * Image [DiskImageDescription] <p>The image.</p>
-- * AvailabilityZone [String] <p>The Availability Zone where the resulting volume will reside.</p>
-- * Description [String] <p>The description you provided when starting the import volume task.</p>
-- Required key: AvailabilityZone
-- Required key: BytesConverted
-- Required key: Image
-- Required key: Volume
-- @return ImportVolumeTaskDetails structure as a key-value pair table
function M.ImportVolumeTaskDetails(args)
	assert(args, "You must provdide an argument table when creating ImportVolumeTaskDetails")
	local t = { 
		["BytesConverted"] = args["BytesConverted"],
		["Volume"] = args["Volume"],
		["Image"] = args["Image"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Description"] = args["Description"],
	}
	asserts.AssertImportVolumeTaskDetails(t)
	return t
end

keys.ImportSnapshotResult = { ["SnapshotTaskDetail"] = true, ["Description"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportSnapshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotResult to be of type 'table'")
	if struct["SnapshotTaskDetail"] then asserts.AssertSnapshotTaskDetail(struct["SnapshotTaskDetail"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportSnapshotResult[k], "ImportSnapshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotResult
-- <p>Contains the output for ImportSnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SnapshotTaskDetail [SnapshotTaskDetail] <p>Information about the import snapshot task.</p>
-- * Description [String] <p>A description of the import snapshot task.</p>
-- * ImportTaskId [String] <p>The ID of the import snapshot task.</p>
-- @return ImportSnapshotResult structure as a key-value pair table
function M.ImportSnapshotResult(args)
	assert(args, "You must provdide an argument table when creating ImportSnapshotResult")
	local t = { 
		["SnapshotTaskDetail"] = args["SnapshotTaskDetail"],
		["Description"] = args["Description"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertImportSnapshotResult(t)
	return t
end

keys.VolumeStatusEvent = { ["EventId"] = true, ["EventType"] = true, ["NotBefore"] = true, ["Description"] = true, ["NotAfter"] = true, nil }

function asserts.AssertVolumeStatusEvent(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusEvent to be of type 'table'")
	if struct["EventId"] then asserts.AssertString(struct["EventId"]) end
	if struct["EventType"] then asserts.AssertString(struct["EventType"]) end
	if struct["NotBefore"] then asserts.AssertDateTime(struct["NotBefore"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NotAfter"] then asserts.AssertDateTime(struct["NotAfter"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusEvent[k], "VolumeStatusEvent contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusEvent
-- <p>Describes a volume status event.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EventId [String] <p>The ID of this event.</p>
-- * EventType [String] <p>The type of this event.</p>
-- * NotBefore [DateTime] <p>The earliest start time of the event.</p>
-- * Description [String] <p>A description of the event.</p>
-- * NotAfter [DateTime] <p>The latest end time of the event.</p>
-- @return VolumeStatusEvent structure as a key-value pair table
function M.VolumeStatusEvent(args)
	assert(args, "You must provdide an argument table when creating VolumeStatusEvent")
	local t = { 
		["EventId"] = args["EventId"],
		["EventType"] = args["EventType"],
		["NotBefore"] = args["NotBefore"],
		["Description"] = args["Description"],
		["NotAfter"] = args["NotAfter"],
	}
	asserts.AssertVolumeStatusEvent(t)
	return t
end

keys.RejectVpcPeeringConnectionResult = { ["Return"] = true, nil }

function asserts.AssertRejectVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcPeeringConnectionResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.RejectVpcPeeringConnectionResult[k], "RejectVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcPeeringConnectionResult
-- <p>Contains the output of RejectVpcPeeringConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return RejectVpcPeeringConnectionResult structure as a key-value pair table
function M.RejectVpcPeeringConnectionResult(args)
	assert(args, "You must provdide an argument table when creating RejectVpcPeeringConnectionResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertRejectVpcPeeringConnectionResult(t)
	return t
end

keys.DeleteFlowLogsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertDeleteFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFlowLogsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFlowLogsResult[k], "DeleteFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFlowLogsResult
-- <p>Contains the output of DeleteFlowLogs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the flow logs that could not be deleted successfully.</p>
-- @return DeleteFlowLogsResult structure as a key-value pair table
function M.DeleteFlowLogsResult(args)
	assert(args, "You must provdide an argument table when creating DeleteFlowLogsResult")
	local t = { 
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertDeleteFlowLogsResult(t)
	return t
end

keys.UserBucket = { ["S3Bucket"] = true, ["S3Key"] = true, nil }

function asserts.AssertUserBucket(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserBucket to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then asserts.AssertString(struct["S3Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserBucket[k], "UserBucket contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserBucket
-- <p>Describes the S3 bucket for the disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3Bucket [String] <p>The name of the S3 bucket where the disk image is located.</p>
-- * S3Key [String] <p>The file name of the disk image.</p>
-- @return UserBucket structure as a key-value pair table
function M.UserBucket(args)
	assert(args, "You must provdide an argument table when creating UserBucket")
	local t = { 
		["S3Bucket"] = args["S3Bucket"],
		["S3Key"] = args["S3Key"],
	}
	asserts.AssertUserBucket(t)
	return t
end

keys.CreateFlowLogsResult = { ["Unsuccessful"] = true, ["FlowLogIds"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFlowLogsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	if struct["FlowLogIds"] then asserts.AssertValueStringList(struct["FlowLogIds"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFlowLogsResult[k], "CreateFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFlowLogsResult
-- <p>Contains the output of CreateFlowLogs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the flow logs that could not be created successfully.</p>
-- * FlowLogIds [ValueStringList] <p>The IDs of the flow logs.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
-- @return CreateFlowLogsResult structure as a key-value pair table
function M.CreateFlowLogsResult(args)
	assert(args, "You must provdide an argument table when creating CreateFlowLogsResult")
	local t = { 
		["Unsuccessful"] = args["Unsuccessful"],
		["FlowLogIds"] = args["FlowLogIds"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateFlowLogsResult(t)
	return t
end

keys.StopInstancesRequest = { ["Force"] = true, ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertStopInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.StopInstancesRequest[k], "StopInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopInstancesRequest
-- <p>Contains the parameters for StopInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Force [Boolean] <p>Forces the instances to stop. The instances do not have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures. This option is not recommended for Windows instances.</p> <p>Default: <code>false</code> </p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return StopInstancesRequest structure as a key-value pair table
function M.StopInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating StopInstancesRequest")
	local t = { 
		["Force"] = args["Force"],
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertStopInstancesRequest(t)
	return t
end

keys.StopInstancesResult = { ["StoppingInstances"] = true, nil }

function asserts.AssertStopInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopInstancesResult to be of type 'table'")
	if struct["StoppingInstances"] then asserts.AssertInstanceStateChangeList(struct["StoppingInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.StopInstancesResult[k], "StopInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopInstancesResult
-- <p>Contains the output of StopInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StoppingInstances [InstanceStateChangeList] <p>Information about one or more stopped instances.</p>
-- @return StopInstancesResult structure as a key-value pair table
function M.StopInstancesResult(args)
	assert(args, "You must provdide an argument table when creating StopInstancesResult")
	local t = { 
		["StoppingInstances"] = args["StoppingInstances"],
	}
	asserts.AssertStopInstancesResult(t)
	return t
end

keys.DescribeReservedInstancesListingsRequest = { ["ReservedInstancesId"] = true, ["ReservedInstancesListingId"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeReservedInstancesListingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesListingsRequest to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["ReservedInstancesListingId"] then asserts.AssertString(struct["ReservedInstancesListingId"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesListingsRequest[k], "DescribeReservedInstancesListingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesListingsRequest
-- <p>Contains the parameters for DescribeReservedInstancesListings.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>One or more Reserved Instance IDs.</p>
-- * ReservedInstancesListingId [String] <p>One or more Reserved Instance listing IDs.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instances.</p> </li> <li> <p> <code>reserved-instances-listing-id</code> - The ID of the Reserved Instances listing.</p> </li> <li> <p> <code>status</code> - The status of the Reserved Instance listing (<code>pending</code> | <code>active</code> | <code>cancelled</code> | <code>closed</code>).</p> </li> <li> <p> <code>status-message</code> - The reason for the status.</p> </li> </ul>
-- @return DescribeReservedInstancesListingsRequest structure as a key-value pair table
function M.DescribeReservedInstancesListingsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeReservedInstancesListingsRequest")
	local t = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["ReservedInstancesListingId"] = args["ReservedInstancesListingId"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeReservedInstancesListingsRequest(t)
	return t
end

keys.ModifySubnetAttributeRequest = { ["SubnetId"] = true, ["MapPublicIpOnLaunch"] = true, ["AssignIpv6AddressOnCreation"] = true, nil }

function asserts.AssertModifySubnetAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySubnetAttributeRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["MapPublicIpOnLaunch"] then asserts.AssertAttributeBooleanValue(struct["MapPublicIpOnLaunch"]) end
	if struct["AssignIpv6AddressOnCreation"] then asserts.AssertAttributeBooleanValue(struct["AssignIpv6AddressOnCreation"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySubnetAttributeRequest[k], "ModifySubnetAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySubnetAttributeRequest
-- <p>Contains the parameters for ModifySubnetAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * MapPublicIpOnLaunch [AttributeBooleanValue] <p>Specify <code>true</code> to indicate that network interfaces created in the specified subnet should be assigned a public IPv4 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives a public IPv4 address).</p>
-- * AssignIpv6AddressOnCreation [AttributeBooleanValue] <p>Specify <code>true</code> to indicate that network interfaces created in the specified subnet should be assigned an IPv6 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives an IPv6 address). </p> <p>If you enable the IPv6 addressing feature for your subnet, your network interface or instance only receives an IPv6 address if it's created using version <code>2016-11-15</code> or later of the Amazon EC2 API.</p>
-- Required key: SubnetId
-- @return ModifySubnetAttributeRequest structure as a key-value pair table
function M.ModifySubnetAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ModifySubnetAttributeRequest")
	local t = { 
		["SubnetId"] = args["SubnetId"],
		["MapPublicIpOnLaunch"] = args["MapPublicIpOnLaunch"],
		["AssignIpv6AddressOnCreation"] = args["AssignIpv6AddressOnCreation"],
	}
	asserts.AssertModifySubnetAttributeRequest(t)
	return t
end

keys.DisassociateAddressRequest = { ["PublicIp"] = true, ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDisassociateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateAddressRequest to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateAddressRequest[k], "DisassociateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateAddressRequest
-- <p>Contains the parameters for DisassociateAddress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
-- * AssociationId [String] <p>[EC2-VPC] The association ID. Required for EC2-VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DisassociateAddressRequest structure as a key-value pair table
function M.DisassociateAddressRequest(args)
	assert(args, "You must provdide an argument table when creating DisassociateAddressRequest")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["AssociationId"] = args["AssociationId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDisassociateAddressRequest(t)
	return t
end

keys.ExportTask = { ["Description"] = true, ["InstanceExportDetails"] = true, ["ExportTaskId"] = true, ["State"] = true, ["StatusMessage"] = true, ["ExportToS3Task"] = true, nil }

function asserts.AssertExportTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportTask to be of type 'table'")
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["InstanceExportDetails"] then asserts.AssertInstanceExportDetails(struct["InstanceExportDetails"]) end
	if struct["ExportTaskId"] then asserts.AssertString(struct["ExportTaskId"]) end
	if struct["State"] then asserts.AssertExportTaskState(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ExportToS3Task"] then asserts.AssertExportToS3Task(struct["ExportToS3Task"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExportTask[k], "ExportTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportTask
-- <p>Describes an instance export task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Description [String] <p>A description of the resource being exported.</p>
-- * InstanceExportDetails [InstanceExportDetails] <p>Information about the instance to export.</p>
-- * ExportTaskId [String] <p>The ID of the export task.</p>
-- * State [ExportTaskState] <p>The state of the export task.</p>
-- * StatusMessage [String] <p>The status message related to the export task.</p>
-- * ExportToS3Task [ExportToS3Task] <p>Information about the export task.</p>
-- @return ExportTask structure as a key-value pair table
function M.ExportTask(args)
	assert(args, "You must provdide an argument table when creating ExportTask")
	local t = { 
		["Description"] = args["Description"],
		["InstanceExportDetails"] = args["InstanceExportDetails"],
		["ExportTaskId"] = args["ExportTaskId"],
		["State"] = args["State"],
		["StatusMessage"] = args["StatusMessage"],
		["ExportToS3Task"] = args["ExportToS3Task"],
	}
	asserts.AssertExportTask(t)
	return t
end

keys.ImportVolumeRequest = { ["Volume"] = true, ["Image"] = true, ["AvailabilityZone"] = true, ["DryRun"] = true, ["Description"] = true, nil }

function asserts.AssertImportVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["Volume"] then asserts.AssertVolumeDetail(struct["Volume"]) end
	if struct["Image"] then asserts.AssertDiskImageDetail(struct["Image"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportVolumeRequest[k], "ImportVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeRequest
-- <p>Contains the parameters for ImportVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Volume [VolumeDetail] <p>The volume size.</p>
-- * Image [DiskImageDetail] <p>The disk image.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the resulting EBS volume.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description of the volume.</p>
-- Required key: AvailabilityZone
-- Required key: Image
-- Required key: Volume
-- @return ImportVolumeRequest structure as a key-value pair table
function M.ImportVolumeRequest(args)
	assert(args, "You must provdide an argument table when creating ImportVolumeRequest")
	local t = { 
		["Volume"] = args["Volume"],
		["Image"] = args["Image"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
	}
	asserts.AssertImportVolumeRequest(t)
	return t
end

keys.DescribeVpnGatewaysResult = { ["VpnGateways"] = true, nil }

function asserts.AssertDescribeVpnGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnGatewaysResult to be of type 'table'")
	if struct["VpnGateways"] then asserts.AssertVpnGatewayList(struct["VpnGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnGatewaysResult[k], "DescribeVpnGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnGatewaysResult
-- <p>Contains the output of DescribeVpnGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnGateways [VpnGatewayList] <p>Information about one or more virtual private gateways.</p>
-- @return DescribeVpnGatewaysResult structure as a key-value pair table
function M.DescribeVpnGatewaysResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVpnGatewaysResult")
	local t = { 
		["VpnGateways"] = args["VpnGateways"],
	}
	asserts.AssertDescribeVpnGatewaysResult(t)
	return t
end

keys.ImageDiskContainer = { ["DeviceName"] = true, ["Description"] = true, ["Format"] = true, ["Url"] = true, ["SnapshotId"] = true, ["UserBucket"] = true, nil }

function asserts.AssertImageDiskContainer(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImageDiskContainer to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["UserBucket"] then asserts.AssertUserBucket(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImageDiskContainer[k], "ImageDiskContainer contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImageDiskContainer
-- <p>Describes the disk container object for an import image task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceName [String] <p>The block device mapping for the disk.</p>
-- * Description [String] <p>The description of the disk image.</p>
-- * Format [String] <p>The format of the disk image being imported.</p> <p>Valid values: <code>RAW</code> | <code>VHD</code> | <code>VMDK</code> | <code>OVA</code> </p>
-- * Url [String] <p>The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an Amazon S3 URL (s3://..)</p>
-- * SnapshotId [String] <p>The ID of the EBS snapshot to be used for importing the snapshot.</p>
-- * UserBucket [UserBucket] <p>The S3 bucket for the disk image.</p>
-- @return ImageDiskContainer structure as a key-value pair table
function M.ImageDiskContainer(args)
	assert(args, "You must provdide an argument table when creating ImageDiskContainer")
	local t = { 
		["DeviceName"] = args["DeviceName"],
		["Description"] = args["Description"],
		["Format"] = args["Format"],
		["Url"] = args["Url"],
		["SnapshotId"] = args["SnapshotId"],
		["UserBucket"] = args["UserBucket"],
	}
	asserts.AssertImageDiskContainer(t)
	return t
end

keys.DescribeSpotPriceHistoryRequest = { ["NextToken"] = true, ["AvailabilityZone"] = true, ["DryRun"] = true, ["StartTime"] = true, ["InstanceTypes"] = true, ["MaxResults"] = true, ["ProductDescriptions"] = true, ["Filters"] = true, ["EndTime"] = true, nil }

function asserts.AssertDescribeSpotPriceHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotPriceHistoryRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["InstanceTypes"] then asserts.AssertInstanceTypeList(struct["InstanceTypes"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["ProductDescriptions"] then asserts.AssertProductDescriptionList(struct["ProductDescriptions"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotPriceHistoryRequest[k], "DescribeSpotPriceHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotPriceHistoryRequest
-- <p>Contains the parameters for DescribeSpotPriceHistory.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * AvailabilityZone [String] <p>Filters the results by the specified Availability Zone.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * StartTime [DateTime] <p>The date and time, up to the past 90 days, from which to start retrieving the price history data, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- * InstanceTypes [InstanceTypeList] <p>Filters the results by the specified instance types. Note that T2 and HS1 instance types are not supported.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * ProductDescriptions [ProductDescriptionList] <p>Filters the results by the specified basic product descriptions.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone for which prices should be returned.</p> </li> <li> <p> <code>instance-type</code> - The type of instance (for example, <code>m3.medium</code>).</p> </li> <li> <p> <code>product-description</code> - The product description for the Spot price (<code>Linux/UNIX</code> | <code>SUSE Linux</code> | <code>Windows</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Windows (Amazon VPC)</code>).</p> </li> <li> <p> <code>spot-price</code> - The Spot price. The value must match exactly (or use wildcards; greater than or less than comparison is not supported).</p> </li> <li> <p> <code>timestamp</code> - The timestamp of the Spot price history, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). You can use wildcards (* and ?). Greater than or less than comparison is not supported.</p> </li> </ul>
-- * EndTime [DateTime] <p>The date and time, up to the current date, from which to stop retrieving the price history data, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @return DescribeSpotPriceHistoryRequest structure as a key-value pair table
function M.DescribeSpotPriceHistoryRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotPriceHistoryRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["DryRun"] = args["DryRun"],
		["StartTime"] = args["StartTime"],
		["InstanceTypes"] = args["InstanceTypes"],
		["MaxResults"] = args["MaxResults"],
		["ProductDescriptions"] = args["ProductDescriptions"],
		["Filters"] = args["Filters"],
		["EndTime"] = args["EndTime"],
	}
	asserts.AssertDescribeSpotPriceHistoryRequest(t)
	return t
end

keys.ModifyHostsRequest = { ["HostIds"] = true, ["AutoPlacement"] = true, nil }

function asserts.AssertModifyHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyHostsRequest to be of type 'table'")
	assert(struct["AutoPlacement"], "Expected key AutoPlacement to exist in table")
	assert(struct["HostIds"], "Expected key HostIds to exist in table")
	if struct["HostIds"] then asserts.AssertRequestHostIdList(struct["HostIds"]) end
	if struct["AutoPlacement"] then asserts.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyHostsRequest[k], "ModifyHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyHostsRequest
-- <p>Contains the parameters for ModifyHosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostIds [RequestHostIdList] <p>The host IDs of the Dedicated Hosts you want to modify.</p>
-- * AutoPlacement [AutoPlacement] <p>Specify whether to enable or disable auto-placement.</p>
-- Required key: AutoPlacement
-- Required key: HostIds
-- @return ModifyHostsRequest structure as a key-value pair table
function M.ModifyHostsRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyHostsRequest")
	local t = { 
		["HostIds"] = args["HostIds"],
		["AutoPlacement"] = args["AutoPlacement"],
	}
	asserts.AssertModifyHostsRequest(t)
	return t
end

keys.ResetImageAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["ImageId"] = true, nil }

function asserts.AssertResetImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetImageAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["Attribute"] then asserts.AssertResetImageAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetImageAttributeRequest[k], "ResetImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetImageAttributeRequest
-- <p>Contains the parameters for ResetImageAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [ResetImageAttributeName] <p>The attribute to reset (currently you can only reset the launch permission attribute).</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- Required key: Attribute
-- Required key: ImageId
-- @return ResetImageAttributeRequest structure as a key-value pair table
function M.ResetImageAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ResetImageAttributeRequest")
	local t = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertResetImageAttributeRequest(t)
	return t
end

keys.DescribeAvailabilityZonesResult = { ["AvailabilityZones"] = true, nil }

function asserts.AssertDescribeAvailabilityZonesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailabilityZonesResult to be of type 'table'")
	if struct["AvailabilityZones"] then asserts.AssertAvailabilityZoneList(struct["AvailabilityZones"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAvailabilityZonesResult[k], "DescribeAvailabilityZonesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailabilityZonesResult
-- <p>Contains the output of DescribeAvailabiltyZones.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZones [AvailabilityZoneList] <p>Information about one or more Availability Zones.</p>
-- @return DescribeAvailabilityZonesResult structure as a key-value pair table
function M.DescribeAvailabilityZonesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeAvailabilityZonesResult")
	local t = { 
		["AvailabilityZones"] = args["AvailabilityZones"],
	}
	asserts.AssertDescribeAvailabilityZonesResult(t)
	return t
end

keys.RecurringCharge = { ["Amount"] = true, ["Frequency"] = true, nil }

function asserts.AssertRecurringCharge(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RecurringCharge to be of type 'table'")
	if struct["Amount"] then asserts.AssertDouble(struct["Amount"]) end
	if struct["Frequency"] then asserts.AssertRecurringChargeFrequency(struct["Frequency"]) end
	for k,_ in pairs(struct) do
		assert(keys.RecurringCharge[k], "RecurringCharge contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RecurringCharge
-- <p>Describes a recurring charge.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Amount [Double] <p>The amount of the recurring charge.</p>
-- * Frequency [RecurringChargeFrequency] <p>The frequency of the recurring charge.</p>
-- @return RecurringCharge structure as a key-value pair table
function M.RecurringCharge(args)
	assert(args, "You must provdide an argument table when creating RecurringCharge")
	local t = { 
		["Amount"] = args["Amount"],
		["Frequency"] = args["Frequency"],
	}
	asserts.AssertRecurringCharge(t)
	return t
end

keys.InstanceStateChange = { ["InstanceId"] = true, ["CurrentState"] = true, ["PreviousState"] = true, nil }

function asserts.AssertInstanceStateChange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStateChange to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["CurrentState"] then asserts.AssertInstanceState(struct["CurrentState"]) end
	if struct["PreviousState"] then asserts.AssertInstanceState(struct["PreviousState"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStateChange[k], "InstanceStateChange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStateChange
-- <p>Describes an instance state change.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * CurrentState [InstanceState] <p>The current state of the instance.</p>
-- * PreviousState [InstanceState] <p>The previous state of the instance.</p>
-- @return InstanceStateChange structure as a key-value pair table
function M.InstanceStateChange(args)
	assert(args, "You must provdide an argument table when creating InstanceStateChange")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["CurrentState"] = args["CurrentState"],
		["PreviousState"] = args["PreviousState"],
	}
	asserts.AssertInstanceStateChange(t)
	return t
end

keys.PurchaseRequest = { ["InstanceCount"] = true, ["PurchaseToken"] = true, nil }

function asserts.AssertPurchaseRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseRequest to be of type 'table'")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["PurchaseToken"], "Expected key PurchaseToken to exist in table")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["PurchaseToken"] then asserts.AssertString(struct["PurchaseToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseRequest[k], "PurchaseRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseRequest
-- <p>Describes a request to purchase Scheduled Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceCount [Integer] <p>The number of instances.</p>
-- * PurchaseToken [String] <p>The purchase token.</p>
-- Required key: InstanceCount
-- Required key: PurchaseToken
-- @return PurchaseRequest structure as a key-value pair table
function M.PurchaseRequest(args)
	assert(args, "You must provdide an argument table when creating PurchaseRequest")
	local t = { 
		["InstanceCount"] = args["InstanceCount"],
		["PurchaseToken"] = args["PurchaseToken"],
	}
	asserts.AssertPurchaseRequest(t)
	return t
end

keys.ResetSnapshotAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertResetSnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetSnapshotAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["Attribute"] then asserts.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetSnapshotAttributeRequest[k], "ResetSnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetSnapshotAttributeRequest
-- <p>Contains the parameters for ResetSnapshotAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [SnapshotAttributeName] <p>The attribute to reset. Currently, only the attribute for permission to create volumes can be reset.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- Required key: Attribute
-- Required key: SnapshotId
-- @return ResetSnapshotAttributeRequest structure as a key-value pair table
function M.ResetSnapshotAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ResetSnapshotAttributeRequest")
	local t = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertResetSnapshotAttributeRequest(t)
	return t
end

keys.DescribeVolumesModificationsResult = { ["VolumesModifications"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeVolumesModificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesModificationsResult to be of type 'table'")
	if struct["VolumesModifications"] then asserts.AssertVolumeModificationList(struct["VolumesModifications"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesModificationsResult[k], "DescribeVolumesModificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesModificationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumesModifications [VolumeModificationList] <p>A list of returned <a>VolumeModification</a> objects.</p>
-- * NextToken [String] <p>Token for pagination, null if there are no more results </p>
-- @return DescribeVolumesModificationsResult structure as a key-value pair table
function M.DescribeVolumesModificationsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVolumesModificationsResult")
	local t = { 
		["VolumesModifications"] = args["VolumesModifications"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeVolumesModificationsResult(t)
	return t
end

keys.ImportKeyPairRequest = { ["PublicKeyMaterial"] = true, ["KeyName"] = true, ["DryRun"] = true, nil }

function asserts.AssertImportKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	assert(struct["PublicKeyMaterial"], "Expected key PublicKeyMaterial to exist in table")
	if struct["PublicKeyMaterial"] then asserts.AssertBlob(struct["PublicKeyMaterial"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportKeyPairRequest[k], "ImportKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportKeyPairRequest
-- <p>Contains the parameters for ImportKeyPair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicKeyMaterial [Blob] <p>The public key. For API calls, the text must be base64-encoded. For command line tools, base64 encoding is performed for you.</p>
-- * KeyName [String] <p>A unique name for the key pair.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: KeyName
-- Required key: PublicKeyMaterial
-- @return ImportKeyPairRequest structure as a key-value pair table
function M.ImportKeyPairRequest(args)
	assert(args, "You must provdide an argument table when creating ImportKeyPairRequest")
	local t = { 
		["PublicKeyMaterial"] = args["PublicKeyMaterial"],
		["KeyName"] = args["KeyName"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertImportKeyPairRequest(t)
	return t
end

keys.SpotFleetLaunchSpecification = { ["WeightedCapacity"] = true, ["UserData"] = true, ["SubnetId"] = true, ["Monitoring"] = true, ["ImageId"] = true, ["KeyName"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroups"] = true, ["SpotPrice"] = true, ["RamdiskId"] = true, ["KernelId"] = true, ["Placement"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["AddressingType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertSpotFleetLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetLaunchSpecification to be of type 'table'")
	if struct["WeightedCapacity"] then asserts.AssertDouble(struct["WeightedCapacity"]) end
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then asserts.AssertSpotFleetMonitoring(struct["Monitoring"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then asserts.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Placement"] then asserts.AssertSpotPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then asserts.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetLaunchSpecification[k], "SpotFleetLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetLaunchSpecification
-- <p>Describes the launch specification for one or more Spot instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WeightedCapacity [Double] <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms (instances or a performance characteristic such as vCPUs, memory, or I/O).</p> <p>If the target capacity divided by this value is not a whole number, we round the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
-- * UserData [String] <p>The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-a61dafcf, subnet-65ea5f08".</p>
-- * Monitoring [SpotFleetMonitoring] <p>Enable or disable monitoring for the instances.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- * SecurityGroups [GroupIdentifierList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- * SpotPrice [String] <p>The bid price per unit hour for the specified instance type. If this value is not specified, the default is the Spot bid price specified for the fleet. To determine the bid price per unit hour, divide the Spot bid price by the value of <code>WeightedCapacity</code>.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * Placement [SpotPlacement] <p>The placement information.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- * InstanceType [InstanceType] <p>The instance type. Note that T2 and HS1 instance types are not supported.</p>
-- * AddressingType [String] <p>Deprecated.</p>
-- * NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
-- @return SpotFleetLaunchSpecification structure as a key-value pair table
function M.SpotFleetLaunchSpecification(args)
	assert(args, "You must provdide an argument table when creating SpotFleetLaunchSpecification")
	local t = { 
		["WeightedCapacity"] = args["WeightedCapacity"],
		["UserData"] = args["UserData"],
		["SubnetId"] = args["SubnetId"],
		["Monitoring"] = args["Monitoring"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["SecurityGroups"] = args["SecurityGroups"],
		["SpotPrice"] = args["SpotPrice"],
		["RamdiskId"] = args["RamdiskId"],
		["KernelId"] = args["KernelId"],
		["Placement"] = args["Placement"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["InstanceType"] = args["InstanceType"],
		["AddressingType"] = args["AddressingType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertSpotFleetLaunchSpecification(t)
	return t
end

keys.DeleteNetworkAclRequest = { ["NetworkAclId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteNetworkAclRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkAclRequest to be of type 'table'")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkAclRequest[k], "DeleteNetworkAclRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkAclRequest
-- <p>Contains the parameters for DeleteNetworkAcl.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: NetworkAclId
-- @return DeleteNetworkAclRequest structure as a key-value pair table
function M.DeleteNetworkAclRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteNetworkAclRequest")
	local t = { 
		["NetworkAclId"] = args["NetworkAclId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteNetworkAclRequest(t)
	return t
end

keys.DescribePlacementGroupsRequest = { ["GroupNames"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribePlacementGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePlacementGroupsRequest to be of type 'table'")
	if struct["GroupNames"] then asserts.AssertPlacementGroupStringList(struct["GroupNames"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePlacementGroupsRequest[k], "DescribePlacementGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePlacementGroupsRequest
-- <p>Contains the parameters for DescribePlacementGroups.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupNames [PlacementGroupStringList] <p>One or more placement group names.</p> <p>Default: Describes all your placement groups, or only those otherwise specified.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>group-name</code> - The name of the placement group.</p> </li> <li> <p> <code>state</code> - The state of the placement group (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>strategy</code> - The strategy of the placement group (<code>cluster</code>).</p> </li> </ul>
-- @return DescribePlacementGroupsRequest structure as a key-value pair table
function M.DescribePlacementGroupsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribePlacementGroupsRequest")
	local t = { 
		["GroupNames"] = args["GroupNames"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribePlacementGroupsRequest(t)
	return t
end

keys.DescribeNetworkAclsRequest = { ["NetworkAclIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeNetworkAclsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkAclsRequest to be of type 'table'")
	if struct["NetworkAclIds"] then asserts.AssertValueStringList(struct["NetworkAclIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkAclsRequest[k], "DescribeNetworkAclsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkAclsRequest
-- <p>Contains the parameters for DescribeNetworkAcls.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAclIds [ValueStringList] <p>One or more network ACL IDs.</p> <p>Default: Describes all your network ACLs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>association.association-id</code> - The ID of an association ID for the ACL.</p> </li> <li> <p> <code>association.network-acl-id</code> - The ID of the network ACL involved in the association.</p> </li> <li> <p> <code>association.subnet-id</code> - The ID of the subnet involved in the association.</p> </li> <li> <p> <code>default</code> - Indicates whether the ACL is the default network ACL for the VPC.</p> </li> <li> <p> <code>entry.cidr</code> - The IPv4 CIDR range specified in the entry.</p> </li> <li> <p> <code>entry.egress</code> - Indicates whether the entry applies to egress traffic.</p> </li> <li> <p> <code>entry.icmp.code</code> - The ICMP code specified in the entry, if any.</p> </li> <li> <p> <code>entry.icmp.type</code> - The ICMP type specified in the entry, if any.</p> </li> <li> <p> <code>entry.ipv6-cidr</code> - The IPv6 CIDR range specified in the entry.</p> </li> <li> <p> <code>entry.port-range.from</code> - The start of the port range specified in the entry. </p> </li> <li> <p> <code>entry.port-range.to</code> - The end of the port range specified in the entry. </p> </li> <li> <p> <code>entry.protocol</code> - The protocol specified in the entry (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p> </li> <li> <p> <code>entry.rule-action</code> - Allows or denies the matching traffic (<code>allow</code> | <code>deny</code>).</p> </li> <li> <p> <code>entry.rule-number</code> - The number of an entry (in other words, rule) in the ACL's set of entries.</p> </li> <li> <p> <code>network-acl-id</code> - The ID of the network ACL.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the network ACL.</p> </li> </ul>
-- @return DescribeNetworkAclsRequest structure as a key-value pair table
function M.DescribeNetworkAclsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeNetworkAclsRequest")
	local t = { 
		["NetworkAclIds"] = args["NetworkAclIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeNetworkAclsRequest(t)
	return t
end

keys.AssignIpv6AddressesRequest = { ["Ipv6Addresses"] = true, ["Ipv6AddressCount"] = true, ["NetworkInterfaceId"] = true, nil }

function asserts.AssertAssignIpv6AddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignIpv6AddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Ipv6Addresses"] then asserts.AssertIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssignIpv6AddressesRequest[k], "AssignIpv6AddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignIpv6AddressesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Addresses [Ipv6AddressList] <p>One or more specific IPv6 addresses to be assigned to the network interface. You can't use this option if you're specifying a number of IPv6 addresses.</p>
-- * Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to the network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- Required key: NetworkInterfaceId
-- @return AssignIpv6AddressesRequest structure as a key-value pair table
function M.AssignIpv6AddressesRequest(args)
	assert(args, "You must provdide an argument table when creating AssignIpv6AddressesRequest")
	local t = { 
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
	}
	asserts.AssertAssignIpv6AddressesRequest(t)
	return t
end

keys.MonitorInstancesResult = { ["InstanceMonitorings"] = true, nil }

function asserts.AssertMonitorInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MonitorInstancesResult to be of type 'table'")
	if struct["InstanceMonitorings"] then asserts.AssertInstanceMonitoringList(struct["InstanceMonitorings"]) end
	for k,_ in pairs(struct) do
		assert(keys.MonitorInstancesResult[k], "MonitorInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MonitorInstancesResult
-- <p>Contains the output of MonitorInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceMonitorings [InstanceMonitoringList] <p>The monitoring information.</p>
-- @return MonitorInstancesResult structure as a key-value pair table
function M.MonitorInstancesResult(args)
	assert(args, "You must provdide an argument table when creating MonitorInstancesResult")
	local t = { 
		["InstanceMonitorings"] = args["InstanceMonitorings"],
	}
	asserts.AssertMonitorInstancesResult(t)
	return t
end

keys.SlotDateTimeRangeRequest = { ["LatestTime"] = true, ["EarliestTime"] = true, nil }

function asserts.AssertSlotDateTimeRangeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SlotDateTimeRangeRequest to be of type 'table'")
	assert(struct["EarliestTime"], "Expected key EarliestTime to exist in table")
	assert(struct["LatestTime"], "Expected key LatestTime to exist in table")
	if struct["LatestTime"] then asserts.AssertDateTime(struct["LatestTime"]) end
	if struct["EarliestTime"] then asserts.AssertDateTime(struct["EarliestTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.SlotDateTimeRangeRequest[k], "SlotDateTimeRangeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SlotDateTimeRangeRequest
-- <p>Describes the time period for a Scheduled Instance to start its first schedule. The time period must span less than one day.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LatestTime [DateTime] <p>The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.</p>
-- * EarliestTime [DateTime] <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
-- Required key: EarliestTime
-- Required key: LatestTime
-- @return SlotDateTimeRangeRequest structure as a key-value pair table
function M.SlotDateTimeRangeRequest(args)
	assert(args, "You must provdide an argument table when creating SlotDateTimeRangeRequest")
	local t = { 
		["LatestTime"] = args["LatestTime"],
		["EarliestTime"] = args["EarliestTime"],
	}
	asserts.AssertSlotDateTimeRangeRequest(t)
	return t
end

keys.DescribeVpcEndpointsResult = { ["NextToken"] = true, ["VpcEndpoints"] = true, nil }

function asserts.AssertDescribeVpcEndpointsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["VpcEndpoints"] then asserts.AssertVpcEndpointSet(struct["VpcEndpoints"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointsResult[k], "DescribeVpcEndpointsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointsResult
-- <p>Contains the output of DescribeVpcEndpoints.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * VpcEndpoints [VpcEndpointSet] <p>Information about the endpoints.</p>
-- @return DescribeVpcEndpointsResult structure as a key-value pair table
function M.DescribeVpcEndpointsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcEndpointsResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["VpcEndpoints"] = args["VpcEndpoints"],
	}
	asserts.AssertDescribeVpcEndpointsResult(t)
	return t
end

keys.FpgaImage = { ["OwnerAlias"] = true, ["UpdateTime"] = true, ["Name"] = true, ["ProductCodes"] = true, ["PciId"] = true, ["Tags"] = true, ["FpgaImageGlobalId"] = true, ["State"] = true, ["ShellVersion"] = true, ["OwnerId"] = true, ["FpgaImageId"] = true, ["CreateTime"] = true, ["Description"] = true, nil }

function asserts.AssertFpgaImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FpgaImage to be of type 'table'")
	if struct["OwnerAlias"] then asserts.AssertString(struct["OwnerAlias"]) end
	if struct["UpdateTime"] then asserts.AssertDateTime(struct["UpdateTime"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["PciId"] then asserts.AssertPciId(struct["PciId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["FpgaImageGlobalId"] then asserts.AssertString(struct["FpgaImageGlobalId"]) end
	if struct["State"] then asserts.AssertFpgaImageState(struct["State"]) end
	if struct["ShellVersion"] then asserts.AssertString(struct["ShellVersion"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.FpgaImage[k], "FpgaImage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FpgaImage
-- <p>Describes an Amazon FPGA image (AFI).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OwnerAlias [String] <p>The alias of the AFI owner. Possible values include <code>self</code>, <code>amazon</code>, and <code>aws-marketplace</code>.</p>
-- * UpdateTime [DateTime] <p>The time of the most recent update to the AFI.</p>
-- * Name [String] <p>The name of the AFI.</p>
-- * ProductCodes [ProductCodeList] <p>The product codes for the AFI.</p>
-- * PciId [PciId] <p>Information about the PCI bus.</p>
-- * Tags [TagList] <p>Any tags assigned to the AFI.</p>
-- * FpgaImageGlobalId [String] <p>The global FPGA image identifier (AGFI ID).</p>
-- * State [FpgaImageState] <p>Information about the state of the AFI.</p>
-- * ShellVersion [String] <p>The version of the AWS Shell that was used to create the bitstream.</p>
-- * OwnerId [String] <p>The AWS account ID of the AFI owner.</p>
-- * FpgaImageId [String] <p>The FPGA image identifier (AFI ID).</p>
-- * CreateTime [DateTime] <p>The date and time the AFI was created.</p>
-- * Description [String] <p>The description of the AFI.</p>
-- @return FpgaImage structure as a key-value pair table
function M.FpgaImage(args)
	assert(args, "You must provdide an argument table when creating FpgaImage")
	local t = { 
		["OwnerAlias"] = args["OwnerAlias"],
		["UpdateTime"] = args["UpdateTime"],
		["Name"] = args["Name"],
		["ProductCodes"] = args["ProductCodes"],
		["PciId"] = args["PciId"],
		["Tags"] = args["Tags"],
		["FpgaImageGlobalId"] = args["FpgaImageGlobalId"],
		["State"] = args["State"],
		["ShellVersion"] = args["ShellVersion"],
		["OwnerId"] = args["OwnerId"],
		["FpgaImageId"] = args["FpgaImageId"],
		["CreateTime"] = args["CreateTime"],
		["Description"] = args["Description"],
	}
	asserts.AssertFpgaImage(t)
	return t
end

keys.DescribeKeyPairsRequest = { ["DryRun"] = true, ["Filters"] = true, ["KeyNames"] = true, nil }

function asserts.AssertDescribeKeyPairsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeKeyPairsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["KeyNames"] then asserts.AssertKeyNameStringList(struct["KeyNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeKeyPairsRequest[k], "DescribeKeyPairsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeKeyPairsRequest
-- <p>Contains the parameters for DescribeKeyPairs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>fingerprint</code> - The fingerprint of the key pair.</p> </li> <li> <p> <code>key-name</code> - The name of the key pair.</p> </li> </ul>
-- * KeyNames [KeyNameStringList] <p>One or more key pair names.</p> <p>Default: Describes all your key pairs.</p>
-- @return DescribeKeyPairsRequest structure as a key-value pair table
function M.DescribeKeyPairsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeKeyPairsRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["KeyNames"] = args["KeyNames"],
	}
	asserts.AssertDescribeKeyPairsRequest(t)
	return t
end

keys.PurchaseReservedInstancesOfferingResult = { ["ReservedInstancesId"] = true, nil }

function asserts.AssertPurchaseReservedInstancesOfferingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseReservedInstancesOfferingResult to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseReservedInstancesOfferingResult[k], "PurchaseReservedInstancesOfferingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseReservedInstancesOfferingResult
-- <p>Contains the output of PurchaseReservedInstancesOffering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The IDs of the purchased Reserved Instances.</p>
-- @return PurchaseReservedInstancesOfferingResult structure as a key-value pair table
function M.PurchaseReservedInstancesOfferingResult(args)
	assert(args, "You must provdide an argument table when creating PurchaseReservedInstancesOfferingResult")
	local t = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
	}
	asserts.AssertPurchaseReservedInstancesOfferingResult(t)
	return t
end

keys.CancelBundleTaskRequest = { ["DryRun"] = true, ["BundleId"] = true, nil }

function asserts.AssertCancelBundleTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelBundleTaskRequest to be of type 'table'")
	assert(struct["BundleId"], "Expected key BundleId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["BundleId"] then asserts.AssertString(struct["BundleId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelBundleTaskRequest[k], "CancelBundleTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelBundleTaskRequest
-- <p>Contains the parameters for CancelBundleTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * BundleId [String] <p>The ID of the bundle task.</p>
-- Required key: BundleId
-- @return CancelBundleTaskRequest structure as a key-value pair table
function M.CancelBundleTaskRequest(args)
	assert(args, "You must provdide an argument table when creating CancelBundleTaskRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["BundleId"] = args["BundleId"],
	}
	asserts.AssertCancelBundleTaskRequest(t)
	return t
end

keys.ReleaseAddressRequest = { ["PublicIp"] = true, ["DryRun"] = true, ["AllocationId"] = true, nil }

function asserts.AssertReleaseAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseAddressRequest to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReleaseAddressRequest[k], "ReleaseAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseAddressRequest
-- <p>Contains the parameters for ReleaseAddress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AllocationId [String] <p>[EC2-VPC] The allocation ID. Required for EC2-VPC.</p>
-- @return ReleaseAddressRequest structure as a key-value pair table
function M.ReleaseAddressRequest(args)
	assert(args, "You must provdide an argument table when creating ReleaseAddressRequest")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["DryRun"] = args["DryRun"],
		["AllocationId"] = args["AllocationId"],
	}
	asserts.AssertReleaseAddressRequest(t)
	return t
end

keys.TerminateInstancesResult = { ["TerminatingInstances"] = true, nil }

function asserts.AssertTerminateInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateInstancesResult to be of type 'table'")
	if struct["TerminatingInstances"] then asserts.AssertInstanceStateChangeList(struct["TerminatingInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.TerminateInstancesResult[k], "TerminateInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateInstancesResult
-- <p>Contains the output of TerminateInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TerminatingInstances [InstanceStateChangeList] <p>Information about one or more terminated instances.</p>
-- @return TerminateInstancesResult structure as a key-value pair table
function M.TerminateInstancesResult(args)
	assert(args, "You must provdide an argument table when creating TerminateInstancesResult")
	local t = { 
		["TerminatingInstances"] = args["TerminatingInstances"],
	}
	asserts.AssertTerminateInstancesResult(t)
	return t
end

keys.InstanceMonitoring = { ["InstanceId"] = true, ["Monitoring"] = true, nil }

function asserts.AssertInstanceMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceMonitoring to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Monitoring"] then asserts.AssertMonitoring(struct["Monitoring"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceMonitoring[k], "InstanceMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceMonitoring
-- <p>Describes the monitoring of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Monitoring [Monitoring] <p>The monitoring for the instance.</p>
-- @return InstanceMonitoring structure as a key-value pair table
function M.InstanceMonitoring(args)
	assert(args, "You must provdide an argument table when creating InstanceMonitoring")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["Monitoring"] = args["Monitoring"],
	}
	asserts.AssertInstanceMonitoring(t)
	return t
end

keys.DescribeRegionsResult = { ["Regions"] = true, nil }

function asserts.AssertDescribeRegionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRegionsResult to be of type 'table'")
	if struct["Regions"] then asserts.AssertRegionList(struct["Regions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRegionsResult[k], "DescribeRegionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRegionsResult
-- <p>Contains the output of DescribeRegions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Regions [RegionList] <p>Information about one or more regions.</p>
-- @return DescribeRegionsResult structure as a key-value pair table
function M.DescribeRegionsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeRegionsResult")
	local t = { 
		["Regions"] = args["Regions"],
	}
	asserts.AssertDescribeRegionsResult(t)
	return t
end

keys.VpcPeeringConnectionOptionsDescription = { ["AllowEgressFromLocalVpcToRemoteClassicLink"] = true, ["AllowDnsResolutionFromRemoteVpc"] = true, ["AllowEgressFromLocalClassicLinkToRemoteVpc"] = true, nil }

function asserts.AssertVpcPeeringConnectionOptionsDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionOptionsDescription to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then asserts.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then asserts.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then asserts.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnectionOptionsDescription[k], "VpcPeeringConnectionOptionsDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionOptionsDescription
-- <p>Describes the VPC peering connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.</p>
-- * AllowDnsResolutionFromRemoteVpc [Boolean] <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.</p>
-- * AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.</p>
-- @return VpcPeeringConnectionOptionsDescription structure as a key-value pair table
function M.VpcPeeringConnectionOptionsDescription(args)
	assert(args, "You must provdide an argument table when creating VpcPeeringConnectionOptionsDescription")
	local t = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = args["AllowEgressFromLocalVpcToRemoteClassicLink"],
		["AllowDnsResolutionFromRemoteVpc"] = args["AllowDnsResolutionFromRemoteVpc"],
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = args["AllowEgressFromLocalClassicLinkToRemoteVpc"],
	}
	asserts.AssertVpcPeeringConnectionOptionsDescription(t)
	return t
end

keys.NatGateway = { ["NatGatewayAddresses"] = true, ["ProvisionedBandwidth"] = true, ["VpcId"] = true, ["State"] = true, ["FailureMessage"] = true, ["FailureCode"] = true, ["NatGatewayId"] = true, ["SubnetId"] = true, ["DeleteTime"] = true, ["CreateTime"] = true, nil }

function asserts.AssertNatGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NatGateway to be of type 'table'")
	if struct["NatGatewayAddresses"] then asserts.AssertNatGatewayAddressList(struct["NatGatewayAddresses"]) end
	if struct["ProvisionedBandwidth"] then asserts.AssertProvisionedBandwidth(struct["ProvisionedBandwidth"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["State"] then asserts.AssertNatGatewayState(struct["State"]) end
	if struct["FailureMessage"] then asserts.AssertString(struct["FailureMessage"]) end
	if struct["FailureCode"] then asserts.AssertString(struct["FailureCode"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteTime"] then asserts.AssertDateTime(struct["DeleteTime"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.NatGateway[k], "NatGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NatGateway
-- <p>Describes a NAT gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NatGatewayAddresses [NatGatewayAddressList] <p>Information about the IP addresses and network interface associated with the NAT gateway.</p>
-- * ProvisionedBandwidth [ProvisionedBandwidth] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * VpcId [String] <p>The ID of the VPC in which the NAT gateway is located.</p>
-- * State [NatGatewayState] <p>The state of the NAT gateway.</p> <ul> <li> <p> <code>pending</code>: The NAT gateway is being created and is not ready to process traffic.</p> </li> <li> <p> <code>failed</code>: The NAT gateway could not be created. Check the <code>failureCode</code> and <code>failureMessage</code> fields for the reason.</p> </li> <li> <p> <code>available</code>: The NAT gateway is able to process traffic. This status remains until you delete the NAT gateway, and does not indicate the health of the NAT gateway.</p> </li> <li> <p> <code>deleting</code>: The NAT gateway is in the process of being terminated and may still be processing traffic.</p> </li> <li> <p> <code>deleted</code>: The NAT gateway has been terminated and is no longer processing traffic.</p> </li> </ul>
-- * FailureMessage [String] <p>If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.</p> <ul> <li> <p>For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free addresses to create this NAT gateway"</p> </li> <li> <p>For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway attached"</p> </li> <li> <p>For InvalidAllocationID.NotFound: "Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway"</p> </li> <li> <p>For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx is already associated"</p> </li> <li> <p>For InternalError: "Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again."</p> </li> <li> <p>For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx does not exist or could not be found."</p> </li> </ul>
-- * FailureCode [String] <p>If the NAT gateway could not be created, specifies the error code for the failure. (<code>InsufficientFreeAddressesInSubnet</code> | <code>Gateway.NotAttached</code> | <code>InvalidAllocationID.NotFound</code> | <code>Resource.AlreadyAssociated</code> | <code>InternalError</code> | <code>InvalidSubnetID.NotFound</code>)</p>
-- * NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- * SubnetId [String] <p>The ID of the subnet in which the NAT gateway is located.</p>
-- * DeleteTime [DateTime] <p>The date and time the NAT gateway was deleted, if applicable.</p>
-- * CreateTime [DateTime] <p>The date and time the NAT gateway was created.</p>
-- @return NatGateway structure as a key-value pair table
function M.NatGateway(args)
	assert(args, "You must provdide an argument table when creating NatGateway")
	local t = { 
		["NatGatewayAddresses"] = args["NatGatewayAddresses"],
		["ProvisionedBandwidth"] = args["ProvisionedBandwidth"],
		["VpcId"] = args["VpcId"],
		["State"] = args["State"],
		["FailureMessage"] = args["FailureMessage"],
		["FailureCode"] = args["FailureCode"],
		["NatGatewayId"] = args["NatGatewayId"],
		["SubnetId"] = args["SubnetId"],
		["DeleteTime"] = args["DeleteTime"],
		["CreateTime"] = args["CreateTime"],
	}
	asserts.AssertNatGateway(t)
	return t
end

keys.DescribeVpnConnectionsRequest = { ["DryRun"] = true, ["VpnConnectionIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpnConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnConnectionsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnConnectionIds"] then asserts.AssertVpnConnectionIdStringList(struct["VpnConnectionIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnConnectionsRequest[k], "DescribeVpnConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnConnectionsRequest
-- <p>Contains the parameters for DescribeVpnConnections.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnConnectionIds [VpnConnectionIdStringList] <p>One or more VPN connection IDs.</p> <p>Default: Describes your VPN connections.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>customer-gateway-configuration</code> - The configuration information for the customer gateway.</p> </li> <li> <p> <code>customer-gateway-id</code> - The ID of a customer gateway associated with the VPN connection.</p> </li> <li> <p> <code>state</code> - The state of the VPN connection (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>option.static-routes-only</code> - Indicates whether the connection has static routes only. Used for devices that do not support Border Gateway Protocol (BGP).</p> </li> <li> <p> <code>route.destination-cidr-block</code> - The destination CIDR block. This corresponds to the subnet used in a customer data center.</p> </li> <li> <p> <code>bgp-asn</code> - The BGP Autonomous System Number (ASN) associated with a BGP device.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>type</code> - The type of VPN connection. Currently the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>vpn-connection-id</code> - The ID of the VPN connection.</p> </li> <li> <p> <code>vpn-gateway-id</code> - The ID of a virtual private gateway associated with the VPN connection.</p> </li> </ul>
-- @return DescribeVpnConnectionsRequest structure as a key-value pair table
function M.DescribeVpnConnectionsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVpnConnectionsRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["VpnConnectionIds"] = args["VpnConnectionIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpnConnectionsRequest(t)
	return t
end

keys.SpotDatafeedSubscription = { ["Fault"] = true, ["Prefix"] = true, ["Bucket"] = true, ["State"] = true, ["OwnerId"] = true, nil }

function asserts.AssertSpotDatafeedSubscription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotDatafeedSubscription to be of type 'table'")
	if struct["Fault"] then asserts.AssertSpotInstanceStateFault(struct["Fault"]) end
	if struct["Prefix"] then asserts.AssertString(struct["Prefix"]) end
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	if struct["State"] then asserts.AssertDatafeedSubscriptionState(struct["State"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotDatafeedSubscription[k], "SpotDatafeedSubscription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotDatafeedSubscription
-- <p>Describes the data feed for a Spot instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Fault [SpotInstanceStateFault] <p>The fault codes for the Spot instance request, if any.</p>
-- * Prefix [String] <p>The prefix that is prepended to data feed files.</p>
-- * Bucket [String] <p>The Amazon S3 bucket where the Spot instance data feed is located.</p>
-- * State [DatafeedSubscriptionState] <p>The state of the Spot instance data feed subscription.</p>
-- * OwnerId [String] <p>The AWS account ID of the account.</p>
-- @return SpotDatafeedSubscription structure as a key-value pair table
function M.SpotDatafeedSubscription(args)
	assert(args, "You must provdide an argument table when creating SpotDatafeedSubscription")
	local t = { 
		["Fault"] = args["Fault"],
		["Prefix"] = args["Prefix"],
		["Bucket"] = args["Bucket"],
		["State"] = args["State"],
		["OwnerId"] = args["OwnerId"],
	}
	asserts.AssertSpotDatafeedSubscription(t)
	return t
end

keys.StorageLocation = { ["Bucket"] = true, ["Key"] = true, nil }

function asserts.AssertStorageLocation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StorageLocation to be of type 'table'")
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.StorageLocation[k], "StorageLocation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StorageLocation
-- <p>Describes a storage location in Amazon S3.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Bucket [String] <p>The name of the S3 bucket.</p>
-- * Key [String] <p>The key.</p>
-- @return StorageLocation structure as a key-value pair table
function M.StorageLocation(args)
	assert(args, "You must provdide an argument table when creating StorageLocation")
	local t = { 
		["Bucket"] = args["Bucket"],
		["Key"] = args["Key"],
	}
	asserts.AssertStorageLocation(t)
	return t
end

keys.ModifyHostsResult = { ["Successful"] = true, ["Unsuccessful"] = true, nil }

function asserts.AssertModifyHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyHostsResult to be of type 'table'")
	if struct["Successful"] then asserts.AssertResponseHostIdList(struct["Successful"]) end
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemList(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyHostsResult[k], "ModifyHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyHostsResult
-- <p>Contains the output of ModifyHosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Successful [ResponseHostIdList] <p>The IDs of the Dedicated Hosts that were successfully modified.</p>
-- * Unsuccessful [UnsuccessfulItemList] <p>The IDs of the Dedicated Hosts that could not be modified. Check whether the setting you requested can be used.</p>
-- @return ModifyHostsResult structure as a key-value pair table
function M.ModifyHostsResult(args)
	assert(args, "You must provdide an argument table when creating ModifyHostsResult")
	local t = { 
		["Successful"] = args["Successful"],
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertModifyHostsResult(t)
	return t
end

keys.CreateInternetGatewayRequest = { ["DryRun"] = true, nil }

function asserts.AssertCreateInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInternetGatewayRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInternetGatewayRequest[k], "CreateInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInternetGatewayRequest
-- <p>Contains the parameters for CreateInternetGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return CreateInternetGatewayRequest structure as a key-value pair table
function M.CreateInternetGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating CreateInternetGatewayRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateInternetGatewayRequest(t)
	return t
end

keys.DescribeNetworkInterfacesResult = { ["NetworkInterfaces"] = true, nil }

function asserts.AssertDescribeNetworkInterfacesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacesResult to be of type 'table'")
	if struct["NetworkInterfaces"] then asserts.AssertNetworkInterfaceList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfacesResult[k], "DescribeNetworkInterfacesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacesResult
-- <p>Contains the output of DescribeNetworkInterfaces.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaces [NetworkInterfaceList] <p>Information about one or more network interfaces.</p>
-- @return DescribeNetworkInterfacesResult structure as a key-value pair table
function M.DescribeNetworkInterfacesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeNetworkInterfacesResult")
	local t = { 
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertDescribeNetworkInterfacesResult(t)
	return t
end

keys.InstanceNetworkInterfaceAssociation = { ["PublicIp"] = true, ["PublicDnsName"] = true, ["IpOwnerId"] = true, nil }

function asserts.AssertInstanceNetworkInterfaceAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceAssociation to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["PublicDnsName"] then asserts.AssertString(struct["PublicDnsName"]) end
	if struct["IpOwnerId"] then asserts.AssertString(struct["IpOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterfaceAssociation[k], "InstanceNetworkInterfaceAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceAssociation
-- <p>Describes association information for an Elastic IP address (IPv4).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The public IP address or Elastic IP address bound to the network interface.</p>
-- * PublicDnsName [String] <p>The public DNS name.</p>
-- * IpOwnerId [String] <p>The ID of the owner of the Elastic IP address.</p>
-- @return InstanceNetworkInterfaceAssociation structure as a key-value pair table
function M.InstanceNetworkInterfaceAssociation(args)
	assert(args, "You must provdide an argument table when creating InstanceNetworkInterfaceAssociation")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["PublicDnsName"] = args["PublicDnsName"],
		["IpOwnerId"] = args["IpOwnerId"],
	}
	asserts.AssertInstanceNetworkInterfaceAssociation(t)
	return t
end

keys.InstanceExportDetails = { ["InstanceId"] = true, ["TargetEnvironment"] = true, nil }

function asserts.AssertInstanceExportDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceExportDetails to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["TargetEnvironment"] then asserts.AssertExportEnvironment(struct["TargetEnvironment"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceExportDetails[k], "InstanceExportDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceExportDetails
-- <p>Describes an instance to export.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the resource being exported.</p>
-- * TargetEnvironment [ExportEnvironment] <p>The target virtualization environment.</p>
-- @return InstanceExportDetails structure as a key-value pair table
function M.InstanceExportDetails(args)
	assert(args, "You must provdide an argument table when creating InstanceExportDetails")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["TargetEnvironment"] = args["TargetEnvironment"],
	}
	asserts.AssertInstanceExportDetails(t)
	return t
end

keys.VpcClassicLink = { ["ClassicLinkEnabled"] = true, ["VpcId"] = true, ["Tags"] = true, nil }

function asserts.AssertVpcClassicLink(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcClassicLink to be of type 'table'")
	if struct["ClassicLinkEnabled"] then asserts.AssertBoolean(struct["ClassicLinkEnabled"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcClassicLink[k], "VpcClassicLink contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcClassicLink
-- <p>Describes whether a VPC is enabled for ClassicLink.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ClassicLinkEnabled [Boolean] <p>Indicates whether the VPC is enabled for ClassicLink.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * Tags [TagList] <p>Any tags assigned to the VPC.</p>
-- @return VpcClassicLink structure as a key-value pair table
function M.VpcClassicLink(args)
	assert(args, "You must provdide an argument table when creating VpcClassicLink")
	local t = { 
		["ClassicLinkEnabled"] = args["ClassicLinkEnabled"],
		["VpcId"] = args["VpcId"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertVpcClassicLink(t)
	return t
end

keys.NetworkInterfaceIpv6Address = { ["Ipv6Address"] = true, nil }

function asserts.AssertNetworkInterfaceIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertString(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceIpv6Address[k], "NetworkInterfaceIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceIpv6Address
-- <p>Describes an IPv6 address associated with a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Address [String] <p>The IPv6 address.</p>
-- @return NetworkInterfaceIpv6Address structure as a key-value pair table
function M.NetworkInterfaceIpv6Address(args)
	assert(args, "You must provdide an argument table when creating NetworkInterfaceIpv6Address")
	local t = { 
		["Ipv6Address"] = args["Ipv6Address"],
	}
	asserts.AssertNetworkInterfaceIpv6Address(t)
	return t
end

keys.DisableVpcClassicLinkRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDisableVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkRequest[k], "DisableVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkRequest
-- <p>Contains the parameters for DisableVpcClassicLink.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return DisableVpcClassicLinkRequest structure as a key-value pair table
function M.DisableVpcClassicLinkRequest(args)
	assert(args, "You must provdide an argument table when creating DisableVpcClassicLinkRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDisableVpcClassicLinkRequest(t)
	return t
end

keys.SpotFleetRequestConfigData = { ["Type"] = true, ["FulfilledCapacity"] = true, ["TerminateInstancesWithExpiration"] = true, ["LaunchSpecifications"] = true, ["IamFleetRole"] = true, ["ValidUntil"] = true, ["ClientToken"] = true, ["TargetCapacity"] = true, ["ValidFrom"] = true, ["ExcessCapacityTerminationPolicy"] = true, ["ReplaceUnhealthyInstances"] = true, ["SpotPrice"] = true, ["AllocationStrategy"] = true, nil }

function asserts.AssertSpotFleetRequestConfigData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetRequestConfigData to be of type 'table'")
	assert(struct["IamFleetRole"], "Expected key IamFleetRole to exist in table")
	assert(struct["LaunchSpecifications"], "Expected key LaunchSpecifications to exist in table")
	assert(struct["SpotPrice"], "Expected key SpotPrice to exist in table")
	assert(struct["TargetCapacity"], "Expected key TargetCapacity to exist in table")
	if struct["Type"] then asserts.AssertFleetType(struct["Type"]) end
	if struct["FulfilledCapacity"] then asserts.AssertDouble(struct["FulfilledCapacity"]) end
	if struct["TerminateInstancesWithExpiration"] then asserts.AssertBoolean(struct["TerminateInstancesWithExpiration"]) end
	if struct["LaunchSpecifications"] then asserts.AssertLaunchSpecsList(struct["LaunchSpecifications"]) end
	if struct["IamFleetRole"] then asserts.AssertString(struct["IamFleetRole"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["TargetCapacity"] then asserts.AssertInteger(struct["TargetCapacity"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["ExcessCapacityTerminationPolicy"] then asserts.AssertExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	if struct["ReplaceUnhealthyInstances"] then asserts.AssertBoolean(struct["ReplaceUnhealthyInstances"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	if struct["AllocationStrategy"] then asserts.AssertAllocationStrategy(struct["AllocationStrategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetRequestConfigData[k], "SpotFleetRequestConfigData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetRequestConfigData
-- <p>Describes the configuration of a Spot fleet request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [FleetType] <p>The type of request. Indicates whether the fleet will only <code>request</code> the target capacity or also attempt to <code>maintain</code> it. When you <code>request</code> a certain target capacity, the fleet will only place the required bids. It will not attempt to replenish Spot instances if capacity is diminished, nor will it submit bids in alternative Spot pools if capacity is not available. When you want to <code>maintain</code> a certain target capacity, fleet will place the required bids to meet this target capacity. It will also automatically replenish any interrupted instances. Default: <code>maintain</code>.</p>
-- * FulfilledCapacity [Double] <p>The number of units fulfilled by this request compared to the set target capacity.</p>
-- * TerminateInstancesWithExpiration [Boolean] <p>Indicates whether running Spot instances should be terminated when the Spot fleet request expires.</p>
-- * LaunchSpecifications [LaunchSpecsList] <p>Information about the launch specifications for the Spot fleet request.</p>
-- * IamFleetRole [String] <p>Grants the Spot fleet permission to terminate Spot instances on your behalf when you cancel its Spot fleet request using <a>CancelSpotFleetRequests</a> or when the Spot fleet request expires, if you set <code>terminateInstancesWithExpiration</code>.</p>
-- * ValidUntil [DateTime] <p>The end date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). At this point, no new Spot instance requests are placed or enabled to fulfill the request.</p>
-- * ClientToken [String] <p>A unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * TargetCapacity [Integer] <p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O.</p>
-- * ValidFrom [DateTime] <p>The start date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The default is to start fulfilling the request immediately.</p>
-- * ExcessCapacityTerminationPolicy [ExcessCapacityTerminationPolicy] <p>Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.</p>
-- * ReplaceUnhealthyInstances [Boolean] <p>Indicates whether Spot fleet should replace unhealthy instances.</p>
-- * SpotPrice [String] <p>The bid price per unit hour.</p>
-- * AllocationStrategy [AllocationStrategy] <p>Indicates how to allocate the target capacity across the Spot pools specified by the Spot fleet request. The default is <code>lowestPrice</code>.</p>
-- Required key: IamFleetRole
-- Required key: LaunchSpecifications
-- Required key: SpotPrice
-- Required key: TargetCapacity
-- @return SpotFleetRequestConfigData structure as a key-value pair table
function M.SpotFleetRequestConfigData(args)
	assert(args, "You must provdide an argument table when creating SpotFleetRequestConfigData")
	local t = { 
		["Type"] = args["Type"],
		["FulfilledCapacity"] = args["FulfilledCapacity"],
		["TerminateInstancesWithExpiration"] = args["TerminateInstancesWithExpiration"],
		["LaunchSpecifications"] = args["LaunchSpecifications"],
		["IamFleetRole"] = args["IamFleetRole"],
		["ValidUntil"] = args["ValidUntil"],
		["ClientToken"] = args["ClientToken"],
		["TargetCapacity"] = args["TargetCapacity"],
		["ValidFrom"] = args["ValidFrom"],
		["ExcessCapacityTerminationPolicy"] = args["ExcessCapacityTerminationPolicy"],
		["ReplaceUnhealthyInstances"] = args["ReplaceUnhealthyInstances"],
		["SpotPrice"] = args["SpotPrice"],
		["AllocationStrategy"] = args["AllocationStrategy"],
	}
	asserts.AssertSpotFleetRequestConfigData(t)
	return t
end

keys.VolumeStatusItem = { ["VolumeStatus"] = true, ["AvailabilityZone"] = true, ["Events"] = true, ["Actions"] = true, ["VolumeId"] = true, nil }

function asserts.AssertVolumeStatusItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusItem to be of type 'table'")
	if struct["VolumeStatus"] then asserts.AssertVolumeStatusInfo(struct["VolumeStatus"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Events"] then asserts.AssertVolumeStatusEventsList(struct["Events"]) end
	if struct["Actions"] then asserts.AssertVolumeStatusActionsList(struct["Actions"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusItem[k], "VolumeStatusItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusItem
-- <p>Describes the volume status.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeStatus [VolumeStatusInfo] <p>The volume status.</p>
-- * AvailabilityZone [String] <p>The Availability Zone of the volume.</p>
-- * Events [VolumeStatusEventsList] <p>A list of events associated with the volume.</p>
-- * Actions [VolumeStatusActionsList] <p>The details of the operation.</p>
-- * VolumeId [String] <p>The volume ID.</p>
-- @return VolumeStatusItem structure as a key-value pair table
function M.VolumeStatusItem(args)
	assert(args, "You must provdide an argument table when creating VolumeStatusItem")
	local t = { 
		["VolumeStatus"] = args["VolumeStatus"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Events"] = args["Events"],
		["Actions"] = args["Actions"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertVolumeStatusItem(t)
	return t
end

keys.DescribeVpnGatewaysRequest = { ["DryRun"] = true, ["VpnGatewayIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpnGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnGatewaysRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayIds"] then asserts.AssertVpnGatewayIdStringList(struct["VpnGatewayIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnGatewaysRequest[k], "DescribeVpnGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnGatewaysRequest
-- <p>Contains the parameters for DescribeVpnGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnGatewayIds [VpnGatewayIdStringList] <p>One or more virtual private gateway IDs.</p> <p>Default: Describes all your virtual private gateways.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.state</code> - The current state of the attachment between the gateway and the VPC (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>attachment.vpc-id</code> - The ID of an attached VPC.</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone for the virtual private gateway (if applicable).</p> </li> <li> <p> <code>state</code> - The state of the virtual private gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>type</code> - The type of virtual private gateway. Currently the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>vpn-gateway-id</code> - The ID of the virtual private gateway.</p> </li> </ul>
-- @return DescribeVpnGatewaysRequest structure as a key-value pair table
function M.DescribeVpnGatewaysRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVpnGatewaysRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["VpnGatewayIds"] = args["VpnGatewayIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpnGatewaysRequest(t)
	return t
end

keys.DescribeVpcAttributeResult = { ["EnableDnsSupport"] = true, ["VpcId"] = true, ["EnableDnsHostnames"] = true, nil }

function asserts.AssertDescribeVpcAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcAttributeResult to be of type 'table'")
	if struct["EnableDnsSupport"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsSupport"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["EnableDnsHostnames"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsHostnames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcAttributeResult[k], "DescribeVpcAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcAttributeResult
-- <p>Contains the output of DescribeVpcAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EnableDnsSupport [AttributeBooleanValue] <p>Indicates whether DNS resolution is enabled for the VPC. If this attribute is <code>true</code>, the Amazon DNS server resolves DNS hostnames for your instances to their corresponding IP addresses; otherwise, it does not.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * EnableDnsHostnames [AttributeBooleanValue] <p>Indicates whether the instances launched in the VPC get DNS hostnames. If this attribute is <code>true</code>, instances in the VPC get DNS hostnames; otherwise, they do not.</p>
-- @return DescribeVpcAttributeResult structure as a key-value pair table
function M.DescribeVpcAttributeResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcAttributeResult")
	local t = { 
		["EnableDnsSupport"] = args["EnableDnsSupport"],
		["VpcId"] = args["VpcId"],
		["EnableDnsHostnames"] = args["EnableDnsHostnames"],
	}
	asserts.AssertDescribeVpcAttributeResult(t)
	return t
end

keys.InstanceNetworkInterface = { ["Status"] = true, ["MacAddress"] = true, ["SourceDestCheck"] = true, ["VpcId"] = true, ["Description"] = true, ["NetworkInterfaceId"] = true, ["PrivateIpAddresses"] = true, ["PrivateDnsName"] = true, ["Attachment"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["OwnerId"] = true, ["PrivateIpAddress"] = true, ["SubnetId"] = true, ["Association"] = true, nil }

function asserts.AssertInstanceNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterface to be of type 'table'")
	if struct["Status"] then asserts.AssertNetworkInterfaceStatus(struct["Status"]) end
	if struct["MacAddress"] then asserts.AssertString(struct["MacAddress"]) end
	if struct["SourceDestCheck"] then asserts.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertInstancePrivateIpAddressList(struct["PrivateIpAddresses"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["Attachment"] then asserts.AssertInstanceNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Association"] then asserts.AssertInstanceNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterface[k], "InstanceNetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterface
-- <p>Describes a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [NetworkInterfaceStatus] <p>The status of the network interface.</p>
-- * MacAddress [String] <p>The MAC address.</p>
-- * SourceDestCheck [Boolean] <p>Indicates whether to validate network traffic to or from this network interface.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * Description [String] <p>The description.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * PrivateIpAddresses [InstancePrivateIpAddressList] <p>One or more private IPv4 addresses associated with the network interface.</p>
-- * PrivateDnsName [String] <p>The private DNS name.</p>
-- * Attachment [InstanceNetworkInterfaceAttachment] <p>The network interface attachment.</p>
-- * Groups [GroupIdentifierList] <p>One or more security groups.</p>
-- * Ipv6Addresses [InstanceIpv6AddressList] <p>One or more IPv6 addresses associated with the network interface.</p>
-- * OwnerId [String] <p>The ID of the AWS account that created the network interface.</p>
-- * PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * Association [InstanceNetworkInterfaceAssociation] <p>The association information for an Elastic IPv4 associated with the network interface.</p>
-- @return InstanceNetworkInterface structure as a key-value pair table
function M.InstanceNetworkInterface(args)
	assert(args, "You must provdide an argument table when creating InstanceNetworkInterface")
	local t = { 
		["Status"] = args["Status"],
		["MacAddress"] = args["MacAddress"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["VpcId"] = args["VpcId"],
		["Description"] = args["Description"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["PrivateDnsName"] = args["PrivateDnsName"],
		["Attachment"] = args["Attachment"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["OwnerId"] = args["OwnerId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["SubnetId"] = args["SubnetId"],
		["Association"] = args["Association"],
	}
	asserts.AssertInstanceNetworkInterface(t)
	return t
end

keys.DescribeExportTasksRequest = { ["ExportTaskIds"] = true, nil }

function asserts.AssertDescribeExportTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeExportTasksRequest to be of type 'table'")
	if struct["ExportTaskIds"] then asserts.AssertExportTaskIdStringList(struct["ExportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeExportTasksRequest[k], "DescribeExportTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeExportTasksRequest
-- <p>Contains the parameters for DescribeExportTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExportTaskIds [ExportTaskIdStringList] <p>One or more export task IDs.</p>
-- @return DescribeExportTasksRequest structure as a key-value pair table
function M.DescribeExportTasksRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeExportTasksRequest")
	local t = { 
		["ExportTaskIds"] = args["ExportTaskIds"],
	}
	asserts.AssertDescribeExportTasksRequest(t)
	return t
end

keys.CreateKeyPairRequest = { ["KeyName"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateKeyPairRequest[k], "CreateKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateKeyPairRequest
-- <p>Contains the parameters for CreateKeyPair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyName [String] <p>A unique name for the key pair.</p> <p>Constraints: Up to 255 ASCII characters</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: KeyName
-- @return CreateKeyPairRequest structure as a key-value pair table
function M.CreateKeyPairRequest(args)
	assert(args, "You must provdide an argument table when creating CreateKeyPairRequest")
	local t = { 
		["KeyName"] = args["KeyName"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateKeyPairRequest(t)
	return t
end

keys.DeleteVolumeRequest = { ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDeleteVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVolumeRequest[k], "DeleteVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVolumeRequest
-- <p>Contains the parameters for DeleteVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: VolumeId
-- @return DeleteVolumeRequest structure as a key-value pair table
function M.DeleteVolumeRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteVolumeRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertDeleteVolumeRequest(t)
	return t
end

keys.PurchaseScheduledInstancesRequest = { ["PurchaseRequests"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertPurchaseScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseScheduledInstancesRequest to be of type 'table'")
	assert(struct["PurchaseRequests"], "Expected key PurchaseRequests to exist in table")
	if struct["PurchaseRequests"] then asserts.AssertPurchaseRequestSet(struct["PurchaseRequests"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseScheduledInstancesRequest[k], "PurchaseScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseScheduledInstancesRequest
-- <p>Contains the parameters for PurchaseScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PurchaseRequests [PurchaseRequestSet] <p>One or more purchase requests.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: PurchaseRequests
-- @return PurchaseScheduledInstancesRequest structure as a key-value pair table
function M.PurchaseScheduledInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating PurchaseScheduledInstancesRequest")
	local t = { 
		["PurchaseRequests"] = args["PurchaseRequests"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertPurchaseScheduledInstancesRequest(t)
	return t
end

keys.DescribeImportSnapshotTasksRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["ImportTaskIds"] = true, nil }

function asserts.AssertDescribeImportSnapshotTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportSnapshotTasksRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ImportTaskIds"] then asserts.AssertImportTaskIdList(struct["ImportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportSnapshotTasksRequest[k], "DescribeImportSnapshotTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportSnapshotTasksRequest
-- <p>Contains the parameters for DescribeImportSnapshotTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>A token that indicates the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * Filters [FilterList] <p>One or more filters.</p>
-- * ImportTaskIds [ImportTaskIdList] <p>A list of import snapshot task IDs.</p>
-- @return DescribeImportSnapshotTasksRequest structure as a key-value pair table
function M.DescribeImportSnapshotTasksRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeImportSnapshotTasksRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["ImportTaskIds"] = args["ImportTaskIds"],
	}
	asserts.AssertDescribeImportSnapshotTasksRequest(t)
	return t
end

keys.CreateEgressOnlyInternetGatewayResult = { ["EgressOnlyInternetGateway"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateEgressOnlyInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateEgressOnlyInternetGatewayResult to be of type 'table'")
	if struct["EgressOnlyInternetGateway"] then asserts.AssertEgressOnlyInternetGateway(struct["EgressOnlyInternetGateway"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateEgressOnlyInternetGatewayResult[k], "CreateEgressOnlyInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateEgressOnlyInternetGatewayResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EgressOnlyInternetGateway [EgressOnlyInternetGateway] <p>Information about the egress-only Internet gateway.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
-- @return CreateEgressOnlyInternetGatewayResult structure as a key-value pair table
function M.CreateEgressOnlyInternetGatewayResult(args)
	assert(args, "You must provdide an argument table when creating CreateEgressOnlyInternetGatewayResult")
	local t = { 
		["EgressOnlyInternetGateway"] = args["EgressOnlyInternetGateway"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateEgressOnlyInternetGatewayResult(t)
	return t
end

keys.DescribeClassicLinkInstancesResult = { ["Instances"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeClassicLinkInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeClassicLinkInstancesResult to be of type 'table'")
	if struct["Instances"] then asserts.AssertClassicLinkInstanceList(struct["Instances"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeClassicLinkInstancesResult[k], "DescribeClassicLinkInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeClassicLinkInstancesResult
-- <p>Contains the output of DescribeClassicLinkInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Instances [ClassicLinkInstanceList] <p>Information about one or more linked EC2-Classic instances.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeClassicLinkInstancesResult structure as a key-value pair table
function M.DescribeClassicLinkInstancesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeClassicLinkInstancesResult")
	local t = { 
		["Instances"] = args["Instances"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeClassicLinkInstancesResult(t)
	return t
end

keys.CopyImageRequest = { ["SourceRegion"] = true, ["DryRun"] = true, ["Name"] = true, ["Encrypted"] = true, ["SourceImageId"] = true, ["KmsKeyId"] = true, ["ClientToken"] = true, ["Description"] = true, nil }

function asserts.AssertCopyImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyImageRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["SourceImageId"], "Expected key SourceImageId to exist in table")
	assert(struct["SourceRegion"], "Expected key SourceRegion to exist in table")
	if struct["SourceRegion"] then asserts.AssertString(struct["SourceRegion"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["SourceImageId"] then asserts.AssertString(struct["SourceImageId"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopyImageRequest[k], "CopyImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyImageRequest
-- <p>Contains the parameters for CopyImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SourceRegion [String] <p>The name of the region that contains the AMI to copy.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Name [String] <p>The name of the new AMI in the destination region.</p>
-- * Encrypted [Boolean] <p>Specifies whether the destination snapshots of the copied image should be encrypted. The default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with <code>KmsKeyId</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * SourceImageId [String] <p>The ID of the AMI to copy.</p>
-- * KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when encrypting the snapshots of an image during a copy operation. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. The specified CMK must exist in the region that the snapshot is being copied to. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * Description [String] <p>A description for the new AMI in the destination region.</p>
-- Required key: Name
-- Required key: SourceImageId
-- Required key: SourceRegion
-- @return CopyImageRequest structure as a key-value pair table
function M.CopyImageRequest(args)
	assert(args, "You must provdide an argument table when creating CopyImageRequest")
	local t = { 
		["SourceRegion"] = args["SourceRegion"],
		["DryRun"] = args["DryRun"],
		["Name"] = args["Name"],
		["Encrypted"] = args["Encrypted"],
		["SourceImageId"] = args["SourceImageId"],
		["KmsKeyId"] = args["KmsKeyId"],
		["ClientToken"] = args["ClientToken"],
		["Description"] = args["Description"],
	}
	asserts.AssertCopyImageRequest(t)
	return t
end

keys.CreateNetworkAclRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateNetworkAclRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkAclRequest[k], "CreateNetworkAclRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclRequest
-- <p>Contains the parameters for CreateNetworkAcl.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return CreateNetworkAclRequest structure as a key-value pair table
function M.CreateNetworkAclRequest(args)
	assert(args, "You must provdide an argument table when creating CreateNetworkAclRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateNetworkAclRequest(t)
	return t
end

keys.DisassociateRouteTableRequest = { ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDisassociateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateRouteTableRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateRouteTableRequest[k], "DisassociateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateRouteTableRequest
-- <p>Contains the parameters for DisassociateRouteTable.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The association ID representing the current association between the route table and subnet.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: AssociationId
-- @return DisassociateRouteTableRequest structure as a key-value pair table
function M.DisassociateRouteTableRequest(args)
	assert(args, "You must provdide an argument table when creating DisassociateRouteTableRequest")
	local t = { 
		["AssociationId"] = args["AssociationId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDisassociateRouteTableRequest(t)
	return t
end

keys.DescribeAddressesRequest = { ["PublicIps"] = true, ["DryRun"] = true, ["AllocationIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAddressesRequest to be of type 'table'")
	if struct["PublicIps"] then asserts.AssertPublicIpStringList(struct["PublicIps"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AllocationIds"] then asserts.AssertAllocationIdList(struct["AllocationIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAddressesRequest[k], "DescribeAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAddressesRequest
-- <p>Contains the parameters for DescribeAddresses.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIps [PublicIpStringList] <p>[EC2-Classic] One or more Elastic IP addresses.</p> <p>Default: Describes all your Elastic IP addresses.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AllocationIds [AllocationIdList] <p>[EC2-VPC] One or more allocation IDs.</p> <p>Default: Describes all your Elastic IP addresses.</p>
-- * Filters [FilterList] <p>One or more filters. Filter names and values are case-sensitive.</p> <ul> <li> <p> <code>allocation-id</code> - [EC2-VPC] The allocation ID for the address.</p> </li> <li> <p> <code>association-id</code> - [EC2-VPC] The association ID for the address.</p> </li> <li> <p> <code>domain</code> - Indicates whether the address is for use in EC2-Classic (<code>standard</code>) or in a VPC (<code>vpc</code>).</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance the address is associated with, if any.</p> </li> <li> <p> <code>network-interface-id</code> - [EC2-VPC] The ID of the network interface that the address is associated with, if any.</p> </li> <li> <p> <code>network-interface-owner-id</code> - The AWS account ID of the owner.</p> </li> <li> <p> <code>private-ip-address</code> - [EC2-VPC] The private IP address associated with the Elastic IP address.</p> </li> <li> <p> <code>public-ip</code> - The Elastic IP address.</p> </li> </ul>
-- @return DescribeAddressesRequest structure as a key-value pair table
function M.DescribeAddressesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeAddressesRequest")
	local t = { 
		["PublicIps"] = args["PublicIps"],
		["DryRun"] = args["DryRun"],
		["AllocationIds"] = args["AllocationIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeAddressesRequest(t)
	return t
end

keys.AllocateAddressResult = { ["PublicIp"] = true, ["Domain"] = true, ["AllocationId"] = true, nil }

function asserts.AssertAllocateAddressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateAddressResult to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["Domain"] then asserts.AssertDomainType(struct["Domain"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateAddressResult[k], "AllocateAddressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateAddressResult
-- <p>Contains the output of AllocateAddress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * Domain [DomainType] <p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
-- * AllocationId [String] <p>[EC2-VPC] The ID that AWS assigns to represent the allocation of the Elastic IP address for use with instances in a VPC.</p>
-- @return AllocateAddressResult structure as a key-value pair table
function M.AllocateAddressResult(args)
	assert(args, "You must provdide an argument table when creating AllocateAddressResult")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["Domain"] = args["Domain"],
		["AllocationId"] = args["AllocationId"],
	}
	asserts.AssertAllocateAddressResult(t)
	return t
end

keys.FpgaImageState = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertFpgaImageState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FpgaImageState to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertFpgaImageStateCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.FpgaImageState[k], "FpgaImageState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FpgaImageState
-- <p>Describes the state of the bitstream generation process for an Amazon FPGA image (AFI).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>If the state is <code>failed</code>, this is the error message.</p>
-- * Code [FpgaImageStateCode] <p>The state. The following are the possible values:</p> <ul> <li> <p> <code>pending</code> - AFI bitstream generation is in progress.</p> </li> <li> <p> <code>available</code> - The AFI is available for use.</p> </li> <li> <p> <code>failed</code> - AFI bitstream generation failed.</p> </li> <li> <p> <code>unavailable</code> - The AFI is no longer available for use.</p> </li> </ul>
-- @return FpgaImageState structure as a key-value pair table
function M.FpgaImageState(args)
	assert(args, "You must provdide an argument table when creating FpgaImageState")
	local t = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertFpgaImageState(t)
	return t
end

keys.DescribeNetworkInterfaceAttributeRequest = { ["Attribute"] = true, ["NetworkInterfaceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Attribute"] then asserts.AssertNetworkInterfaceAttribute(struct["Attribute"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfaceAttributeRequest[k], "DescribeNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for DescribeNetworkInterfaceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [NetworkInterfaceAttribute] <p>The attribute of the network interface. This parameter is required.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: NetworkInterfaceId
-- @return DescribeNetworkInterfaceAttributeRequest structure as a key-value pair table
function M.DescribeNetworkInterfaceAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeNetworkInterfaceAttributeRequest")
	local t = { 
		["Attribute"] = args["Attribute"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeNetworkInterfaceAttributeRequest(t)
	return t
end

keys.DescribeSpotDatafeedSubscriptionRequest = { ["DryRun"] = true, nil }

function asserts.AssertDescribeSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotDatafeedSubscriptionRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotDatafeedSubscriptionRequest[k], "DescribeSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for DescribeSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DescribeSpotDatafeedSubscriptionRequest structure as a key-value pair table
function M.DescribeSpotDatafeedSubscriptionRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotDatafeedSubscriptionRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeSpotDatafeedSubscriptionRequest(t)
	return t
end

keys.ReplaceNetworkAclAssociationRequest = { ["NetworkAclId"] = true, ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertReplaceNetworkAclAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclAssociationRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceNetworkAclAssociationRequest[k], "ReplaceNetworkAclAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclAssociationRequest
-- <p>Contains the parameters for ReplaceNetworkAclAssociation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAclId [String] <p>The ID of the new network ACL to associate with the subnet.</p>
-- * AssociationId [String] <p>The ID of the current association between the original network ACL and the subnet.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: AssociationId
-- Required key: NetworkAclId
-- @return ReplaceNetworkAclAssociationRequest structure as a key-value pair table
function M.ReplaceNetworkAclAssociationRequest(args)
	assert(args, "You must provdide an argument table when creating ReplaceNetworkAclAssociationRequest")
	local t = { 
		["NetworkAclId"] = args["NetworkAclId"],
		["AssociationId"] = args["AssociationId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertReplaceNetworkAclAssociationRequest(t)
	return t
end

keys.DeleteNetworkAclEntryRequest = { ["NetworkAclId"] = true, ["Egress"] = true, ["DryRun"] = true, ["RuleNumber"] = true, nil }

function asserts.AssertDeleteNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkAclEntryRequest[k], "DeleteNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkAclEntryRequest
-- <p>Contains the parameters for DeleteNetworkAclEntry.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * Egress [Boolean] <p>Indicates whether the rule is an egress rule.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * RuleNumber [Integer] <p>The rule number of the entry to delete.</p>
-- Required key: Egress
-- Required key: NetworkAclId
-- Required key: RuleNumber
-- @return DeleteNetworkAclEntryRequest structure as a key-value pair table
function M.DeleteNetworkAclEntryRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteNetworkAclEntryRequest")
	local t = { 
		["NetworkAclId"] = args["NetworkAclId"],
		["Egress"] = args["Egress"],
		["DryRun"] = args["DryRun"],
		["RuleNumber"] = args["RuleNumber"],
	}
	asserts.AssertDeleteNetworkAclEntryRequest(t)
	return t
end

keys.DeleteSpotDatafeedSubscriptionRequest = { ["DryRun"] = true, nil }

function asserts.AssertDeleteSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSpotDatafeedSubscriptionRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSpotDatafeedSubscriptionRequest[k], "DeleteSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for DeleteSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DeleteSpotDatafeedSubscriptionRequest structure as a key-value pair table
function M.DeleteSpotDatafeedSubscriptionRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteSpotDatafeedSubscriptionRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteSpotDatafeedSubscriptionRequest(t)
	return t
end

keys.DescribeBundleTasksResult = { ["BundleTasks"] = true, nil }

function asserts.AssertDescribeBundleTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeBundleTasksResult to be of type 'table'")
	if struct["BundleTasks"] then asserts.AssertBundleTaskList(struct["BundleTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeBundleTasksResult[k], "DescribeBundleTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeBundleTasksResult
-- <p>Contains the output of DescribeBundleTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BundleTasks [BundleTaskList] <p>Information about one or more bundle tasks.</p>
-- @return DescribeBundleTasksResult structure as a key-value pair table
function M.DescribeBundleTasksResult(args)
	assert(args, "You must provdide an argument table when creating DescribeBundleTasksResult")
	local t = { 
		["BundleTasks"] = args["BundleTasks"],
	}
	asserts.AssertDescribeBundleTasksResult(t)
	return t
end

keys.ReplaceIamInstanceProfileAssociationRequest = { ["AssociationId"] = true, ["IamInstanceProfile"] = true, nil }

function asserts.AssertReplaceIamInstanceProfileAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceIamInstanceProfileAssociationRequest to be of type 'table'")
	assert(struct["IamInstanceProfile"], "Expected key IamInstanceProfile to exist in table")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceIamInstanceProfileAssociationRequest[k], "ReplaceIamInstanceProfileAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceIamInstanceProfileAssociationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The ID of the existing IAM instance profile association.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- Required key: IamInstanceProfile
-- Required key: AssociationId
-- @return ReplaceIamInstanceProfileAssociationRequest structure as a key-value pair table
function M.ReplaceIamInstanceProfileAssociationRequest(args)
	assert(args, "You must provdide an argument table when creating ReplaceIamInstanceProfileAssociationRequest")
	local t = { 
		["AssociationId"] = args["AssociationId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
	}
	asserts.AssertReplaceIamInstanceProfileAssociationRequest(t)
	return t
end

keys.PurchaseHostReservationResult = { ["TotalHourlyPrice"] = true, ["Purchase"] = true, ["CurrencyCode"] = true, ["TotalUpfrontPrice"] = true, ["ClientToken"] = true, nil }

function asserts.AssertPurchaseHostReservationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseHostReservationResult to be of type 'table'")
	if struct["TotalHourlyPrice"] then asserts.AssertString(struct["TotalHourlyPrice"]) end
	if struct["Purchase"] then asserts.AssertPurchaseSet(struct["Purchase"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["TotalUpfrontPrice"] then asserts.AssertString(struct["TotalUpfrontPrice"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseHostReservationResult[k], "PurchaseHostReservationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseHostReservationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TotalHourlyPrice [String] <p>The total hourly price of the reservation calculated per hour.</p>
-- * Purchase [PurchaseSet] <p>Describes the details of the purchase.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * TotalUpfrontPrice [String] <p>The total amount that will be charged to your account when you purchase the reservation.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i> </p>
-- @return PurchaseHostReservationResult structure as a key-value pair table
function M.PurchaseHostReservationResult(args)
	assert(args, "You must provdide an argument table when creating PurchaseHostReservationResult")
	local t = { 
		["TotalHourlyPrice"] = args["TotalHourlyPrice"],
		["Purchase"] = args["Purchase"],
		["CurrencyCode"] = args["CurrencyCode"],
		["TotalUpfrontPrice"] = args["TotalUpfrontPrice"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertPurchaseHostReservationResult(t)
	return t
end

keys.ModifyVolumeAttributeRequest = { ["AutoEnableIO"] = true, ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertModifyVolumeAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeAttributeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["AutoEnableIO"] then asserts.AssertAttributeBooleanValue(struct["AutoEnableIO"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVolumeAttributeRequest[k], "ModifyVolumeAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeAttributeRequest
-- <p>Contains the parameters for ModifyVolumeAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutoEnableIO [AttributeBooleanValue] <p>Indicates whether the volume should be auto-enabled for I/O operations.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: VolumeId
-- @return ModifyVolumeAttributeRequest structure as a key-value pair table
function M.ModifyVolumeAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyVolumeAttributeRequest")
	local t = { 
		["AutoEnableIO"] = args["AutoEnableIO"],
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertModifyVolumeAttributeRequest(t)
	return t
end

keys.CreateRouteResult = { ["Return"] = true, nil }

function asserts.AssertCreateRouteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteResult[k], "CreateRouteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteResult
-- <p>Contains the output of CreateRoute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return CreateRouteResult structure as a key-value pair table
function M.CreateRouteResult(args)
	assert(args, "You must provdide an argument table when creating CreateRouteResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertCreateRouteResult(t)
	return t
end

keys.ImportInstanceLaunchSpecification = { ["AdditionalInfo"] = true, ["Monitoring"] = true, ["UserData"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["GroupNames"] = true, ["Architecture"] = true, ["SubnetId"] = true, ["Placement"] = true, ["InstanceType"] = true, ["PrivateIpAddress"] = true, ["GroupIds"] = true, nil }

function asserts.AssertImportInstanceLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceLaunchSpecification to be of type 'table'")
	if struct["AdditionalInfo"] then asserts.AssertString(struct["AdditionalInfo"]) end
	if struct["Monitoring"] then asserts.AssertBoolean(struct["Monitoring"]) end
	if struct["UserData"] then asserts.AssertUserData(struct["UserData"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["GroupNames"] then asserts.AssertSecurityGroupStringList(struct["GroupNames"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Placement"] then asserts.AssertPlacement(struct["Placement"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["GroupIds"] then asserts.AssertSecurityGroupIdStringList(struct["GroupIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceLaunchSpecification[k], "ImportInstanceLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceLaunchSpecification
-- <p>Describes the launch specification for VM import.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AdditionalInfo [String] <p>Reserved.</p>
-- * Monitoring [Boolean] <p>Indicates whether monitoring is enabled.</p>
-- * UserData [UserData] <p>The user data to make available to the instance. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- * InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- * GroupNames [SecurityGroupStringList] <p>One or more security group names.</p>
-- * Architecture [ArchitectureValues] <p>The architecture of the instance.</p>
-- * SubnetId [String] <p>[EC2-VPC] The ID of the subnet in which to launch the instance.</p>
-- * Placement [Placement] <p>The placement information for the instance.</p>
-- * InstanceType [InstanceType] <p>The instance type. For more information about the instance types that you can import, see <a href="http://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html#vmimport-instance-types">Instance Types</a> in the VM Import/Export User Guide.</p>
-- * PrivateIpAddress [String] <p>[EC2-VPC] An available IP address from the IP address range of the subnet.</p>
-- * GroupIds [SecurityGroupIdStringList] <p>One or more security group IDs.</p>
-- @return ImportInstanceLaunchSpecification structure as a key-value pair table
function M.ImportInstanceLaunchSpecification(args)
	assert(args, "You must provdide an argument table when creating ImportInstanceLaunchSpecification")
	local t = { 
		["AdditionalInfo"] = args["AdditionalInfo"],
		["Monitoring"] = args["Monitoring"],
		["UserData"] = args["UserData"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["GroupNames"] = args["GroupNames"],
		["Architecture"] = args["Architecture"],
		["SubnetId"] = args["SubnetId"],
		["Placement"] = args["Placement"],
		["InstanceType"] = args["InstanceType"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["GroupIds"] = args["GroupIds"],
	}
	asserts.AssertImportInstanceLaunchSpecification(t)
	return t
end

keys.CreateDhcpOptionsRequest = { ["DryRun"] = true, ["DhcpConfigurations"] = true, nil }

function asserts.AssertCreateDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpConfigurations"], "Expected key DhcpConfigurations to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpConfigurations"] then asserts.AssertNewDhcpConfigurationList(struct["DhcpConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDhcpOptionsRequest[k], "CreateDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDhcpOptionsRequest
-- <p>Contains the parameters for CreateDhcpOptions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * DhcpConfigurations [NewDhcpConfigurationList] <p>A DHCP configuration option.</p>
-- Required key: DhcpConfigurations
-- @return CreateDhcpOptionsRequest structure as a key-value pair table
function M.CreateDhcpOptionsRequest(args)
	assert(args, "You must provdide an argument table when creating CreateDhcpOptionsRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["DhcpConfigurations"] = args["DhcpConfigurations"],
	}
	asserts.AssertCreateDhcpOptionsRequest(t)
	return t
end

keys.DisassociateVpcCidrBlockResult = { ["Ipv6CidrBlockAssociation"] = true, ["VpcId"] = true, nil }

function asserts.AssertDisassociateVpcCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateVpcCidrBlockResult to be of type 'table'")
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertVpcIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateVpcCidrBlockResult[k], "DisassociateVpcCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateVpcCidrBlockResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlockAssociation [VpcIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return DisassociateVpcCidrBlockResult structure as a key-value pair table
function M.DisassociateVpcCidrBlockResult(args)
	assert(args, "You must provdide an argument table when creating DisassociateVpcCidrBlockResult")
	local t = { 
		["Ipv6CidrBlockAssociation"] = args["Ipv6CidrBlockAssociation"],
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertDisassociateVpcCidrBlockResult(t)
	return t
end

keys.DeleteVpnConnectionRequest = { ["VpnConnectionId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpnConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnConnectionRequest to be of type 'table'")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpnConnectionRequest[k], "DeleteVpnConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnConnectionRequest
-- <p>Contains the parameters for DeleteVpnConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpnConnectionId
-- @return DeleteVpnConnectionRequest structure as a key-value pair table
function M.DeleteVpnConnectionRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteVpnConnectionRequest")
	local t = { 
		["VpnConnectionId"] = args["VpnConnectionId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteVpnConnectionRequest(t)
	return t
end

keys.CreateVpnGatewayResult = { ["VpnGateway"] = true, nil }

function asserts.AssertCreateVpnGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnGatewayResult to be of type 'table'")
	if struct["VpnGateway"] then asserts.AssertVpnGateway(struct["VpnGateway"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnGatewayResult[k], "CreateVpnGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnGatewayResult
-- <p>Contains the output of CreateVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnGateway [VpnGateway] <p>Information about the virtual private gateway.</p>
-- @return CreateVpnGatewayResult structure as a key-value pair table
function M.CreateVpnGatewayResult(args)
	assert(args, "You must provdide an argument table when creating CreateVpnGatewayResult")
	local t = { 
		["VpnGateway"] = args["VpnGateway"],
	}
	asserts.AssertCreateVpnGatewayResult(t)
	return t
end

keys.ModifyIdentityIdFormatRequest = { ["UseLongIds"] = true, ["PrincipalArn"] = true, ["Resource"] = true, nil }

function asserts.AssertModifyIdentityIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyIdentityIdFormatRequest to be of type 'table'")
	assert(struct["PrincipalArn"], "Expected key PrincipalArn to exist in table")
	assert(struct["Resource"], "Expected key Resource to exist in table")
	assert(struct["UseLongIds"], "Expected key UseLongIds to exist in table")
	if struct["UseLongIds"] then asserts.AssertBoolean(struct["UseLongIds"]) end
	if struct["PrincipalArn"] then asserts.AssertString(struct["PrincipalArn"]) end
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyIdentityIdFormatRequest[k], "ModifyIdentityIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyIdentityIdFormatRequest
-- <p>Contains the parameters of ModifyIdentityIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UseLongIds [Boolean] <p>Indicates whether the resource should use longer IDs (17-character IDs)</p>
-- * PrincipalArn [String] <p>The ARN of the principal, which can be an IAM user, IAM role, or the root user. Specify <code>all</code> to modify the ID format for all IAM users, IAM roles, and the root user of the account.</p>
-- * Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- Required key: PrincipalArn
-- Required key: Resource
-- Required key: UseLongIds
-- @return ModifyIdentityIdFormatRequest structure as a key-value pair table
function M.ModifyIdentityIdFormatRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyIdentityIdFormatRequest")
	local t = { 
		["UseLongIds"] = args["UseLongIds"],
		["PrincipalArn"] = args["PrincipalArn"],
		["Resource"] = args["Resource"],
	}
	asserts.AssertModifyIdentityIdFormatRequest(t)
	return t
end

keys.AttachVolumeRequest = { ["Device"] = true, ["InstanceId"] = true, ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertAttachVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVolumeRequest to be of type 'table'")
	assert(struct["Device"], "Expected key Device to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Device"] then asserts.AssertString(struct["Device"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachVolumeRequest[k], "AttachVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVolumeRequest
-- <p>Contains the parameters for AttachVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Device [String] <p>The device name to expose to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the EBS volume. The volume and instance must be within the same Availability Zone.</p>
-- Required key: Device
-- Required key: InstanceId
-- Required key: VolumeId
-- @return AttachVolumeRequest structure as a key-value pair table
function M.AttachVolumeRequest(args)
	assert(args, "You must provdide an argument table when creating AttachVolumeRequest")
	local t = { 
		["Device"] = args["Device"],
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertAttachVolumeRequest(t)
	return t
end

keys.SnapshotDiskContainer = { ["Url"] = true, ["UserBucket"] = true, ["Description"] = true, ["Format"] = true, nil }

function asserts.AssertSnapshotDiskContainer(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotDiskContainer to be of type 'table'")
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["UserBucket"] then asserts.AssertUserBucket(struct["UserBucket"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnapshotDiskContainer[k], "SnapshotDiskContainer contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotDiskContainer
-- <p>The disk container object for the import snapshot request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Url [String] <p>The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..).</p>
-- * UserBucket [UserBucket] <p>The S3 bucket for the disk image.</p>
-- * Description [String] <p>The description of the disk image being imported.</p>
-- * Format [String] <p>The format of the disk image being imported.</p> <p>Valid values: <code>RAW</code> | <code>VHD</code> | <code>VMDK</code> | <code>OVA</code> </p>
-- @return SnapshotDiskContainer structure as a key-value pair table
function M.SnapshotDiskContainer(args)
	assert(args, "You must provdide an argument table when creating SnapshotDiskContainer")
	local t = { 
		["Url"] = args["Url"],
		["UserBucket"] = args["UserBucket"],
		["Description"] = args["Description"],
		["Format"] = args["Format"],
	}
	asserts.AssertSnapshotDiskContainer(t)
	return t
end

keys.InstanceStatusEvent = { ["Code"] = true, ["Description"] = true, ["NotBefore"] = true, ["NotAfter"] = true, nil }

function asserts.AssertInstanceStatusEvent(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusEvent to be of type 'table'")
	if struct["Code"] then asserts.AssertEventCode(struct["Code"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NotBefore"] then asserts.AssertDateTime(struct["NotBefore"]) end
	if struct["NotAfter"] then asserts.AssertDateTime(struct["NotAfter"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatusEvent[k], "InstanceStatusEvent contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusEvent
-- <p>Describes a scheduled event for an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Code [EventCode] <p>The event code.</p>
-- * Description [String] <p>A description of the event.</p> <p>After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].</p>
-- * NotBefore [DateTime] <p>The earliest scheduled start time for the event.</p>
-- * NotAfter [DateTime] <p>The latest scheduled end time for the event.</p>
-- @return InstanceStatusEvent structure as a key-value pair table
function M.InstanceStatusEvent(args)
	assert(args, "You must provdide an argument table when creating InstanceStatusEvent")
	local t = { 
		["Code"] = args["Code"],
		["Description"] = args["Description"],
		["NotBefore"] = args["NotBefore"],
		["NotAfter"] = args["NotAfter"],
	}
	asserts.AssertInstanceStatusEvent(t)
	return t
end

keys.BundleTask = { ["UpdateTime"] = true, ["InstanceId"] = true, ["Storage"] = true, ["BundleTaskError"] = true, ["State"] = true, ["StartTime"] = true, ["Progress"] = true, ["BundleId"] = true, nil }

function asserts.AssertBundleTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleTask to be of type 'table'")
	if struct["UpdateTime"] then asserts.AssertDateTime(struct["UpdateTime"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Storage"] then asserts.AssertStorage(struct["Storage"]) end
	if struct["BundleTaskError"] then asserts.AssertBundleTaskError(struct["BundleTaskError"]) end
	if struct["State"] then asserts.AssertBundleTaskState(struct["State"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["BundleId"] then asserts.AssertString(struct["BundleId"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleTask[k], "BundleTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleTask
-- <p>Describes a bundle task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UpdateTime [DateTime] <p>The time of the most recent update for the task.</p>
-- * InstanceId [String] <p>The ID of the instance associated with this bundle task.</p>
-- * Storage [Storage] <p>The Amazon S3 storage locations.</p>
-- * BundleTaskError [BundleTaskError] <p>If the task fails, a description of the error.</p>
-- * State [BundleTaskState] <p>The state of the task.</p>
-- * StartTime [DateTime] <p>The time this task started.</p>
-- * Progress [String] <p>The level of task completion, as a percent (for example, 20%).</p>
-- * BundleId [String] <p>The ID of the bundle task.</p>
-- @return BundleTask structure as a key-value pair table
function M.BundleTask(args)
	assert(args, "You must provdide an argument table when creating BundleTask")
	local t = { 
		["UpdateTime"] = args["UpdateTime"],
		["InstanceId"] = args["InstanceId"],
		["Storage"] = args["Storage"],
		["BundleTaskError"] = args["BundleTaskError"],
		["State"] = args["State"],
		["StartTime"] = args["StartTime"],
		["Progress"] = args["Progress"],
		["BundleId"] = args["BundleId"],
	}
	asserts.AssertBundleTask(t)
	return t
end

keys.VpcPeeringConnectionVpcInfo = { ["PeeringOptions"] = true, ["Ipv6CidrBlockSet"] = true, ["VpcId"] = true, ["CidrBlock"] = true, ["OwnerId"] = true, nil }

function asserts.AssertVpcPeeringConnectionVpcInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionVpcInfo to be of type 'table'")
	if struct["PeeringOptions"] then asserts.AssertVpcPeeringConnectionOptionsDescription(struct["PeeringOptions"]) end
	if struct["Ipv6CidrBlockSet"] then asserts.AssertIpv6CidrBlockSet(struct["Ipv6CidrBlockSet"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnectionVpcInfo[k], "VpcPeeringConnectionVpcInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionVpcInfo
-- <p>Describes a VPC in a VPC peering connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PeeringOptions [VpcPeeringConnectionOptionsDescription] <p>Information about the VPC peering connection options for the accepter or requester VPC.</p>
-- * Ipv6CidrBlockSet [Ipv6CidrBlockSet] <p>The IPv6 CIDR block for the VPC.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * CidrBlock [String] <p>The IPv4 CIDR block for the VPC.</p>
-- * OwnerId [String] <p>The AWS account ID of the VPC owner.</p>
-- @return VpcPeeringConnectionVpcInfo structure as a key-value pair table
function M.VpcPeeringConnectionVpcInfo(args)
	assert(args, "You must provdide an argument table when creating VpcPeeringConnectionVpcInfo")
	local t = { 
		["PeeringOptions"] = args["PeeringOptions"],
		["Ipv6CidrBlockSet"] = args["Ipv6CidrBlockSet"],
		["VpcId"] = args["VpcId"],
		["CidrBlock"] = args["CidrBlock"],
		["OwnerId"] = args["OwnerId"],
	}
	asserts.AssertVpcPeeringConnectionVpcInfo(t)
	return t
end

keys.ImportImageResult = { ["Status"] = true, ["LicenseType"] = true, ["Description"] = true, ["Hypervisor"] = true, ["ImageId"] = true, ["Platform"] = true, ["Architecture"] = true, ["SnapshotDetails"] = true, ["Progress"] = true, ["StatusMessage"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageResult to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["LicenseType"] then asserts.AssertString(struct["LicenseType"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Hypervisor"] then asserts.AssertString(struct["Hypervisor"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["Architecture"] then asserts.AssertString(struct["Architecture"]) end
	if struct["SnapshotDetails"] then asserts.AssertSnapshotDetailList(struct["SnapshotDetails"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportImageResult[k], "ImportImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageResult
-- <p>Contains the output for ImportImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>A brief status of the task.</p>
-- * LicenseType [String] <p>The license type of the virtual machine.</p>
-- * Description [String] <p>A description of the import task.</p>
-- * Hypervisor [String] <p>The target hypervisor of the import task.</p>
-- * ImageId [String] <p>The ID of the Amazon Machine Image (AMI) created by the import task.</p>
-- * Platform [String] <p>The operating system of the virtual machine.</p>
-- * Architecture [String] <p>The architecture of the virtual machine.</p>
-- * SnapshotDetails [SnapshotDetailList] <p>Information about the snapshots.</p>
-- * Progress [String] <p>The progress of the task.</p>
-- * StatusMessage [String] <p>A detailed status message of the import task.</p>
-- * ImportTaskId [String] <p>The task ID of the import image task.</p>
-- @return ImportImageResult structure as a key-value pair table
function M.ImportImageResult(args)
	assert(args, "You must provdide an argument table when creating ImportImageResult")
	local t = { 
		["Status"] = args["Status"],
		["LicenseType"] = args["LicenseType"],
		["Description"] = args["Description"],
		["Hypervisor"] = args["Hypervisor"],
		["ImageId"] = args["ImageId"],
		["Platform"] = args["Platform"],
		["Architecture"] = args["Architecture"],
		["SnapshotDetails"] = args["SnapshotDetails"],
		["Progress"] = args["Progress"],
		["StatusMessage"] = args["StatusMessage"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertImportImageResult(t)
	return t
end

keys.CreateNetworkInterfaceResult = { ["NetworkInterface"] = true, nil }

function asserts.AssertCreateNetworkInterfaceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfaceResult to be of type 'table'")
	if struct["NetworkInterface"] then asserts.AssertNetworkInterface(struct["NetworkInterface"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkInterfaceResult[k], "CreateNetworkInterfaceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfaceResult
-- <p>Contains the output of CreateNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterface [NetworkInterface] <p>Information about the network interface.</p>
-- @return CreateNetworkInterfaceResult structure as a key-value pair table
function M.CreateNetworkInterfaceResult(args)
	assert(args, "You must provdide an argument table when creating CreateNetworkInterfaceResult")
	local t = { 
		["NetworkInterface"] = args["NetworkInterface"],
	}
	asserts.AssertCreateNetworkInterfaceResult(t)
	return t
end

keys.ModifyImageAttributeRequest = { ["ProductCodes"] = true, ["UserGroups"] = true, ["DryRun"] = true, ["Description"] = true, ["Attribute"] = true, ["UserIds"] = true, ["Value"] = true, ["ImageId"] = true, ["OperationType"] = true, ["LaunchPermission"] = true, nil }

function asserts.AssertModifyImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyImageAttributeRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["ProductCodes"] then asserts.AssertProductCodeStringList(struct["ProductCodes"]) end
	if struct["UserGroups"] then asserts.AssertUserGroupStringList(struct["UserGroups"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	if struct["Attribute"] then asserts.AssertString(struct["Attribute"]) end
	if struct["UserIds"] then asserts.AssertUserIdStringList(struct["UserIds"]) end
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["OperationType"] then asserts.AssertOperationType(struct["OperationType"]) end
	if struct["LaunchPermission"] then asserts.AssertLaunchPermissionModifications(struct["LaunchPermission"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyImageAttributeRequest[k], "ModifyImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyImageAttributeRequest
-- <p>Contains the parameters for ModifyImageAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodes [ProductCodeStringList] <p>One or more product codes. After you add a product code to an AMI, it can't be removed. This is only valid when modifying the <code>productCodes</code> attribute.</p>
-- * UserGroups [UserGroupStringList] <p>One or more user groups. This is only valid when modifying the <code>launchPermission</code> attribute.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [AttributeValue] <p>A description for the AMI.</p>
-- * Attribute [String] <p>The name of the attribute to modify.</p>
-- * UserIds [UserIdStringList] <p>One or more AWS account IDs. This is only valid when modifying the <code>launchPermission</code> attribute.</p>
-- * Value [String] <p>The value of the attribute being modified. This is only valid when modifying the <code>description</code> attribute.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * OperationType [OperationType] <p>The operation type.</p>
-- * LaunchPermission [LaunchPermissionModifications] <p>A launch permission modification.</p>
-- Required key: ImageId
-- @return ModifyImageAttributeRequest structure as a key-value pair table
function M.ModifyImageAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyImageAttributeRequest")
	local t = { 
		["ProductCodes"] = args["ProductCodes"],
		["UserGroups"] = args["UserGroups"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["Attribute"] = args["Attribute"],
		["UserIds"] = args["UserIds"],
		["Value"] = args["Value"],
		["ImageId"] = args["ImageId"],
		["OperationType"] = args["OperationType"],
		["LaunchPermission"] = args["LaunchPermission"],
	}
	asserts.AssertModifyImageAttributeRequest(t)
	return t
end

keys.DescribeSpotFleetRequestsResponse = { ["SpotFleetRequestConfigs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestsResponse to be of type 'table'")
	assert(struct["SpotFleetRequestConfigs"], "Expected key SpotFleetRequestConfigs to exist in table")
	if struct["SpotFleetRequestConfigs"] then asserts.AssertSpotFleetRequestConfigSet(struct["SpotFleetRequestConfigs"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestsResponse[k], "DescribeSpotFleetRequestsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestsResponse
-- <p>Contains the output of DescribeSpotFleetRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestConfigs [SpotFleetRequestConfigSet] <p>Information about the configuration of your Spot fleet.</p>
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- Required key: SpotFleetRequestConfigs
-- @return DescribeSpotFleetRequestsResponse structure as a key-value pair table
function M.DescribeSpotFleetRequestsResponse(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotFleetRequestsResponse")
	local t = { 
		["SpotFleetRequestConfigs"] = args["SpotFleetRequestConfigs"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeSpotFleetRequestsResponse(t)
	return t
end

keys.DescribeVpcEndpointServicesRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeVpcEndpointServicesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicesRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServicesRequest[k], "DescribeVpcEndpointServicesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicesRequest
-- <p>Contains the parameters for DescribeVpcEndpointServices.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- @return DescribeVpcEndpointServicesRequest structure as a key-value pair table
function M.DescribeVpcEndpointServicesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcEndpointServicesRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeVpcEndpointServicesRequest(t)
	return t
end

keys.NewDhcpConfiguration = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertNewDhcpConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NewDhcpConfiguration to be of type 'table'")
	if struct["Values"] then asserts.AssertValueStringList(struct["Values"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.NewDhcpConfiguration[k], "NewDhcpConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NewDhcpConfiguration
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [ValueStringList] 
-- * Key [String] 
-- @return NewDhcpConfiguration structure as a key-value pair table
function M.NewDhcpConfiguration(args)
	assert(args, "You must provdide an argument table when creating NewDhcpConfiguration")
	local t = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertNewDhcpConfiguration(t)
	return t
end

keys.ModifyVpcPeeringConnectionOptionsResult = { ["RequesterPeeringConnectionOptions"] = true, ["AccepterPeeringConnectionOptions"] = true, nil }

function asserts.AssertModifyVpcPeeringConnectionOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcPeeringConnectionOptionsResult to be of type 'table'")
	if struct["RequesterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptions(struct["RequesterPeeringConnectionOptions"]) end
	if struct["AccepterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptions(struct["AccepterPeeringConnectionOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcPeeringConnectionOptionsResult[k], "ModifyVpcPeeringConnectionOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcPeeringConnectionOptionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RequesterPeeringConnectionOptions [PeeringConnectionOptions] <p>Information about the VPC peering connection options for the requester VPC.</p>
-- * AccepterPeeringConnectionOptions [PeeringConnectionOptions] <p>Information about the VPC peering connection options for the accepter VPC.</p>
-- @return ModifyVpcPeeringConnectionOptionsResult structure as a key-value pair table
function M.ModifyVpcPeeringConnectionOptionsResult(args)
	assert(args, "You must provdide an argument table when creating ModifyVpcPeeringConnectionOptionsResult")
	local t = { 
		["RequesterPeeringConnectionOptions"] = args["RequesterPeeringConnectionOptions"],
		["AccepterPeeringConnectionOptions"] = args["AccepterPeeringConnectionOptions"],
	}
	asserts.AssertModifyVpcPeeringConnectionOptionsResult(t)
	return t
end

keys.StateReason = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertStateReason(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StateReason to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.StateReason[k], "StateReason contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StateReason
-- <p>Describes a state change.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The message for the state change.</p> <ul> <li> <p> <code>Server.InsufficientInstanceCapacity</code>: There was insufficient instance capacity to satisfy the launch request.</p> </li> <li> <p> <code>Server.InternalError</code>: An internal error occurred during instance launch, resulting in termination.</p> </li> <li> <p> <code>Server.ScheduledStop</code>: The instance was stopped due to a scheduled retirement.</p> </li> <li> <p> <code>Server.SpotInstanceTermination</code>: A Spot instance was terminated due to an increase in the market price.</p> </li> <li> <p> <code>Client.InternalError</code>: A client error caused the instance to terminate on launch.</p> </li> <li> <p> <code>Client.InstanceInitiatedShutdown</code>: The instance was shut down using the <code>shutdown -h</code> command from the instance.</p> </li> <li> <p> <code>Client.UserInitiatedShutdown</code>: The instance was shut down using the Amazon EC2 API.</p> </li> <li> <p> <code>Client.VolumeLimitExceeded</code>: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your limits.</p> </li> <li> <p> <code>Client.InvalidSnapshot.NotFound</code>: The specified snapshot was not found.</p> </li> </ul>
-- * Code [String] <p>The reason code for the state change.</p>
-- @return StateReason structure as a key-value pair table
function M.StateReason(args)
	assert(args, "You must provdide an argument table when creating StateReason")
	local t = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertStateReason(t)
	return t
end

keys.VpcPeeringConnectionStateReason = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertVpcPeeringConnectionStateReason(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionStateReason to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertVpcPeeringConnectionStateReasonCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnectionStateReason[k], "VpcPeeringConnectionStateReason contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionStateReason
-- <p>Describes the status of a VPC peering connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>A message that provides more information about the status, if applicable.</p>
-- * Code [VpcPeeringConnectionStateReasonCode] <p>The status of the VPC peering connection.</p>
-- @return VpcPeeringConnectionStateReason structure as a key-value pair table
function M.VpcPeeringConnectionStateReason(args)
	assert(args, "You must provdide an argument table when creating VpcPeeringConnectionStateReason")
	local t = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertVpcPeeringConnectionStateReason(t)
	return t
end

keys.IamInstanceProfile = { ["Id"] = true, ["Arn"] = true, nil }

function asserts.AssertIamInstanceProfile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfile to be of type 'table'")
	if struct["Id"] then asserts.AssertString(struct["Id"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.IamInstanceProfile[k], "IamInstanceProfile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfile
-- <p>Describes an IAM instance profile.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Id [String] <p>The ID of the instance profile.</p>
-- * Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
-- @return IamInstanceProfile structure as a key-value pair table
function M.IamInstanceProfile(args)
	assert(args, "You must provdide an argument table when creating IamInstanceProfile")
	local t = { 
		["Id"] = args["Id"],
		["Arn"] = args["Arn"],
	}
	asserts.AssertIamInstanceProfile(t)
	return t
end

keys.IpRange = { ["CidrIp"] = true, nil }

function asserts.AssertIpRange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IpRange to be of type 'table'")
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	for k,_ in pairs(struct) do
		assert(keys.IpRange[k], "IpRange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IpRange
-- <p>Describes an IPv4 range.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CidrIp [String] <p>The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix.</p>
-- @return IpRange structure as a key-value pair table
function M.IpRange(args)
	assert(args, "You must provdide an argument table when creating IpRange")
	local t = { 
		["CidrIp"] = args["CidrIp"],
	}
	asserts.AssertIpRange(t)
	return t
end

keys.InstanceCount = { ["State"] = true, ["InstanceCount"] = true, nil }

function asserts.AssertInstanceCount(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCount to be of type 'table'")
	if struct["State"] then asserts.AssertListingState(struct["State"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceCount[k], "InstanceCount contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCount
-- <p>Describes a Reserved Instance listing state.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [ListingState] <p>The states of the listed Reserved Instances.</p>
-- * InstanceCount [Integer] <p>The number of listed Reserved Instances in the state specified by the <code>state</code>.</p>
-- @return InstanceCount structure as a key-value pair table
function M.InstanceCount(args)
	assert(args, "You must provdide an argument table when creating InstanceCount")
	local t = { 
		["State"] = args["State"],
		["InstanceCount"] = args["InstanceCount"],
	}
	asserts.AssertInstanceCount(t)
	return t
end

keys.ScheduledInstancesIamInstanceProfile = { ["Name"] = true, ["Arn"] = true, nil }

function asserts.AssertScheduledInstancesIamInstanceProfile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesIamInstanceProfile to be of type 'table'")
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesIamInstanceProfile[k], "ScheduledInstancesIamInstanceProfile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesIamInstanceProfile
-- <p>Describes an IAM instance profile for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [String] <p>The name.</p>
-- * Arn [String] <p>The Amazon Resource Name (ARN).</p>
-- @return ScheduledInstancesIamInstanceProfile structure as a key-value pair table
function M.ScheduledInstancesIamInstanceProfile(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstancesIamInstanceProfile")
	local t = { 
		["Name"] = args["Name"],
		["Arn"] = args["Arn"],
	}
	asserts.AssertScheduledInstancesIamInstanceProfile(t)
	return t
end

keys.VolumeStatusAction = { ["EventId"] = true, ["EventType"] = true, ["Code"] = true, ["Description"] = true, nil }

function asserts.AssertVolumeStatusAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusAction to be of type 'table'")
	if struct["EventId"] then asserts.AssertString(struct["EventId"]) end
	if struct["EventType"] then asserts.AssertString(struct["EventType"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusAction[k], "VolumeStatusAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusAction
-- <p>Describes a volume status operation code.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EventId [String] <p>The ID of the event associated with this operation.</p>
-- * EventType [String] <p>The event type associated with this operation.</p>
-- * Code [String] <p>The code identifying the operation, for example, <code>enable-volume-io</code>.</p>
-- * Description [String] <p>A description of the operation.</p>
-- @return VolumeStatusAction structure as a key-value pair table
function M.VolumeStatusAction(args)
	assert(args, "You must provdide an argument table when creating VolumeStatusAction")
	local t = { 
		["EventId"] = args["EventId"],
		["EventType"] = args["EventType"],
		["Code"] = args["Code"],
		["Description"] = args["Description"],
	}
	asserts.AssertVolumeStatusAction(t)
	return t
end

keys.VgwTelemetry = { ["Status"] = true, ["AcceptedRouteCount"] = true, ["LastStatusChange"] = true, ["OutsideIpAddress"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertVgwTelemetry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VgwTelemetry to be of type 'table'")
	if struct["Status"] then asserts.AssertTelemetryStatus(struct["Status"]) end
	if struct["AcceptedRouteCount"] then asserts.AssertInteger(struct["AcceptedRouteCount"]) end
	if struct["LastStatusChange"] then asserts.AssertDateTime(struct["LastStatusChange"]) end
	if struct["OutsideIpAddress"] then asserts.AssertString(struct["OutsideIpAddress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.VgwTelemetry[k], "VgwTelemetry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VgwTelemetry
-- <p>Describes telemetry for a VPN tunnel.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [TelemetryStatus] <p>The status of the VPN tunnel.</p>
-- * AcceptedRouteCount [Integer] <p>The number of accepted routes.</p>
-- * LastStatusChange [DateTime] <p>The date and time of the last change in status.</p>
-- * OutsideIpAddress [String] <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
-- * StatusMessage [String] <p>If an error occurs, a description of the error.</p>
-- @return VgwTelemetry structure as a key-value pair table
function M.VgwTelemetry(args)
	assert(args, "You must provdide an argument table when creating VgwTelemetry")
	local t = { 
		["Status"] = args["Status"],
		["AcceptedRouteCount"] = args["AcceptedRouteCount"],
		["LastStatusChange"] = args["LastStatusChange"],
		["OutsideIpAddress"] = args["OutsideIpAddress"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertVgwTelemetry(t)
	return t
end

keys.VpcEndpoint = { ["VpcId"] = true, ["ServiceName"] = true, ["State"] = true, ["PolicyDocument"] = true, ["RouteTableIds"] = true, ["VpcEndpointId"] = true, ["CreationTimestamp"] = true, nil }

function asserts.AssertVpcEndpoint(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcEndpoint to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["ServiceName"] then asserts.AssertString(struct["ServiceName"]) end
	if struct["State"] then asserts.AssertState(struct["State"]) end
	if struct["PolicyDocument"] then asserts.AssertString(struct["PolicyDocument"]) end
	if struct["RouteTableIds"] then asserts.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["VpcEndpointId"] then asserts.AssertString(struct["VpcEndpointId"]) end
	if struct["CreationTimestamp"] then asserts.AssertDateTime(struct["CreationTimestamp"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcEndpoint[k], "VpcEndpoint contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcEndpoint
-- <p>Describes a VPC endpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC to which the endpoint is associated.</p>
-- * ServiceName [String] <p>The name of the AWS service to which the endpoint is associated.</p>
-- * State [State] <p>The state of the VPC endpoint.</p>
-- * PolicyDocument [String] <p>The policy document associated with the endpoint.</p>
-- * RouteTableIds [ValueStringList] <p>One or more route tables associated with the endpoint.</p>
-- * VpcEndpointId [String] <p>The ID of the VPC endpoint.</p>
-- * CreationTimestamp [DateTime] <p>The date and time the VPC endpoint was created.</p>
-- @return VpcEndpoint structure as a key-value pair table
function M.VpcEndpoint(args)
	assert(args, "You must provdide an argument table when creating VpcEndpoint")
	local t = { 
		["VpcId"] = args["VpcId"],
		["ServiceName"] = args["ServiceName"],
		["State"] = args["State"],
		["PolicyDocument"] = args["PolicyDocument"],
		["RouteTableIds"] = args["RouteTableIds"],
		["VpcEndpointId"] = args["VpcEndpointId"],
		["CreationTimestamp"] = args["CreationTimestamp"],
	}
	asserts.AssertVpcEndpoint(t)
	return t
end

keys.AssociateAddressResult = { ["AssociationId"] = true, nil }

function asserts.AssertAssociateAddressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateAddressResult to be of type 'table'")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateAddressResult[k], "AssociateAddressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateAddressResult
-- <p>Contains the output of AssociateAddress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>[EC2-VPC] The ID that represents the association of the Elastic IP address with an instance.</p>
-- @return AssociateAddressResult structure as a key-value pair table
function M.AssociateAddressResult(args)
	assert(args, "You must provdide an argument table when creating AssociateAddressResult")
	local t = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertAssociateAddressResult(t)
	return t
end

keys.InternetGatewayAttachment = { ["State"] = true, ["VpcId"] = true, nil }

function asserts.AssertInternetGatewayAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InternetGatewayAttachment to be of type 'table'")
	if struct["State"] then asserts.AssertAttachmentStatus(struct["State"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.InternetGatewayAttachment[k], "InternetGatewayAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InternetGatewayAttachment
-- <p>Describes the attachment of a VPC to an Internet gateway or an egress-only Internet gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [AttachmentStatus] <p>The current state of the attachment.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return InternetGatewayAttachment structure as a key-value pair table
function M.InternetGatewayAttachment(args)
	assert(args, "You must provdide an argument table when creating InternetGatewayAttachment")
	local t = { 
		["State"] = args["State"],
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertInternetGatewayAttachment(t)
	return t
end

keys.CancelSpotFleetRequestsSuccessItem = { ["PreviousSpotFleetRequestState"] = true, ["CurrentSpotFleetRequestState"] = true, ["SpotFleetRequestId"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsSuccessItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsSuccessItem to be of type 'table'")
	assert(struct["CurrentSpotFleetRequestState"], "Expected key CurrentSpotFleetRequestState to exist in table")
	assert(struct["PreviousSpotFleetRequestState"], "Expected key PreviousSpotFleetRequestState to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["PreviousSpotFleetRequestState"] then asserts.AssertBatchState(struct["PreviousSpotFleetRequestState"]) end
	if struct["CurrentSpotFleetRequestState"] then asserts.AssertBatchState(struct["CurrentSpotFleetRequestState"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsSuccessItem[k], "CancelSpotFleetRequestsSuccessItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsSuccessItem
-- <p>Describes a Spot fleet request that was successfully canceled.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PreviousSpotFleetRequestState [BatchState] <p>The previous state of the Spot fleet request.</p>
-- * CurrentSpotFleetRequestState [BatchState] <p>The current state of the Spot fleet request.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- Required key: CurrentSpotFleetRequestState
-- Required key: PreviousSpotFleetRequestState
-- Required key: SpotFleetRequestId
-- @return CancelSpotFleetRequestsSuccessItem structure as a key-value pair table
function M.CancelSpotFleetRequestsSuccessItem(args)
	assert(args, "You must provdide an argument table when creating CancelSpotFleetRequestsSuccessItem")
	local t = { 
		["PreviousSpotFleetRequestState"] = args["PreviousSpotFleetRequestState"],
		["CurrentSpotFleetRequestState"] = args["CurrentSpotFleetRequestState"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
	}
	asserts.AssertCancelSpotFleetRequestsSuccessItem(t)
	return t
end

keys.RevokeSecurityGroupEgressRequest = { ["DryRun"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertRevokeSecurityGroupEgressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RevokeSecurityGroupEgressRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RevokeSecurityGroupEgressRequest[k], "RevokeSecurityGroupEgressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RevokeSecurityGroupEgressRequest
-- <p>Contains the parameters for RevokeSecurityGroupEgress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * CidrIp [String] <p>The CIDR IP address range. We recommend that you specify the CIDR range in a set of IP permissions instead.</p>
-- * IpPermissions [IpPermissionList] <p>A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.</p>
-- * FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- * SourceSecurityGroupOwnerId [String] <p>The AWS account number for a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- * SourceSecurityGroupName [String] <p>The name of a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- * ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- * IpProtocol [String] <p>The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- Required key: GroupId
-- @return RevokeSecurityGroupEgressRequest structure as a key-value pair table
function M.RevokeSecurityGroupEgressRequest(args)
	assert(args, "You must provdide an argument table when creating RevokeSecurityGroupEgressRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["CidrIp"] = args["CidrIp"],
		["IpPermissions"] = args["IpPermissions"],
		["FromPort"] = args["FromPort"],
		["SourceSecurityGroupOwnerId"] = args["SourceSecurityGroupOwnerId"],
		["SourceSecurityGroupName"] = args["SourceSecurityGroupName"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertRevokeSecurityGroupEgressRequest(t)
	return t
end

keys.DescribeImportImageTasksRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["ImportTaskIds"] = true, nil }

function asserts.AssertDescribeImportImageTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportImageTasksRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ImportTaskIds"] then asserts.AssertImportTaskIdList(struct["ImportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportImageTasksRequest[k], "DescribeImportImageTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportImageTasksRequest
-- <p>Contains the parameters for DescribeImportImageTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>A token that indicates the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * Filters [FilterList] <p>Filter tasks using the <code>task-state</code> filter and one of the following values: active, completed, deleting, deleted.</p>
-- * ImportTaskIds [ImportTaskIdList] <p>A list of import image task IDs.</p>
-- @return DescribeImportImageTasksRequest structure as a key-value pair table
function M.DescribeImportImageTasksRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeImportImageTasksRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["ImportTaskIds"] = args["ImportTaskIds"],
	}
	asserts.AssertDescribeImportImageTasksRequest(t)
	return t
end

keys.DescribeVpcClassicLinkDnsSupportResult = { ["Vpcs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Vpcs"] then asserts.AssertClassicLinkDnsSupportList(struct["Vpcs"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkDnsSupportResult[k], "DescribeVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkDnsSupportResult
-- <p>Contains the output of DescribeVpcClassicLinkDnsSupport.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Vpcs [ClassicLinkDnsSupportList] <p>Information about the ClassicLink DNS support status of the VPCs.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items.</p>
-- @return DescribeVpcClassicLinkDnsSupportResult structure as a key-value pair table
function M.DescribeVpcClassicLinkDnsSupportResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcClassicLinkDnsSupportResult")
	local t = { 
		["Vpcs"] = args["Vpcs"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeVpcClassicLinkDnsSupportResult(t)
	return t
end

keys.RegisterImageRequest = { ["VirtualizationType"] = true, ["DryRun"] = true, ["Description"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["BlockDeviceMappings"] = true, ["Architecture"] = true, ["BillingProducts"] = true, ["ImageLocation"] = true, ["KernelId"] = true, ["RamdiskId"] = true, ["RootDeviceName"] = true, ["Name"] = true, nil }

function asserts.AssertRegisterImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterImageRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["VirtualizationType"] then asserts.AssertString(struct["VirtualizationType"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["EnaSupport"] then asserts.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertString(struct["SriovNetSupport"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["BillingProducts"] then asserts.AssertBillingProductList(struct["BillingProducts"]) end
	if struct["ImageLocation"] then asserts.AssertString(struct["ImageLocation"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["RootDeviceName"] then asserts.AssertString(struct["RootDeviceName"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterImageRequest[k], "RegisterImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterImageRequest
-- <p>Contains the parameters for RegisterImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VirtualizationType [String] <p>The type of virtualization.</p> <p>Default: <code>paravirtual</code> </p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for your AMI.</p>
-- * EnaSupport [Boolean] <p>Set to <code>true</code> to enable enhanced networking with ENA for the AMI and any instances that you launch from the AMI.</p> <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
-- * SriovNetSupport [String] <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI.</p> <p>There is no way to disable <code>sriovNetSupport</code> at this time.</p> <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
-- * BlockDeviceMappings [BlockDeviceMappingRequestList] <p>One or more block device mapping entries.</p>
-- * Architecture [ArchitectureValues] <p>The architecture of the AMI.</p> <p>Default: For Amazon EBS-backed AMIs, <code>i386</code>. For instance store-backed AMIs, the architecture specified in the manifest file.</p>
-- * BillingProducts [BillingProductList] <p>The billing product codes. Your account must be authorized to specify billing product codes. Otherwise, you can use the AWS Marketplace to bill for the use of an AMI.</p>
-- * ImageLocation [String] <p>The full path to your AMI manifest in Amazon S3 storage.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * RootDeviceName [String] <p>The name of the root device (for example, <code>/dev/sda1</code>, or <code>/dev/xvda</code>).</p>
-- * Name [String] <p>A name for your AMI.</p> <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
-- Required key: Name
-- @return RegisterImageRequest structure as a key-value pair table
function M.RegisterImageRequest(args)
	assert(args, "You must provdide an argument table when creating RegisterImageRequest")
	local t = { 
		["VirtualizationType"] = args["VirtualizationType"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["Architecture"] = args["Architecture"],
		["BillingProducts"] = args["BillingProducts"],
		["ImageLocation"] = args["ImageLocation"],
		["KernelId"] = args["KernelId"],
		["RamdiskId"] = args["RamdiskId"],
		["RootDeviceName"] = args["RootDeviceName"],
		["Name"] = args["Name"],
	}
	asserts.AssertRegisterImageRequest(t)
	return t
end

keys.IcmpTypeCode = { ["Code"] = true, ["Type"] = true, nil }

function asserts.AssertIcmpTypeCode(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IcmpTypeCode to be of type 'table'")
	if struct["Code"] then asserts.AssertInteger(struct["Code"]) end
	if struct["Type"] then asserts.AssertInteger(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.IcmpTypeCode[k], "IcmpTypeCode contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IcmpTypeCode
-- <p>Describes the ICMP type and code.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Code [Integer] <p>The ICMP code. A value of -1 means all codes for the specified ICMP type.</p>
-- * Type [Integer] <p>The ICMP type. A value of -1 means all types.</p>
-- @return IcmpTypeCode structure as a key-value pair table
function M.IcmpTypeCode(args)
	assert(args, "You must provdide an argument table when creating IcmpTypeCode")
	local t = { 
		["Code"] = args["Code"],
		["Type"] = args["Type"],
	}
	asserts.AssertIcmpTypeCode(t)
	return t
end

keys.DescribeInternetGatewaysRequest = { ["DryRun"] = true, ["InternetGatewayIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInternetGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInternetGatewaysRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayIds"] then asserts.AssertValueStringList(struct["InternetGatewayIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInternetGatewaysRequest[k], "DescribeInternetGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInternetGatewaysRequest
-- <p>Contains the parameters for DescribeInternetGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InternetGatewayIds [ValueStringList] <p>One or more Internet gateway IDs.</p> <p>Default: Describes all your Internet gateways.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.state</code> - The current state of the attachment between the gateway and the VPC (<code>available</code>). Present only if a VPC is attached.</p> </li> <li> <p> <code>attachment.vpc-id</code> - The ID of an attached VPC.</p> </li> <li> <p> <code>internet-gateway-id</code> - The ID of the Internet gateway.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
-- @return DescribeInternetGatewaysRequest structure as a key-value pair table
function M.DescribeInternetGatewaysRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeInternetGatewaysRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["InternetGatewayIds"] = args["InternetGatewayIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeInternetGatewaysRequest(t)
	return t
end

keys.CreateVpcPeeringConnectionResult = { ["VpcPeeringConnection"] = true, nil }

function asserts.AssertCreateVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcPeeringConnectionResult to be of type 'table'")
	if struct["VpcPeeringConnection"] then asserts.AssertVpcPeeringConnection(struct["VpcPeeringConnection"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcPeeringConnectionResult[k], "CreateVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcPeeringConnectionResult
-- <p>Contains the output of CreateVpcPeeringConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcPeeringConnection [VpcPeeringConnection] <p>Information about the VPC peering connection.</p>
-- @return CreateVpcPeeringConnectionResult structure as a key-value pair table
function M.CreateVpcPeeringConnectionResult(args)
	assert(args, "You must provdide an argument table when creating CreateVpcPeeringConnectionResult")
	local t = { 
		["VpcPeeringConnection"] = args["VpcPeeringConnection"],
	}
	asserts.AssertCreateVpcPeeringConnectionResult(t)
	return t
end

keys.NetworkInterfaceAttachmentChanges = { ["DeleteOnTermination"] = true, ["AttachmentId"] = true, nil }

function asserts.AssertNetworkInterfaceAttachmentChanges(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAttachmentChanges to be of type 'table'")
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceAttachmentChanges[k], "NetworkInterfaceAttachmentChanges contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAttachmentChanges
-- <p>Describes an attachment change.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- * AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- @return NetworkInterfaceAttachmentChanges structure as a key-value pair table
function M.NetworkInterfaceAttachmentChanges(args)
	assert(args, "You must provdide an argument table when creating NetworkInterfaceAttachmentChanges")
	local t = { 
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["AttachmentId"] = args["AttachmentId"],
	}
	asserts.AssertNetworkInterfaceAttachmentChanges(t)
	return t
end

keys.CreateNetworkInterfaceRequest = { ["DryRun"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["PrivateIpAddresses"] = true, ["SubnetId"] = true, ["SecondaryPrivateIpAddressCount"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertCreateNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfaceRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkInterfaceRequest[k], "CreateNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfaceRequest
-- <p>Contains the parameters for CreateNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the network interface.</p>
-- * Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses. If your subnet has the <code>AssignIpv6AddressOnCreation</code> attribute set to <code>true</code>, you can specify <code>0</code> to override this setting.</p>
-- * PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses.</p>
-- * SubnetId [String] <p>The ID of the subnet to associate with the network interface.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using <code>privateIpAddresses</code>.</p> <p>The number of IP addresses you can assign to a network interface varies by instance type. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI">IP Addresses Per ENI Per Instance Type</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- * Groups [SecurityGroupIdStringList] <p>The IDs of one or more security groups.</p>
-- * Ipv6Addresses [InstanceIpv6AddressList] <p>One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.</p>
-- * PrivateIpAddress [String] <p>The primary private IPv4 address of the network interface. If you don't specify an IPv4 address, Amazon EC2 selects one for you from the subnet's IPv4 CIDR range. If you specify an IP address, you cannot indicate any IP addresses specified in <code>privateIpAddresses</code> as primary (only one IP address can be designated as primary).</p>
-- Required key: SubnetId
-- @return CreateNetworkInterfaceRequest structure as a key-value pair table
function M.CreateNetworkInterfaceRequest(args)
	assert(args, "You must provdide an argument table when creating CreateNetworkInterfaceRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["SubnetId"] = args["SubnetId"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertCreateNetworkInterfaceRequest(t)
	return t
end

keys.DescribeImportSnapshotTasksResult = { ["NextToken"] = true, ["ImportSnapshotTasks"] = true, nil }

function asserts.AssertDescribeImportSnapshotTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportSnapshotTasksResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ImportSnapshotTasks"] then asserts.AssertImportSnapshotTaskList(struct["ImportSnapshotTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportSnapshotTasksResult[k], "DescribeImportSnapshotTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportSnapshotTasksResult
-- <p>Contains the output for DescribeImportSnapshotTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ImportSnapshotTasks [ImportSnapshotTaskList] <p>A list of zero or more import snapshot tasks that are currently active or were completed or canceled in the previous 7 days.</p>
-- @return DescribeImportSnapshotTasksResult structure as a key-value pair table
function M.DescribeImportSnapshotTasksResult(args)
	assert(args, "You must provdide an argument table when creating DescribeImportSnapshotTasksResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["ImportSnapshotTasks"] = args["ImportSnapshotTasks"],
	}
	asserts.AssertDescribeImportSnapshotTasksResult(t)
	return t
end

keys.DescribeStaleSecurityGroupsResult = { ["StaleSecurityGroupSet"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeStaleSecurityGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStaleSecurityGroupsResult to be of type 'table'")
	if struct["StaleSecurityGroupSet"] then asserts.AssertStaleSecurityGroupSet(struct["StaleSecurityGroupSet"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeStaleSecurityGroupsResult[k], "DescribeStaleSecurityGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStaleSecurityGroupsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StaleSecurityGroupSet [StaleSecurityGroupSet] <p>Information about the stale security groups.</p>
-- * NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeStaleSecurityGroupsResult structure as a key-value pair table
function M.DescribeStaleSecurityGroupsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeStaleSecurityGroupsResult")
	local t = { 
		["StaleSecurityGroupSet"] = args["StaleSecurityGroupSet"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeStaleSecurityGroupsResult(t)
	return t
end

keys.PriceScheduleSpecification = { ["Term"] = true, ["CurrencyCode"] = true, ["Price"] = true, nil }

function asserts.AssertPriceScheduleSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PriceScheduleSpecification to be of type 'table'")
	if struct["Term"] then asserts.AssertLong(struct["Term"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Price"] then asserts.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(keys.PriceScheduleSpecification[k], "PriceScheduleSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PriceScheduleSpecification
-- <p>Describes the price for a Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Term [Long] <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>
-- * Price [Double] <p>The fixed price for the term.</p>
-- @return PriceScheduleSpecification structure as a key-value pair table
function M.PriceScheduleSpecification(args)
	assert(args, "You must provdide an argument table when creating PriceScheduleSpecification")
	local t = { 
		["Term"] = args["Term"],
		["CurrencyCode"] = args["CurrencyCode"],
		["Price"] = args["Price"],
	}
	asserts.AssertPriceScheduleSpecification(t)
	return t
end

keys.UnassignIpv6AddressesResult = { ["NetworkInterfaceId"] = true, ["UnassignedIpv6Addresses"] = true, nil }

function asserts.AssertUnassignIpv6AddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignIpv6AddressesResult to be of type 'table'")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["UnassignedIpv6Addresses"] then asserts.AssertIpv6AddressList(struct["UnassignedIpv6Addresses"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnassignIpv6AddressesResult[k], "UnassignIpv6AddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignIpv6AddressesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * UnassignedIpv6Addresses [Ipv6AddressList] <p>The IPv6 addresses that have been unassigned from the network interface.</p>
-- @return UnassignIpv6AddressesResult structure as a key-value pair table
function M.UnassignIpv6AddressesResult(args)
	assert(args, "You must provdide an argument table when creating UnassignIpv6AddressesResult")
	local t = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["UnassignedIpv6Addresses"] = args["UnassignedIpv6Addresses"],
	}
	asserts.AssertUnassignIpv6AddressesResult(t)
	return t
end

keys.DescribeImageAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["ImageId"] = true, nil }

function asserts.AssertDescribeImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImageAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["Attribute"] then asserts.AssertImageAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImageAttributeRequest[k], "DescribeImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImageAttributeRequest
-- <p>Contains the parameters for DescribeImageAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [ImageAttributeName] <p>The AMI attribute.</p> <p> <b>Note</b>: Depending on your account privileges, the <code>blockDeviceMapping</code> attribute may return a <code>Client.AuthFailure</code> error. If this happens, use <a>DescribeImages</a> to get information about the block device mapping for the AMI.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- Required key: Attribute
-- Required key: ImageId
-- @return DescribeImageAttributeRequest structure as a key-value pair table
function M.DescribeImageAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeImageAttributeRequest")
	local t = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertDescribeImageAttributeRequest(t)
	return t
end

keys.DescribeEgressOnlyInternetGatewaysResult = { ["NextToken"] = true, ["EgressOnlyInternetGateways"] = true, nil }

function asserts.AssertDescribeEgressOnlyInternetGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEgressOnlyInternetGatewaysResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["EgressOnlyInternetGateways"] then asserts.AssertEgressOnlyInternetGatewayList(struct["EgressOnlyInternetGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEgressOnlyInternetGatewaysResult[k], "DescribeEgressOnlyInternetGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEgressOnlyInternetGatewaysResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- * EgressOnlyInternetGateways [EgressOnlyInternetGatewayList] <p>Information about the egress-only Internet gateways.</p>
-- @return DescribeEgressOnlyInternetGatewaysResult structure as a key-value pair table
function M.DescribeEgressOnlyInternetGatewaysResult(args)
	assert(args, "You must provdide an argument table when creating DescribeEgressOnlyInternetGatewaysResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["EgressOnlyInternetGateways"] = args["EgressOnlyInternetGateways"],
	}
	asserts.AssertDescribeEgressOnlyInternetGatewaysResult(t)
	return t
end

keys.InstanceNetworkInterfaceAttachment = { ["Status"] = true, ["DeviceIndex"] = true, ["DeleteOnTermination"] = true, ["AttachmentId"] = true, ["AttachTime"] = true, nil }

function asserts.AssertInstanceNetworkInterfaceAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceAttachment to be of type 'table'")
	if struct["Status"] then asserts.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterfaceAttachment[k], "InstanceNetworkInterfaceAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceAttachment
-- <p>Describes a network interface attachment.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [AttachmentStatus] <p>The attachment state.</p>
-- * DeviceIndex [Integer] <p>The index of the device on the instance for the network interface attachment.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- * AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- * AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
-- @return InstanceNetworkInterfaceAttachment structure as a key-value pair table
function M.InstanceNetworkInterfaceAttachment(args)
	assert(args, "You must provdide an argument table when creating InstanceNetworkInterfaceAttachment")
	local t = { 
		["Status"] = args["Status"],
		["DeviceIndex"] = args["DeviceIndex"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["AttachmentId"] = args["AttachmentId"],
		["AttachTime"] = args["AttachTime"],
	}
	asserts.AssertInstanceNetworkInterfaceAttachment(t)
	return t
end

keys.DescribeSubnetsRequest = { ["SubnetIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeSubnetsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSubnetsRequest to be of type 'table'")
	if struct["SubnetIds"] then asserts.AssertSubnetIdStringList(struct["SubnetIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSubnetsRequest[k], "DescribeSubnetsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSubnetsRequest
-- <p>Contains the parameters for DescribeSubnets.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetIds [SubnetIdStringList] <p>One or more subnet IDs.</p> <p>Default: Describes all your subnets.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availabilityZone</code> - The Availability Zone for the subnet. You can also use <code>availability-zone</code> as the filter name.</p> </li> <li> <p> <code>available-ip-address-count</code> - The number of IPv4 addresses in the subnet that are available.</p> </li> <li> <p> <code>cidrBlock</code> - The IPv4 CIDR block of the subnet. The CIDR block you specify must exactly match the subnet's CIDR block for information to be returned for the subnet. You can also use <code>cidr</code> or <code>cidr-block</code> as the filter names.</p> </li> <li> <p> <code>defaultForAz</code> - Indicates whether this is the default subnet for the Availability Zone. You can also use <code>default-for-az</code> as the filter name.</p> </li> <li> <p> <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>ipv6-cidr-block-association.association-id</code> - An association ID for an IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>state</code> - The state of the subnet (<code>pending</code> | <code>available</code>).</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the subnet.</p> </li> </ul>
-- @return DescribeSubnetsRequest structure as a key-value pair table
function M.DescribeSubnetsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSubnetsRequest")
	local t = { 
		["SubnetIds"] = args["SubnetIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeSubnetsRequest(t)
	return t
end

keys.CreateSubnetRequest = { ["VpcId"] = true, ["Ipv6CidrBlock"] = true, ["DryRun"] = true, ["AvailabilityZone"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertCreateSubnetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSubnetRequest to be of type 'table'")
	assert(struct["CidrBlock"], "Expected key CidrBlock to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSubnetRequest[k], "CreateSubnetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSubnetRequest
-- <p>Contains the parameters for CreateSubnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the subnet.</p> <p>Default: AWS selects one for you. If you create more than one subnet in your VPC, we may not necessarily select a different zone for each subnet.</p>
-- * CidrBlock [String] <p>The IPv4 network range for the subnet, in CIDR notation. For example, <code>10.0.0.0/24</code>.</p>
-- Required key: CidrBlock
-- Required key: VpcId
-- @return CreateSubnetRequest structure as a key-value pair table
function M.CreateSubnetRequest(args)
	assert(args, "You must provdide an argument table when creating CreateSubnetRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["DryRun"] = args["DryRun"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertCreateSubnetRequest(t)
	return t
end

keys.ConfirmProductInstanceRequest = { ["InstanceId"] = true, ["ProductCode"] = true, ["DryRun"] = true, nil }

function asserts.AssertConfirmProductInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConfirmProductInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["ProductCode"], "Expected key ProductCode to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["ProductCode"] then asserts.AssertString(struct["ProductCode"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConfirmProductInstanceRequest[k], "ConfirmProductInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConfirmProductInstanceRequest
-- <p>Contains the parameters for ConfirmProductInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * ProductCode [String] <p>The product code. This must be a product code that you own.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- Required key: ProductCode
-- @return ConfirmProductInstanceRequest structure as a key-value pair table
function M.ConfirmProductInstanceRequest(args)
	assert(args, "You must provdide an argument table when creating ConfirmProductInstanceRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["ProductCode"] = args["ProductCode"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertConfirmProductInstanceRequest(t)
	return t
end

keys.ScheduledInstanceRecurrenceRequest = { ["OccurrenceDays"] = true, ["Interval"] = true, ["Frequency"] = true, ["OccurrenceRelativeToEnd"] = true, ["OccurrenceUnit"] = true, nil }

function asserts.AssertScheduledInstanceRecurrenceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceRecurrenceRequest to be of type 'table'")
	if struct["OccurrenceDays"] then asserts.AssertOccurrenceDayRequestSet(struct["OccurrenceDays"]) end
	if struct["Interval"] then asserts.AssertInteger(struct["Interval"]) end
	if struct["Frequency"] then asserts.AssertString(struct["Frequency"]) end
	if struct["OccurrenceRelativeToEnd"] then asserts.AssertBoolean(struct["OccurrenceRelativeToEnd"]) end
	if struct["OccurrenceUnit"] then asserts.AssertString(struct["OccurrenceUnit"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstanceRecurrenceRequest[k], "ScheduledInstanceRecurrenceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceRecurrenceRequest
-- <p>Describes the recurring schedule for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OccurrenceDays [OccurrenceDayRequestSet] <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday). You can't specify this value with a daily schedule. If the occurrence is relative to the end of the month, you can specify only a single day.</p>
-- * Interval [Integer] <p>The interval quantity. The interval unit depends on the value of <code>Frequency</code>. For example, every 2 weeks or every 2 months.</p>
-- * Frequency [String] <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
-- * OccurrenceRelativeToEnd [Boolean] <p>Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.</p>
-- * OccurrenceUnit [String] <p>The unit for <code>OccurrenceDays</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>). This value is required for a monthly schedule. You can't specify <code>DayOfWeek</code> with a weekly schedule. You can't specify this value with a daily schedule.</p>
-- @return ScheduledInstanceRecurrenceRequest structure as a key-value pair table
function M.ScheduledInstanceRecurrenceRequest(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstanceRecurrenceRequest")
	local t = { 
		["OccurrenceDays"] = args["OccurrenceDays"],
		["Interval"] = args["Interval"],
		["Frequency"] = args["Frequency"],
		["OccurrenceRelativeToEnd"] = args["OccurrenceRelativeToEnd"],
		["OccurrenceUnit"] = args["OccurrenceUnit"],
	}
	asserts.AssertScheduledInstanceRecurrenceRequest(t)
	return t
end

keys.DescribeStaleSecurityGroupsRequest = { ["VpcId"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeStaleSecurityGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStaleSecurityGroupsRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeStaleSecurityGroupsRequest[k], "DescribeStaleSecurityGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStaleSecurityGroupsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required key: VpcId
-- @return DescribeStaleSecurityGroupsRequest structure as a key-value pair table
function M.DescribeStaleSecurityGroupsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeStaleSecurityGroupsRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeStaleSecurityGroupsRequest(t)
	return t
end

keys.ReservationValue = { ["RemainingUpfrontValue"] = true, ["HourlyPrice"] = true, ["RemainingTotalValue"] = true, nil }

function asserts.AssertReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservationValue to be of type 'table'")
	if struct["RemainingUpfrontValue"] then asserts.AssertString(struct["RemainingUpfrontValue"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["RemainingTotalValue"] then asserts.AssertString(struct["RemainingTotalValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservationValue[k], "ReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservationValue
-- <p>The cost associated with the Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RemainingUpfrontValue [String] <p>The remaining upfront cost of the reservation.</p>
-- * HourlyPrice [String] <p>The hourly rate of the reservation.</p>
-- * RemainingTotalValue [String] <p>The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).</p>
-- @return ReservationValue structure as a key-value pair table
function M.ReservationValue(args)
	assert(args, "You must provdide an argument table when creating ReservationValue")
	local t = { 
		["RemainingUpfrontValue"] = args["RemainingUpfrontValue"],
		["HourlyPrice"] = args["HourlyPrice"],
		["RemainingTotalValue"] = args["RemainingTotalValue"],
	}
	asserts.AssertReservationValue(t)
	return t
end

keys.AssociateVpcCidrBlockRequest = { ["VpcId"] = true, ["AmazonProvidedIpv6CidrBlock"] = true, nil }

function asserts.AssertAssociateVpcCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateVpcCidrBlockRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["AmazonProvidedIpv6CidrBlock"] then asserts.AssertBoolean(struct["AmazonProvidedIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateVpcCidrBlockRequest[k], "AssociateVpcCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateVpcCidrBlockRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * AmazonProvidedIpv6CidrBlock [Boolean] <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.</p>
-- Required key: VpcId
-- @return AssociateVpcCidrBlockRequest structure as a key-value pair table
function M.AssociateVpcCidrBlockRequest(args)
	assert(args, "You must provdide an argument table when creating AssociateVpcCidrBlockRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["AmazonProvidedIpv6CidrBlock"] = args["AmazonProvidedIpv6CidrBlock"],
	}
	asserts.AssertAssociateVpcCidrBlockRequest(t)
	return t
end

keys.ExportToS3Task = { ["S3Bucket"] = true, ["S3Key"] = true, ["DiskImageFormat"] = true, ["ContainerFormat"] = true, nil }

function asserts.AssertExportToS3Task(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportToS3Task to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then asserts.AssertString(struct["S3Key"]) end
	if struct["DiskImageFormat"] then asserts.AssertDiskImageFormat(struct["DiskImageFormat"]) end
	if struct["ContainerFormat"] then asserts.AssertContainerFormat(struct["ContainerFormat"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExportToS3Task[k], "ExportToS3Task contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportToS3Task
-- <p>Describes the format and location for an instance export task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3Bucket [String] <p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>
-- * S3Key [String] <p>The encryption key for your S3 bucket.</p>
-- * DiskImageFormat [DiskImageFormat] <p>The format for the exported image.</p>
-- * ContainerFormat [ContainerFormat] <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>
-- @return ExportToS3Task structure as a key-value pair table
function M.ExportToS3Task(args)
	assert(args, "You must provdide an argument table when creating ExportToS3Task")
	local t = { 
		["S3Bucket"] = args["S3Bucket"],
		["S3Key"] = args["S3Key"],
		["DiskImageFormat"] = args["DiskImageFormat"],
		["ContainerFormat"] = args["ContainerFormat"],
	}
	asserts.AssertExportToS3Task(t)
	return t
end

keys.AuthorizeSecurityGroupIngressRequest = { ["DryRun"] = true, ["GroupName"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertAuthorizeSecurityGroupIngressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizeSecurityGroupIngressRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthorizeSecurityGroupIngressRequest[k], "AuthorizeSecurityGroupIngressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizeSecurityGroupIngressRequest
-- <p>Contains the parameters for AuthorizeSecurityGroupIngress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group.</p>
-- * CidrIp [String] <p>The CIDR IPv4 address range. You can't specify this parameter when specifying a source security group.</p>
-- * IpPermissions [IpPermissionList] <p>A set of IP permissions. Can be used to specify multiple rules in a single command.</p>
-- * FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. For the ICMP/ICMPv6 type number, use <code>-1</code> to specify all types.</p>
-- * SourceSecurityGroupOwnerId [String] <p>[EC2-Classic] The AWS account number for the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead.</p>
-- * SourceSecurityGroupName [String] <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead. For EC2-VPC, the source security group must be in the same VPC.</p>
-- * ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code number. For the ICMP/ICMPv6 code number, use <code>-1</code> to specify all codes.</p>
-- * IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). (VPC only) Use <code>-1</code> to specify all protocols. If you specify <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>58</code> (ICMPv6), traffic on all ports is allowed, regardless of any ports you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For protocol <code>58</code> (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed.</p>
-- * GroupId [String] <p>The ID of the security group. Required for a nondefault VPC.</p>
-- @return AuthorizeSecurityGroupIngressRequest structure as a key-value pair table
function M.AuthorizeSecurityGroupIngressRequest(args)
	assert(args, "You must provdide an argument table when creating AuthorizeSecurityGroupIngressRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["GroupName"] = args["GroupName"],
		["CidrIp"] = args["CidrIp"],
		["IpPermissions"] = args["IpPermissions"],
		["FromPort"] = args["FromPort"],
		["SourceSecurityGroupOwnerId"] = args["SourceSecurityGroupOwnerId"],
		["SourceSecurityGroupName"] = args["SourceSecurityGroupName"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertAuthorizeSecurityGroupIngressRequest(t)
	return t
end

keys.DescribeAccountAttributesRequest = { ["DryRun"] = true, ["AttributeNames"] = true, nil }

function asserts.AssertDescribeAccountAttributesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAttributesRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AttributeNames"] then asserts.AssertAccountAttributeNameStringList(struct["AttributeNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAccountAttributesRequest[k], "DescribeAccountAttributesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAttributesRequest
-- <p>Contains the parameters for DescribeAccountAttributes.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AttributeNames [AccountAttributeNameStringList] <p>One or more account attribute names.</p>
-- @return DescribeAccountAttributesRequest structure as a key-value pair table
function M.DescribeAccountAttributesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeAccountAttributesRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["AttributeNames"] = args["AttributeNames"],
	}
	asserts.AssertDescribeAccountAttributesRequest(t)
	return t
end

keys.VpcPeeringConnection = { ["Status"] = true, ["Tags"] = true, ["RequesterVpcInfo"] = true, ["VpcPeeringConnectionId"] = true, ["ExpirationTime"] = true, ["AccepterVpcInfo"] = true, nil }

function asserts.AssertVpcPeeringConnection(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnection to be of type 'table'")
	if struct["Status"] then asserts.AssertVpcPeeringConnectionStateReason(struct["Status"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["RequesterVpcInfo"] then asserts.AssertVpcPeeringConnectionVpcInfo(struct["RequesterVpcInfo"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["ExpirationTime"] then asserts.AssertDateTime(struct["ExpirationTime"]) end
	if struct["AccepterVpcInfo"] then asserts.AssertVpcPeeringConnectionVpcInfo(struct["AccepterVpcInfo"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnection[k], "VpcPeeringConnection contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnection
-- <p>Describes a VPC peering connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [VpcPeeringConnectionStateReason] <p>The status of the VPC peering connection.</p>
-- * Tags [TagList] <p>Any tags assigned to the resource.</p>
-- * RequesterVpcInfo [VpcPeeringConnectionVpcInfo] <p>Information about the requester VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- * ExpirationTime [DateTime] <p>The time that an unaccepted VPC peering connection will expire.</p>
-- * AccepterVpcInfo [VpcPeeringConnectionVpcInfo] <p>Information about the accepter VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
-- @return VpcPeeringConnection structure as a key-value pair table
function M.VpcPeeringConnection(args)
	assert(args, "You must provdide an argument table when creating VpcPeeringConnection")
	local t = { 
		["Status"] = args["Status"],
		["Tags"] = args["Tags"],
		["RequesterVpcInfo"] = args["RequesterVpcInfo"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["ExpirationTime"] = args["ExpirationTime"],
		["AccepterVpcInfo"] = args["AccepterVpcInfo"],
	}
	asserts.AssertVpcPeeringConnection(t)
	return t
end

keys.DescribeScheduledInstanceAvailabilityResult = { ["NextToken"] = true, ["ScheduledInstanceAvailabilitySet"] = true, nil }

function asserts.AssertDescribeScheduledInstanceAvailabilityResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstanceAvailabilityResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ScheduledInstanceAvailabilitySet"] then asserts.AssertScheduledInstanceAvailabilitySet(struct["ScheduledInstanceAvailabilitySet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstanceAvailabilityResult[k], "DescribeScheduledInstanceAvailabilityResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstanceAvailabilityResult
-- <p>Contains the output of DescribeScheduledInstanceAvailability.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ScheduledInstanceAvailabilitySet [ScheduledInstanceAvailabilitySet] <p>Information about the available Scheduled Instances.</p>
-- @return DescribeScheduledInstanceAvailabilityResult structure as a key-value pair table
function M.DescribeScheduledInstanceAvailabilityResult(args)
	assert(args, "You must provdide an argument table when creating DescribeScheduledInstanceAvailabilityResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["ScheduledInstanceAvailabilitySet"] = args["ScheduledInstanceAvailabilitySet"],
	}
	asserts.AssertDescribeScheduledInstanceAvailabilityResult(t)
	return t
end

keys.DescribeIamInstanceProfileAssociationsRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, ["AssociationIds"] = true, nil }

function asserts.AssertDescribeIamInstanceProfileAssociationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIamInstanceProfileAssociationsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["AssociationIds"] then asserts.AssertAssociationIdList(struct["AssociationIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIamInstanceProfileAssociationsRequest[k], "DescribeIamInstanceProfileAssociationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIamInstanceProfileAssociationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to request the next page of results.</p>
-- * MaxResults [MaxResults] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>state</code> - The state of the association (<code>associating</code> | <code>associated</code> | <code>disassociating</code> | <code>disassociated</code>).</p> </li> </ul>
-- * AssociationIds [AssociationIdList] <p>One or more IAM instance profile associations.</p>
-- @return DescribeIamInstanceProfileAssociationsRequest structure as a key-value pair table
function M.DescribeIamInstanceProfileAssociationsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeIamInstanceProfileAssociationsRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["AssociationIds"] = args["AssociationIds"],
	}
	asserts.AssertDescribeIamInstanceProfileAssociationsRequest(t)
	return t
end

keys.ConversionTask = { ["ImportInstance"] = true, ["ImportVolume"] = true, ["Tags"] = true, ["ConversionTaskId"] = true, ["State"] = true, ["ExpirationTime"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertConversionTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConversionTask to be of type 'table'")
	assert(struct["ConversionTaskId"], "Expected key ConversionTaskId to exist in table")
	assert(struct["State"], "Expected key State to exist in table")
	if struct["ImportInstance"] then asserts.AssertImportInstanceTaskDetails(struct["ImportInstance"]) end
	if struct["ImportVolume"] then asserts.AssertImportVolumeTaskDetails(struct["ImportVolume"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["ConversionTaskId"] then asserts.AssertString(struct["ConversionTaskId"]) end
	if struct["State"] then asserts.AssertConversionTaskState(struct["State"]) end
	if struct["ExpirationTime"] then asserts.AssertString(struct["ExpirationTime"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConversionTask[k], "ConversionTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConversionTask
-- <p>Describes a conversion task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ImportInstance [ImportInstanceTaskDetails] <p>If the task is for importing an instance, this contains information about the import instance task.</p>
-- * ImportVolume [ImportVolumeTaskDetails] <p>If the task is for importing a volume, this contains information about the import volume task.</p>
-- * Tags [TagList] <p>Any tags assigned to the task.</p>
-- * ConversionTaskId [String] <p>The ID of the conversion task.</p>
-- * State [ConversionTaskState] <p>The state of the conversion task.</p>
-- * ExpirationTime [String] <p>The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel the task.</p>
-- * StatusMessage [String] <p>The status message related to the conversion task.</p>
-- Required key: ConversionTaskId
-- Required key: State
-- @return ConversionTask structure as a key-value pair table
function M.ConversionTask(args)
	assert(args, "You must provdide an argument table when creating ConversionTask")
	local t = { 
		["ImportInstance"] = args["ImportInstance"],
		["ImportVolume"] = args["ImportVolume"],
		["Tags"] = args["Tags"],
		["ConversionTaskId"] = args["ConversionTaskId"],
		["State"] = args["State"],
		["ExpirationTime"] = args["ExpirationTime"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertConversionTask(t)
	return t
end

keys.CreateVpcEndpointResult = { ["VpcEndpoint"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateVpcEndpointResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointResult to be of type 'table'")
	if struct["VpcEndpoint"] then asserts.AssertVpcEndpoint(struct["VpcEndpoint"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointResult[k], "CreateVpcEndpointResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointResult
-- <p>Contains the output of CreateVpcEndpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpoint [VpcEndpoint] <p>Information about the endpoint.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
-- @return CreateVpcEndpointResult structure as a key-value pair table
function M.CreateVpcEndpointResult(args)
	assert(args, "You must provdide an argument table when creating CreateVpcEndpointResult")
	local t = { 
		["VpcEndpoint"] = args["VpcEndpoint"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateVpcEndpointResult(t)
	return t
end

keys.DescribeSpotPriceHistoryResult = { ["NextToken"] = true, ["SpotPriceHistory"] = true, nil }

function asserts.AssertDescribeSpotPriceHistoryResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotPriceHistoryResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["SpotPriceHistory"] then asserts.AssertSpotPriceHistoryList(struct["SpotPriceHistory"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotPriceHistoryResult[k], "DescribeSpotPriceHistoryResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotPriceHistoryResult
-- <p>Contains the output of DescribeSpotPriceHistory.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- * SpotPriceHistory [SpotPriceHistoryList] <p>The historical Spot prices.</p>
-- @return DescribeSpotPriceHistoryResult structure as a key-value pair table
function M.DescribeSpotPriceHistoryResult(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotPriceHistoryResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["SpotPriceHistory"] = args["SpotPriceHistory"],
	}
	asserts.AssertDescribeSpotPriceHistoryResult(t)
	return t
end

keys.DescribeScheduledInstanceAvailabilityRequest = { ["DryRun"] = true, ["Filters"] = true, ["MinSlotDurationInHours"] = true, ["MaxResults"] = true, ["FirstSlotStartTimeRange"] = true, ["Recurrence"] = true, ["MaxSlotDurationInHours"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeScheduledInstanceAvailabilityRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstanceAvailabilityRequest to be of type 'table'")
	assert(struct["FirstSlotStartTimeRange"], "Expected key FirstSlotStartTimeRange to exist in table")
	assert(struct["Recurrence"], "Expected key Recurrence to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MinSlotDurationInHours"] then asserts.AssertInteger(struct["MinSlotDurationInHours"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["FirstSlotStartTimeRange"] then asserts.AssertSlotDateTimeRangeRequest(struct["FirstSlotStartTimeRange"]) end
	if struct["Recurrence"] then asserts.AssertScheduledInstanceRecurrenceRequest(struct["Recurrence"]) end
	if struct["MaxSlotDurationInHours"] then asserts.AssertInteger(struct["MaxSlotDurationInHours"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstanceAvailabilityRequest[k], "DescribeScheduledInstanceAvailabilityRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstanceAvailabilityRequest
-- <p>Contains the parameters for DescribeScheduledInstanceAvailability.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p> </li> <li> <p> <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p> </li> <li> <p> <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p> </li> <li> <p> <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p> </li> </ul>
-- * MinSlotDurationInHours [Integer] <p>The minimum available duration, in hours. The minimum required duration is 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 300. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * FirstSlotStartTimeRange [SlotDateTimeRangeRequest] <p>The time period for the first schedule to start.</p>
-- * Recurrence [ScheduledInstanceRecurrenceRequest] <p>The schedule recurrence.</p>
-- * MaxSlotDurationInHours [Integer] <p>The maximum available duration, in hours. This value must be greater than <code>MinSlotDurationInHours</code> and less than 1,720.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- Required key: FirstSlotStartTimeRange
-- Required key: Recurrence
-- @return DescribeScheduledInstanceAvailabilityRequest structure as a key-value pair table
function M.DescribeScheduledInstanceAvailabilityRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeScheduledInstanceAvailabilityRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["MinSlotDurationInHours"] = args["MinSlotDurationInHours"],
		["MaxResults"] = args["MaxResults"],
		["FirstSlotStartTimeRange"] = args["FirstSlotStartTimeRange"],
		["Recurrence"] = args["Recurrence"],
		["MaxSlotDurationInHours"] = args["MaxSlotDurationInHours"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeScheduledInstanceAvailabilityRequest(t)
	return t
end

keys.DescribeNatGatewaysResult = { ["NextToken"] = true, ["NatGateways"] = true, nil }

function asserts.AssertDescribeNatGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNatGatewaysResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["NatGateways"] then asserts.AssertNatGatewayList(struct["NatGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNatGatewaysResult[k], "DescribeNatGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNatGatewaysResult
-- <p>Contains the output of DescribeNatGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * NatGateways [NatGatewayList] <p>Information about the NAT gateways.</p>
-- @return DescribeNatGatewaysResult structure as a key-value pair table
function M.DescribeNatGatewaysResult(args)
	assert(args, "You must provdide an argument table when creating DescribeNatGatewaysResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["NatGateways"] = args["NatGateways"],
	}
	asserts.AssertDescribeNatGatewaysResult(t)
	return t
end

keys.ReplaceIamInstanceProfileAssociationResult = { ["IamInstanceProfileAssociation"] = true, nil }

function asserts.AssertReplaceIamInstanceProfileAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceIamInstanceProfileAssociationResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then asserts.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceIamInstanceProfileAssociationResult[k], "ReplaceIamInstanceProfileAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceIamInstanceProfileAssociationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
-- @return ReplaceIamInstanceProfileAssociationResult structure as a key-value pair table
function M.ReplaceIamInstanceProfileAssociationResult(args)
	assert(args, "You must provdide an argument table when creating ReplaceIamInstanceProfileAssociationResult")
	local t = { 
		["IamInstanceProfileAssociation"] = args["IamInstanceProfileAssociation"],
	}
	asserts.AssertReplaceIamInstanceProfileAssociationResult(t)
	return t
end

keys.ProvisionedBandwidth = { ["Status"] = true, ["Provisioned"] = true, ["RequestTime"] = true, ["Requested"] = true, ["ProvisionTime"] = true, nil }

function asserts.AssertProvisionedBandwidth(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProvisionedBandwidth to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["Provisioned"] then asserts.AssertString(struct["Provisioned"]) end
	if struct["RequestTime"] then asserts.AssertDateTime(struct["RequestTime"]) end
	if struct["Requested"] then asserts.AssertString(struct["Requested"]) end
	if struct["ProvisionTime"] then asserts.AssertDateTime(struct["ProvisionTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.ProvisionedBandwidth[k], "ProvisionedBandwidth contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProvisionedBandwidth
-- <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * Provisioned [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * RequestTime [DateTime] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * Requested [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * ProvisionTime [DateTime] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @return ProvisionedBandwidth structure as a key-value pair table
function M.ProvisionedBandwidth(args)
	assert(args, "You must provdide an argument table when creating ProvisionedBandwidth")
	local t = { 
		["Status"] = args["Status"],
		["Provisioned"] = args["Provisioned"],
		["RequestTime"] = args["RequestTime"],
		["Requested"] = args["Requested"],
		["ProvisionTime"] = args["ProvisionTime"],
	}
	asserts.AssertProvisionedBandwidth(t)
	return t
end

keys.DescribePlacementGroupsResult = { ["PlacementGroups"] = true, nil }

function asserts.AssertDescribePlacementGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePlacementGroupsResult to be of type 'table'")
	if struct["PlacementGroups"] then asserts.AssertPlacementGroupList(struct["PlacementGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePlacementGroupsResult[k], "DescribePlacementGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePlacementGroupsResult
-- <p>Contains the output of DescribePlacementGroups.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PlacementGroups [PlacementGroupList] <p>One or more placement groups.</p>
-- @return DescribePlacementGroupsResult structure as a key-value pair table
function M.DescribePlacementGroupsResult(args)
	assert(args, "You must provdide an argument table when creating DescribePlacementGroupsResult")
	local t = { 
		["PlacementGroups"] = args["PlacementGroups"],
	}
	asserts.AssertDescribePlacementGroupsResult(t)
	return t
end

keys.UnmonitorInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertUnmonitorInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnmonitorInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnmonitorInstancesRequest[k], "UnmonitorInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnmonitorInstancesRequest
-- <p>Contains the parameters for UnmonitorInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return UnmonitorInstancesRequest structure as a key-value pair table
function M.UnmonitorInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating UnmonitorInstancesRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertUnmonitorInstancesRequest(t)
	return t
end

keys.BundleInstanceResult = { ["BundleTask"] = true, nil }

function asserts.AssertBundleInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleInstanceResult to be of type 'table'")
	if struct["BundleTask"] then asserts.AssertBundleTask(struct["BundleTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleInstanceResult[k], "BundleInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleInstanceResult
-- <p>Contains the output of BundleInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BundleTask [BundleTask] <p>Information about the bundle task.</p>
-- @return BundleInstanceResult structure as a key-value pair table
function M.BundleInstanceResult(args)
	assert(args, "You must provdide an argument table when creating BundleInstanceResult")
	local t = { 
		["BundleTask"] = args["BundleTask"],
	}
	asserts.AssertBundleInstanceResult(t)
	return t
end

keys.AccountAttributeValue = { ["AttributeValue"] = true, nil }

function asserts.AssertAccountAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AccountAttributeValue to be of type 'table'")
	if struct["AttributeValue"] then asserts.AssertString(struct["AttributeValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.AccountAttributeValue[k], "AccountAttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AccountAttributeValue
-- <p>Describes a value of an account attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AttributeValue [String] <p>The value of the attribute.</p>
-- @return AccountAttributeValue structure as a key-value pair table
function M.AccountAttributeValue(args)
	assert(args, "You must provdide an argument table when creating AccountAttributeValue")
	local t = { 
		["AttributeValue"] = args["AttributeValue"],
	}
	asserts.AssertAccountAttributeValue(t)
	return t
end

keys.DescribeHostReservationsRequest = { ["Filter"] = true, ["HostReservationIdSet"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeHostReservationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationsRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["HostReservationIdSet"] then asserts.AssertHostReservationIdSet(struct["HostReservationIdSet"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationsRequest[k], "DescribeHostReservationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-family</code> - The instance family (e.g., <code>m4</code>).</p> </li> <li> <p> <code>payment-option</code> - The payment option (<code>NoUpfront</code> | <code>PartialUpfront</code> | <code>AllUpfront</code>).</p> </li> <li> <p> <code>state</code> - The state of the reservation (<code>payment-pending</code> | <code>payment-failed</code> | <code>active</code> | <code>retired</code>).</p> </li> </ul>
-- * HostReservationIdSet [HostReservationIdSet] <p>One or more host reservation IDs.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500; if <code>maxResults</code> is given a larger value than 500, you will receive an error.</p>
-- @return DescribeHostReservationsRequest structure as a key-value pair table
function M.DescribeHostReservationsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeHostReservationsRequest")
	local t = { 
		["Filter"] = args["Filter"],
		["HostReservationIdSet"] = args["HostReservationIdSet"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeHostReservationsRequest(t)
	return t
end

keys.DescribeScheduledInstancesRequest = { ["ScheduledInstanceIds"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["SlotStartTimeRange"] = true, ["Filters"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstancesRequest to be of type 'table'")
	if struct["ScheduledInstanceIds"] then asserts.AssertScheduledInstanceIdRequestSet(struct["ScheduledInstanceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["SlotStartTimeRange"] then asserts.AssertSlotStartTimeRangeRequest(struct["SlotStartTimeRange"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstancesRequest[k], "DescribeScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstancesRequest
-- <p>Contains the parameters for DescribeScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ScheduledInstanceIds [ScheduledInstanceIdRequestSet] <p>One or more Scheduled Instance IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 100. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * SlotStartTimeRange [SlotStartTimeRangeRequest] <p>The time period for the first schedule to start.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p> </li> <li> <p> <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p> </li> <li> <p> <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p> </li> <li> <p> <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p> </li> </ul>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- @return DescribeScheduledInstancesRequest structure as a key-value pair table
function M.DescribeScheduledInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeScheduledInstancesRequest")
	local t = { 
		["ScheduledInstanceIds"] = args["ScheduledInstanceIds"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["SlotStartTimeRange"] = args["SlotStartTimeRange"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeScheduledInstancesRequest(t)
	return t
end

keys.GetConsoleScreenshotRequest = { ["InstanceId"] = true, ["WakeUp"] = true, ["DryRun"] = true, nil }

function asserts.AssertGetConsoleScreenshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleScreenshotRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["WakeUp"] then asserts.AssertBoolean(struct["WakeUp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleScreenshotRequest[k], "GetConsoleScreenshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleScreenshotRequest
-- <p>Contains the parameters for the request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * WakeUp [Boolean] <p>When set to <code>true</code>, acts as keystroke input and wakes up an instance that's in standby or "sleep" mode.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- @return GetConsoleScreenshotRequest structure as a key-value pair table
function M.GetConsoleScreenshotRequest(args)
	assert(args, "You must provdide an argument table when creating GetConsoleScreenshotRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["WakeUp"] = args["WakeUp"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertGetConsoleScreenshotRequest(t)
	return t
end

keys.NetworkAclAssociation = { ["SubnetId"] = true, ["NetworkAclId"] = true, ["NetworkAclAssociationId"] = true, nil }

function asserts.AssertNetworkAclAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAclAssociation to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["NetworkAclAssociationId"] then asserts.AssertString(struct["NetworkAclAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkAclAssociation[k], "NetworkAclAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAclAssociation
-- <p>Describes an association between a network ACL and a subnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * NetworkAclAssociationId [String] <p>The ID of the association between a network ACL and a subnet.</p>
-- @return NetworkAclAssociation structure as a key-value pair table
function M.NetworkAclAssociation(args)
	assert(args, "You must provdide an argument table when creating NetworkAclAssociation")
	local t = { 
		["SubnetId"] = args["SubnetId"],
		["NetworkAclId"] = args["NetworkAclId"],
		["NetworkAclAssociationId"] = args["NetworkAclAssociationId"],
	}
	asserts.AssertNetworkAclAssociation(t)
	return t
end

keys.DescribeExportTasksResult = { ["ExportTasks"] = true, nil }

function asserts.AssertDescribeExportTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeExportTasksResult to be of type 'table'")
	if struct["ExportTasks"] then asserts.AssertExportTaskList(struct["ExportTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeExportTasksResult[k], "DescribeExportTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeExportTasksResult
-- <p>Contains the output for DescribeExportTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExportTasks [ExportTaskList] <p>Information about the export tasks.</p>
-- @return DescribeExportTasksResult structure as a key-value pair table
function M.DescribeExportTasksResult(args)
	assert(args, "You must provdide an argument table when creating DescribeExportTasksResult")
	local t = { 
		["ExportTasks"] = args["ExportTasks"],
	}
	asserts.AssertDescribeExportTasksResult(t)
	return t
end

keys.CancelSpotFleetRequestsRequest = { ["SpotFleetRequestIds"] = true, ["DryRun"] = true, ["TerminateInstances"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsRequest to be of type 'table'")
	assert(struct["SpotFleetRequestIds"], "Expected key SpotFleetRequestIds to exist in table")
	assert(struct["TerminateInstances"], "Expected key TerminateInstances to exist in table")
	if struct["SpotFleetRequestIds"] then asserts.AssertValueStringList(struct["SpotFleetRequestIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TerminateInstances"] then asserts.AssertBoolean(struct["TerminateInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsRequest[k], "CancelSpotFleetRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsRequest
-- <p>Contains the parameters for CancelSpotFleetRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestIds [ValueStringList] <p>The IDs of the Spot fleet requests.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TerminateInstances [Boolean] <p>Indicates whether to terminate instances for a Spot fleet request if it is canceled successfully.</p>
-- Required key: SpotFleetRequestIds
-- Required key: TerminateInstances
-- @return CancelSpotFleetRequestsRequest structure as a key-value pair table
function M.CancelSpotFleetRequestsRequest(args)
	assert(args, "You must provdide an argument table when creating CancelSpotFleetRequestsRequest")
	local t = { 
		["SpotFleetRequestIds"] = args["SpotFleetRequestIds"],
		["DryRun"] = args["DryRun"],
		["TerminateInstances"] = args["TerminateInstances"],
	}
	asserts.AssertCancelSpotFleetRequestsRequest(t)
	return t
end

keys.DiskImage = { ["Volume"] = true, ["Image"] = true, ["Description"] = true, nil }

function asserts.AssertDiskImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImage to be of type 'table'")
	if struct["Volume"] then asserts.AssertVolumeDetail(struct["Volume"]) end
	if struct["Image"] then asserts.AssertDiskImageDetail(struct["Image"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImage[k], "DiskImage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImage
-- <p>Describes a disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Volume [VolumeDetail] <p>Information about the volume.</p>
-- * Image [DiskImageDetail] <p>Information about the disk image.</p>
-- * Description [String] <p>A description of the disk image.</p>
-- @return DiskImage structure as a key-value pair table
function M.DiskImage(args)
	assert(args, "You must provdide an argument table when creating DiskImage")
	local t = { 
		["Volume"] = args["Volume"],
		["Image"] = args["Image"],
		["Description"] = args["Description"],
	}
	asserts.AssertDiskImage(t)
	return t
end

keys.AttachInternetGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertAttachInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachInternetGatewayRequest[k], "AttachInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachInternetGatewayRequest
-- <p>Contains the parameters for AttachInternetGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- Required key: InternetGatewayId
-- Required key: VpcId
-- @return AttachInternetGatewayRequest structure as a key-value pair table
function M.AttachInternetGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating AttachInternetGatewayRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["InternetGatewayId"] = args["InternetGatewayId"],
	}
	asserts.AssertAttachInternetGatewayRequest(t)
	return t
end

keys.AttachClassicLinkVpcRequest = { ["InstanceId"] = true, ["VpcId"] = true, ["DryRun"] = true, ["Groups"] = true, nil }

function asserts.AssertAttachClassicLinkVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachClassicLinkVpcRequest to be of type 'table'")
	assert(struct["Groups"], "Expected key Groups to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Groups"] then asserts.AssertGroupIdStringList(struct["Groups"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachClassicLinkVpcRequest[k], "AttachClassicLinkVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachClassicLinkVpcRequest
-- <p>Contains the parameters for AttachClassicLinkVpc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of an EC2-Classic instance to link to the ClassicLink-enabled VPC.</p>
-- * VpcId [String] <p>The ID of a ClassicLink-enabled VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Groups [GroupIdStringList] <p>The ID of one or more of the VPC's security groups. You cannot specify security groups from a different VPC.</p>
-- Required key: Groups
-- Required key: InstanceId
-- Required key: VpcId
-- @return AttachClassicLinkVpcRequest structure as a key-value pair table
function M.AttachClassicLinkVpcRequest(args)
	assert(args, "You must provdide an argument table when creating AttachClassicLinkVpcRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["Groups"] = args["Groups"],
	}
	asserts.AssertAttachClassicLinkVpcRequest(t)
	return t
end

keys.Storage = { ["S3"] = true, nil }

function asserts.AssertStorage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Storage to be of type 'table'")
	if struct["S3"] then asserts.AssertS3Storage(struct["S3"]) end
	for k,_ in pairs(struct) do
		assert(keys.Storage[k], "Storage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Storage
-- <p>Describes the storage location for an instance store-backed AMI.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3 [S3Storage] <p>An Amazon S3 storage location.</p>
-- @return Storage structure as a key-value pair table
function M.Storage(args)
	assert(args, "You must provdide an argument table when creating Storage")
	local t = { 
		["S3"] = args["S3"],
	}
	asserts.AssertStorage(t)
	return t
end

keys.DescribeMovingAddressesRequest = { ["PublicIps"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeMovingAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMovingAddressesRequest to be of type 'table'")
	if struct["PublicIps"] then asserts.AssertValueStringList(struct["PublicIps"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMovingAddressesRequest[k], "DescribeMovingAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMovingAddressesRequest
-- <p>Contains the parameters for DescribeMovingAddresses.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIps [ValueStringList] <p>One or more Elastic IP addresses.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value outside of this range, an error is returned.</p> <p>Default: If no value is provided, the default is 1000.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>moving-status</code> - The status of the Elastic IP address (<code>MovingToVpc</code> | <code>RestoringToClassic</code>).</p> </li> </ul>
-- @return DescribeMovingAddressesRequest structure as a key-value pair table
function M.DescribeMovingAddressesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeMovingAddressesRequest")
	local t = { 
		["PublicIps"] = args["PublicIps"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeMovingAddressesRequest(t)
	return t
end

keys.CopySnapshotRequest = { ["DryRun"] = true, ["Description"] = true, ["Encrypted"] = true, ["PresignedUrl"] = true, ["SourceRegion"] = true, ["KmsKeyId"] = true, ["SourceSnapshotId"] = true, ["DestinationRegion"] = true, nil }

function asserts.AssertCopySnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopySnapshotRequest to be of type 'table'")
	assert(struct["SourceRegion"], "Expected key SourceRegion to exist in table")
	assert(struct["SourceSnapshotId"], "Expected key SourceSnapshotId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["PresignedUrl"] then asserts.AssertString(struct["PresignedUrl"]) end
	if struct["SourceRegion"] then asserts.AssertString(struct["SourceRegion"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["SourceSnapshotId"] then asserts.AssertString(struct["SourceSnapshotId"]) end
	if struct["DestinationRegion"] then asserts.AssertString(struct["DestinationRegion"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopySnapshotRequest[k], "CopySnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopySnapshotRequest
-- <p>Contains the parameters for CopySnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the EBS snapshot.</p>
-- * Encrypted [Boolean] <p>Specifies whether the destination snapshot should be encrypted. You can encrypt a copy of an unencrypted snapshot using this flag, but you cannot use it to create an unencrypted copy from an encrypted snapshot. Your default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with <code>KmsKeyId</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * PresignedUrl [String] <p>The pre-signed URL that facilitates copying an encrypted snapshot. This parameter is only required when copying an encrypted snapshot with the Amazon EC2 Query API; it is available as an optional parameter in all other cases. The <code>PresignedUrl</code> should use the snapshot source endpoint, the <code>CopySnapshot</code> action, and include the <code>SourceRegion</code>, <code>SourceSnapshotId</code>, and <code>DestinationRegion</code> parameters. The <code>PresignedUrl</code> must be signed using AWS Signature Version 4. Because EBS snapshots are stored in Amazon S3, the signing algorithm for this parameter uses the same logic that is described in <a href="http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">Authenticating Requests by Using Query Parameters (AWS Signature Version 4)</a> in the <i>Amazon Simple Storage Service API Reference</i>. An invalid or improperly signed <code>PresignedUrl</code> will cause the copy operation to fail asynchronously, and the snapshot will move to an <code>error</code> state.</p>
-- * SourceRegion [String] <p>The ID of the region that contains the snapshot to be copied.</p>
-- * KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when creating the snapshot copy. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. The specified CMK must exist in the region that the snapshot is being copied to. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set.</p>
-- * SourceSnapshotId [String] <p>The ID of the EBS snapshot to copy.</p>
-- * DestinationRegion [String] <p>The destination region to use in the <code>PresignedUrl</code> parameter of a snapshot copy operation. This parameter is only valid for specifying the destination region in a <code>PresignedUrl</code> parameter, where it is required.</p> <note> <p> <code>CopySnapshot</code> sends the snapshot copy to the regional endpoint that you send the HTTP request to, such as <code>ec2.us-east-1.amazonaws.com</code> (in the AWS CLI, this is specified with the <code>--region</code> parameter or the default region in your AWS configuration file).</p> </note>
-- Required key: SourceRegion
-- Required key: SourceSnapshotId
-- @return CopySnapshotRequest structure as a key-value pair table
function M.CopySnapshotRequest(args)
	assert(args, "You must provdide an argument table when creating CopySnapshotRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["Encrypted"] = args["Encrypted"],
		["PresignedUrl"] = args["PresignedUrl"],
		["SourceRegion"] = args["SourceRegion"],
		["KmsKeyId"] = args["KmsKeyId"],
		["SourceSnapshotId"] = args["SourceSnapshotId"],
		["DestinationRegion"] = args["DestinationRegion"],
	}
	asserts.AssertCopySnapshotRequest(t)
	return t
end

keys.ModifyVpcPeeringConnectionOptionsRequest = { ["DryRun"] = true, ["RequesterPeeringConnectionOptions"] = true, ["VpcPeeringConnectionId"] = true, ["AccepterPeeringConnectionOptions"] = true, nil }

function asserts.AssertModifyVpcPeeringConnectionOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcPeeringConnectionOptionsRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["RequesterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptionsRequest(struct["RequesterPeeringConnectionOptions"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["AccepterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptionsRequest(struct["AccepterPeeringConnectionOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcPeeringConnectionOptionsRequest[k], "ModifyVpcPeeringConnectionOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcPeeringConnectionOptionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * RequesterPeeringConnectionOptions [PeeringConnectionOptionsRequest] <p>The VPC peering connection options for the requester VPC.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- * AccepterPeeringConnectionOptions [PeeringConnectionOptionsRequest] <p>The VPC peering connection options for the accepter VPC.</p>
-- Required key: VpcPeeringConnectionId
-- @return ModifyVpcPeeringConnectionOptionsRequest structure as a key-value pair table
function M.ModifyVpcPeeringConnectionOptionsRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyVpcPeeringConnectionOptionsRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["RequesterPeeringConnectionOptions"] = args["RequesterPeeringConnectionOptions"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["AccepterPeeringConnectionOptions"] = args["AccepterPeeringConnectionOptions"],
	}
	asserts.AssertModifyVpcPeeringConnectionOptionsRequest(t)
	return t
end

keys.RequestSpotInstancesResult = { ["SpotInstanceRequests"] = true, nil }

function asserts.AssertRequestSpotInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotInstancesResult to be of type 'table'")
	if struct["SpotInstanceRequests"] then asserts.AssertSpotInstanceRequestList(struct["SpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotInstancesResult[k], "RequestSpotInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotInstancesResult
-- <p>Contains the output of RequestSpotInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceRequests [SpotInstanceRequestList] <p>One or more Spot instance requests.</p>
-- @return RequestSpotInstancesResult structure as a key-value pair table
function M.RequestSpotInstancesResult(args)
	assert(args, "You must provdide an argument table when creating RequestSpotInstancesResult")
	local t = { 
		["SpotInstanceRequests"] = args["SpotInstanceRequests"],
	}
	asserts.AssertRequestSpotInstancesResult(t)
	return t
end

keys.DeleteVpnGatewayRequest = { ["DryRun"] = true, ["VpnGatewayId"] = true, nil }

function asserts.AssertDeleteVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnGatewayRequest to be of type 'table'")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpnGatewayRequest[k], "DeleteVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnGatewayRequest
-- <p>Contains the parameters for DeleteVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required key: VpnGatewayId
-- @return DeleteVpnGatewayRequest structure as a key-value pair table
function M.DeleteVpnGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteVpnGatewayRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["VpnGatewayId"] = args["VpnGatewayId"],
	}
	asserts.AssertDeleteVpnGatewayRequest(t)
	return t
end

keys.InstanceAttribute = { ["ProductCodes"] = true, ["SourceDestCheck"] = true, ["UserData"] = true, ["InstanceId"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["Groups"] = true, ["KernelId"] = true, ["RamdiskId"] = true, ["RootDeviceName"] = true, ["DisableApiTermination"] = true, ["InstanceType"] = true, nil }

function asserts.AssertInstanceAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceAttribute to be of type 'table'")
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["UserData"] then asserts.AssertAttributeValue(struct["UserData"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["EnaSupport"] then asserts.AssertAttributeBooleanValue(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertAttributeValue(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertInstanceBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertAttributeBooleanValue(struct["EbsOptimized"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["KernelId"] then asserts.AssertAttributeValue(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertAttributeValue(struct["RamdiskId"]) end
	if struct["RootDeviceName"] then asserts.AssertAttributeValue(struct["RootDeviceName"]) end
	if struct["DisableApiTermination"] then asserts.AssertAttributeBooleanValue(struct["DisableApiTermination"]) end
	if struct["InstanceType"] then asserts.AssertAttributeValue(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceAttribute[k], "InstanceAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceAttribute
-- <p>Describes an instance attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- * SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT.</p>
-- * UserData [AttributeValue] <p>The user data.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * EnaSupport [AttributeBooleanValue] <p>Indicates whether enhanced networking with ENA is enabled.</p>
-- * SriovNetSupport [AttributeValue] <p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- * InstanceInitiatedShutdownBehavior [AttributeValue] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- * BlockDeviceMappings [InstanceBlockDeviceMappingList] <p>The block device mapping of the instance.</p>
-- * EbsOptimized [AttributeBooleanValue] <p>Indicates whether the instance is optimized for EBS I/O.</p>
-- * Groups [GroupIdentifierList] <p>The security groups associated with the instance.</p>
-- * KernelId [AttributeValue] <p>The kernel ID.</p>
-- * RamdiskId [AttributeValue] <p>The RAM disk ID.</p>
-- * RootDeviceName [AttributeValue] <p>The name of the root device (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p>
-- * DisableApiTermination [AttributeBooleanValue] <p>If the value is <code>true</code>, you can't terminate the instance through the Amazon EC2 console, CLI, or API; otherwise, you can.</p>
-- * InstanceType [AttributeValue] <p>The instance type.</p>
-- @return InstanceAttribute structure as a key-value pair table
function M.InstanceAttribute(args)
	assert(args, "You must provdide an argument table when creating InstanceAttribute")
	local t = { 
		["ProductCodes"] = args["ProductCodes"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["UserData"] = args["UserData"],
		["InstanceId"] = args["InstanceId"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["Groups"] = args["Groups"],
		["KernelId"] = args["KernelId"],
		["RamdiskId"] = args["RamdiskId"],
		["RootDeviceName"] = args["RootDeviceName"],
		["DisableApiTermination"] = args["DisableApiTermination"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertInstanceAttribute(t)
	return t
end

keys.DeleteEgressOnlyInternetGatewayResult = { ["ReturnCode"] = true, nil }

function asserts.AssertDeleteEgressOnlyInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteEgressOnlyInternetGatewayResult to be of type 'table'")
	if struct["ReturnCode"] then asserts.AssertBoolean(struct["ReturnCode"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteEgressOnlyInternetGatewayResult[k], "DeleteEgressOnlyInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteEgressOnlyInternetGatewayResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReturnCode [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DeleteEgressOnlyInternetGatewayResult structure as a key-value pair table
function M.DeleteEgressOnlyInternetGatewayResult(args)
	assert(args, "You must provdide an argument table when creating DeleteEgressOnlyInternetGatewayResult")
	local t = { 
		["ReturnCode"] = args["ReturnCode"],
	}
	asserts.AssertDeleteEgressOnlyInternetGatewayResult(t)
	return t
end

keys.DeleteNatGatewayRequest = { ["NatGatewayId"] = true, nil }

function asserts.AssertDeleteNatGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNatGatewayRequest to be of type 'table'")
	assert(struct["NatGatewayId"], "Expected key NatGatewayId to exist in table")
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNatGatewayRequest[k], "DeleteNatGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNatGatewayRequest
-- <p>Contains the parameters for DeleteNatGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- Required key: NatGatewayId
-- @return DeleteNatGatewayRequest structure as a key-value pair table
function M.DeleteNatGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteNatGatewayRequest")
	local t = { 
		["NatGatewayId"] = args["NatGatewayId"],
	}
	asserts.AssertDeleteNatGatewayRequest(t)
	return t
end

keys.CopySnapshotResult = { ["SnapshotId"] = true, nil }

function asserts.AssertCopySnapshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopySnapshotResult to be of type 'table'")
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopySnapshotResult[k], "CopySnapshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopySnapshotResult
-- <p>Contains the output of CopySnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SnapshotId [String] <p>The ID of the new snapshot.</p>
-- @return CopySnapshotResult structure as a key-value pair table
function M.CopySnapshotResult(args)
	assert(args, "You must provdide an argument table when creating CopySnapshotResult")
	local t = { 
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertCopySnapshotResult(t)
	return t
end

keys.InstanceBlockDeviceMappingSpecification = { ["VirtualName"] = true, ["DeviceName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertInstanceBlockDeviceMappingSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceBlockDeviceMappingSpecification to be of type 'table'")
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertEbsInstanceBlockDeviceSpecification(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceBlockDeviceMappingSpecification[k], "InstanceBlockDeviceMappingSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceBlockDeviceMappingSpecification
-- <p>Describes a block device mapping entry.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VirtualName [String] <p>The virtual device name.</p>
-- * DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * NoDevice [String] <p>suppress the specified device included in the block device mapping.</p>
-- * Ebs [EbsInstanceBlockDeviceSpecification] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
-- @return InstanceBlockDeviceMappingSpecification structure as a key-value pair table
function M.InstanceBlockDeviceMappingSpecification(args)
	assert(args, "You must provdide an argument table when creating InstanceBlockDeviceMappingSpecification")
	local t = { 
		["VirtualName"] = args["VirtualName"],
		["DeviceName"] = args["DeviceName"],
		["NoDevice"] = args["NoDevice"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertInstanceBlockDeviceMappingSpecification(t)
	return t
end

keys.StartInstancesRequest = { ["AdditionalInfo"] = true, ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertStartInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["AdditionalInfo"] then asserts.AssertString(struct["AdditionalInfo"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartInstancesRequest[k], "StartInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartInstancesRequest
-- <p>Contains the parameters for StartInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AdditionalInfo [String] <p>Reserved.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return StartInstancesRequest structure as a key-value pair table
function M.StartInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating StartInstancesRequest")
	local t = { 
		["AdditionalInfo"] = args["AdditionalInfo"],
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertStartInstancesRequest(t)
	return t
end

keys.DescribeIdFormatResult = { ["Statuses"] = true, nil }

function asserts.AssertDescribeIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdFormatResult to be of type 'table'")
	if struct["Statuses"] then asserts.AssertIdFormatList(struct["Statuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdFormatResult[k], "DescribeIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdFormatResult
-- <p>Contains the output of DescribeIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Statuses [IdFormatList] <p>Information about the ID format for the resource.</p>
-- @return DescribeIdFormatResult structure as a key-value pair table
function M.DescribeIdFormatResult(args)
	assert(args, "You must provdide an argument table when creating DescribeIdFormatResult")
	local t = { 
		["Statuses"] = args["Statuses"],
	}
	asserts.AssertDescribeIdFormatResult(t)
	return t
end

keys.CancelReservedInstancesListingResult = { ["ReservedInstancesListings"] = true, nil }

function asserts.AssertCancelReservedInstancesListingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelReservedInstancesListingResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then asserts.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelReservedInstancesListingResult[k], "CancelReservedInstancesListingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelReservedInstancesListingResult
-- <p>Contains the output of CancelReservedInstancesListing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesListings [ReservedInstancesListingList] <p>The Reserved Instance listing.</p>
-- @return CancelReservedInstancesListingResult structure as a key-value pair table
function M.CancelReservedInstancesListingResult(args)
	assert(args, "You must provdide an argument table when creating CancelReservedInstancesListingResult")
	local t = { 
		["ReservedInstancesListings"] = args["ReservedInstancesListings"],
	}
	asserts.AssertCancelReservedInstancesListingResult(t)
	return t
end

keys.RestoreAddressToClassicResult = { ["PublicIp"] = true, ["Status"] = true, nil }

function asserts.AssertRestoreAddressToClassicResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RestoreAddressToClassicResult to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["Status"] then asserts.AssertStatus(struct["Status"]) end
	for k,_ in pairs(struct) do
		assert(keys.RestoreAddressToClassicResult[k], "RestoreAddressToClassicResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RestoreAddressToClassicResult
-- <p>Contains the output of RestoreAddressToClassic.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * Status [Status] <p>The move status for the IP address.</p>
-- @return RestoreAddressToClassicResult structure as a key-value pair table
function M.RestoreAddressToClassicResult(args)
	assert(args, "You must provdide an argument table when creating RestoreAddressToClassicResult")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["Status"] = args["Status"],
	}
	asserts.AssertRestoreAddressToClassicResult(t)
	return t
end

keys.PrefixListId = { ["PrefixListId"] = true, nil }

function asserts.AssertPrefixListId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrefixListId to be of type 'table'")
	if struct["PrefixListId"] then asserts.AssertString(struct["PrefixListId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrefixListId[k], "PrefixListId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrefixListId
-- <p>The ID of the prefix.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrefixListId [String] <p>The ID of the prefix.</p>
-- @return PrefixListId structure as a key-value pair table
function M.PrefixListId(args)
	assert(args, "You must provdide an argument table when creating PrefixListId")
	local t = { 
		["PrefixListId"] = args["PrefixListId"],
	}
	asserts.AssertPrefixListId(t)
	return t
end

keys.Placement = { ["HostId"] = true, ["AvailabilityZone"] = true, ["SpreadDomain"] = true, ["GroupName"] = true, ["Tenancy"] = true, ["Affinity"] = true, nil }

function asserts.AssertPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Placement to be of type 'table'")
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["SpreadDomain"] then asserts.AssertString(struct["SpreadDomain"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["Tenancy"] then asserts.AssertTenancy(struct["Tenancy"]) end
	if struct["Affinity"] then asserts.AssertString(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(keys.Placement[k], "Placement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Placement
-- <p>Describes the placement of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostId [String] <p>The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the <a>ImportInstance</a> command.</p>
-- * AvailabilityZone [String] <p>The Availability Zone of the instance.</p>
-- * SpreadDomain [String] <p>Reserved for future use.</p>
-- * GroupName [String] <p>The name of the placement group the instance is in (for cluster compute instances).</p>
-- * Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for the <a>ImportInstance</a> command.</p>
-- * Affinity [String] <p>The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the <a>ImportInstance</a> command.</p>
-- @return Placement structure as a key-value pair table
function M.Placement(args)
	assert(args, "You must provdide an argument table when creating Placement")
	local t = { 
		["HostId"] = args["HostId"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["SpreadDomain"] = args["SpreadDomain"],
		["GroupName"] = args["GroupName"],
		["Tenancy"] = args["Tenancy"],
		["Affinity"] = args["Affinity"],
	}
	asserts.AssertPlacement(t)
	return t
end

keys.ScheduledInstancesBlockDeviceMapping = { ["VirtualName"] = true, ["DeviceName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertScheduledInstancesBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesBlockDeviceMapping to be of type 'table'")
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertScheduledInstancesEbs(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesBlockDeviceMapping[k], "ScheduledInstancesBlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesBlockDeviceMapping
-- <p>Describes a block device mapping for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VirtualName [String] <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with two available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
-- * DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- * Ebs [ScheduledInstancesEbs] <p>Parameters used to set up EBS volumes automatically when the instance is launched.</p>
-- @return ScheduledInstancesBlockDeviceMapping structure as a key-value pair table
function M.ScheduledInstancesBlockDeviceMapping(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstancesBlockDeviceMapping")
	local t = { 
		["VirtualName"] = args["VirtualName"],
		["DeviceName"] = args["DeviceName"],
		["NoDevice"] = args["NoDevice"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertScheduledInstancesBlockDeviceMapping(t)
	return t
end

keys.CreateVolumePermissionModifications = { ["Add"] = true, ["Remove"] = true, nil }

function asserts.AssertCreateVolumePermissionModifications(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumePermissionModifications to be of type 'table'")
	if struct["Add"] then asserts.AssertCreateVolumePermissionList(struct["Add"]) end
	if struct["Remove"] then asserts.AssertCreateVolumePermissionList(struct["Remove"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVolumePermissionModifications[k], "CreateVolumePermissionModifications contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumePermissionModifications
-- <p>Describes modifications to the permissions for a volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Add [CreateVolumePermissionList] <p>Adds a specific AWS account ID or group to a volume's list of create volume permissions.</p>
-- * Remove [CreateVolumePermissionList] <p>Removes a specific AWS account ID or group from a volume's list of create volume permissions.</p>
-- @return CreateVolumePermissionModifications structure as a key-value pair table
function M.CreateVolumePermissionModifications(args)
	assert(args, "You must provdide an argument table when creating CreateVolumePermissionModifications")
	local t = { 
		["Add"] = args["Add"],
		["Remove"] = args["Remove"],
	}
	asserts.AssertCreateVolumePermissionModifications(t)
	return t
end

keys.EbsBlockDevice = { ["VolumeSize"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["DeleteOnTermination"] = true, ["SnapshotId"] = true, ["Iops"] = true, nil }

function asserts.AssertEbsBlockDevice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsBlockDevice to be of type 'table'")
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	for k,_ in pairs(struct) do
		assert(keys.EbsBlockDevice[k], "EbsBlockDevice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsBlockDevice
-- <p>Describes a block device for an EBS volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeSize [Integer] <p>The size of the volume, in GiB.</p> <p>Constraints: 1-16384 for General Purpose SSD (<code>gp2</code>), 4-16384 for Provisioned IOPS SSD (<code>io1</code>), 500-16384 for Throughput Optimized HDD (<code>st1</code>), 500-16384 for Cold HDD (<code>sc1</code>), and 1-1024 for Magnetic (<code>standard</code>) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- * Encrypted [Boolean] <p>Indicates whether the EBS volume is encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption.</p>
-- * VolumeType [VolumeType] <p>The volume type: <code>gp2</code>, <code>io1</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code>.</p> <p>Default: <code>standard</code> </p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- * Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For <code>io1</code>, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code>, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for <code>io1</code> volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
-- @return EbsBlockDevice structure as a key-value pair table
function M.EbsBlockDevice(args)
	assert(args, "You must provdide an argument table when creating EbsBlockDevice")
	local t = { 
		["VolumeSize"] = args["VolumeSize"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["SnapshotId"] = args["SnapshotId"],
		["Iops"] = args["Iops"],
	}
	asserts.AssertEbsBlockDevice(t)
	return t
end

keys.TargetConfiguration = { ["InstanceCount"] = true, ["OfferingId"] = true, nil }

function asserts.AssertTargetConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetConfiguration to be of type 'table'")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetConfiguration[k], "TargetConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetConfiguration
-- <p>Information about the Convertible Reserved Instance offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceCount [Integer] <p>The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>
-- * OfferingId [String] <p>The ID of the Convertible Reserved Instance offering.</p>
-- @return TargetConfiguration structure as a key-value pair table
function M.TargetConfiguration(args)
	assert(args, "You must provdide an argument table when creating TargetConfiguration")
	local t = { 
		["InstanceCount"] = args["InstanceCount"],
		["OfferingId"] = args["OfferingId"],
	}
	asserts.AssertTargetConfiguration(t)
	return t
end

keys.DescribeVolumesModificationsRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["VolumeIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVolumesModificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesModificationsRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeIds"] then asserts.AssertVolumeIdStringList(struct["VolumeIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesModificationsRequest[k], "DescribeVolumesModificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesModificationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of results (up to a limit of 500) to be returned in a paginated request.</p>
-- * NextToken [String] <p>The <code>nextToken</code> value returned by a previous paginated request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeIds [VolumeIdStringList] <p>One or more volume IDs for which in-progress modifications will be described.</p>
-- * Filters [FilterList] <p>One or more filters. Supported filters: <code>volume-id</code>, <code>modification-state</code>, <code>target-size</code>, <code>target-iops</code>, <code>target-volume-type</code>, <code>original-size</code>, <code>original-iops</code>, <code>original-volume-type</code>, <code>start-time</code>. </p>
-- @return DescribeVolumesModificationsRequest structure as a key-value pair table
function M.DescribeVolumesModificationsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVolumesModificationsRequest")
	local t = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["VolumeIds"] = args["VolumeIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVolumesModificationsRequest(t)
	return t
end

keys.UserData = { ["Data"] = true, nil }

function asserts.AssertUserData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserData to be of type 'table'")
	if struct["Data"] then asserts.AssertString(struct["Data"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserData[k], "UserData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserData
-- <p>Describes the user data for an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Data [String] <p>The user data. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @return UserData structure as a key-value pair table
function M.UserData(args)
	assert(args, "You must provdide an argument table when creating UserData")
	local t = { 
		["Data"] = args["Data"],
	}
	asserts.AssertUserData(t)
	return t
end

keys.ImportInstanceVolumeDetailItem = { ["Status"] = true, ["AvailabilityZone"] = true, ["Description"] = true, ["Image"] = true, ["Volume"] = true, ["BytesConverted"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertImportInstanceVolumeDetailItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceVolumeDetailItem to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["BytesConverted"], "Expected key BytesConverted to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Status"], "Expected key Status to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Image"] then asserts.AssertDiskImageDescription(struct["Image"]) end
	if struct["Volume"] then asserts.AssertDiskImageVolumeDescription(struct["Volume"]) end
	if struct["BytesConverted"] then asserts.AssertLong(struct["BytesConverted"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceVolumeDetailItem[k], "ImportInstanceVolumeDetailItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceVolumeDetailItem
-- <p>Describes an import volume task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>The status of the import of this particular disk image.</p>
-- * AvailabilityZone [String] <p>The Availability Zone where the resulting instance will reside.</p>
-- * Description [String] <p>A description of the task.</p>
-- * Image [DiskImageDescription] <p>The image.</p>
-- * Volume [DiskImageVolumeDescription] <p>The volume.</p>
-- * BytesConverted [Long] <p>The number of bytes converted so far.</p>
-- * StatusMessage [String] <p>The status information or errors related to the disk image.</p>
-- Required key: AvailabilityZone
-- Required key: BytesConverted
-- Required key: Image
-- Required key: Status
-- Required key: Volume
-- @return ImportInstanceVolumeDetailItem structure as a key-value pair table
function M.ImportInstanceVolumeDetailItem(args)
	assert(args, "You must provdide an argument table when creating ImportInstanceVolumeDetailItem")
	local t = { 
		["Status"] = args["Status"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Description"] = args["Description"],
		["Image"] = args["Image"],
		["Volume"] = args["Volume"],
		["BytesConverted"] = args["BytesConverted"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertImportInstanceVolumeDetailItem(t)
	return t
end

keys.DescribeReservedInstancesModificationsRequest = { ["NextToken"] = true, ["ReservedInstancesModificationIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeReservedInstancesModificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesModificationsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesModificationIds"] then asserts.AssertReservedInstancesModificationIdStringList(struct["ReservedInstancesModificationIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesModificationsRequest[k], "DescribeReservedInstancesModificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesModificationsRequest
-- <p>Contains the parameters for DescribeReservedInstancesModifications.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * ReservedInstancesModificationIds [ReservedInstancesModificationIdStringList] <p>IDs for the submitted modification request.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>client-token</code> - The idempotency token for the modification request.</p> </li> <li> <p> <code>create-date</code> - The time when the modification request was created.</p> </li> <li> <p> <code>effective-date</code> - The time when the modification becomes effective.</p> </li> <li> <p> <code>modification-result.reserved-instances-id</code> - The ID for the Reserved Instances created as part of the modification request. This ID is only available when the status of the modification is <code>fulfilled</code>.</p> </li> <li> <p> <code>modification-result.target-configuration.availability-zone</code> - The Availability Zone for the new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.instance-count </code> - The number of new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.instance-type</code> - The instance type of the new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.platform</code> - The network platform of the new Reserved Instances (<code>EC2-Classic</code> | <code>EC2-VPC</code>).</p> </li> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instances modified.</p> </li> <li> <p> <code>reserved-instances-modification-id</code> - The ID of the modification request.</p> </li> <li> <p> <code>status</code> - The status of the Reserved Instances modification request (<code>processing</code> | <code>fulfilled</code> | <code>failed</code>).</p> </li> <li> <p> <code>status-message</code> - The reason for the status.</p> </li> <li> <p> <code>update-date</code> - The time when the modification request was last updated.</p> </li> </ul>
-- @return DescribeReservedInstancesModificationsRequest structure as a key-value pair table
function M.DescribeReservedInstancesModificationsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeReservedInstancesModificationsRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["ReservedInstancesModificationIds"] = args["ReservedInstancesModificationIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeReservedInstancesModificationsRequest(t)
	return t
end

keys.DescribeIdFormatRequest = { ["Resource"] = true, nil }

function asserts.AssertDescribeIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdFormatRequest to be of type 'table'")
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdFormatRequest[k], "DescribeIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdFormatRequest
-- <p>Contains the parameters for DescribeIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- @return DescribeIdFormatRequest structure as a key-value pair table
function M.DescribeIdFormatRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeIdFormatRequest")
	local t = { 
		["Resource"] = args["Resource"],
	}
	asserts.AssertDescribeIdFormatRequest(t)
	return t
end

keys.CreateSecurityGroupRequest = { ["GroupName"] = true, ["VpcId"] = true, ["DryRun"] = true, ["Description"] = true, nil }

function asserts.AssertCreateSecurityGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityGroupRequest to be of type 'table'")
	assert(struct["Description"], "Expected key Description to exist in table")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSecurityGroupRequest[k], "CreateSecurityGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityGroupRequest
-- <p>Contains the parameters for CreateSecurityGroup.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the security group.</p> <p>Constraints: Up to 255 characters in length</p> <p>Constraints for EC2-Classic: ASCII characters</p> <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
-- * VpcId [String] <p>[EC2-VPC] The ID of the VPC. Required for EC2-VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the security group. This is informational only.</p> <p>Constraints: Up to 255 characters in length</p> <p>Constraints for EC2-Classic: ASCII characters</p> <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
-- Required key: Description
-- Required key: GroupName
-- @return CreateSecurityGroupRequest structure as a key-value pair table
function M.CreateSecurityGroupRequest(args)
	assert(args, "You must provdide an argument table when creating CreateSecurityGroupRequest")
	local t = { 
		["GroupName"] = args["GroupName"],
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
	}
	asserts.AssertCreateSecurityGroupRequest(t)
	return t
end

keys.BundleTaskError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertBundleTaskError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleTaskError to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleTaskError[k], "BundleTaskError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleTaskError
-- <p>Describes an error for <a>BundleInstance</a>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The error message.</p>
-- * Code [String] <p>The error code.</p>
-- @return BundleTaskError structure as a key-value pair table
function M.BundleTaskError(args)
	assert(args, "You must provdide an argument table when creating BundleTaskError")
	local t = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertBundleTaskError(t)
	return t
end

keys.CreateFlowLogsRequest = { ["ResourceType"] = true, ["LogGroupName"] = true, ["TrafficType"] = true, ["ResourceIds"] = true, ["DeliverLogsPermissionArn"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFlowLogsRequest to be of type 'table'")
	assert(struct["DeliverLogsPermissionArn"], "Expected key DeliverLogsPermissionArn to exist in table")
	assert(struct["LogGroupName"], "Expected key LogGroupName to exist in table")
	assert(struct["ResourceIds"], "Expected key ResourceIds to exist in table")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	assert(struct["TrafficType"], "Expected key TrafficType to exist in table")
	if struct["ResourceType"] then asserts.AssertFlowLogsResourceType(struct["ResourceType"]) end
	if struct["LogGroupName"] then asserts.AssertString(struct["LogGroupName"]) end
	if struct["TrafficType"] then asserts.AssertTrafficType(struct["TrafficType"]) end
	if struct["ResourceIds"] then asserts.AssertValueStringList(struct["ResourceIds"]) end
	if struct["DeliverLogsPermissionArn"] then asserts.AssertString(struct["DeliverLogsPermissionArn"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFlowLogsRequest[k], "CreateFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFlowLogsRequest
-- <p>Contains the parameters for CreateFlowLogs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [FlowLogsResourceType] <p>The type of resource on which to create the flow log.</p>
-- * LogGroupName [String] <p>The name of the CloudWatch log group.</p>
-- * TrafficType [TrafficType] <p>The type of traffic to log.</p>
-- * ResourceIds [ValueStringList] <p>One or more subnet, network interface, or VPC IDs.</p> <p>Constraints: Maximum of 1000 resources</p>
-- * DeliverLogsPermissionArn [String] <p>The ARN for the IAM role that's used to post flow logs to a CloudWatch Logs log group.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required key: DeliverLogsPermissionArn
-- Required key: LogGroupName
-- Required key: ResourceIds
-- Required key: ResourceType
-- Required key: TrafficType
-- @return CreateFlowLogsRequest structure as a key-value pair table
function M.CreateFlowLogsRequest(args)
	assert(args, "You must provdide an argument table when creating CreateFlowLogsRequest")
	local t = { 
		["ResourceType"] = args["ResourceType"],
		["LogGroupName"] = args["LogGroupName"],
		["TrafficType"] = args["TrafficType"],
		["ResourceIds"] = args["ResourceIds"],
		["DeliverLogsPermissionArn"] = args["DeliverLogsPermissionArn"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateFlowLogsRequest(t)
	return t
end

keys.S3Storage = { ["UploadPolicySignature"] = true, ["Prefix"] = true, ["AWSAccessKeyId"] = true, ["Bucket"] = true, ["UploadPolicy"] = true, nil }

function asserts.AssertS3Storage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected S3Storage to be of type 'table'")
	if struct["UploadPolicySignature"] then asserts.AssertString(struct["UploadPolicySignature"]) end
	if struct["Prefix"] then asserts.AssertString(struct["Prefix"]) end
	if struct["AWSAccessKeyId"] then asserts.AssertString(struct["AWSAccessKeyId"]) end
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	if struct["UploadPolicy"] then asserts.AssertBlob(struct["UploadPolicy"]) end
	for k,_ in pairs(struct) do
		assert(keys.S3Storage[k], "S3Storage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type S3Storage
-- <p>Describes the storage parameters for S3 and S3 buckets for an instance store-backed AMI.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UploadPolicySignature [String] <p>The signature of the JSON document.</p>
-- * Prefix [String] <p>The beginning of the file name of the AMI.</p>
-- * AWSAccessKeyId [String] <p>The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance in <a href="http://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html">Best Practices for Managing AWS Access Keys</a>.</p>
-- * Bucket [String] <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
-- * UploadPolicy [Blob] <p>An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.</p>
-- @return S3Storage structure as a key-value pair table
function M.S3Storage(args)
	assert(args, "You must provdide an argument table when creating S3Storage")
	local t = { 
		["UploadPolicySignature"] = args["UploadPolicySignature"],
		["Prefix"] = args["Prefix"],
		["AWSAccessKeyId"] = args["AWSAccessKeyId"],
		["Bucket"] = args["Bucket"],
		["UploadPolicy"] = args["UploadPolicy"],
	}
	asserts.AssertS3Storage(t)
	return t
end

keys.EnableVgwRoutePropagationRequest = { ["GatewayId"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertEnableVgwRoutePropagationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVgwRoutePropagationRequest to be of type 'table'")
	assert(struct["GatewayId"], "Expected key GatewayId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVgwRoutePropagationRequest[k], "EnableVgwRoutePropagationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVgwRoutePropagationRequest
-- <p>Contains the parameters for EnableVgwRoutePropagation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GatewayId [String] <p>The ID of the virtual private gateway.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- Required key: GatewayId
-- Required key: RouteTableId
-- @return EnableVgwRoutePropagationRequest structure as a key-value pair table
function M.EnableVgwRoutePropagationRequest(args)
	assert(args, "You must provdide an argument table when creating EnableVgwRoutePropagationRequest")
	local t = { 
		["GatewayId"] = args["GatewayId"],
		["RouteTableId"] = args["RouteTableId"],
	}
	asserts.AssertEnableVgwRoutePropagationRequest(t)
	return t
end

keys.IamInstanceProfileAssociation = { ["InstanceId"] = true, ["Timestamp"] = true, ["State"] = true, ["AssociationId"] = true, ["IamInstanceProfile"] = true, nil }

function asserts.AssertIamInstanceProfileAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfileAssociation to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	if struct["State"] then asserts.AssertIamInstanceProfileAssociationState(struct["State"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfile(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(keys.IamInstanceProfileAssociation[k], "IamInstanceProfileAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfileAssociation
-- <p>Describes an association between an IAM instance profile and an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Timestamp [DateTime] <p>The time the IAM instance profile was associated with the instance.</p>
-- * State [IamInstanceProfileAssociationState] <p>The state of the association.</p>
-- * AssociationId [String] <p>The ID of the association.</p>
-- * IamInstanceProfile [IamInstanceProfile] <p>The IAM instance profile.</p>
-- @return IamInstanceProfileAssociation structure as a key-value pair table
function M.IamInstanceProfileAssociation(args)
	assert(args, "You must provdide an argument table when creating IamInstanceProfileAssociation")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["Timestamp"] = args["Timestamp"],
		["State"] = args["State"],
		["AssociationId"] = args["AssociationId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
	}
	asserts.AssertIamInstanceProfileAssociation(t)
	return t
end

keys.ScheduledInstance = { ["AvailabilityZone"] = true, ["ScheduledInstanceId"] = true, ["HourlyPrice"] = true, ["CreateDate"] = true, ["Recurrence"] = true, ["Platform"] = true, ["TermEndDate"] = true, ["InstanceCount"] = true, ["SlotDurationInHours"] = true, ["PreviousSlotEndTime"] = true, ["TermStartDate"] = true, ["NetworkPlatform"] = true, ["TotalScheduledInstanceHours"] = true, ["NextSlotStartTime"] = true, ["InstanceType"] = true, nil }

function asserts.AssertScheduledInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstance to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["ScheduledInstanceId"] then asserts.AssertString(struct["ScheduledInstanceId"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["Recurrence"] then asserts.AssertScheduledInstanceRecurrence(struct["Recurrence"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["TermEndDate"] then asserts.AssertDateTime(struct["TermEndDate"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["SlotDurationInHours"] then asserts.AssertInteger(struct["SlotDurationInHours"]) end
	if struct["PreviousSlotEndTime"] then asserts.AssertDateTime(struct["PreviousSlotEndTime"]) end
	if struct["TermStartDate"] then asserts.AssertDateTime(struct["TermStartDate"]) end
	if struct["NetworkPlatform"] then asserts.AssertString(struct["NetworkPlatform"]) end
	if struct["TotalScheduledInstanceHours"] then asserts.AssertInteger(struct["TotalScheduledInstanceHours"]) end
	if struct["NextSlotStartTime"] then asserts.AssertDateTime(struct["NextSlotStartTime"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstance[k], "ScheduledInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstance
-- <p>Describes a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- * ScheduledInstanceId [String] <p>The Scheduled Instance ID.</p>
-- * HourlyPrice [String] <p>The hourly price for a single instance.</p>
-- * CreateDate [DateTime] <p>The date when the Scheduled Instance was purchased.</p>
-- * Recurrence [ScheduledInstanceRecurrence] <p>The schedule recurrence.</p>
-- * Platform [String] <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
-- * TermEndDate [DateTime] <p>The end date for the Scheduled Instance.</p>
-- * InstanceCount [Integer] <p>The number of instances.</p>
-- * SlotDurationInHours [Integer] <p>The number of hours in the schedule.</p>
-- * PreviousSlotEndTime [DateTime] <p>The time that the previous schedule ended or will end.</p>
-- * TermStartDate [DateTime] <p>The start date for the Scheduled Instance.</p>
-- * NetworkPlatform [String] <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
-- * TotalScheduledInstanceHours [Integer] <p>The total number of hours for a single instance for the entire term.</p>
-- * NextSlotStartTime [DateTime] <p>The time for the next schedule to start.</p>
-- * InstanceType [String] <p>The instance type.</p>
-- @return ScheduledInstance structure as a key-value pair table
function M.ScheduledInstance(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstance")
	local t = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["ScheduledInstanceId"] = args["ScheduledInstanceId"],
		["HourlyPrice"] = args["HourlyPrice"],
		["CreateDate"] = args["CreateDate"],
		["Recurrence"] = args["Recurrence"],
		["Platform"] = args["Platform"],
		["TermEndDate"] = args["TermEndDate"],
		["InstanceCount"] = args["InstanceCount"],
		["SlotDurationInHours"] = args["SlotDurationInHours"],
		["PreviousSlotEndTime"] = args["PreviousSlotEndTime"],
		["TermStartDate"] = args["TermStartDate"],
		["NetworkPlatform"] = args["NetworkPlatform"],
		["TotalScheduledInstanceHours"] = args["TotalScheduledInstanceHours"],
		["NextSlotStartTime"] = args["NextSlotStartTime"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertScheduledInstance(t)
	return t
end

keys.HostInstance = { ["InstanceId"] = true, ["InstanceType"] = true, nil }

function asserts.AssertHostInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostInstance to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostInstance[k], "HostInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostInstance
-- <p>Describes an instance running on a Dedicated Host.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>the IDs of instances that are running on the Dedicated Host.</p>
-- * InstanceType [String] <p>The instance type size (for example, <code>m3.medium</code>) of the running instance.</p>
-- @return HostInstance structure as a key-value pair table
function M.HostInstance(args)
	assert(args, "You must provdide an argument table when creating HostInstance")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertHostInstance(t)
	return t
end

keys.Monitoring = { ["State"] = true, nil }

function asserts.AssertMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Monitoring to be of type 'table'")
	if struct["State"] then asserts.AssertMonitoringState(struct["State"]) end
	for k,_ in pairs(struct) do
		assert(keys.Monitoring[k], "Monitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Monitoring
-- <p>Describes the monitoring of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [MonitoringState] <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
-- @return Monitoring structure as a key-value pair table
function M.Monitoring(args)
	assert(args, "You must provdide an argument table when creating Monitoring")
	local t = { 
		["State"] = args["State"],
	}
	asserts.AssertMonitoring(t)
	return t
end

keys.AttachVpnGatewayResult = { ["VpcAttachment"] = true, nil }

function asserts.AssertAttachVpnGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVpnGatewayResult to be of type 'table'")
	if struct["VpcAttachment"] then asserts.AssertVpcAttachment(struct["VpcAttachment"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachVpnGatewayResult[k], "AttachVpnGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVpnGatewayResult
-- <p>Contains the output of AttachVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcAttachment [VpcAttachment] <p>Information about the attachment.</p>
-- @return AttachVpnGatewayResult structure as a key-value pair table
function M.AttachVpnGatewayResult(args)
	assert(args, "You must provdide an argument table when creating AttachVpnGatewayResult")
	local t = { 
		["VpcAttachment"] = args["VpcAttachment"],
	}
	asserts.AssertAttachVpnGatewayResult(t)
	return t
end

keys.DeletePlacementGroupRequest = { ["GroupName"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeletePlacementGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeletePlacementGroupRequest to be of type 'table'")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeletePlacementGroupRequest[k], "DeletePlacementGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeletePlacementGroupRequest
-- <p>Contains the parameters for DeletePlacementGroup.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the placement group.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: GroupName
-- @return DeletePlacementGroupRequest structure as a key-value pair table
function M.DeletePlacementGroupRequest(args)
	assert(args, "You must provdide an argument table when creating DeletePlacementGroupRequest")
	local t = { 
		["GroupName"] = args["GroupName"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeletePlacementGroupRequest(t)
	return t
end

keys.MoveAddressToVpcRequest = { ["PublicIp"] = true, ["DryRun"] = true, nil }

function asserts.AssertMoveAddressToVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MoveAddressToVpcRequest to be of type 'table'")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.MoveAddressToVpcRequest[k], "MoveAddressToVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MoveAddressToVpcRequest
-- <p>Contains the parameters for MoveAddressToVpc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: PublicIp
-- @return MoveAddressToVpcRequest structure as a key-value pair table
function M.MoveAddressToVpcRequest(args)
	assert(args, "You must provdide an argument table when creating MoveAddressToVpcRequest")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertMoveAddressToVpcRequest(t)
	return t
end

keys.CreateNatGatewayResult = { ["NatGateway"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateNatGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNatGatewayResult to be of type 'table'")
	if struct["NatGateway"] then asserts.AssertNatGateway(struct["NatGateway"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNatGatewayResult[k], "CreateNatGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNatGatewayResult
-- <p>Contains the output of CreateNatGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NatGateway [NatGateway] <p>Information about the NAT gateway.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.</p>
-- @return CreateNatGatewayResult structure as a key-value pair table
function M.CreateNatGatewayResult(args)
	assert(args, "You must provdide an argument table when creating CreateNatGatewayResult")
	local t = { 
		["NatGateway"] = args["NatGateway"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateNatGatewayResult(t)
	return t
end

keys.DisassociateSubnetCidrBlockRequest = { ["AssociationId"] = true, nil }

function asserts.AssertDisassociateSubnetCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateSubnetCidrBlockRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateSubnetCidrBlockRequest[k], "DisassociateSubnetCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateSubnetCidrBlockRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The association ID for the CIDR block.</p>
-- Required key: AssociationId
-- @return DisassociateSubnetCidrBlockRequest structure as a key-value pair table
function M.DisassociateSubnetCidrBlockRequest(args)
	assert(args, "You must provdide an argument table when creating DisassociateSubnetCidrBlockRequest")
	local t = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertDisassociateSubnetCidrBlockRequest(t)
	return t
end

keys.InternetGateway = { ["Tags"] = true, ["Attachments"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertInternetGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InternetGateway to be of type 'table'")
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Attachments"] then asserts.AssertInternetGatewayAttachmentList(struct["Attachments"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.InternetGateway[k], "InternetGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InternetGateway
-- <p>Describes an Internet gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Tags [TagList] <p>Any tags assigned to the Internet gateway.</p>
-- * Attachments [InternetGatewayAttachmentList] <p>Any VPCs attached to the Internet gateway.</p>
-- * InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- @return InternetGateway structure as a key-value pair table
function M.InternetGateway(args)
	assert(args, "You must provdide an argument table when creating InternetGateway")
	local t = { 
		["Tags"] = args["Tags"],
		["Attachments"] = args["Attachments"],
		["InternetGatewayId"] = args["InternetGatewayId"],
	}
	asserts.AssertInternetGateway(t)
	return t
end

keys.AccountAttribute = { ["AttributeName"] = true, ["AttributeValues"] = true, nil }

function asserts.AssertAccountAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AccountAttribute to be of type 'table'")
	if struct["AttributeName"] then asserts.AssertString(struct["AttributeName"]) end
	if struct["AttributeValues"] then asserts.AssertAccountAttributeValueList(struct["AttributeValues"]) end
	for k,_ in pairs(struct) do
		assert(keys.AccountAttribute[k], "AccountAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AccountAttribute
-- <p>Describes an account attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AttributeName [String] <p>The name of the account attribute.</p>
-- * AttributeValues [AccountAttributeValueList] <p>One or more values for the account attribute.</p>
-- @return AccountAttribute structure as a key-value pair table
function M.AccountAttribute(args)
	assert(args, "You must provdide an argument table when creating AccountAttribute")
	local t = { 
		["AttributeName"] = args["AttributeName"],
		["AttributeValues"] = args["AttributeValues"],
	}
	asserts.AssertAccountAttribute(t)
	return t
end

keys.DescribeDhcpOptionsResult = { ["DhcpOptions"] = true, nil }

function asserts.AssertDescribeDhcpOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDhcpOptionsResult to be of type 'table'")
	if struct["DhcpOptions"] then asserts.AssertDhcpOptionsList(struct["DhcpOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDhcpOptionsResult[k], "DescribeDhcpOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDhcpOptionsResult
-- <p>Contains the output of DescribeDhcpOptions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DhcpOptions [DhcpOptionsList] <p>Information about one or more DHCP options sets.</p>
-- @return DescribeDhcpOptionsResult structure as a key-value pair table
function M.DescribeDhcpOptionsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeDhcpOptionsResult")
	local t = { 
		["DhcpOptions"] = args["DhcpOptions"],
	}
	asserts.AssertDescribeDhcpOptionsResult(t)
	return t
end

keys.DeleteTagsRequest = { ["DryRun"] = true, ["Resources"] = true, ["Tags"] = true, nil }

function asserts.AssertDeleteTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteTagsRequest to be of type 'table'")
	assert(struct["Resources"], "Expected key Resources to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Resources"] then asserts.AssertResourceIdList(struct["Resources"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteTagsRequest[k], "DeleteTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteTagsRequest
-- <p>Contains the parameters for DeleteTags.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Resources [ResourceIdList] <p>The ID of the resource. For example, ami-1a2b3c4d. You can specify more than one resource ID.</p>
-- * Tags [TagList] <p>One or more tags to delete. If you omit the <code>value</code> parameter, we delete the tag regardless of its value. If you specify this parameter with an empty string as the value, we delete the key only if its value is an empty string.</p>
-- Required key: Resources
-- @return DeleteTagsRequest structure as a key-value pair table
function M.DeleteTagsRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteTagsRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Resources"] = args["Resources"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertDeleteTagsRequest(t)
	return t
end

keys.ModifyVpcAttributeRequest = { ["VpcId"] = true, ["EnableDnsSupport"] = true, ["EnableDnsHostnames"] = true, nil }

function asserts.AssertModifyVpcAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcAttributeRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["EnableDnsSupport"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsSupport"]) end
	if struct["EnableDnsHostnames"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsHostnames"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcAttributeRequest[k], "ModifyVpcAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcAttributeRequest
-- <p>Contains the parameters for ModifyVpcAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * EnableDnsSupport [AttributeBooleanValue] <p>Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" will succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled.</p> <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute.</p>
-- * EnableDnsHostnames [AttributeBooleanValue] <p>Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not.</p> <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute. You can only enable DNS hostnames if you've enabled DNS support.</p>
-- Required key: VpcId
-- @return ModifyVpcAttributeRequest structure as a key-value pair table
function M.ModifyVpcAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyVpcAttributeRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["EnableDnsSupport"] = args["EnableDnsSupport"],
		["EnableDnsHostnames"] = args["EnableDnsHostnames"],
	}
	asserts.AssertModifyVpcAttributeRequest(t)
	return t
end

keys.ScheduledInstancesIpv6Address = { ["Ipv6Address"] = true, nil }

function asserts.AssertScheduledInstancesIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertIpv6Address(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesIpv6Address[k], "ScheduledInstancesIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesIpv6Address
-- <p>Describes an IPv6 address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Address [Ipv6Address] <p>The IPv6 address.</p>
-- @return ScheduledInstancesIpv6Address structure as a key-value pair table
function M.ScheduledInstancesIpv6Address(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstancesIpv6Address")
	local t = { 
		["Ipv6Address"] = args["Ipv6Address"],
	}
	asserts.AssertScheduledInstancesIpv6Address(t)
	return t
end

keys.SpotInstanceRequest = { ["Status"] = true, ["ActualBlockHourlyPrice"] = true, ["ValidUntil"] = true, ["LaunchGroup"] = true, ["Tags"] = true, ["InstanceId"] = true, ["Fault"] = true, ["BlockDurationMinutes"] = true, ["SpotInstanceRequestId"] = true, ["State"] = true, ["ProductDescription"] = true, ["AvailabilityZoneGroup"] = true, ["LaunchSpecification"] = true, ["ValidFrom"] = true, ["Type"] = true, ["CreateTime"] = true, ["SpotPrice"] = true, ["LaunchedAvailabilityZone"] = true, nil }

function asserts.AssertSpotInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceRequest to be of type 'table'")
	if struct["Status"] then asserts.AssertSpotInstanceStatus(struct["Status"]) end
	if struct["ActualBlockHourlyPrice"] then asserts.AssertString(struct["ActualBlockHourlyPrice"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["LaunchGroup"] then asserts.AssertString(struct["LaunchGroup"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Fault"] then asserts.AssertSpotInstanceStateFault(struct["Fault"]) end
	if struct["BlockDurationMinutes"] then asserts.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	if struct["State"] then asserts.AssertSpotInstanceState(struct["State"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["AvailabilityZoneGroup"] then asserts.AssertString(struct["AvailabilityZoneGroup"]) end
	if struct["LaunchSpecification"] then asserts.AssertLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["Type"] then asserts.AssertSpotInstanceType(struct["Type"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	if struct["LaunchedAvailabilityZone"] then asserts.AssertString(struct["LaunchedAvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotInstanceRequest[k], "SpotInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceRequest
-- <p>Describes a Spot instance request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [SpotInstanceStatus] <p>The status code and status message describing the Spot instance request.</p>
-- * ActualBlockHourlyPrice [String] <p>If you specified a duration and your Spot instance request was fulfilled, this is the fixed hourly price in effect for the Spot instance while it runs.</p>
-- * ValidUntil [DateTime] <p>The end date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). If this is a one-time request, it remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date is reached.</p>
-- * LaunchGroup [String] <p>The instance launch group. Launch groups are Spot instances that launch together and terminate together.</p>
-- * Tags [TagList] <p>Any tags assigned to the resource.</p>
-- * InstanceId [String] <p>The instance ID, if an instance has been launched to fulfill the Spot instance request.</p>
-- * Fault [SpotInstanceStateFault] <p>The fault codes for the Spot instance request, if any.</p>
-- * BlockDurationMinutes [Integer] <p>The duration for the Spot instance, in minutes.</p>
-- * SpotInstanceRequestId [String] <p>The ID of the Spot instance request.</p>
-- * State [SpotInstanceState] <p>The state of the Spot instance request. Spot bid status information can help you track your Spot instance requests. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot Bid Status</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * ProductDescription [RIProductDescription] <p>The product description associated with the Spot instance.</p>
-- * AvailabilityZoneGroup [String] <p>The Availability Zone group. If you specify the same Availability Zone group for all Spot instance requests, all Spot instances are launched in the same Availability Zone.</p>
-- * LaunchSpecification [LaunchSpecification] <p>Additional information for launching instances.</p>
-- * ValidFrom [DateTime] <p>The start date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The request becomes active at this date and time.</p>
-- * Type [SpotInstanceType] <p>The Spot instance request type.</p>
-- * CreateTime [DateTime] <p>The date and time when the Spot instance request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- * SpotPrice [String] <p>The maximum hourly price (bid) for the Spot instance launched to fulfill the request.</p>
-- * LaunchedAvailabilityZone [String] <p>The Availability Zone in which the bid is launched.</p>
-- @return SpotInstanceRequest structure as a key-value pair table
function M.SpotInstanceRequest(args)
	assert(args, "You must provdide an argument table when creating SpotInstanceRequest")
	local t = { 
		["Status"] = args["Status"],
		["ActualBlockHourlyPrice"] = args["ActualBlockHourlyPrice"],
		["ValidUntil"] = args["ValidUntil"],
		["LaunchGroup"] = args["LaunchGroup"],
		["Tags"] = args["Tags"],
		["InstanceId"] = args["InstanceId"],
		["Fault"] = args["Fault"],
		["BlockDurationMinutes"] = args["BlockDurationMinutes"],
		["SpotInstanceRequestId"] = args["SpotInstanceRequestId"],
		["State"] = args["State"],
		["ProductDescription"] = args["ProductDescription"],
		["AvailabilityZoneGroup"] = args["AvailabilityZoneGroup"],
		["LaunchSpecification"] = args["LaunchSpecification"],
		["ValidFrom"] = args["ValidFrom"],
		["Type"] = args["Type"],
		["CreateTime"] = args["CreateTime"],
		["SpotPrice"] = args["SpotPrice"],
		["LaunchedAvailabilityZone"] = args["LaunchedAvailabilityZone"],
	}
	asserts.AssertSpotInstanceRequest(t)
	return t
end

keys.DescribeReservedInstancesResult = { ["ReservedInstances"] = true, nil }

function asserts.AssertDescribeReservedInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesResult to be of type 'table'")
	if struct["ReservedInstances"] then asserts.AssertReservedInstancesList(struct["ReservedInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesResult[k], "DescribeReservedInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesResult
-- <p>Contains the output for DescribeReservedInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstances [ReservedInstancesList] <p>A list of Reserved Instances.</p>
-- @return DescribeReservedInstancesResult structure as a key-value pair table
function M.DescribeReservedInstancesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeReservedInstancesResult")
	local t = { 
		["ReservedInstances"] = args["ReservedInstances"],
	}
	asserts.AssertDescribeReservedInstancesResult(t)
	return t
end

keys.DescribeAccountAttributesResult = { ["AccountAttributes"] = true, nil }

function asserts.AssertDescribeAccountAttributesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAttributesResult to be of type 'table'")
	if struct["AccountAttributes"] then asserts.AssertAccountAttributeList(struct["AccountAttributes"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAccountAttributesResult[k], "DescribeAccountAttributesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAttributesResult
-- <p>Contains the output of DescribeAccountAttributes.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AccountAttributes [AccountAttributeList] <p>Information about one or more account attributes.</p>
-- @return DescribeAccountAttributesResult structure as a key-value pair table
function M.DescribeAccountAttributesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeAccountAttributesResult")
	local t = { 
		["AccountAttributes"] = args["AccountAttributes"],
	}
	asserts.AssertDescribeAccountAttributesResult(t)
	return t
end

keys.UserIdGroupPair = { ["VpcId"] = true, ["PeeringStatus"] = true, ["UserId"] = true, ["GroupName"] = true, ["VpcPeeringConnectionId"] = true, ["GroupId"] = true, nil }

function asserts.AssertUserIdGroupPair(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserIdGroupPair to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PeeringStatus"] then asserts.AssertString(struct["PeeringStatus"]) end
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserIdGroupPair[k], "UserIdGroupPair contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserIdGroupPair
-- <p>Describes a security group and AWS account ID pair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC for the referenced security group, if applicable.</p>
-- * PeeringStatus [String] <p>The status of a VPC peering connection, if applicable.</p>
-- * UserId [String] <p>The ID of an AWS account. For a referenced security group in another VPC, the account ID of the referenced security group is returned.</p> <p>[EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.</p>
-- * GroupName [String] <p>The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection, if applicable.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- @return UserIdGroupPair structure as a key-value pair table
function M.UserIdGroupPair(args)
	assert(args, "You must provdide an argument table when creating UserIdGroupPair")
	local t = { 
		["VpcId"] = args["VpcId"],
		["PeeringStatus"] = args["PeeringStatus"],
		["UserId"] = args["UserId"],
		["GroupName"] = args["GroupName"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertUserIdGroupPair(t)
	return t
end

keys.DescribeRouteTablesRequest = { ["RouteTableIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeRouteTablesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRouteTablesRequest to be of type 'table'")
	if struct["RouteTableIds"] then asserts.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRouteTablesRequest[k], "DescribeRouteTablesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRouteTablesRequest
-- <p>Contains the parameters for DescribeRouteTables.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RouteTableIds [ValueStringList] <p>One or more route table IDs.</p> <p>Default: Describes all your route tables.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>association.route-table-association-id</code> - The ID of an association ID for the route table.</p> </li> <li> <p> <code>association.route-table-id</code> - The ID of the route table involved in the association.</p> </li> <li> <p> <code>association.subnet-id</code> - The ID of the subnet involved in the association.</p> </li> <li> <p> <code>association.main</code> - Indicates whether the route table is the main route table for the VPC (<code>true</code> | <code>false</code>). Route tables that do not have an association ID are not returned in the response.</p> </li> <li> <p> <code>route-table-id</code> - The ID of the route table.</p> </li> <li> <p> <code>route.destination-cidr-block</code> - The IPv4 CIDR range specified in a route in the table.</p> </li> <li> <p> <code>route.destination-ipv6-cidr-block</code> - The IPv6 CIDR range specified in a route in the route table.</p> </li> <li> <p> <code>route.destination-prefix-list-id</code> - The ID (prefix) of the AWS service specified in a route in the table.</p> </li> <li> <p> <code>route.egress-only-internet-gateway-id</code> - The ID of an egress-only Internet gateway specified in a route in the route table.</p> </li> <li> <p> <code>route.gateway-id</code> - The ID of a gateway specified in a route in the table.</p> </li> <li> <p> <code>route.instance-id</code> - The ID of an instance specified in a route in the table.</p> </li> <li> <p> <code>route.nat-gateway-id</code> - The ID of a NAT gateway.</p> </li> <li> <p> <code>route.origin</code> - Describes how the route was created. <code>CreateRouteTable</code> indicates that the route was automatically created when the route table was created; <code>CreateRoute</code> indicates that the route was manually added to the route table; <code>EnableVgwRoutePropagation</code> indicates that the route was propagated by route propagation.</p> </li> <li> <p> <code>route.state</code> - The state of a route in the route table (<code>active</code> | <code>blackhole</code>). The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, the specified NAT instance has been terminated, and so on).</p> </li> <li> <p> <code>route.vpc-peering-connection-id</code> - The ID of a VPC peering connection specified in a route in the table.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the route table.</p> </li> </ul>
-- @return DescribeRouteTablesRequest structure as a key-value pair table
function M.DescribeRouteTablesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeRouteTablesRequest")
	local t = { 
		["RouteTableIds"] = args["RouteTableIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeRouteTablesRequest(t)
	return t
end

keys.DescribeInternetGatewaysResult = { ["InternetGateways"] = true, nil }

function asserts.AssertDescribeInternetGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInternetGatewaysResult to be of type 'table'")
	if struct["InternetGateways"] then asserts.AssertInternetGatewayList(struct["InternetGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInternetGatewaysResult[k], "DescribeInternetGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInternetGatewaysResult
-- <p>Contains the output of DescribeInternetGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InternetGateways [InternetGatewayList] <p>Information about one or more Internet gateways.</p>
-- @return DescribeInternetGatewaysResult structure as a key-value pair table
function M.DescribeInternetGatewaysResult(args)
	assert(args, "You must provdide an argument table when creating DescribeInternetGatewaysResult")
	local t = { 
		["InternetGateways"] = args["InternetGateways"],
	}
	asserts.AssertDescribeInternetGatewaysResult(t)
	return t
end

keys.DescribeSecurityGroupReferencesRequest = { ["DryRun"] = true, ["GroupId"] = true, nil }

function asserts.AssertDescribeSecurityGroupReferencesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupReferencesRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then asserts.AssertGroupIds(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupReferencesRequest[k], "DescribeSecurityGroupReferencesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupReferencesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.</p>
-- * GroupId [GroupIds] <p>One or more security group IDs in your account.</p>
-- Required key: GroupId
-- @return DescribeSecurityGroupReferencesRequest structure as a key-value pair table
function M.DescribeSecurityGroupReferencesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSecurityGroupReferencesRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertDescribeSecurityGroupReferencesRequest(t)
	return t
end

keys.ImportImageRequest = { ["LicenseType"] = true, ["DryRun"] = true, ["Description"] = true, ["ClientData"] = true, ["Hypervisor"] = true, ["DiskContainers"] = true, ["Platform"] = true, ["Architecture"] = true, ["ClientToken"] = true, ["RoleName"] = true, nil }

function asserts.AssertImportImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageRequest to be of type 'table'")
	if struct["LicenseType"] then asserts.AssertString(struct["LicenseType"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ClientData"] then asserts.AssertClientData(struct["ClientData"]) end
	if struct["Hypervisor"] then asserts.AssertString(struct["Hypervisor"]) end
	if struct["DiskContainers"] then asserts.AssertImageDiskContainerList(struct["DiskContainers"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["Architecture"] then asserts.AssertString(struct["Architecture"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["RoleName"] then asserts.AssertString(struct["RoleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportImageRequest[k], "ImportImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageRequest
-- <p>Contains the parameters for ImportImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LicenseType [String] <p>The license type to be used for the Amazon Machine Image (AMI) after importing.</p> <p> <b>Note:</b> You may only use BYOL if you have existing licenses with rights to use these licenses in a third party cloud like AWS. For more information, see <a href="http://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html#prerequisites-image">Prerequisites</a> in the VM Import/Export User Guide.</p> <p>Valid values: <code>AWS</code> | <code>BYOL</code> </p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description string for the import image task.</p>
-- * ClientData [ClientData] <p>The client-specific data.</p>
-- * Hypervisor [String] <p>The target hypervisor platform.</p> <p>Valid values: <code>xen</code> </p>
-- * DiskContainers [ImageDiskContainerList] <p>Information about the disk containers.</p>
-- * Platform [String] <p>The operating system of the virtual machine.</p> <p>Valid values: <code>Windows</code> | <code>Linux</code> </p>
-- * Architecture [String] <p>The architecture of the virtual machine.</p> <p>Valid values: <code>i386</code> | <code>x86_64</code> </p>
-- * ClientToken [String] <p>The token to enable idempotency for VM import requests.</p>
-- * RoleName [String] <p>The name of the role to use when not using the default role, 'vmimport'.</p>
-- @return ImportImageRequest structure as a key-value pair table
function M.ImportImageRequest(args)
	assert(args, "You must provdide an argument table when creating ImportImageRequest")
	local t = { 
		["LicenseType"] = args["LicenseType"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["ClientData"] = args["ClientData"],
		["Hypervisor"] = args["Hypervisor"],
		["DiskContainers"] = args["DiskContainers"],
		["Platform"] = args["Platform"],
		["Architecture"] = args["Architecture"],
		["ClientToken"] = args["ClientToken"],
		["RoleName"] = args["RoleName"],
	}
	asserts.AssertImportImageRequest(t)
	return t
end

keys.DescribeReservedInstancesOfferingsResult = { ["NextToken"] = true, ["ReservedInstancesOfferings"] = true, nil }

function asserts.AssertDescribeReservedInstancesOfferingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesOfferingsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesOfferings"] then asserts.AssertReservedInstancesOfferingList(struct["ReservedInstancesOfferings"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesOfferingsResult[k], "DescribeReservedInstancesOfferingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesOfferingsResult
-- <p>Contains the output of DescribeReservedInstancesOfferings.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ReservedInstancesOfferings [ReservedInstancesOfferingList] <p>A list of Reserved Instances offerings.</p>
-- @return DescribeReservedInstancesOfferingsResult structure as a key-value pair table
function M.DescribeReservedInstancesOfferingsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeReservedInstancesOfferingsResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["ReservedInstancesOfferings"] = args["ReservedInstancesOfferings"],
	}
	asserts.AssertDescribeReservedInstancesOfferingsResult(t)
	return t
end

keys.ScheduledInstancesMonitoring = { ["Enabled"] = true, nil }

function asserts.AssertScheduledInstancesMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesMonitoring to be of type 'table'")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesMonitoring[k], "ScheduledInstancesMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesMonitoring
-- <p>Describes whether monitoring is enabled for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Enabled [Boolean] <p>Indicates whether monitoring is enabled.</p>
-- @return ScheduledInstancesMonitoring structure as a key-value pair table
function M.ScheduledInstancesMonitoring(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstancesMonitoring")
	local t = { 
		["Enabled"] = args["Enabled"],
	}
	asserts.AssertScheduledInstancesMonitoring(t)
	return t
end

keys.ScheduledInstancesLaunchSpecification = { ["UserData"] = true, ["SubnetId"] = true, ["Monitoring"] = true, ["ImageId"] = true, ["KeyName"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroupIds"] = true, ["RamdiskId"] = true, ["KernelId"] = true, ["Placement"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertScheduledInstancesLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesLaunchSpecification to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then asserts.AssertScheduledInstancesMonitoring(struct["Monitoring"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertScheduledInstancesBlockDeviceMappingSet(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroupIds"] then asserts.AssertScheduledInstancesSecurityGroupIdSet(struct["SecurityGroupIds"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Placement"] then asserts.AssertScheduledInstancesPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then asserts.AssertScheduledInstancesIamInstanceProfile(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertScheduledInstancesNetworkInterfaceSet(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesLaunchSpecification[k], "ScheduledInstancesLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesLaunchSpecification
-- <p>Describes the launch specification for a Scheduled Instance.</p> <p>If you are launching the Scheduled Instance in EC2-VPC, you must specify the ID of the subnet. You can specify the subnet using either <code>SubnetId</code> or <code>NetworkInterface</code>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserData [String] <p>The base64-encoded MIME user data.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instances.</p>
-- * Monitoring [ScheduledInstancesMonitoring] <p>Enable or disable monitoring for the instances.</p>
-- * ImageId [String] <p>The ID of the Amazon Machine Image (AMI).</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * BlockDeviceMappings [ScheduledInstancesBlockDeviceMappingSet] <p>One or more block device mapping entries.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p> <p>Default: <code>false</code> </p>
-- * SecurityGroupIds [ScheduledInstancesSecurityGroupIdSet] <p>The IDs of one or more security groups.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * Placement [ScheduledInstancesPlacement] <p>The placement information.</p>
-- * IamInstanceProfile [ScheduledInstancesIamInstanceProfile] <p>The IAM instance profile.</p>
-- * InstanceType [String] <p>The instance type.</p>
-- * NetworkInterfaces [ScheduledInstancesNetworkInterfaceSet] <p>One or more network interfaces.</p>
-- Required key: ImageId
-- @return ScheduledInstancesLaunchSpecification structure as a key-value pair table
function M.ScheduledInstancesLaunchSpecification(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstancesLaunchSpecification")
	local t = { 
		["UserData"] = args["UserData"],
		["SubnetId"] = args["SubnetId"],
		["Monitoring"] = args["Monitoring"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["SecurityGroupIds"] = args["SecurityGroupIds"],
		["RamdiskId"] = args["RamdiskId"],
		["KernelId"] = args["KernelId"],
		["Placement"] = args["Placement"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["InstanceType"] = args["InstanceType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertScheduledInstancesLaunchSpecification(t)
	return t
end

keys.InstanceCapacity = { ["AvailableCapacity"] = true, ["InstanceType"] = true, ["TotalCapacity"] = true, nil }

function asserts.AssertInstanceCapacity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCapacity to be of type 'table'")
	if struct["AvailableCapacity"] then asserts.AssertInteger(struct["AvailableCapacity"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["TotalCapacity"] then asserts.AssertInteger(struct["TotalCapacity"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceCapacity[k], "InstanceCapacity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCapacity
-- <p>Information about the instance type that the Dedicated Host supports.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailableCapacity [Integer] <p>The number of instances that can still be launched onto the Dedicated Host.</p>
-- * InstanceType [String] <p>The instance type size supported by the Dedicated Host.</p>
-- * TotalCapacity [Integer] <p>The total number of instances that can be launched onto the Dedicated Host.</p>
-- @return InstanceCapacity structure as a key-value pair table
function M.InstanceCapacity(args)
	assert(args, "You must provdide an argument table when creating InstanceCapacity")
	local t = { 
		["AvailableCapacity"] = args["AvailableCapacity"],
		["InstanceType"] = args["InstanceType"],
		["TotalCapacity"] = args["TotalCapacity"],
	}
	asserts.AssertInstanceCapacity(t)
	return t
end

keys.DescribeInstancesRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["InstanceIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancesRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancesRequest[k], "DescribeInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancesRequest
-- <p>Contains the parameters for DescribeInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter or tag filters in the same call.</p>
-- * NextToken [String] <p>The token to request the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Default: Describes all your instances.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>affinity</code> - The affinity setting for an instance running on a Dedicated Host (<code>default</code> | <code>host</code>).</p> </li> <li> <p> <code>architecture</code> - The instance architecture (<code>i386</code> | <code>x86_64</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>block-device-mapping.attach-time</code> - The attach time for an EBS volume mapped to the instance, for example, <code>2010-09-15T17:15:20.000Z</code>.</p> </li> <li> <p> <code>block-device-mapping.delete-on-termination</code> - A Boolean that indicates whether the EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>block-device-mapping.device-name</code> - The device name for the EBS volume (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p> </li> <li> <p> <code>block-device-mapping.status</code> - The status for the EBS volume (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>block-device-mapping.volume-id</code> - The volume ID of the EBS volume.</p> </li> <li> <p> <code>client-token</code> - The idempotency token you provided when you launched the instance.</p> </li> <li> <p> <code>dns-name</code> - The public DNS name of the instance.</p> </li> <li> <p> <code>group-id</code> - The ID of the security group for the instance. EC2-Classic only.</p> </li> <li> <p> <code>group-name</code> - The name of the security group for the instance. EC2-Classic only.</p> </li> <li> <p> <code>host-id</code> - The ID of the Dedicated Host on which the instance is running, if applicable.</p> </li> <li> <p> <code>hypervisor</code> - The hypervisor type of the instance (<code>ovm</code> | <code>xen</code>).</p> </li> <li> <p> <code>iam-instance-profile.arn</code> - The instance profile associated with the instance. Specified as an ARN.</p> </li> <li> <p> <code>image-id</code> - The ID of the image used to launch the instance.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>instance-lifecycle</code> - Indicates whether this is a Spot Instance or a Scheduled Instance (<code>spot</code> | <code>scheduled</code>).</p> </li> <li> <p> <code>instance-state-code</code> - The state of the instance, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are: 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).</p> </li> <li> <p> <code>instance-state-name</code> - The state of the instance (<code>pending</code> | <code>running</code> | <code>shutting-down</code> | <code>terminated</code> | <code>stopping</code> | <code>stopped</code>).</p> </li> <li> <p> <code>instance-type</code> - The type of instance (for example, <code>t2.micro</code>).</p> </li> <li> <p> <code>instance.group-id</code> - The ID of the security group for the instance. </p> </li> <li> <p> <code>instance.group-name</code> - The name of the security group for the instance. </p> </li> <li> <p> <code>ip-address</code> - The public IPv4 address of the instance.</p> </li> <li> <p> <code>kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>key-name</code> - The name of the key pair used when the instance was launched.</p> </li> <li> <p> <code>launch-index</code> - When launching multiple instances, this is the index for the instance in the launch group (for example, 0, 1, 2, and so on). </p> </li> <li> <p> <code>launch-time</code> - The time when the instance was launched.</p> </li> <li> <p> <code>monitoring-state</code> - Indicates whether detailed monitoring is enabled (<code>disabled</code> | <code>enabled</code>).</p> </li> <li> <p> <code>network-interface.addresses.private-ip-address</code> - The private IPv4 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.addresses.primary</code> - Specifies whether the IPv4 address of the network interface is the primary private IPv4 address.</p> </li> <li> <p> <code>network-interface.addresses.association.public-ip</code> - The ID of the association of an Elastic IP address (IPv4) with a network interface.</p> </li> <li> <p> <code>network-interface.addresses.association.ip-owner-id</code> - The owner ID of the private IPv4 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.association.public-ip</code> - The address of the Elastic IP address (IPv4) bound to the network interface.</p> </li> <li> <p> <code>network-interface.association.ip-owner-id</code> - The owner of the Elastic IP address (IPv4) associated with the network interface.</p> </li> <li> <p> <code>network-interface.association.allocation-id</code> - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.</p> </li> <li> <p> <code>network-interface.association.association-id</code> - The association ID returned when the network interface was associated with an IPv4 address.</p> </li> <li> <p> <code>network-interface.attachment.attachment-id</code> - The ID of the interface attachment.</p> </li> <li> <p> <code>network-interface.attachment.instance-id</code> - The ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.instance-owner-id</code> - The owner ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.device-index</code> - The device index to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.status</code> - The status of the attachment (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>network-interface.attachment.attach-time</code> - The time that the network interface was attached to an instance.</p> </li> <li> <p> <code>network-interface.attachment.delete-on-termination</code> - Specifies whether the attachment is deleted when an instance is terminated.</p> </li> <li> <p> <code>network-interface.availability-zone</code> - The Availability Zone for the network interface.</p> </li> <li> <p> <code>network-interface.description</code> - The description of the network interface.</p> </li> <li> <p> <code>network-interface.group-id</code> - The ID of a security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.group-name</code> - The name of a security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.ipv6-addresses.ipv6-address</code> - The IPv6 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.mac-address</code> - The MAC address of the network interface.</p> </li> <li> <p> <code>network-interface.network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>network-interface.owner-id</code> - The ID of the owner of the network interface.</p> </li> <li> <p> <code>network-interface.private-dns-name</code> - The private DNS name of the network interface.</p> </li> <li> <p> <code>network-interface.requester-id</code> - The requester ID for the network interface.</p> </li> <li> <p> <code>network-interface.requester-managed</code> - Indicates whether the network interface is being managed by AWS.</p> </li> <li> <p> <code>network-interface.status</code> - The status of the network interface (<code>available</code>) | <code>in-use</code>).</p> </li> <li> <p> <code>network-interface.source-dest-check</code> - Whether the network interface performs source/destination checking. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the network interface to perform network address translation (NAT) in your VPC.</p> </li> <li> <p> <code>network-interface.subnet-id</code> - The ID of the subnet for the network interface.</p> </li> <li> <p> <code>network-interface.vpc-id</code> - The ID of the VPC for the network interface.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the instance owner.</p> </li> <li> <p> <code>placement-group-name</code> - The name of the placement group for the instance.</p> </li> <li> <p> <code>platform</code> - The platform. Use <code>windows</code> if you have Windows instances; otherwise, leave blank.</p> </li> <li> <p> <code>private-dns-name</code> - The private IPv4 DNS name of the instance.</p> </li> <li> <p> <code>private-ip-address</code> - The private IPv4 address of the instance.</p> </li> <li> <p> <code>product-code</code> - The product code associated with the AMI used to launch the instance.</p> </li> <li> <p> <code>product-code.type</code> - The type of product code (<code>devpay</code> | <code>marketplace</code>).</p> </li> <li> <p> <code>ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>reason</code> - The reason for the current state of the instance (for example, shows "User Initiated [date]" when you stop or terminate the instance). Similar to the state-reason-code filter.</p> </li> <li> <p> <code>requester-id</code> - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>reservation-id</code> - The ID of the instance's reservation. A reservation ID is created any time you launch an instance. A reservation ID has a one-to-one relationship with an instance launch request, but can be associated with more than one instance if you launch multiple instances using the same launch request. For example, if you launch one instance, you'll get one reservation ID. If you launch ten instances using the same launch request, you'll also get one reservation ID.</p> </li> <li> <p> <code>root-device-name</code> - The name of the root device for the instance (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p> </li> <li> <p> <code>root-device-type</code> - The type of root device that the instance uses (<code>ebs</code> | <code>instance-store</code>).</p> </li> <li> <p> <code>source-dest-check</code> - Indicates whether the instance performs source/destination checking. A value of <code>true</code> means that checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the instance to perform network address translation (NAT) in your VPC. </p> </li> <li> <p> <code>spot-instance-request-id</code> - The ID of the Spot instance request.</p> </li> <li> <p> <code>state-reason-code</code> - The reason code for the state change.</p> </li> <li> <p> <code>state-reason-message</code> - A message that describes the state change.</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet for the instance.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>tenancy</code> - The tenancy of an instance (<code>dedicated</code> | <code>default</code> | <code>host</code>).</p> </li> <li> <p> <code>virtualization-type</code> - The virtualization type of the instance (<code>paravirtual</code> | <code>hvm</code>).</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC that the instance is running in.</p> </li> </ul>
-- @return DescribeInstancesRequest structure as a key-value pair table
function M.DescribeInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeInstancesRequest")
	local t = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeInstancesRequest(t)
	return t
end

keys.ReservedInstancesModificationResult = { ["ReservedInstancesId"] = true, ["TargetConfiguration"] = true, nil }

function asserts.AssertReservedInstancesModificationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesModificationResult to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["TargetConfiguration"] then asserts.AssertReservedInstancesConfiguration(struct["TargetConfiguration"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesModificationResult[k], "ReservedInstancesModificationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesModificationResult
-- <p>Describes the modification request/s.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.</p>
-- * TargetConfiguration [ReservedInstancesConfiguration] <p>The target Reserved Instances configurations supplied as part of the modification request.</p>
-- @return ReservedInstancesModificationResult structure as a key-value pair table
function M.ReservedInstancesModificationResult(args)
	assert(args, "You must provdide an argument table when creating ReservedInstancesModificationResult")
	local t = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["TargetConfiguration"] = args["TargetConfiguration"],
	}
	asserts.AssertReservedInstancesModificationResult(t)
	return t
end

keys.CreateRouteTableRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteTableRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteTableRequest[k], "CreateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteTableRequest
-- <p>Contains the parameters for CreateRouteTable.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return CreateRouteTableRequest structure as a key-value pair table
function M.CreateRouteTableRequest(args)
	assert(args, "You must provdide an argument table when creating CreateRouteTableRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateRouteTableRequest(t)
	return t
end

keys.DescribeSpotDatafeedSubscriptionResult = { ["SpotDatafeedSubscription"] = true, nil }

function asserts.AssertDescribeSpotDatafeedSubscriptionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotDatafeedSubscriptionResult to be of type 'table'")
	if struct["SpotDatafeedSubscription"] then asserts.AssertSpotDatafeedSubscription(struct["SpotDatafeedSubscription"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotDatafeedSubscriptionResult[k], "DescribeSpotDatafeedSubscriptionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotDatafeedSubscriptionResult
-- <p>Contains the output of DescribeSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotDatafeedSubscription [SpotDatafeedSubscription] <p>The Spot instance data feed subscription.</p>
-- @return DescribeSpotDatafeedSubscriptionResult structure as a key-value pair table
function M.DescribeSpotDatafeedSubscriptionResult(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotDatafeedSubscriptionResult")
	local t = { 
		["SpotDatafeedSubscription"] = args["SpotDatafeedSubscription"],
	}
	asserts.AssertDescribeSpotDatafeedSubscriptionResult(t)
	return t
end

keys.DescribeCustomerGatewaysRequest = { ["CustomerGatewayIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeCustomerGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCustomerGatewaysRequest to be of type 'table'")
	if struct["CustomerGatewayIds"] then asserts.AssertCustomerGatewayIdStringList(struct["CustomerGatewayIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCustomerGatewaysRequest[k], "DescribeCustomerGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCustomerGatewaysRequest
-- <p>Contains the parameters for DescribeCustomerGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGatewayIds [CustomerGatewayIdStringList] <p>One or more customer gateway IDs.</p> <p>Default: Describes all your customer gateways.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>bgp-asn</code> - The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p> </li> <li> <p> <code>customer-gateway-id</code> - The ID of the customer gateway.</p> </li> <li> <p> <code>ip-address</code> - The IP address of the customer gateway's Internet-routable external interface.</p> </li> <li> <p> <code>state</code> - The state of the customer gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>type</code> - The type of customer gateway. Currently, the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
-- @return DescribeCustomerGatewaysRequest structure as a key-value pair table
function M.DescribeCustomerGatewaysRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeCustomerGatewaysRequest")
	local t = { 
		["CustomerGatewayIds"] = args["CustomerGatewayIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeCustomerGatewaysRequest(t)
	return t
end

keys.CancelledSpotInstanceRequest = { ["State"] = true, ["SpotInstanceRequestId"] = true, nil }

function asserts.AssertCancelledSpotInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelledSpotInstanceRequest to be of type 'table'")
	if struct["State"] then asserts.AssertCancelSpotInstanceRequestState(struct["State"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelledSpotInstanceRequest[k], "CancelledSpotInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelledSpotInstanceRequest
-- <p>Describes a request to cancel a Spot instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [CancelSpotInstanceRequestState] <p>The state of the Spot instance request.</p>
-- * SpotInstanceRequestId [String] <p>The ID of the Spot instance request.</p>
-- @return CancelledSpotInstanceRequest structure as a key-value pair table
function M.CancelledSpotInstanceRequest(args)
	assert(args, "You must provdide an argument table when creating CancelledSpotInstanceRequest")
	local t = { 
		["State"] = args["State"],
		["SpotInstanceRequestId"] = args["SpotInstanceRequestId"],
	}
	asserts.AssertCancelledSpotInstanceRequest(t)
	return t
end

keys.ScheduledInstanceAvailability = { ["AvailabilityZone"] = true, ["TotalScheduledInstanceHours"] = true, ["HourlyPrice"] = true, ["MinTermDurationInDays"] = true, ["AvailableInstanceCount"] = true, ["SlotDurationInHours"] = true, ["Recurrence"] = true, ["MaxTermDurationInDays"] = true, ["FirstSlotStartTime"] = true, ["Platform"] = true, ["NetworkPlatform"] = true, ["InstanceType"] = true, ["PurchaseToken"] = true, nil }

function asserts.AssertScheduledInstanceAvailability(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceAvailability to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["TotalScheduledInstanceHours"] then asserts.AssertInteger(struct["TotalScheduledInstanceHours"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["MinTermDurationInDays"] then asserts.AssertInteger(struct["MinTermDurationInDays"]) end
	if struct["AvailableInstanceCount"] then asserts.AssertInteger(struct["AvailableInstanceCount"]) end
	if struct["SlotDurationInHours"] then asserts.AssertInteger(struct["SlotDurationInHours"]) end
	if struct["Recurrence"] then asserts.AssertScheduledInstanceRecurrence(struct["Recurrence"]) end
	if struct["MaxTermDurationInDays"] then asserts.AssertInteger(struct["MaxTermDurationInDays"]) end
	if struct["FirstSlotStartTime"] then asserts.AssertDateTime(struct["FirstSlotStartTime"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["NetworkPlatform"] then asserts.AssertString(struct["NetworkPlatform"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["PurchaseToken"] then asserts.AssertString(struct["PurchaseToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstanceAvailability[k], "ScheduledInstanceAvailability contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceAvailability
-- <p>Describes a schedule that is available for your Scheduled Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- * TotalScheduledInstanceHours [Integer] <p>The total number of hours for a single instance for the entire term.</p>
-- * HourlyPrice [String] <p>The hourly price for a single instance.</p>
-- * MinTermDurationInDays [Integer] <p>The minimum term. The only possible value is 365 days.</p>
-- * AvailableInstanceCount [Integer] <p>The number of available instances.</p>
-- * SlotDurationInHours [Integer] <p>The number of hours in the schedule.</p>
-- * Recurrence [ScheduledInstanceRecurrence] <p>The schedule recurrence.</p>
-- * MaxTermDurationInDays [Integer] <p>The maximum term. The only possible value is 365 days.</p>
-- * FirstSlotStartTime [DateTime] <p>The time period for the first schedule to start.</p>
-- * Platform [String] <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
-- * NetworkPlatform [String] <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
-- * InstanceType [String] <p>The instance type. You can specify one of the C3, C4, M4, or R3 instance types.</p>
-- * PurchaseToken [String] <p>The purchase token. This token expires in two hours.</p>
-- @return ScheduledInstanceAvailability structure as a key-value pair table
function M.ScheduledInstanceAvailability(args)
	assert(args, "You must provdide an argument table when creating ScheduledInstanceAvailability")
	local t = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["TotalScheduledInstanceHours"] = args["TotalScheduledInstanceHours"],
		["HourlyPrice"] = args["HourlyPrice"],
		["MinTermDurationInDays"] = args["MinTermDurationInDays"],
		["AvailableInstanceCount"] = args["AvailableInstanceCount"],
		["SlotDurationInHours"] = args["SlotDurationInHours"],
		["Recurrence"] = args["Recurrence"],
		["MaxTermDurationInDays"] = args["MaxTermDurationInDays"],
		["FirstSlotStartTime"] = args["FirstSlotStartTime"],
		["Platform"] = args["Platform"],
		["NetworkPlatform"] = args["NetworkPlatform"],
		["InstanceType"] = args["InstanceType"],
		["PurchaseToken"] = args["PurchaseToken"],
	}
	asserts.AssertScheduledInstanceAvailability(t)
	return t
end

keys.DescribeSnapshotsResult = { ["NextToken"] = true, ["Snapshots"] = true, nil }

function asserts.AssertDescribeSnapshotsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Snapshots"] then asserts.AssertSnapshotList(struct["Snapshots"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotsResult[k], "DescribeSnapshotsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotsResult
-- <p>Contains the output of DescribeSnapshots.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeSnapshots</code> request. When the results of a <code>DescribeSnapshots</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * Snapshots [SnapshotList] <p>Information about the snapshots.</p>
-- @return DescribeSnapshotsResult structure as a key-value pair table
function M.DescribeSnapshotsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeSnapshotsResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["Snapshots"] = args["Snapshots"],
	}
	asserts.AssertDescribeSnapshotsResult(t)
	return t
end

keys.DeleteInternetGatewayRequest = { ["DryRun"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertDeleteInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteInternetGatewayRequest[k], "DeleteInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteInternetGatewayRequest
-- <p>Contains the parameters for DeleteInternetGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- Required key: InternetGatewayId
-- @return DeleteInternetGatewayRequest structure as a key-value pair table
function M.DeleteInternetGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteInternetGatewayRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["InternetGatewayId"] = args["InternetGatewayId"],
	}
	asserts.AssertDeleteInternetGatewayRequest(t)
	return t
end

keys.UnmonitorInstancesResult = { ["InstanceMonitorings"] = true, nil }

function asserts.AssertUnmonitorInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnmonitorInstancesResult to be of type 'table'")
	if struct["InstanceMonitorings"] then asserts.AssertInstanceMonitoringList(struct["InstanceMonitorings"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnmonitorInstancesResult[k], "UnmonitorInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnmonitorInstancesResult
-- <p>Contains the output of UnmonitorInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceMonitorings [InstanceMonitoringList] <p>The monitoring information.</p>
-- @return UnmonitorInstancesResult structure as a key-value pair table
function M.UnmonitorInstancesResult(args)
	assert(args, "You must provdide an argument table when creating UnmonitorInstancesResult")
	local t = { 
		["InstanceMonitorings"] = args["InstanceMonitorings"],
	}
	asserts.AssertUnmonitorInstancesResult(t)
	return t
end

keys.StaleIpPermission = { ["PrefixListIds"] = true, ["FromPort"] = true, ["IpRanges"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["UserIdGroupPairs"] = true, nil }

function asserts.AssertStaleIpPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StaleIpPermission to be of type 'table'")
	if struct["PrefixListIds"] then asserts.AssertPrefixListIdSet(struct["PrefixListIds"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["IpRanges"] then asserts.AssertIpRanges(struct["IpRanges"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["UserIdGroupPairs"] then asserts.AssertUserIdGroupPairSet(struct["UserIdGroupPairs"]) end
	for k,_ in pairs(struct) do
		assert(keys.StaleIpPermission[k], "StaleIpPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StaleIpPermission
-- <p>Describes a stale rule in a security group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrefixListIds [PrefixListIdSet] <p>One or more prefix list IDs for an AWS service. Not applicable for stale security group rules.</p>
-- * FromPort [Integer] <p>The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>
-- * IpRanges [IpRanges] <p>One or more IP ranges. Not applicable for stale security group rules.</p>
-- * ToPort [Integer] <p>The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>
-- * IpProtocol [String] <p>The IP protocol name (for <code>tcp</code>, <code>udp</code>, and <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers)</a>.</p>
-- * UserIdGroupPairs [UserIdGroupPairSet] <p>One or more security group pairs. Returns the ID of the referenced security group and VPC, and the ID and status of the VPC peering connection.</p>
-- @return StaleIpPermission structure as a key-value pair table
function M.StaleIpPermission(args)
	assert(args, "You must provdide an argument table when creating StaleIpPermission")
	local t = { 
		["PrefixListIds"] = args["PrefixListIds"],
		["FromPort"] = args["FromPort"],
		["IpRanges"] = args["IpRanges"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["UserIdGroupPairs"] = args["UserIdGroupPairs"],
	}
	asserts.AssertStaleIpPermission(t)
	return t
end

keys.DescribeRegionsRequest = { ["DryRun"] = true, ["Filters"] = true, ["RegionNames"] = true, nil }

function asserts.AssertDescribeRegionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRegionsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["RegionNames"] then asserts.AssertRegionNameStringList(struct["RegionNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRegionsRequest[k], "DescribeRegionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRegionsRequest
-- <p>Contains the parameters for DescribeRegions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>endpoint</code> - The endpoint of the region (for example, <code>ec2.us-east-1.amazonaws.com</code>).</p> </li> <li> <p> <code>region-name</code> - The name of the region (for example, <code>us-east-1</code>).</p> </li> </ul>
-- * RegionNames [RegionNameStringList] <p>The names of one or more regions.</p>
-- @return DescribeRegionsRequest structure as a key-value pair table
function M.DescribeRegionsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeRegionsRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["RegionNames"] = args["RegionNames"],
	}
	asserts.AssertDescribeRegionsRequest(t)
	return t
end

keys.CancelSpotFleetRequestsResponse = { ["SuccessfulFleetRequests"] = true, ["UnsuccessfulFleetRequests"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsResponse to be of type 'table'")
	if struct["SuccessfulFleetRequests"] then asserts.AssertCancelSpotFleetRequestsSuccessSet(struct["SuccessfulFleetRequests"]) end
	if struct["UnsuccessfulFleetRequests"] then asserts.AssertCancelSpotFleetRequestsErrorSet(struct["UnsuccessfulFleetRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsResponse[k], "CancelSpotFleetRequestsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsResponse
-- <p>Contains the output of CancelSpotFleetRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SuccessfulFleetRequests [CancelSpotFleetRequestsSuccessSet] <p>Information about the Spot fleet requests that are successfully canceled.</p>
-- * UnsuccessfulFleetRequests [CancelSpotFleetRequestsErrorSet] <p>Information about the Spot fleet requests that are not successfully canceled.</p>
-- @return CancelSpotFleetRequestsResponse structure as a key-value pair table
function M.CancelSpotFleetRequestsResponse(args)
	assert(args, "You must provdide an argument table when creating CancelSpotFleetRequestsResponse")
	local t = { 
		["SuccessfulFleetRequests"] = args["SuccessfulFleetRequests"],
		["UnsuccessfulFleetRequests"] = args["UnsuccessfulFleetRequests"],
	}
	asserts.AssertCancelSpotFleetRequestsResponse(t)
	return t
end

keys.PlacementGroup = { ["GroupName"] = true, ["State"] = true, ["Strategy"] = true, nil }

function asserts.AssertPlacementGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PlacementGroup to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["State"] then asserts.AssertPlacementGroupState(struct["State"]) end
	if struct["Strategy"] then asserts.AssertPlacementStrategy(struct["Strategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.PlacementGroup[k], "PlacementGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PlacementGroup
-- <p>Describes a placement group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the placement group.</p>
-- * State [PlacementGroupState] <p>The state of the placement group.</p>
-- * Strategy [PlacementStrategy] <p>The placement strategy.</p>
-- @return PlacementGroup structure as a key-value pair table
function M.PlacementGroup(args)
	assert(args, "You must provdide an argument table when creating PlacementGroup")
	local t = { 
		["GroupName"] = args["GroupName"],
		["State"] = args["State"],
		["Strategy"] = args["Strategy"],
	}
	asserts.AssertPlacementGroup(t)
	return t
end

keys.AssociateIamInstanceProfileRequest = { ["InstanceId"] = true, ["IamInstanceProfile"] = true, nil }

function asserts.AssertAssociateIamInstanceProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateIamInstanceProfileRequest to be of type 'table'")
	assert(struct["IamInstanceProfile"], "Expected key IamInstanceProfile to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateIamInstanceProfileRequest[k], "AssociateIamInstanceProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateIamInstanceProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- Required key: IamInstanceProfile
-- Required key: InstanceId
-- @return AssociateIamInstanceProfileRequest structure as a key-value pair table
function M.AssociateIamInstanceProfileRequest(args)
	assert(args, "You must provdide an argument table when creating AssociateIamInstanceProfileRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
	}
	asserts.AssertAssociateIamInstanceProfileRequest(t)
	return t
end

keys.CreateNatGatewayRequest = { ["SubnetId"] = true, ["AllocationId"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateNatGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNatGatewayRequest to be of type 'table'")
	assert(struct["AllocationId"], "Expected key AllocationId to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNatGatewayRequest[k], "CreateNatGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNatGatewayRequest
-- <p>Contains the parameters for CreateNatGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The subnet in which to create the NAT gateway.</p>
-- * AllocationId [String] <p>The allocation ID of an Elastic IP address to associate with the NAT gateway. If the Elastic IP address is associated with another resource, you must first disassociate it.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p> <p>Constraint: Maximum 64 ASCII characters.</p>
-- Required key: AllocationId
-- Required key: SubnetId
-- @return CreateNatGatewayRequest structure as a key-value pair table
function M.CreateNatGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating CreateNatGatewayRequest")
	local t = { 
		["SubnetId"] = args["SubnetId"],
		["AllocationId"] = args["AllocationId"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateNatGatewayRequest(t)
	return t
end

keys.PricingDetail = { ["Count"] = true, ["Price"] = true, nil }

function asserts.AssertPricingDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PricingDetail to be of type 'table'")
	if struct["Count"] then asserts.AssertInteger(struct["Count"]) end
	if struct["Price"] then asserts.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(keys.PricingDetail[k], "PricingDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PricingDetail
-- <p>Describes a Reserved Instance offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Count [Integer] <p>The number of reservations available for the price.</p>
-- * Price [Double] <p>The price per instance.</p>
-- @return PricingDetail structure as a key-value pair table
function M.PricingDetail(args)
	assert(args, "You must provdide an argument table when creating PricingDetail")
	local t = { 
		["Count"] = args["Count"],
		["Price"] = args["Price"],
	}
	asserts.AssertPricingDetail(t)
	return t
end

keys.UnassignIpv6AddressesRequest = { ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, nil }

function asserts.AssertUnassignIpv6AddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignIpv6AddressesRequest to be of type 'table'")
	assert(struct["Ipv6Addresses"], "Expected key Ipv6Addresses to exist in table")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Ipv6Addresses"] then asserts.AssertIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnassignIpv6AddressesRequest[k], "UnassignIpv6AddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignIpv6AddressesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Addresses [Ipv6AddressList] <p>The IPv6 addresses to unassign from the network interface.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- Required key: Ipv6Addresses
-- Required key: NetworkInterfaceId
-- @return UnassignIpv6AddressesRequest structure as a key-value pair table
function M.UnassignIpv6AddressesRequest(args)
	assert(args, "You must provdide an argument table when creating UnassignIpv6AddressesRequest")
	local t = { 
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
	}
	asserts.AssertUnassignIpv6AddressesRequest(t)
	return t
end

keys.EnableVpcClassicLinkResult = { ["Return"] = true, nil }

function asserts.AssertEnableVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkResult[k], "EnableVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkResult
-- <p>Contains the output of EnableVpcClassicLink.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return EnableVpcClassicLinkResult structure as a key-value pair table
function M.EnableVpcClassicLinkResult(args)
	assert(args, "You must provdide an argument table when creating EnableVpcClassicLinkResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertEnableVpcClassicLinkResult(t)
	return t
end

keys.SpotPlacement = { ["Tenancy"] = true, ["GroupName"] = true, ["AvailabilityZone"] = true, nil }

function asserts.AssertSpotPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotPlacement to be of type 'table'")
	if struct["Tenancy"] then asserts.AssertTenancy(struct["Tenancy"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotPlacement[k], "SpotPlacement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotPlacement
-- <p>Describes Spot instance placement.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for Spot instances.</p>
-- * GroupName [String] <p>The name of the placement group (for cluster instances).</p>
-- * AvailabilityZone [String] <p>The Availability Zone.</p> <p>[Spot fleet only] To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".</p>
-- @return SpotPlacement structure as a key-value pair table
function M.SpotPlacement(args)
	assert(args, "You must provdide an argument table when creating SpotPlacement")
	local t = { 
		["Tenancy"] = args["Tenancy"],
		["GroupName"] = args["GroupName"],
		["AvailabilityZone"] = args["AvailabilityZone"],
	}
	asserts.AssertSpotPlacement(t)
	return t
end

keys.DeleteVpcEndpointsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertDeleteVpcEndpointsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointsResult[k], "DeleteVpcEndpointsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointsResult
-- <p>Contains the output of DeleteVpcEndpoints.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the endpoints that were not successfully deleted.</p>
-- @return DeleteVpcEndpointsResult structure as a key-value pair table
function M.DeleteVpcEndpointsResult(args)
	assert(args, "You must provdide an argument table when creating DeleteVpcEndpointsResult")
	local t = { 
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertDeleteVpcEndpointsResult(t)
	return t
end

keys.EbsInstanceBlockDevice = { ["Status"] = true, ["DeleteOnTermination"] = true, ["VolumeId"] = true, ["AttachTime"] = true, nil }

function asserts.AssertEbsInstanceBlockDevice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsInstanceBlockDevice to be of type 'table'")
	if struct["Status"] then asserts.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.EbsInstanceBlockDevice[k], "EbsInstanceBlockDevice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsInstanceBlockDevice
-- <p>Describes a parameter used to set up an EBS volume in a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [AttachmentStatus] <p>The attachment state.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- * VolumeId [String] <p>The ID of the EBS volume.</p>
-- * AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
-- @return EbsInstanceBlockDevice structure as a key-value pair table
function M.EbsInstanceBlockDevice(args)
	assert(args, "You must provdide an argument table when creating EbsInstanceBlockDevice")
	local t = { 
		["Status"] = args["Status"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["VolumeId"] = args["VolumeId"],
		["AttachTime"] = args["AttachTime"],
	}
	asserts.AssertEbsInstanceBlockDevice(t)
	return t
end

keys.VolumeStatusDetails = { ["Status"] = true, ["Name"] = true, nil }

function asserts.AssertVolumeStatusDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusDetails to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["Name"] then asserts.AssertVolumeStatusName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusDetails[k], "VolumeStatusDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusDetails
-- <p>Describes a volume status.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>The intended status of the volume status.</p>
-- * Name [VolumeStatusName] <p>The name of the volume status.</p>
-- @return VolumeStatusDetails structure as a key-value pair table
function M.VolumeStatusDetails(args)
	assert(args, "You must provdide an argument table when creating VolumeStatusDetails")
	local t = { 
		["Status"] = args["Status"],
		["Name"] = args["Name"],
	}
	asserts.AssertVolumeStatusDetails(t)
	return t
end

keys.DescribeHostReservationOfferingsRequest = { ["OfferingId"] = true, ["MaxResults"] = true, ["Filter"] = true, ["MinDuration"] = true, ["NextToken"] = true, ["MaxDuration"] = true, nil }

function asserts.AssertDescribeHostReservationOfferingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationOfferingsRequest to be of type 'table'")
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["MinDuration"] then asserts.AssertInteger(struct["MinDuration"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxDuration"] then asserts.AssertInteger(struct["MaxDuration"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationOfferingsRequest[k], "DescribeHostReservationOfferingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationOfferingsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OfferingId [String] <p>The ID of the reservation offering.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500; if <code>maxResults</code> is given a larger value than 500, you will receive an error.</p>
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-family</code> - The instance family of the offering (e.g., <code>m4</code>).</p> </li> <li> <p> <code>payment-option</code> - The payment option (<code>NoUpfront</code> | <code>PartialUpfront</code> | <code>AllUpfront</code>).</p> </li> </ul>
-- * MinDuration [Integer] <p>This is the minimum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 31536000 for one year.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- * MaxDuration [Integer] <p>This is the maximum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 94608000 for three years.</p>
-- @return DescribeHostReservationOfferingsRequest structure as a key-value pair table
function M.DescribeHostReservationOfferingsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeHostReservationOfferingsRequest")
	local t = { 
		["OfferingId"] = args["OfferingId"],
		["MaxResults"] = args["MaxResults"],
		["Filter"] = args["Filter"],
		["MinDuration"] = args["MinDuration"],
		["NextToken"] = args["NextToken"],
		["MaxDuration"] = args["MaxDuration"],
	}
	asserts.AssertDescribeHostReservationOfferingsRequest(t)
	return t
end

keys.StartInstancesResult = { ["StartingInstances"] = true, nil }

function asserts.AssertStartInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartInstancesResult to be of type 'table'")
	if struct["StartingInstances"] then asserts.AssertInstanceStateChangeList(struct["StartingInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartInstancesResult[k], "StartInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartInstancesResult
-- <p>Contains the output of StartInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StartingInstances [InstanceStateChangeList] <p>Information about one or more started instances.</p>
-- @return StartInstancesResult structure as a key-value pair table
function M.StartInstancesResult(args)
	assert(args, "You must provdide an argument table when creating StartInstancesResult")
	local t = { 
		["StartingInstances"] = args["StartingInstances"],
	}
	asserts.AssertStartInstancesResult(t)
	return t
end

keys.Address = { ["Domain"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["AssociationId"] = true, ["NetworkInterfaceOwnerId"] = true, ["PublicIp"] = true, ["AllocationId"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Address to be of type 'table'")
	if struct["Domain"] then asserts.AssertDomainType(struct["Domain"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["NetworkInterfaceOwnerId"] then asserts.AssertString(struct["NetworkInterfaceOwnerId"]) end
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.Address[k], "Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Address
-- <p>Describes an Elastic IP address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Domain [DomainType] <p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
-- * InstanceId [String] <p>The ID of the instance that the address is associated with (if any).</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * AssociationId [String] <p>The ID representing the association of the address with an instance in a VPC.</p>
-- * NetworkInterfaceOwnerId [String] <p>The ID of the AWS account that owns the network interface.</p>
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * AllocationId [String] <p>The ID representing the allocation of the address for use with EC2-VPC.</p>
-- * PrivateIpAddress [String] <p>The private IP address associated with the Elastic IP address.</p>
-- @return Address structure as a key-value pair table
function M.Address(args)
	assert(args, "You must provdide an argument table when creating Address")
	local t = { 
		["Domain"] = args["Domain"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AssociationId"] = args["AssociationId"],
		["NetworkInterfaceOwnerId"] = args["NetworkInterfaceOwnerId"],
		["PublicIp"] = args["PublicIp"],
		["AllocationId"] = args["AllocationId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertAddress(t)
	return t
end

keys.VpnGateway = { ["AvailabilityZone"] = true, ["Tags"] = true, ["VpcAttachments"] = true, ["State"] = true, ["VpnGatewayId"] = true, ["Type"] = true, nil }

function asserts.AssertVpnGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnGateway to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["VpcAttachments"] then asserts.AssertVpcAttachmentList(struct["VpcAttachments"]) end
	if struct["State"] then asserts.AssertVpnState(struct["State"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnGateway[k], "VpnGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnGateway
-- <p>Describes a virtual private gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.</p>
-- * Tags [TagList] <p>Any tags assigned to the virtual private gateway.</p>
-- * VpcAttachments [VpcAttachmentList] <p>Any VPCs attached to the virtual private gateway.</p>
-- * State [VpnState] <p>The current state of the virtual private gateway.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- * Type [GatewayType] <p>The type of VPN connection the virtual private gateway supports.</p>
-- @return VpnGateway structure as a key-value pair table
function M.VpnGateway(args)
	assert(args, "You must provdide an argument table when creating VpnGateway")
	local t = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Tags"] = args["Tags"],
		["VpcAttachments"] = args["VpcAttachments"],
		["State"] = args["State"],
		["VpnGatewayId"] = args["VpnGatewayId"],
		["Type"] = args["Type"],
	}
	asserts.AssertVpnGateway(t)
	return t
end

keys.ReleaseHostsRequest = { ["HostIds"] = true, nil }

function asserts.AssertReleaseHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseHostsRequest to be of type 'table'")
	assert(struct["HostIds"], "Expected key HostIds to exist in table")
	if struct["HostIds"] then asserts.AssertRequestHostIdList(struct["HostIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReleaseHostsRequest[k], "ReleaseHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseHostsRequest
-- <p>Contains the parameters for ReleaseHosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostIds [RequestHostIdList] <p>The IDs of the Dedicated Hosts you want to release.</p>
-- Required key: HostIds
-- @return ReleaseHostsRequest structure as a key-value pair table
function M.ReleaseHostsRequest(args)
	assert(args, "You must provdide an argument table when creating ReleaseHostsRequest")
	local t = { 
		["HostIds"] = args["HostIds"],
	}
	asserts.AssertReleaseHostsRequest(t)
	return t
end

keys.EbsInstanceBlockDeviceSpecification = { ["DeleteOnTermination"] = true, ["VolumeId"] = true, nil }

function asserts.AssertEbsInstanceBlockDeviceSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsInstanceBlockDeviceSpecification to be of type 'table'")
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EbsInstanceBlockDeviceSpecification[k], "EbsInstanceBlockDeviceSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsInstanceBlockDeviceSpecification
-- <p>Describes information used to set up an EBS volume specified in a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- * VolumeId [String] <p>The ID of the EBS volume.</p>
-- @return EbsInstanceBlockDeviceSpecification structure as a key-value pair table
function M.EbsInstanceBlockDeviceSpecification(args)
	assert(args, "You must provdide an argument table when creating EbsInstanceBlockDeviceSpecification")
	local t = { 
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertEbsInstanceBlockDeviceSpecification(t)
	return t
end

keys.EnableVolumeIORequest = { ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertEnableVolumeIORequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVolumeIORequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVolumeIORequest[k], "EnableVolumeIORequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVolumeIORequest
-- <p>Contains the parameters for EnableVolumeIO.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: VolumeId
-- @return EnableVolumeIORequest structure as a key-value pair table
function M.EnableVolumeIORequest(args)
	assert(args, "You must provdide an argument table when creating EnableVolumeIORequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertEnableVolumeIORequest(t)
	return t
end

keys.DescribeScheduledInstancesResult = { ["NextToken"] = true, ["ScheduledInstanceSet"] = true, nil }

function asserts.AssertDescribeScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstancesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ScheduledInstanceSet"] then asserts.AssertScheduledInstanceSet(struct["ScheduledInstanceSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstancesResult[k], "DescribeScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstancesResult
-- <p>Contains the output of DescribeScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ScheduledInstanceSet [ScheduledInstanceSet] <p>Information about the Scheduled Instances.</p>
-- @return DescribeScheduledInstancesResult structure as a key-value pair table
function M.DescribeScheduledInstancesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeScheduledInstancesResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["ScheduledInstanceSet"] = args["ScheduledInstanceSet"],
	}
	asserts.AssertDescribeScheduledInstancesResult(t)
	return t
end

keys.AssociateVpcCidrBlockResult = { ["Ipv6CidrBlockAssociation"] = true, ["VpcId"] = true, nil }

function asserts.AssertAssociateVpcCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateVpcCidrBlockResult to be of type 'table'")
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertVpcIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateVpcCidrBlockResult[k], "AssociateVpcCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateVpcCidrBlockResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlockAssociation [VpcIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return AssociateVpcCidrBlockResult structure as a key-value pair table
function M.AssociateVpcCidrBlockResult(args)
	assert(args, "You must provdide an argument table when creating AssociateVpcCidrBlockResult")
	local t = { 
		["Ipv6CidrBlockAssociation"] = args["Ipv6CidrBlockAssociation"],
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertAssociateVpcCidrBlockResult(t)
	return t
end

keys.PciId = { ["SubsystemVendorId"] = true, ["VendorId"] = true, ["DeviceId"] = true, ["SubsystemId"] = true, nil }

function asserts.AssertPciId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PciId to be of type 'table'")
	if struct["SubsystemVendorId"] then asserts.AssertString(struct["SubsystemVendorId"]) end
	if struct["VendorId"] then asserts.AssertString(struct["VendorId"]) end
	if struct["DeviceId"] then asserts.AssertString(struct["DeviceId"]) end
	if struct["SubsystemId"] then asserts.AssertString(struct["SubsystemId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PciId[k], "PciId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PciId
-- <p>Describes the data that identifies an Amazon FPGA image (AFI) on the PCI bus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubsystemVendorId [String] <p>The ID of the vendor for the subsystem.</p>
-- * VendorId [String] <p>The ID of the vendor.</p>
-- * DeviceId [String] <p>The ID of the device.</p>
-- * SubsystemId [String] <p>The ID of the subsystem.</p>
-- @return PciId structure as a key-value pair table
function M.PciId(args)
	assert(args, "You must provdide an argument table when creating PciId")
	local t = { 
		["SubsystemVendorId"] = args["SubsystemVendorId"],
		["VendorId"] = args["VendorId"],
		["DeviceId"] = args["DeviceId"],
		["SubsystemId"] = args["SubsystemId"],
	}
	asserts.AssertPciId(t)
	return t
end

keys.RequestSpotLaunchSpecification = { ["UserData"] = true, ["SubnetId"] = true, ["Monitoring"] = true, ["KeyName"] = true, ["SecurityGroupIds"] = true, ["ImageId"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroups"] = true, ["RamdiskId"] = true, ["KernelId"] = true, ["Placement"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["AddressingType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertRequestSpotLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotLaunchSpecification to be of type 'table'")
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then asserts.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroupIds"] then asserts.AssertValueStringList(struct["SecurityGroupIds"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then asserts.AssertValueStringList(struct["SecurityGroups"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Placement"] then asserts.AssertSpotPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then asserts.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotLaunchSpecification[k], "RequestSpotLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotLaunchSpecification
-- <p>Describes the launch specification for an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserData [String] <p>The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instance.</p>
-- * Monitoring [RunInstancesMonitoringEnabled] <p>Indicates whether basic or detailed monitoring is enabled for the instance.</p> <p>Default: Disabled</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * SecurityGroupIds [ValueStringList] <p>One or more security group IDs.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p> <p>Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- * SecurityGroups [ValueStringList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * Placement [SpotPlacement] <p>The placement information for the instance.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * AddressingType [String] <p>Deprecated.</p>
-- * NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
-- @return RequestSpotLaunchSpecification structure as a key-value pair table
function M.RequestSpotLaunchSpecification(args)
	assert(args, "You must provdide an argument table when creating RequestSpotLaunchSpecification")
	local t = { 
		["UserData"] = args["UserData"],
		["SubnetId"] = args["SubnetId"],
		["Monitoring"] = args["Monitoring"],
		["KeyName"] = args["KeyName"],
		["SecurityGroupIds"] = args["SecurityGroupIds"],
		["ImageId"] = args["ImageId"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["SecurityGroups"] = args["SecurityGroups"],
		["RamdiskId"] = args["RamdiskId"],
		["KernelId"] = args["KernelId"],
		["Placement"] = args["Placement"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["InstanceType"] = args["InstanceType"],
		["AddressingType"] = args["AddressingType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertRequestSpotLaunchSpecification(t)
	return t
end

keys.CustomerGateway = { ["Tags"] = true, ["IpAddress"] = true, ["State"] = true, ["CustomerGatewayId"] = true, ["BgpAsn"] = true, ["Type"] = true, nil }

function asserts.AssertCustomerGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CustomerGateway to be of type 'table'")
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["IpAddress"] then asserts.AssertString(struct["IpAddress"]) end
	if struct["State"] then asserts.AssertString(struct["State"]) end
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["BgpAsn"] then asserts.AssertString(struct["BgpAsn"]) end
	if struct["Type"] then asserts.AssertString(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.CustomerGateway[k], "CustomerGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CustomerGateway
-- <p>Describes a customer gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Tags [TagList] <p>Any tags assigned to the customer gateway.</p>
-- * IpAddress [String] <p>The Internet-routable IP address of the customer gateway's outside interface.</p>
-- * State [String] <p>The current state of the customer gateway (<code>pending | available | deleting | deleted</code>).</p>
-- * CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- * BgpAsn [String] <p>The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p>
-- * Type [String] <p>The type of VPN connection the customer gateway supports (<code>ipsec.1</code>).</p>
-- @return CustomerGateway structure as a key-value pair table
function M.CustomerGateway(args)
	assert(args, "You must provdide an argument table when creating CustomerGateway")
	local t = { 
		["Tags"] = args["Tags"],
		["IpAddress"] = args["IpAddress"],
		["State"] = args["State"],
		["CustomerGatewayId"] = args["CustomerGatewayId"],
		["BgpAsn"] = args["BgpAsn"],
		["Type"] = args["Type"],
	}
	asserts.AssertCustomerGateway(t)
	return t
end

keys.CreateSpotDatafeedSubscriptionRequest = { ["DryRun"] = true, ["Prefix"] = true, ["Bucket"] = true, nil }

function asserts.AssertCreateSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSpotDatafeedSubscriptionRequest to be of type 'table'")
	assert(struct["Bucket"], "Expected key Bucket to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Prefix"] then asserts.AssertString(struct["Prefix"]) end
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSpotDatafeedSubscriptionRequest[k], "CreateSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for CreateSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Prefix [String] <p>A prefix for the data feed file names.</p>
-- * Bucket [String] <p>The Amazon S3 bucket in which to store the Spot instance data feed.</p>
-- Required key: Bucket
-- @return CreateSpotDatafeedSubscriptionRequest structure as a key-value pair table
function M.CreateSpotDatafeedSubscriptionRequest(args)
	assert(args, "You must provdide an argument table when creating CreateSpotDatafeedSubscriptionRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Prefix"] = args["Prefix"],
		["Bucket"] = args["Bucket"],
	}
	asserts.AssertCreateSpotDatafeedSubscriptionRequest(t)
	return t
end

keys.DeleteFlowLogsRequest = { ["FlowLogIds"] = true, nil }

function asserts.AssertDeleteFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFlowLogsRequest to be of type 'table'")
	assert(struct["FlowLogIds"], "Expected key FlowLogIds to exist in table")
	if struct["FlowLogIds"] then asserts.AssertValueStringList(struct["FlowLogIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFlowLogsRequest[k], "DeleteFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFlowLogsRequest
-- <p>Contains the parameters for DeleteFlowLogs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FlowLogIds [ValueStringList] <p>One or more flow log IDs.</p>
-- Required key: FlowLogIds
-- @return DeleteFlowLogsRequest structure as a key-value pair table
function M.DeleteFlowLogsRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteFlowLogsRequest")
	local t = { 
		["FlowLogIds"] = args["FlowLogIds"],
	}
	asserts.AssertDeleteFlowLogsRequest(t)
	return t
end

keys.DescribeSpotFleetInstancesRequest = { ["SpotFleetRequestId"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeSpotFleetInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetInstancesRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetInstancesRequest[k], "DescribeSpotFleetInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetInstancesRequest
-- <p>Contains the parameters for DescribeSpotFleetInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- Required key: SpotFleetRequestId
-- @return DescribeSpotFleetInstancesRequest structure as a key-value pair table
function M.DescribeSpotFleetInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotFleetInstancesRequest")
	local t = { 
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeSpotFleetInstancesRequest(t)
	return t
end

keys.AvailableCapacity = { ["AvailableInstanceCapacity"] = true, ["AvailableVCpus"] = true, nil }

function asserts.AssertAvailableCapacity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailableCapacity to be of type 'table'")
	if struct["AvailableInstanceCapacity"] then asserts.AssertAvailableInstanceCapacityList(struct["AvailableInstanceCapacity"]) end
	if struct["AvailableVCpus"] then asserts.AssertInteger(struct["AvailableVCpus"]) end
	for k,_ in pairs(struct) do
		assert(keys.AvailableCapacity[k], "AvailableCapacity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailableCapacity
-- <p>The capacity information for instances launched onto the Dedicated Host.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailableInstanceCapacity [AvailableInstanceCapacityList] <p>The total number of instances that the Dedicated Host supports.</p>
-- * AvailableVCpus [Integer] <p>The number of vCPUs available on the Dedicated Host.</p>
-- @return AvailableCapacity structure as a key-value pair table
function M.AvailableCapacity(args)
	assert(args, "You must provdide an argument table when creating AvailableCapacity")
	local t = { 
		["AvailableInstanceCapacity"] = args["AvailableInstanceCapacity"],
		["AvailableVCpus"] = args["AvailableVCpus"],
	}
	asserts.AssertAvailableCapacity(t)
	return t
end

keys.LaunchPermissionModifications = { ["Add"] = true, ["Remove"] = true, nil }

function asserts.AssertLaunchPermissionModifications(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchPermissionModifications to be of type 'table'")
	if struct["Add"] then asserts.AssertLaunchPermissionList(struct["Add"]) end
	if struct["Remove"] then asserts.AssertLaunchPermissionList(struct["Remove"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchPermissionModifications[k], "LaunchPermissionModifications contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchPermissionModifications
-- <p>Describes a launch permission modification.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Add [LaunchPermissionList] <p>The AWS account ID to add to the list of launch permissions for the AMI.</p>
-- * Remove [LaunchPermissionList] <p>The AWS account ID to remove from the list of launch permissions for the AMI.</p>
-- @return LaunchPermissionModifications structure as a key-value pair table
function M.LaunchPermissionModifications(args)
	assert(args, "You must provdide an argument table when creating LaunchPermissionModifications")
	local t = { 
		["Add"] = args["Add"],
		["Remove"] = args["Remove"],
	}
	asserts.AssertLaunchPermissionModifications(t)
	return t
end

keys.GetReservedInstancesExchangeQuoteRequest = { ["ReservedInstanceIds"] = true, ["DryRun"] = true, ["TargetConfigurations"] = true, nil }

function asserts.AssertGetReservedInstancesExchangeQuoteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetReservedInstancesExchangeQuoteRequest to be of type 'table'")
	assert(struct["ReservedInstanceIds"], "Expected key ReservedInstanceIds to exist in table")
	if struct["ReservedInstanceIds"] then asserts.AssertReservedInstanceIdSet(struct["ReservedInstanceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TargetConfigurations"] then asserts.AssertTargetConfigurationRequestSet(struct["TargetConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetReservedInstancesExchangeQuoteRequest[k], "GetReservedInstancesExchangeQuoteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetReservedInstancesExchangeQuoteRequest
-- <p>Contains the parameters for GetReservedInstanceExchangeQuote.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstanceIds [ReservedInstanceIdSet] <p>The IDs of the Convertible Reserved Instances to exchange.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TargetConfigurations [TargetConfigurationRequestSet] <p>The configuration requirements of the Convertible Reserved Instances to exchange for your current Convertible Reserved Instances.</p>
-- Required key: ReservedInstanceIds
-- @return GetReservedInstancesExchangeQuoteRequest structure as a key-value pair table
function M.GetReservedInstancesExchangeQuoteRequest(args)
	assert(args, "You must provdide an argument table when creating GetReservedInstancesExchangeQuoteRequest")
	local t = { 
		["ReservedInstanceIds"] = args["ReservedInstanceIds"],
		["DryRun"] = args["DryRun"],
		["TargetConfigurations"] = args["TargetConfigurations"],
	}
	asserts.AssertGetReservedInstancesExchangeQuoteRequest(t)
	return t
end

keys.VpnStaticRoute = { ["DestinationCidrBlock"] = true, ["State"] = true, ["Source"] = true, nil }

function asserts.AssertVpnStaticRoute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnStaticRoute to be of type 'table'")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["State"] then asserts.AssertVpnState(struct["State"]) end
	if struct["Source"] then asserts.AssertVpnStaticRouteSource(struct["Source"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnStaticRoute[k], "VpnStaticRoute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnStaticRoute
-- <p>Describes a static route for a VPN connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer data center.</p>
-- * State [VpnState] <p>The current state of the static route.</p>
-- * Source [VpnStaticRouteSource] <p>Indicates how the routes were provided.</p>
-- @return VpnStaticRoute structure as a key-value pair table
function M.VpnStaticRoute(args)
	assert(args, "You must provdide an argument table when creating VpnStaticRoute")
	local t = { 
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["State"] = args["State"],
		["Source"] = args["Source"],
	}
	asserts.AssertVpnStaticRoute(t)
	return t
end

keys.DeleteVpcPeeringConnectionRequest = { ["DryRun"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertDeleteVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcPeeringConnectionRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcPeeringConnectionRequest[k], "DeleteVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcPeeringConnectionRequest
-- <p>Contains the parameters for DeleteVpcPeeringConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required key: VpcPeeringConnectionId
-- @return DeleteVpcPeeringConnectionRequest structure as a key-value pair table
function M.DeleteVpcPeeringConnectionRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteVpcPeeringConnectionRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
	}
	asserts.AssertDeleteVpcPeeringConnectionRequest(t)
	return t
end

keys.DescribeReservedInstancesModificationsResult = { ["NextToken"] = true, ["ReservedInstancesModifications"] = true, nil }

function asserts.AssertDescribeReservedInstancesModificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesModificationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesModifications"] then asserts.AssertReservedInstancesModificationList(struct["ReservedInstancesModifications"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesModificationsResult[k], "DescribeReservedInstancesModificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesModificationsResult
-- <p>Contains the output of DescribeReservedInstancesModifications.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ReservedInstancesModifications [ReservedInstancesModificationList] <p>The Reserved Instance modification information.</p>
-- @return DescribeReservedInstancesModificationsResult structure as a key-value pair table
function M.DescribeReservedInstancesModificationsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeReservedInstancesModificationsResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["ReservedInstancesModifications"] = args["ReservedInstancesModifications"],
	}
	asserts.AssertDescribeReservedInstancesModificationsResult(t)
	return t
end

keys.IdFormat = { ["Resource"] = true, ["Deadline"] = true, ["UseLongIds"] = true, nil }

function asserts.AssertIdFormat(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IdFormat to be of type 'table'")
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	if struct["Deadline"] then asserts.AssertDateTime(struct["Deadline"]) end
	if struct["UseLongIds"] then asserts.AssertBoolean(struct["UseLongIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.IdFormat[k], "IdFormat contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IdFormat
-- <p>Describes the ID format for a resource.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Resource [String] <p>The type of resource.</p>
-- * Deadline [DateTime] <p>The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.</p>
-- * UseLongIds [Boolean] <p>Indicates whether longer IDs (17-character IDs) are enabled for the resource.</p>
-- @return IdFormat structure as a key-value pair table
function M.IdFormat(args)
	assert(args, "You must provdide an argument table when creating IdFormat")
	local t = { 
		["Resource"] = args["Resource"],
		["Deadline"] = args["Deadline"],
		["UseLongIds"] = args["UseLongIds"],
	}
	asserts.AssertIdFormat(t)
	return t
end

keys.TargetConfigurationRequest = { ["InstanceCount"] = true, ["OfferingId"] = true, nil }

function asserts.AssertTargetConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetConfigurationRequest to be of type 'table'")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetConfigurationRequest[k], "TargetConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetConfigurationRequest
-- <p>Details about the target configuration.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceCount [Integer] <p>The number of instances the Covertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>
-- * OfferingId [String] <p>The Convertible Reserved Instance offering ID.</p>
-- Required key: OfferingId
-- @return TargetConfigurationRequest structure as a key-value pair table
function M.TargetConfigurationRequest(args)
	assert(args, "You must provdide an argument table when creating TargetConfigurationRequest")
	local t = { 
		["InstanceCount"] = args["InstanceCount"],
		["OfferingId"] = args["OfferingId"],
	}
	asserts.AssertTargetConfigurationRequest(t)
	return t
end

keys.InstanceState = { ["Code"] = true, ["Name"] = true, nil }

function asserts.AssertInstanceState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceState to be of type 'table'")
	if struct["Code"] then asserts.AssertInteger(struct["Code"]) end
	if struct["Name"] then asserts.AssertInstanceStateName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceState[k], "InstanceState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceState
-- <p>Describes the current state of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Code [Integer] <p>The low byte represents the state. The high byte is an opaque internal value and should be ignored.</p> <ul> <li> <p> <code>0</code> : <code>pending</code> </p> </li> <li> <p> <code>16</code> : <code>running</code> </p> </li> <li> <p> <code>32</code> : <code>shutting-down</code> </p> </li> <li> <p> <code>48</code> : <code>terminated</code> </p> </li> <li> <p> <code>64</code> : <code>stopping</code> </p> </li> <li> <p> <code>80</code> : <code>stopped</code> </p> </li> </ul>
-- * Name [InstanceStateName] <p>The current state of the instance.</p>
-- @return InstanceState structure as a key-value pair table
function M.InstanceState(args)
	assert(args, "You must provdide an argument table when creating InstanceState")
	local t = { 
		["Code"] = args["Code"],
		["Name"] = args["Name"],
	}
	asserts.AssertInstanceState(t)
	return t
end

keys.AttachClassicLinkVpcResult = { ["Return"] = true, nil }

function asserts.AssertAttachClassicLinkVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachClassicLinkVpcResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachClassicLinkVpcResult[k], "AttachClassicLinkVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachClassicLinkVpcResult
-- <p>Contains the output of AttachClassicLinkVpc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return AttachClassicLinkVpcResult structure as a key-value pair table
function M.AttachClassicLinkVpcResult(args)
	assert(args, "You must provdide an argument table when creating AttachClassicLinkVpcResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertAttachClassicLinkVpcResult(t)
	return t
end

keys.DetachClassicLinkVpcResult = { ["Return"] = true, nil }

function asserts.AssertDetachClassicLinkVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachClassicLinkVpcResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachClassicLinkVpcResult[k], "DetachClassicLinkVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachClassicLinkVpcResult
-- <p>Contains the output of DetachClassicLinkVpc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DetachClassicLinkVpcResult structure as a key-value pair table
function M.DetachClassicLinkVpcResult(args)
	assert(args, "You must provdide an argument table when creating DetachClassicLinkVpcResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDetachClassicLinkVpcResult(t)
	return t
end

keys.DisassociateSubnetCidrBlockResult = { ["SubnetId"] = true, ["Ipv6CidrBlockAssociation"] = true, nil }

function asserts.AssertDisassociateSubnetCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateSubnetCidrBlockResult to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertSubnetIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateSubnetCidrBlockResult[k], "DisassociateSubnetCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateSubnetCidrBlockResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * Ipv6CidrBlockAssociation [SubnetIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- @return DisassociateSubnetCidrBlockResult structure as a key-value pair table
function M.DisassociateSubnetCidrBlockResult(args)
	assert(args, "You must provdide an argument table when creating DisassociateSubnetCidrBlockResult")
	local t = { 
		["SubnetId"] = args["SubnetId"],
		["Ipv6CidrBlockAssociation"] = args["Ipv6CidrBlockAssociation"],
	}
	asserts.AssertDisassociateSubnetCidrBlockResult(t)
	return t
end

keys.ModifyInstanceAttributeRequest = { ["Ramdisk"] = true, ["Kernel"] = true, ["SourceDestCheck"] = true, ["DryRun"] = true, ["UserData"] = true, ["InstanceId"] = true, ["Attribute"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["BlockDeviceMappings"] = true, ["Value"] = true, ["Groups"] = true, ["EbsOptimized"] = true, ["DisableApiTermination"] = true, ["InstanceType"] = true, nil }

function asserts.AssertModifyInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstanceAttributeRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["Ramdisk"] then asserts.AssertAttributeValue(struct["Ramdisk"]) end
	if struct["Kernel"] then asserts.AssertAttributeValue(struct["Kernel"]) end
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["UserData"] then asserts.AssertBlobAttributeValue(struct["UserData"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then asserts.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["EnaSupport"] then asserts.AssertAttributeBooleanValue(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertAttributeValue(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertInstanceBlockDeviceMappingSpecificationList(struct["BlockDeviceMappings"]) end
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["Groups"] then asserts.AssertGroupIdStringList(struct["Groups"]) end
	if struct["EbsOptimized"] then asserts.AssertAttributeBooleanValue(struct["EbsOptimized"]) end
	if struct["DisableApiTermination"] then asserts.AssertAttributeBooleanValue(struct["DisableApiTermination"]) end
	if struct["InstanceType"] then asserts.AssertAttributeValue(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstanceAttributeRequest[k], "ModifyInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstanceAttributeRequest
-- <p>Contains the parameters for ModifyInstanceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ramdisk [AttributeValue] <p>Changes the instance's RAM disk to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
-- * Kernel [AttributeValue] <p>Changes the instance's kernel to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
-- * SourceDestCheck [AttributeBooleanValue] <p>Specifies whether source/destination checking is enabled. A value of <code>true</code> means that checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * UserData [BlobAttributeValue] <p>Changes the instance's user data to the specified value. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Attribute [InstanceAttributeName] <p>The name of the attribute.</p>
-- * EnaSupport [AttributeBooleanValue] <p>Set to <code>true</code> to enable enhanced networking with ENA for the instance.</p> <p>This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.</p>
-- * SriovNetSupport [AttributeValue] <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual Function interface for the instance.</p> <p>There is no way to disable enhanced networking with the Intel 82599 Virtual Function interface at this time.</p> <p>This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.</p>
-- * InstanceInitiatedShutdownBehavior [AttributeValue] <p>Specifies whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- * BlockDeviceMappings [InstanceBlockDeviceMappingSpecificationList] <p>Modifies the <code>DeleteOnTermination</code> attribute for volumes that are currently attached. The volume must be owned by the caller. If no value is specified for <code>DeleteOnTermination</code>, the default is <code>true</code> and the volume is deleted when the instance is terminated.</p> <p>To add instance store volumes to an Amazon EBS-backed instance, you must add them when you launch the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html#Using_OverridingAMIBDM">Updating the Block Device Mapping when Launching an Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * Value [String] <p>A new value for the attribute. Use only with the <code>kernel</code>, <code>ramdisk</code>, <code>userData</code>, <code>disableApiTermination</code>, or <code>instanceInitiatedShutdownBehavior</code> attribute.</p>
-- * Groups [GroupIdStringList] <p>[EC2-VPC] Changes the security groups of the instance. You must specify at least one security group, even if it's just the default security group for the VPC. You must specify the security group ID, not the security group name.</p>
-- * EbsOptimized [AttributeBooleanValue] <p>Specifies whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
-- * DisableApiTermination [AttributeBooleanValue] <p>If the value is <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this paramater for Spot Instances.</p>
-- * InstanceType [AttributeValue] <p>Changes the instance type to the specified value. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a>. If the instance type is not valid, the error returned is <code>InvalidInstanceAttributeValue</code>.</p>
-- Required key: InstanceId
-- @return ModifyInstanceAttributeRequest structure as a key-value pair table
function M.ModifyInstanceAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyInstanceAttributeRequest")
	local t = { 
		["Ramdisk"] = args["Ramdisk"],
		["Kernel"] = args["Kernel"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["DryRun"] = args["DryRun"],
		["UserData"] = args["UserData"],
		["InstanceId"] = args["InstanceId"],
		["Attribute"] = args["Attribute"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["Value"] = args["Value"],
		["Groups"] = args["Groups"],
		["EbsOptimized"] = args["EbsOptimized"],
		["DisableApiTermination"] = args["DisableApiTermination"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertModifyInstanceAttributeRequest(t)
	return t
end

keys.GetHostReservationPurchasePreviewRequest = { ["HostIdSet"] = true, ["OfferingId"] = true, nil }

function asserts.AssertGetHostReservationPurchasePreviewRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetHostReservationPurchasePreviewRequest to be of type 'table'")
	assert(struct["HostIdSet"], "Expected key HostIdSet to exist in table")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["HostIdSet"] then asserts.AssertRequestHostIdSet(struct["HostIdSet"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetHostReservationPurchasePreviewRequest[k], "GetHostReservationPurchasePreviewRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetHostReservationPurchasePreviewRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostIdSet [RequestHostIdSet] <p>The ID/s of the Dedicated Host/s that the reservation will be associated with.</p>
-- * OfferingId [String] <p>The offering ID of the reservation.</p>
-- Required key: HostIdSet
-- Required key: OfferingId
-- @return GetHostReservationPurchasePreviewRequest structure as a key-value pair table
function M.GetHostReservationPurchasePreviewRequest(args)
	assert(args, "You must provdide an argument table when creating GetHostReservationPurchasePreviewRequest")
	local t = { 
		["HostIdSet"] = args["HostIdSet"],
		["OfferingId"] = args["OfferingId"],
	}
	asserts.AssertGetHostReservationPurchasePreviewRequest(t)
	return t
end

keys.EnableVpcClassicLinkDnsSupportResult = { ["Return"] = true, nil }

function asserts.AssertEnableVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkDnsSupportResult[k], "EnableVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkDnsSupportResult
-- <p>Contains the output of EnableVpcClassicLinkDnsSupport.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return EnableVpcClassicLinkDnsSupportResult structure as a key-value pair table
function M.EnableVpcClassicLinkDnsSupportResult(args)
	assert(args, "You must provdide an argument table when creating EnableVpcClassicLinkDnsSupportResult")
	local t = { 
		["Return"] = args["Return"],
	}
	asserts.AssertEnableVpcClassicLinkDnsSupportResult(t)
	return t
end

keys.GetPasswordDataResult = { ["InstanceId"] = true, ["Timestamp"] = true, ["PasswordData"] = true, nil }

function asserts.AssertGetPasswordDataResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPasswordDataResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	if struct["PasswordData"] then asserts.AssertString(struct["PasswordData"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPasswordDataResult[k], "GetPasswordDataResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPasswordDataResult
-- <p>Contains the output of GetPasswordData.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the Windows instance.</p>
-- * Timestamp [DateTime] <p>The time the data was last updated.</p>
-- * PasswordData [String] <p>The password of the instance.</p>
-- @return GetPasswordDataResult structure as a key-value pair table
function M.GetPasswordDataResult(args)
	assert(args, "You must provdide an argument table when creating GetPasswordDataResult")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["Timestamp"] = args["Timestamp"],
		["PasswordData"] = args["PasswordData"],
	}
	asserts.AssertGetPasswordDataResult(t)
	return t
end

keys.KeyPairInfo = { ["KeyName"] = true, ["KeyFingerprint"] = true, nil }

function asserts.AssertKeyPairInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KeyPairInfo to be of type 'table'")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then asserts.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(keys.KeyPairInfo[k], "KeyPairInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KeyPairInfo
-- <p>Describes a key pair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyName [String] <p>The name of the key pair.</p>
-- * KeyFingerprint [String] <p>If you used <a>CreateKeyPair</a> to create the key pair, this is the SHA-1 digest of the DER encoded private key. If you used <a>ImportKeyPair</a> to provide AWS the public key, this is the MD5 public key fingerprint as specified in section 4 of RFC4716.</p>
-- @return KeyPairInfo structure as a key-value pair table
function M.KeyPairInfo(args)
	assert(args, "You must provdide an argument table when creating KeyPairInfo")
	local t = { 
		["KeyName"] = args["KeyName"],
		["KeyFingerprint"] = args["KeyFingerprint"],
	}
	asserts.AssertKeyPairInfo(t)
	return t
end

keys.DescribeVpcClassicLinkResult = { ["Vpcs"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkResult to be of type 'table'")
	if struct["Vpcs"] then asserts.AssertVpcClassicLinkList(struct["Vpcs"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkResult[k], "DescribeVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkResult
-- <p>Contains the output of DescribeVpcClassicLink.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Vpcs [VpcClassicLinkList] <p>The ClassicLink status of one or more VPCs.</p>
-- @return DescribeVpcClassicLinkResult structure as a key-value pair table
function M.DescribeVpcClassicLinkResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcClassicLinkResult")
	local t = { 
		["Vpcs"] = args["Vpcs"],
	}
	asserts.AssertDescribeVpcClassicLinkResult(t)
	return t
end

keys.DescribeEgressOnlyInternetGatewaysRequest = { ["EgressOnlyInternetGatewayIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeEgressOnlyInternetGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEgressOnlyInternetGatewaysRequest to be of type 'table'")
	if struct["EgressOnlyInternetGatewayIds"] then asserts.AssertEgressOnlyInternetGatewayIdList(struct["EgressOnlyInternetGatewayIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEgressOnlyInternetGatewaysRequest[k], "DescribeEgressOnlyInternetGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEgressOnlyInternetGatewaysRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EgressOnlyInternetGatewayIds [EgressOnlyInternetGatewayIdList] <p>One or more egress-only Internet gateway IDs.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned.</p>
-- @return DescribeEgressOnlyInternetGatewaysRequest structure as a key-value pair table
function M.DescribeEgressOnlyInternetGatewaysRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeEgressOnlyInternetGatewaysRequest")
	local t = { 
		["EgressOnlyInternetGatewayIds"] = args["EgressOnlyInternetGatewayIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeEgressOnlyInternetGatewaysRequest(t)
	return t
end

keys.DetachVpnGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["VpnGatewayId"] = true, nil }

function asserts.AssertDetachVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachVpnGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachVpnGatewayRequest[k], "DetachVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachVpnGatewayRequest
-- <p>Contains the parameters for DetachVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required key: VpcId
-- Required key: VpnGatewayId
-- @return DetachVpnGatewayRequest structure as a key-value pair table
function M.DetachVpnGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating DetachVpnGatewayRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["VpnGatewayId"] = args["VpnGatewayId"],
	}
	asserts.AssertDetachVpnGatewayRequest(t)
	return t
end

keys.DescribeBundleTasksRequest = { ["DryRun"] = true, ["Filters"] = true, ["BundleIds"] = true, nil }

function asserts.AssertDescribeBundleTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeBundleTasksRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["BundleIds"] then asserts.AssertBundleIdStringList(struct["BundleIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeBundleTasksRequest[k], "DescribeBundleTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeBundleTasksRequest
-- <p>Contains the parameters for DescribeBundleTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>bundle-id</code> - The ID of the bundle task.</p> </li> <li> <p> <code>error-code</code> - If the task failed, the error code returned.</p> </li> <li> <p> <code>error-message</code> - If the task failed, the error message returned.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>progress</code> - The level of task completion, as a percentage (for example, 20%).</p> </li> <li> <p> <code>s3-bucket</code> - The Amazon S3 bucket to store the AMI.</p> </li> <li> <p> <code>s3-prefix</code> - The beginning of the AMI name.</p> </li> <li> <p> <code>start-time</code> - The time the task started (for example, 2013-09-15T17:15:20.000Z).</p> </li> <li> <p> <code>state</code> - The state of the task (<code>pending</code> | <code>waiting-for-shutdown</code> | <code>bundling</code> | <code>storing</code> | <code>cancelling</code> | <code>complete</code> | <code>failed</code>).</p> </li> <li> <p> <code>update-time</code> - The time of the most recent update for the task.</p> </li> </ul>
-- * BundleIds [BundleIdStringList] <p>One or more bundle task IDs.</p> <p>Default: Describes all your bundle tasks.</p>
-- @return DescribeBundleTasksRequest structure as a key-value pair table
function M.DescribeBundleTasksRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeBundleTasksRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["BundleIds"] = args["BundleIds"],
	}
	asserts.AssertDescribeBundleTasksRequest(t)
	return t
end

keys.PurchaseHostReservationRequest = { ["CurrencyCode"] = true, ["OfferingId"] = true, ["LimitPrice"] = true, ["HostIdSet"] = true, ["ClientToken"] = true, nil }

function asserts.AssertPurchaseHostReservationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseHostReservationRequest to be of type 'table'")
	assert(struct["HostIdSet"], "Expected key HostIdSet to exist in table")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["LimitPrice"] then asserts.AssertString(struct["LimitPrice"]) end
	if struct["HostIdSet"] then asserts.AssertRequestHostIdSet(struct["HostIdSet"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseHostReservationRequest[k], "PurchaseHostReservationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseHostReservationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code>, <code>LimitPrice</code>, and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * OfferingId [String] <p>The ID of the offering.</p>
-- * LimitPrice [String] <p>The specified limit is checked against the total upfront cost of the reservation (calculated as the offering's upfront cost multiplied by the host count). If the total upfront cost is greater than the specified price limit, the request will fail. This is used to ensure that the purchase does not exceed the expected upfront cost of the purchase. At this time, the only supported currency is <code>USD</code>. For example, to indicate a limit price of USD 100, specify 100.00.</p>
-- * HostIdSet [RequestHostIdSet] <p>The ID/s of the Dedicated Host/s that the reservation will be associated with.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- Required key: HostIdSet
-- Required key: OfferingId
-- @return PurchaseHostReservationRequest structure as a key-value pair table
function M.PurchaseHostReservationRequest(args)
	assert(args, "You must provdide an argument table when creating PurchaseHostReservationRequest")
	local t = { 
		["CurrencyCode"] = args["CurrencyCode"],
		["OfferingId"] = args["OfferingId"],
		["LimitPrice"] = args["LimitPrice"],
		["HostIdSet"] = args["HostIdSet"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertPurchaseHostReservationRequest(t)
	return t
end

keys.ReleaseHostsResult = { ["Successful"] = true, ["Unsuccessful"] = true, nil }

function asserts.AssertReleaseHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseHostsResult to be of type 'table'")
	if struct["Successful"] then asserts.AssertResponseHostIdList(struct["Successful"]) end
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemList(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReleaseHostsResult[k], "ReleaseHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseHostsResult
-- <p>Contains the output of ReleaseHosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Successful [ResponseHostIdList] <p>The IDs of the Dedicated Hosts that were successfully released.</p>
-- * Unsuccessful [UnsuccessfulItemList] <p>The IDs of the Dedicated Hosts that could not be released, including an error message.</p>
-- @return ReleaseHostsResult structure as a key-value pair table
function M.ReleaseHostsResult(args)
	assert(args, "You must provdide an argument table when creating ReleaseHostsResult")
	local t = { 
		["Successful"] = args["Successful"],
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertReleaseHostsResult(t)
	return t
end

keys.LaunchSpecification = { ["UserData"] = true, ["SubnetId"] = true, ["Placement"] = true, ["Monitoring"] = true, ["ImageId"] = true, ["KeyName"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroups"] = true, ["KernelId"] = true, ["RamdiskId"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["AddressingType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchSpecification to be of type 'table'")
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Placement"] then asserts.AssertSpotPlacement(struct["Placement"]) end
	if struct["Monitoring"] then asserts.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then asserts.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then asserts.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchSpecification[k], "LaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchSpecification
-- <p>Describes the launch specification for an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserData [String] <p>The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instance.</p>
-- * Placement [SpotPlacement] <p>The placement information for the instance.</p>
-- * Monitoring [RunInstancesMonitoringEnabled] 
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p> <p>Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- * SecurityGroups [GroupIdentifierList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * AddressingType [String] <p>Deprecated.</p>
-- * NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
-- @return LaunchSpecification structure as a key-value pair table
function M.LaunchSpecification(args)
	assert(args, "You must provdide an argument table when creating LaunchSpecification")
	local t = { 
		["UserData"] = args["UserData"],
		["SubnetId"] = args["SubnetId"],
		["Placement"] = args["Placement"],
		["Monitoring"] = args["Monitoring"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["SecurityGroups"] = args["SecurityGroups"],
		["KernelId"] = args["KernelId"],
		["RamdiskId"] = args["RamdiskId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["InstanceType"] = args["InstanceType"],
		["AddressingType"] = args["AddressingType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertLaunchSpecification(t)
	return t
end

keys.CreateRouteRequest = { ["DestinationCidrBlock"] = true, ["EgressOnlyInternetGatewayId"] = true, ["DryRun"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["RouteTableId"] = true, ["NatGatewayId"] = true, ["VpcPeeringConnectionId"] = true, ["GatewayId"] = true, ["DestinationIpv6CidrBlock"] = true, nil }

function asserts.AssertCreateRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteRequest[k], "CreateRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteRequest
-- <p>Contains the parameters for CreateRoute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DestinationCidrBlock [String] <p>The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match.</p>
-- * EgressOnlyInternetGatewayId [String] <p>[IPv6 traffic only] The ID of an egress-only Internet gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceId [String] <p>The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.</p>
-- * NetworkInterfaceId [String] <p>The ID of a network interface.</p>
-- * RouteTableId [String] <p>The ID of the route table for the route.</p>
-- * NatGatewayId [String] <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of a VPC peering connection.</p>
-- * GatewayId [String] <p>The ID of an Internet gateway or virtual private gateway attached to your VPC.</p>
-- * DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.</p>
-- Required key: RouteTableId
-- @return CreateRouteRequest structure as a key-value pair table
function M.CreateRouteRequest(args)
	assert(args, "You must provdide an argument table when creating CreateRouteRequest")
	local t = { 
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["DryRun"] = args["DryRun"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["RouteTableId"] = args["RouteTableId"],
		["NatGatewayId"] = args["NatGatewayId"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["GatewayId"] = args["GatewayId"],
		["DestinationIpv6CidrBlock"] = args["DestinationIpv6CidrBlock"],
	}
	asserts.AssertCreateRouteRequest(t)
	return t
end

keys.AssociateIamInstanceProfileResult = { ["IamInstanceProfileAssociation"] = true, nil }

function asserts.AssertAssociateIamInstanceProfileResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateIamInstanceProfileResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then asserts.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateIamInstanceProfileResult[k], "AssociateIamInstanceProfileResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateIamInstanceProfileResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
-- @return AssociateIamInstanceProfileResult structure as a key-value pair table
function M.AssociateIamInstanceProfileResult(args)
	assert(args, "You must provdide an argument table when creating AssociateIamInstanceProfileResult")
	local t = { 
		["IamInstanceProfileAssociation"] = args["IamInstanceProfileAssociation"],
	}
	asserts.AssertAssociateIamInstanceProfileResult(t)
	return t
end

keys.MoveAddressToVpcResult = { ["Status"] = true, ["AllocationId"] = true, nil }

function asserts.AssertMoveAddressToVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MoveAddressToVpcResult to be of type 'table'")
	if struct["Status"] then asserts.AssertStatus(struct["Status"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.MoveAddressToVpcResult[k], "MoveAddressToVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MoveAddressToVpcResult
-- <p>Contains the output of MoveAddressToVpc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [Status] <p>The status of the move of the IP address.</p>
-- * AllocationId [String] <p>The allocation ID for the Elastic IP address.</p>
-- @return MoveAddressToVpcResult structure as a key-value pair table
function M.MoveAddressToVpcResult(args)
	assert(args, "You must provdide an argument table when creating MoveAddressToVpcResult")
	local t = { 
		["Status"] = args["Status"],
		["AllocationId"] = args["AllocationId"],
	}
	asserts.AssertMoveAddressToVpcResult(t)
	return t
end

keys.AssociateDhcpOptionsRequest = { ["VpcId"] = true, ["DryRun"] = true, ["DhcpOptionsId"] = true, nil }

function asserts.AssertAssociateDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpOptionsId"], "Expected key DhcpOptionsId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateDhcpOptionsRequest[k], "AssociateDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateDhcpOptionsRequest
-- <p>Contains the parameters for AssociateDhcpOptions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * DhcpOptionsId [String] <p>The ID of the DHCP options set, or <code>default</code> to associate no DHCP options with the VPC.</p>
-- Required key: DhcpOptionsId
-- Required key: VpcId
-- @return AssociateDhcpOptionsRequest structure as a key-value pair table
function M.AssociateDhcpOptionsRequest(args)
	assert(args, "You must provdide an argument table when creating AssociateDhcpOptionsRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["DhcpOptionsId"] = args["DhcpOptionsId"],
	}
	asserts.AssertAssociateDhcpOptionsRequest(t)
	return t
end

keys.MovingAddressStatus = { ["PublicIp"] = true, ["MoveStatus"] = true, nil }

function asserts.AssertMovingAddressStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MovingAddressStatus to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["MoveStatus"] then asserts.AssertMoveStatus(struct["MoveStatus"]) end
	for k,_ in pairs(struct) do
		assert(keys.MovingAddressStatus[k], "MovingAddressStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MovingAddressStatus
-- <p>Describes the status of a moving Elastic IP address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * MoveStatus [MoveStatus] <p>The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.</p>
-- @return MovingAddressStatus structure as a key-value pair table
function M.MovingAddressStatus(args)
	assert(args, "You must provdide an argument table when creating MovingAddressStatus")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["MoveStatus"] = args["MoveStatus"],
	}
	asserts.AssertMovingAddressStatus(t)
	return t
end

keys.DeleteSubnetRequest = { ["SubnetId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteSubnetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSubnetRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSubnetRequest[k], "DeleteSubnetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSubnetRequest
-- <p>Contains the parameters for DeleteSubnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: SubnetId
-- @return DeleteSubnetRequest structure as a key-value pair table
function M.DeleteSubnetRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteSubnetRequest")
	local t = { 
		["SubnetId"] = args["SubnetId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteSubnetRequest(t)
	return t
end

keys.SpotInstanceStateFault = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertSpotInstanceStateFault(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceStateFault to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotInstanceStateFault[k], "SpotInstanceStateFault contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceStateFault
-- <p>Describes a Spot instance state change.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The message for the Spot instance state change.</p>
-- * Code [String] <p>The reason code for the Spot instance state change.</p>
-- @return SpotInstanceStateFault structure as a key-value pair table
function M.SpotInstanceStateFault(args)
	assert(args, "You must provdide an argument table when creating SpotInstanceStateFault")
	local t = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertSpotInstanceStateFault(t)
	return t
end

keys.DhcpConfiguration = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertDhcpConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DhcpConfiguration to be of type 'table'")
	if struct["Values"] then asserts.AssertDhcpConfigurationValueList(struct["Values"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.DhcpConfiguration[k], "DhcpConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DhcpConfiguration
-- <p>Describes a DHCP configuration option.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [DhcpConfigurationValueList] <p>One or more values for the DHCP option.</p>
-- * Key [String] <p>The name of a DHCP option.</p>
-- @return DhcpConfiguration structure as a key-value pair table
function M.DhcpConfiguration(args)
	assert(args, "You must provdide an argument table when creating DhcpConfiguration")
	local t = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertDhcpConfiguration(t)
	return t
end

keys.VolumeDetail = { ["Size"] = true, nil }

function asserts.AssertVolumeDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeDetail to be of type 'table'")
	assert(struct["Size"], "Expected key Size to exist in table")
	if struct["Size"] then asserts.AssertLong(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeDetail[k], "VolumeDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeDetail
-- <p>Describes an EBS volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Size [Long] <p>The size of the volume, in GiB.</p>
-- Required key: Size
-- @return VolumeDetail structure as a key-value pair table
function M.VolumeDetail(args)
	assert(args, "You must provdide an argument table when creating VolumeDetail")
	local t = { 
		["Size"] = args["Size"],
	}
	asserts.AssertVolumeDetail(t)
	return t
end

keys.DisassociateVpcCidrBlockRequest = { ["AssociationId"] = true, nil }

function asserts.AssertDisassociateVpcCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateVpcCidrBlockRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateVpcCidrBlockRequest[k], "DisassociateVpcCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateVpcCidrBlockRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The association ID for the CIDR block.</p>
-- Required key: AssociationId
-- @return DisassociateVpcCidrBlockRequest structure as a key-value pair table
function M.DisassociateVpcCidrBlockRequest(args)
	assert(args, "You must provdide an argument table when creating DisassociateVpcCidrBlockRequest")
	local t = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertDisassociateVpcCidrBlockRequest(t)
	return t
end

keys.Instance = { ["Monitoring"] = true, ["StateReason"] = true, ["PublicDnsName"] = true, ["Platform"] = true, ["State"] = true, ["EbsOptimized"] = true, ["LaunchTime"] = true, ["PublicIpAddress"] = true, ["RamdiskId"] = true, ["PrivateIpAddress"] = true, ["ProductCodes"] = true, ["VpcId"] = true, ["StateTransitionReason"] = true, ["InstanceId"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["ImageId"] = true, ["PrivateDnsName"] = true, ["KeyName"] = true, ["SecurityGroups"] = true, ["ClientToken"] = true, ["SubnetId"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, ["SourceDestCheck"] = true, ["Placement"] = true, ["Hypervisor"] = true, ["InstanceLifecycle"] = true, ["BlockDeviceMappings"] = true, ["Architecture"] = true, ["KernelId"] = true, ["IamInstanceProfile"] = true, ["RootDeviceName"] = true, ["VirtualizationType"] = true, ["RootDeviceType"] = true, ["Tags"] = true, ["SpotInstanceRequestId"] = true, ["AmiLaunchIndex"] = true, nil }

function asserts.AssertInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Instance to be of type 'table'")
	if struct["Monitoring"] then asserts.AssertMonitoring(struct["Monitoring"]) end
	if struct["StateReason"] then asserts.AssertStateReason(struct["StateReason"]) end
	if struct["PublicDnsName"] then asserts.AssertString(struct["PublicDnsName"]) end
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["State"] then asserts.AssertInstanceState(struct["State"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["LaunchTime"] then asserts.AssertDateTime(struct["LaunchTime"]) end
	if struct["PublicIpAddress"] then asserts.AssertString(struct["PublicIpAddress"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["StateTransitionReason"] then asserts.AssertString(struct["StateTransitionReason"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["EnaSupport"] then asserts.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertString(struct["SriovNetSupport"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then asserts.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceList(struct["NetworkInterfaces"]) end
	if struct["SourceDestCheck"] then asserts.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["Placement"] then asserts.AssertPlacement(struct["Placement"]) end
	if struct["Hypervisor"] then asserts.AssertHypervisorType(struct["Hypervisor"]) end
	if struct["InstanceLifecycle"] then asserts.AssertInstanceLifecycleType(struct["InstanceLifecycle"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertInstanceBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfile(struct["IamInstanceProfile"]) end
	if struct["RootDeviceName"] then asserts.AssertString(struct["RootDeviceName"]) end
	if struct["VirtualizationType"] then asserts.AssertVirtualizationType(struct["VirtualizationType"]) end
	if struct["RootDeviceType"] then asserts.AssertDeviceType(struct["RootDeviceType"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	if struct["AmiLaunchIndex"] then asserts.AssertInteger(struct["AmiLaunchIndex"]) end
	for k,_ in pairs(struct) do
		assert(keys.Instance[k], "Instance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Instance
-- <p>Describes an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Monitoring [Monitoring] <p>The monitoring for the instance.</p>
-- * StateReason [StateReason] <p>The reason for the most recent state transition.</p>
-- * PublicDnsName [String] <p>(IPv4 only) The public DNS name assigned to the instance. This name is not available until the instance enters the <code>running</code> state. For EC2-VPC, this name is only available if you've enabled DNS hostnames for your VPC.</p>
-- * Platform [PlatformValues] <p>The value is <code>Windows</code> for Windows instances; otherwise blank.</p>
-- * State [InstanceState] <p>The current state of the instance.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
-- * LaunchTime [DateTime] <p>The time the instance was launched.</p>
-- * PublicIpAddress [String] <p>The public IPv4 address assigned to the instance, if applicable.</p>
-- * RamdiskId [String] <p>The RAM disk associated with this instance, if applicable.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 address assigned to the instance.</p>
-- * ProductCodes [ProductCodeList] <p>The product codes attached to this instance, if applicable.</p>
-- * VpcId [String] <p>[EC2-VPC] The ID of the VPC in which the instance is running.</p>
-- * StateTransitionReason [String] <p>The reason for the most recent state transition. This might be an empty string.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * EnaSupport [Boolean] <p>Specifies whether enhanced networking with ENA is enabled.</p>
-- * SriovNetSupport [String] <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- * ImageId [String] <p>The ID of the AMI used to launch the instance.</p>
-- * PrivateDnsName [String] <p>(IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the <code>running</code> state. </p> <p>[EC2-VPC] The Amazon-provided DNS server will resolve Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.</p>
-- * KeyName [String] <p>The name of the key pair, if this instance was launched with an associated key pair.</p>
-- * SecurityGroups [GroupIdentifierList] <p>One or more security groups for the instance.</p>
-- * ClientToken [String] <p>The idempotency token you provided when you launched the instance, if applicable.</p>
-- * SubnetId [String] <p>[EC2-VPC] The ID of the subnet in which the instance is running.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * NetworkInterfaces [InstanceNetworkInterfaceList] <p>[EC2-VPC] One or more network interfaces for the instance.</p>
-- * SourceDestCheck [Boolean] <p>Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the instance to perform NAT. For more information, see <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html">NAT Instances</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- * Placement [Placement] <p>The location where the instance launched, if applicable.</p>
-- * Hypervisor [HypervisorType] <p>The hypervisor type of the instance.</p>
-- * InstanceLifecycle [InstanceLifecycleType] <p>Indicates whether this is a Spot instance or a Scheduled Instance.</p>
-- * BlockDeviceMappings [InstanceBlockDeviceMappingList] <p>Any block device mapping entries for the instance.</p>
-- * Architecture [ArchitectureValues] <p>The architecture of the image.</p>
-- * KernelId [String] <p>The kernel associated with this instance, if applicable.</p>
-- * IamInstanceProfile [IamInstanceProfile] <p>The IAM instance profile associated with the instance, if applicable.</p>
-- * RootDeviceName [String] <p>The root device name (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p>
-- * VirtualizationType [VirtualizationType] <p>The virtualization type of the instance.</p>
-- * RootDeviceType [DeviceType] <p>The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
-- * Tags [TagList] <p>Any tags assigned to the instance.</p>
-- * SpotInstanceRequestId [String] <p>If the request is a Spot instance request, the ID of the request.</p>
-- * AmiLaunchIndex [Integer] <p>The AMI launch index, which can be used to find this instance in the launch group.</p>
-- @return Instance structure as a key-value pair table
function M.Instance(args)
	assert(args, "You must provdide an argument table when creating Instance")
	local t = { 
		["Monitoring"] = args["Monitoring"],
		["StateReason"] = args["StateReason"],
		["PublicDnsName"] = args["PublicDnsName"],
		["Platform"] = args["Platform"],
		["State"] = args["State"],
		["EbsOptimized"] = args["EbsOptimized"],
		["LaunchTime"] = args["LaunchTime"],
		["PublicIpAddress"] = args["PublicIpAddress"],
		["RamdiskId"] = args["RamdiskId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["ProductCodes"] = args["ProductCodes"],
		["VpcId"] = args["VpcId"],
		["StateTransitionReason"] = args["StateTransitionReason"],
		["InstanceId"] = args["InstanceId"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["ImageId"] = args["ImageId"],
		["PrivateDnsName"] = args["PrivateDnsName"],
		["KeyName"] = args["KeyName"],
		["SecurityGroups"] = args["SecurityGroups"],
		["ClientToken"] = args["ClientToken"],
		["SubnetId"] = args["SubnetId"],
		["InstanceType"] = args["InstanceType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["Placement"] = args["Placement"],
		["Hypervisor"] = args["Hypervisor"],
		["InstanceLifecycle"] = args["InstanceLifecycle"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["Architecture"] = args["Architecture"],
		["KernelId"] = args["KernelId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["RootDeviceName"] = args["RootDeviceName"],
		["VirtualizationType"] = args["VirtualizationType"],
		["RootDeviceType"] = args["RootDeviceType"],
		["Tags"] = args["Tags"],
		["SpotInstanceRequestId"] = args["SpotInstanceRequestId"],
		["AmiLaunchIndex"] = args["AmiLaunchIndex"],
	}
	asserts.AssertInstance(t)
	return t
end

keys.DeleteNetworkInterfaceRequest = { ["NetworkInterfaceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkInterfaceRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkInterfaceRequest[k], "DeleteNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkInterfaceRequest
-- <p>Contains the parameters for DeleteNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: NetworkInterfaceId
-- @return DeleteNetworkInterfaceRequest structure as a key-value pair table
function M.DeleteNetworkInterfaceRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteNetworkInterfaceRequest")
	local t = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteNetworkInterfaceRequest(t)
	return t
end

keys.SpotFleetMonitoring = { ["Enabled"] = true, nil }

function asserts.AssertSpotFleetMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetMonitoring to be of type 'table'")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetMonitoring[k], "SpotFleetMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetMonitoring
-- <p>Describes whether monitoring is enabled.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Enabled [Boolean] <p>Enables monitoring for the instance.</p> <p>Default: <code>false</code> </p>
-- @return SpotFleetMonitoring structure as a key-value pair table
function M.SpotFleetMonitoring(args)
	assert(args, "You must provdide an argument table when creating SpotFleetMonitoring")
	local t = { 
		["Enabled"] = args["Enabled"],
	}
	asserts.AssertSpotFleetMonitoring(t)
	return t
end

keys.RouteTable = { ["Associations"] = true, ["RouteTableId"] = true, ["VpcId"] = true, ["PropagatingVgws"] = true, ["Tags"] = true, ["Routes"] = true, nil }

function asserts.AssertRouteTable(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RouteTable to be of type 'table'")
	if struct["Associations"] then asserts.AssertRouteTableAssociationList(struct["Associations"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PropagatingVgws"] then asserts.AssertPropagatingVgwList(struct["PropagatingVgws"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Routes"] then asserts.AssertRouteList(struct["Routes"]) end
	for k,_ in pairs(struct) do
		assert(keys.RouteTable[k], "RouteTable contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RouteTable
-- <p>Describes a route table.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Associations [RouteTableAssociationList] <p>The associations between the route table and one or more subnets.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * PropagatingVgws [PropagatingVgwList] <p>Any virtual private gateway (VGW) propagating routes.</p>
-- * Tags [TagList] <p>Any tags assigned to the route table.</p>
-- * Routes [RouteList] <p>The routes in the route table.</p>
-- @return RouteTable structure as a key-value pair table
function M.RouteTable(args)
	assert(args, "You must provdide an argument table when creating RouteTable")
	local t = { 
		["Associations"] = args["Associations"],
		["RouteTableId"] = args["RouteTableId"],
		["VpcId"] = args["VpcId"],
		["PropagatingVgws"] = args["PropagatingVgws"],
		["Tags"] = args["Tags"],
		["Routes"] = args["Routes"],
	}
	asserts.AssertRouteTable(t)
	return t
end

keys.VpnConnectionOptionsSpecification = { ["StaticRoutesOnly"] = true, nil }

function asserts.AssertVpnConnectionOptionsSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnectionOptionsSpecification to be of type 'table'")
	if struct["StaticRoutesOnly"] then asserts.AssertBoolean(struct["StaticRoutesOnly"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnConnectionOptionsSpecification[k], "VpnConnectionOptionsSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnectionOptionsSpecification
-- <p>Describes VPN connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StaticRoutesOnly [Boolean] <p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>
-- @return VpnConnectionOptionsSpecification structure as a key-value pair table
function M.VpnConnectionOptionsSpecification(args)
	assert(args, "You must provdide an argument table when creating VpnConnectionOptionsSpecification")
	local t = { 
		["StaticRoutesOnly"] = args["StaticRoutesOnly"],
	}
	asserts.AssertVpnConnectionOptionsSpecification(t)
	return t
end

keys.DescribeNetworkAclsResult = { ["NetworkAcls"] = true, nil }

function asserts.AssertDescribeNetworkAclsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkAclsResult to be of type 'table'")
	if struct["NetworkAcls"] then asserts.AssertNetworkAclList(struct["NetworkAcls"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkAclsResult[k], "DescribeNetworkAclsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkAclsResult
-- <p>Contains the output of DescribeNetworkAcls.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAcls [NetworkAclList] <p>Information about one or more network ACLs.</p>
-- @return DescribeNetworkAclsResult structure as a key-value pair table
function M.DescribeNetworkAclsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeNetworkAclsResult")
	local t = { 
		["NetworkAcls"] = args["NetworkAcls"],
	}
	asserts.AssertDescribeNetworkAclsResult(t)
	return t
end

keys.CreateTagsRequest = { ["DryRun"] = true, ["Resources"] = true, ["Tags"] = true, nil }

function asserts.AssertCreateTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateTagsRequest to be of type 'table'")
	assert(struct["Resources"], "Expected key Resources to exist in table")
	assert(struct["Tags"], "Expected key Tags to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Resources"] then asserts.AssertResourceIdList(struct["Resources"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateTagsRequest[k], "CreateTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateTagsRequest
-- <p>Contains the parameters for CreateTags.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Resources [ResourceIdList] <p>The IDs of one or more resources to tag. For example, ami-1a2b3c4d.</p>
-- * Tags [TagList] <p>One or more tags. The <code>value</code> parameter is required, but if you don't want the tag to have a value, specify the parameter with no value, and we set the value to an empty string. </p>
-- Required key: Resources
-- Required key: Tags
-- @return CreateTagsRequest structure as a key-value pair table
function M.CreateTagsRequest(args)
	assert(args, "You must provdide an argument table when creating CreateTagsRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Resources"] = args["Resources"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertCreateTagsRequest(t)
	return t
end

keys.HostOffering = { ["HourlyPrice"] = true, ["OfferingId"] = true, ["CurrencyCode"] = true, ["InstanceFamily"] = true, ["PaymentOption"] = true, ["UpfrontPrice"] = true, ["Duration"] = true, nil }

function asserts.AssertHostOffering(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostOffering to be of type 'table'")
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["InstanceFamily"] then asserts.AssertString(struct["InstanceFamily"]) end
	if struct["PaymentOption"] then asserts.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["UpfrontPrice"] then asserts.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then asserts.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostOffering[k], "HostOffering contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostOffering
-- <p>Details about the Dedicated Host Reservation offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HourlyPrice [String] <p>The hourly price of the offering.</p>
-- * OfferingId [String] <p>The ID of the offering.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency of the offering.</p>
-- * InstanceFamily [String] <p>The instance family of the offering.</p>
-- * PaymentOption [PaymentOption] <p>The available payment option.</p>
-- * UpfrontPrice [String] <p>The upfront price of the offering. Does not apply to No Upfront offerings.</p>
-- * Duration [Integer] <p>The duration of the offering (in seconds).</p>
-- @return HostOffering structure as a key-value pair table
function M.HostOffering(args)
	assert(args, "You must provdide an argument table when creating HostOffering")
	local t = { 
		["HourlyPrice"] = args["HourlyPrice"],
		["OfferingId"] = args["OfferingId"],
		["CurrencyCode"] = args["CurrencyCode"],
		["InstanceFamily"] = args["InstanceFamily"],
		["PaymentOption"] = args["PaymentOption"],
		["UpfrontPrice"] = args["UpfrontPrice"],
		["Duration"] = args["Duration"],
	}
	asserts.AssertHostOffering(t)
	return t
end

keys.DescribeVpcClassicLinkDnsSupportRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["VpcIds"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["VpcIds"] then asserts.AssertVpcClassicLinkIdList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkDnsSupportRequest[k], "DescribeVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkDnsSupportRequest
-- <p>Contains the parameters for DescribeVpcClassicLinkDnsSupport.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * VpcIds [VpcClassicLinkIdList] <p>One or more VPC IDs.</p>
-- @return DescribeVpcClassicLinkDnsSupportRequest structure as a key-value pair table
function M.DescribeVpcClassicLinkDnsSupportRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcClassicLinkDnsSupportRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["VpcIds"] = args["VpcIds"],
	}
	asserts.AssertDescribeVpcClassicLinkDnsSupportRequest(t)
	return t
end

keys.DescribeSpotInstanceRequestsRequest = { ["SpotInstanceRequestIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeSpotInstanceRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotInstanceRequestsRequest to be of type 'table'")
	if struct["SpotInstanceRequestIds"] then asserts.AssertSpotInstanceRequestIdList(struct["SpotInstanceRequestIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotInstanceRequestsRequest[k], "DescribeSpotInstanceRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotInstanceRequestsRequest
-- <p>Contains the parameters for DescribeSpotInstanceRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceRequestIds [SpotInstanceRequestIdList] <p>One or more Spot instance request IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone-group</code> - The Availability Zone group.</p> </li> <li> <p> <code>create-time</code> - The time stamp when the Spot instance request was created.</p> </li> <li> <p> <code>fault-code</code> - The fault code related to the request.</p> </li> <li> <p> <code>fault-message</code> - The fault message related to the request.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance that fulfilled the request.</p> </li> <li> <p> <code>launch-group</code> - The Spot instance launch group.</p> </li> <li> <p> <code>launch.block-device-mapping.delete-on-termination</code> - Indicates whether the Amazon EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>launch.block-device-mapping.device-name</code> - The device name for the Amazon EBS volume (for example, <code>/dev/sdh</code>).</p> </li> <li> <p> <code>launch.block-device-mapping.snapshot-id</code> - The ID of the snapshot used for the Amazon EBS volume.</p> </li> <li> <p> <code>launch.block-device-mapping.volume-size</code> - The size of the Amazon EBS volume, in GiB.</p> </li> <li> <p> <code>launch.block-device-mapping.volume-type</code> - The type of the Amazon EBS volume: <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code>for Cold HDD, or <code>standard</code> for Magnetic.</p> </li> <li> <p> <code>launch.group-id</code> - The security group for the instance.</p> </li> <li> <p> <code>launch.image-id</code> - The ID of the AMI.</p> </li> <li> <p> <code>launch.instance-type</code> - The type of instance (for example, <code>m3.medium</code>).</p> </li> <li> <p> <code>launch.kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>launch.key-name</code> - The name of the key pair the instance launched with.</p> </li> <li> <p> <code>launch.monitoring-enabled</code> - Whether monitoring is enabled for the Spot instance.</p> </li> <li> <p> <code>launch.ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>network-interface.network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>network-interface.device-index</code> - The index of the device for the network interface attachment on the instance.</p> </li> <li> <p> <code>network-interface.subnet-id</code> - The ID of the subnet for the instance.</p> </li> <li> <p> <code>network-interface.description</code> - A description of the network interface.</p> </li> <li> <p> <code>network-interface.private-ip-address</code> - The primary private IP address of the network interface.</p> </li> <li> <p> <code>network-interface.delete-on-termination</code> - Indicates whether the network interface is deleted when the instance is terminated.</p> </li> <li> <p> <code>network-interface.group-id</code> - The ID of the security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.group-name</code> - The name of the security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.addresses.primary</code> - Indicates whether the IP address is the primary private IP address.</p> </li> <li> <p> <code>product-description</code> - The product description associated with the instance (<code>Linux/UNIX</code> | <code>Windows</code>).</p> </li> <li> <p> <code>spot-instance-request-id</code> - The Spot instance request ID.</p> </li> <li> <p> <code>spot-price</code> - The maximum hourly price for any Spot instance launched to fulfill the request.</p> </li> <li> <p> <code>state</code> - The state of the Spot instance request (<code>open</code> | <code>active</code> | <code>closed</code> | <code>cancelled</code> | <code>failed</code>). Spot bid status information can help you track your Amazon EC2 Spot instance requests. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot Bid Status</a> in the Amazon Elastic Compute Cloud User Guide.</p> </li> <li> <p> <code>status-code</code> - The short code describing the most recent evaluation of your Spot instance request.</p> </li> <li> <p> <code>status-message</code> - The message explaining the status of the Spot instance request.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>type</code> - The type of Spot instance request (<code>one-time</code> | <code>persistent</code>).</p> </li> <li> <p> <code>launched-availability-zone</code> - The Availability Zone in which the bid is launched.</p> </li> <li> <p> <code>valid-from</code> - The start date of the request.</p> </li> <li> <p> <code>valid-until</code> - The end date of the request.</p> </li> </ul>
-- @return DescribeSpotInstanceRequestsRequest structure as a key-value pair table
function M.DescribeSpotInstanceRequestsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotInstanceRequestsRequest")
	local t = { 
		["SpotInstanceRequestIds"] = args["SpotInstanceRequestIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeSpotInstanceRequestsRequest(t)
	return t
end

keys.DeleteRouteTableRequest = { ["RouteTableId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRouteTableRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteRouteTableRequest[k], "DeleteRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRouteTableRequest
-- <p>Contains the parameters for DeleteRouteTable.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: RouteTableId
-- @return DeleteRouteTableRequest structure as a key-value pair table
function M.DeleteRouteTableRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteRouteTableRequest")
	local t = { 
		["RouteTableId"] = args["RouteTableId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteRouteTableRequest(t)
	return t
end

keys.CreateVpnConnectionRouteRequest = { ["VpnConnectionId"] = true, ["DestinationCidrBlock"] = true, nil }

function asserts.AssertCreateVpnConnectionRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionRouteRequest to be of type 'table'")
	assert(struct["DestinationCidrBlock"], "Expected key DestinationCidrBlock to exist in table")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnConnectionRouteRequest[k], "CreateVpnConnectionRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionRouteRequest
-- <p>Contains the parameters for CreateVpnConnectionRoute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- * DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer network.</p>
-- Required key: DestinationCidrBlock
-- Required key: VpnConnectionId
-- @return CreateVpnConnectionRouteRequest structure as a key-value pair table
function M.CreateVpnConnectionRouteRequest(args)
	assert(args, "You must provdide an argument table when creating CreateVpnConnectionRouteRequest")
	local t = { 
		["VpnConnectionId"] = args["VpnConnectionId"],
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
	}
	asserts.AssertCreateVpnConnectionRouteRequest(t)
	return t
end

keys.CreateVpnGatewayRequest = { ["DryRun"] = true, ["AvailabilityZone"] = true, ["Type"] = true, nil }

function asserts.AssertCreateVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnGatewayRequest to be of type 'table'")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnGatewayRequest[k], "CreateVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnGatewayRequest
-- <p>Contains the parameters for CreateVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the virtual private gateway.</p>
-- * Type [GatewayType] <p>The type of VPN connection this virtual private gateway supports.</p>
-- Required key: Type
-- @return CreateVpnGatewayRequest structure as a key-value pair table
function M.CreateVpnGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating CreateVpnGatewayRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Type"] = args["Type"],
	}
	asserts.AssertCreateVpnGatewayRequest(t)
	return t
end

keys.DescribeVpcPeeringConnectionsResult = { ["VpcPeeringConnections"] = true, nil }

function asserts.AssertDescribeVpcPeeringConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcPeeringConnectionsResult to be of type 'table'")
	if struct["VpcPeeringConnections"] then asserts.AssertVpcPeeringConnectionList(struct["VpcPeeringConnections"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcPeeringConnectionsResult[k], "DescribeVpcPeeringConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcPeeringConnectionsResult
-- <p>Contains the output of DescribeVpcPeeringConnections.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcPeeringConnections [VpcPeeringConnectionList] <p>Information about the VPC peering connections.</p>
-- @return DescribeVpcPeeringConnectionsResult structure as a key-value pair table
function M.DescribeVpcPeeringConnectionsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcPeeringConnectionsResult")
	local t = { 
		["VpcPeeringConnections"] = args["VpcPeeringConnections"],
	}
	asserts.AssertDescribeVpcPeeringConnectionsResult(t)
	return t
end

keys.CreateDhcpOptionsResult = { ["DhcpOptions"] = true, nil }

function asserts.AssertCreateDhcpOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDhcpOptionsResult to be of type 'table'")
	if struct["DhcpOptions"] then asserts.AssertDhcpOptions(struct["DhcpOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDhcpOptionsResult[k], "CreateDhcpOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDhcpOptionsResult
-- <p>Contains the output of CreateDhcpOptions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DhcpOptions [DhcpOptions] <p>A set of DHCP options.</p>
-- @return CreateDhcpOptionsResult structure as a key-value pair table
function M.CreateDhcpOptionsResult(args)
	assert(args, "You must provdide an argument table when creating CreateDhcpOptionsResult")
	local t = { 
		["DhcpOptions"] = args["DhcpOptions"],
	}
	asserts.AssertCreateDhcpOptionsResult(t)
	return t
end

keys.DeleteKeyPairRequest = { ["KeyName"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteKeyPairRequest[k], "DeleteKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteKeyPairRequest
-- <p>Contains the parameters for DeleteKeyPair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyName [String] <p>The name of the key pair.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: KeyName
-- @return DeleteKeyPairRequest structure as a key-value pair table
function M.DeleteKeyPairRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteKeyPairRequest")
	local t = { 
		["KeyName"] = args["KeyName"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteKeyPairRequest(t)
	return t
end

keys.EventInformation = { ["InstanceId"] = true, ["EventSubType"] = true, ["EventDescription"] = true, nil }

function asserts.AssertEventInformation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EventInformation to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["EventSubType"] then asserts.AssertString(struct["EventSubType"]) end
	if struct["EventDescription"] then asserts.AssertString(struct["EventDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.EventInformation[k], "EventInformation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EventInformation
-- <p>Describes a Spot fleet event.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance. This information is available only for <code>instanceChange</code> events.</p>
-- * EventSubType [String] <p>The event.</p> <p>The following are the <code>error</code> events.</p> <ul> <li> <p> <code>iamFleetRoleInvalid</code> - The Spot fleet did not have the required permissions either to launch or terminate an instance.</p> </li> <li> <p> <code>launchSpecTemporarilyBlacklisted</code> - The configuration is not valid and several attempts to launch instances have failed. For more information, see the description of the event.</p> </li> <li> <p> <code>spotFleetRequestConfigurationInvalid</code> - The configuration is not valid. For more information, see the description of the event.</p> </li> <li> <p> <code>spotInstanceCountLimitExceeded</code> - You've reached the limit on the number of Spot instances that you can launch.</p> </li> </ul> <p>The following are the <code>fleetRequestChange</code> events.</p> <ul> <li> <p> <code>active</code> - The Spot fleet has been validated and Amazon EC2 is attempting to maintain the target number of running Spot instances.</p> </li> <li> <p> <code>cancelled</code> - The Spot fleet is canceled and has no running Spot instances. The Spot fleet will be deleted two days after its instances were terminated.</p> </li> <li> <p> <code>cancelled_running</code> - The Spot fleet is canceled and will not launch additional Spot instances, but its existing Spot instances continue to run until they are interrupted or terminated.</p> </li> <li> <p> <code>cancelled_terminating</code> - The Spot fleet is canceled and its Spot instances are terminating.</p> </li> <li> <p> <code>expired</code> - The Spot fleet request has expired. A subsequent event indicates that the instances were terminated, if the request was created with <code>TerminateInstancesWithExpiration</code> set.</p> </li> <li> <p> <code>modify_in_progress</code> - A request to modify the Spot fleet request was accepted and is in progress.</p> </li> <li> <p> <code>modify_successful</code> - The Spot fleet request was modified.</p> </li> <li> <p> <code>price_update</code> - The bid price for a launch configuration was adjusted because it was too high. This change is permanent.</p> </li> <li> <p> <code>submitted</code> - The Spot fleet request is being evaluated and Amazon EC2 is preparing to launch the target number of Spot instances.</p> </li> </ul> <p>The following are the <code>instanceChange</code> events.</p> <ul> <li> <p> <code>launched</code> - A bid was fulfilled and a new instance was launched.</p> </li> <li> <p> <code>terminated</code> - An instance was terminated by the user.</p> </li> </ul>
-- * EventDescription [String] <p>The description of the event.</p>
-- @return EventInformation structure as a key-value pair table
function M.EventInformation(args)
	assert(args, "You must provdide an argument table when creating EventInformation")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["EventSubType"] = args["EventSubType"],
		["EventDescription"] = args["EventDescription"],
	}
	asserts.AssertEventInformation(t)
	return t
end

keys.TerminateInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertTerminateInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.TerminateInstancesRequest[k], "TerminateInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateInstancesRequest
-- <p>Contains the parameters for TerminateInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Constraints: Up to 1000 instance IDs. We recommend breaking up this request into smaller batches.</p>
-- Required key: InstanceIds
-- @return TerminateInstancesRequest structure as a key-value pair table
function M.TerminateInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating TerminateInstancesRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertTerminateInstancesRequest(t)
	return t
end

keys.CreateVpnConnectionResult = { ["VpnConnection"] = true, nil }

function asserts.AssertCreateVpnConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionResult to be of type 'table'")
	if struct["VpnConnection"] then asserts.AssertVpnConnection(struct["VpnConnection"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnConnectionResult[k], "CreateVpnConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionResult
-- <p>Contains the output of CreateVpnConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnection [VpnConnection] <p>Information about the VPN connection.</p>
-- @return CreateVpnConnectionResult structure as a key-value pair table
function M.CreateVpnConnectionResult(args)
	assert(args, "You must provdide an argument table when creating CreateVpnConnectionResult")
	local t = { 
		["VpnConnection"] = args["VpnConnection"],
	}
	asserts.AssertCreateVpnConnectionResult(t)
	return t
end

keys.InstanceStatusDetails = { ["Status"] = true, ["ImpairedSince"] = true, ["Name"] = true, nil }

function asserts.AssertInstanceStatusDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusDetails to be of type 'table'")
	if struct["Status"] then asserts.AssertStatusType(struct["Status"]) end
	if struct["ImpairedSince"] then asserts.AssertDateTime(struct["ImpairedSince"]) end
	if struct["Name"] then asserts.AssertStatusName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatusDetails[k], "InstanceStatusDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusDetails
-- <p>Describes the instance status.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [StatusType] <p>The status.</p>
-- * ImpairedSince [DateTime] <p>The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.</p>
-- * Name [StatusName] <p>The type of instance status.</p>
-- @return InstanceStatusDetails structure as a key-value pair table
function M.InstanceStatusDetails(args)
	assert(args, "You must provdide an argument table when creating InstanceStatusDetails")
	local t = { 
		["Status"] = args["Status"],
		["ImpairedSince"] = args["ImpairedSince"],
		["Name"] = args["Name"],
	}
	asserts.AssertInstanceStatusDetails(t)
	return t
end

keys.SlotStartTimeRangeRequest = { ["LatestTime"] = true, ["EarliestTime"] = true, nil }

function asserts.AssertSlotStartTimeRangeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SlotStartTimeRangeRequest to be of type 'table'")
	if struct["LatestTime"] then asserts.AssertDateTime(struct["LatestTime"]) end
	if struct["EarliestTime"] then asserts.AssertDateTime(struct["EarliestTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.SlotStartTimeRangeRequest[k], "SlotStartTimeRangeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SlotStartTimeRangeRequest
-- <p>Describes the time period for a Scheduled Instance to start its first schedule.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LatestTime [DateTime] <p>The latest date and time, in UTC, for the Scheduled Instance to start.</p>
-- * EarliestTime [DateTime] <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
-- @return SlotStartTimeRangeRequest structure as a key-value pair table
function M.SlotStartTimeRangeRequest(args)
	assert(args, "You must provdide an argument table when creating SlotStartTimeRangeRequest")
	local t = { 
		["LatestTime"] = args["LatestTime"],
		["EarliestTime"] = args["EarliestTime"],
	}
	asserts.AssertSlotStartTimeRangeRequest(t)
	return t
end

keys.DescribeRouteTablesResult = { ["RouteTables"] = true, nil }

function asserts.AssertDescribeRouteTablesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRouteTablesResult to be of type 'table'")
	if struct["RouteTables"] then asserts.AssertRouteTableList(struct["RouteTables"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRouteTablesResult[k], "DescribeRouteTablesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRouteTablesResult
-- <p>Contains the output of DescribeRouteTables.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RouteTables [RouteTableList] <p>Information about one or more route tables.</p>
-- @return DescribeRouteTablesResult structure as a key-value pair table
function M.DescribeRouteTablesResult(args)
	assert(args, "You must provdide an argument table when creating DescribeRouteTablesResult")
	local t = { 
		["RouteTables"] = args["RouteTables"],
	}
	asserts.AssertDescribeRouteTablesResult(t)
	return t
end

keys.ReservedInstancesModification = { ["Status"] = true, ["ModificationResults"] = true, ["EffectiveDate"] = true, ["CreateDate"] = true, ["StatusMessage"] = true, ["ClientToken"] = true, ["ReservedInstancesModificationId"] = true, ["ReservedInstancesIds"] = true, ["UpdateDate"] = true, nil }

function asserts.AssertReservedInstancesModification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesModification to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["ModificationResults"] then asserts.AssertReservedInstancesModificationResultList(struct["ModificationResults"]) end
	if struct["EffectiveDate"] then asserts.AssertDateTime(struct["EffectiveDate"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ReservedInstancesModificationId"] then asserts.AssertString(struct["ReservedInstancesModificationId"]) end
	if struct["ReservedInstancesIds"] then asserts.AssertReservedIntancesIds(struct["ReservedInstancesIds"]) end
	if struct["UpdateDate"] then asserts.AssertDateTime(struct["UpdateDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesModification[k], "ReservedInstancesModification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesModification
-- <p>Describes a Reserved Instance modification.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>The status of the Reserved Instances modification request.</p>
-- * ModificationResults [ReservedInstancesModificationResultList] <p>Contains target configurations along with their corresponding new Reserved Instance IDs.</p>
-- * EffectiveDate [DateTime] <p>The time for the modification to become effective.</p>
-- * CreateDate [DateTime] <p>The time when the modification request was created.</p>
-- * StatusMessage [String] <p>The reason for the status.</p>
-- * ClientToken [String] <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * ReservedInstancesModificationId [String] <p>A unique ID for the Reserved Instance modification.</p>
-- * ReservedInstancesIds [ReservedIntancesIds] <p>The IDs of one or more Reserved Instances.</p>
-- * UpdateDate [DateTime] <p>The time when the modification request was last updated.</p>
-- @return ReservedInstancesModification structure as a key-value pair table
function M.ReservedInstancesModification(args)
	assert(args, "You must provdide an argument table when creating ReservedInstancesModification")
	local t = { 
		["Status"] = args["Status"],
		["ModificationResults"] = args["ModificationResults"],
		["EffectiveDate"] = args["EffectiveDate"],
		["CreateDate"] = args["CreateDate"],
		["StatusMessage"] = args["StatusMessage"],
		["ClientToken"] = args["ClientToken"],
		["ReservedInstancesModificationId"] = args["ReservedInstancesModificationId"],
		["ReservedInstancesIds"] = args["ReservedInstancesIds"],
		["UpdateDate"] = args["UpdateDate"],
	}
	asserts.AssertReservedInstancesModification(t)
	return t
end

keys.DescribeSpotFleetRequestHistoryRequest = { ["SpotFleetRequestId"] = true, ["DryRun"] = true, ["EventType"] = true, ["MaxResults"] = true, ["StartTime"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestHistoryRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["StartTime"], "Expected key StartTime to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["EventType"] then asserts.AssertEventType(struct["EventType"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestHistoryRequest[k], "DescribeSpotFleetRequestHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestHistoryRequest
-- <p>Contains the parameters for DescribeSpotFleetRequestHistory.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * EventType [EventType] <p>The type of events to describe. By default, all events are described.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * StartTime [DateTime] <p>The starting date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- Required key: SpotFleetRequestId
-- Required key: StartTime
-- @return DescribeSpotFleetRequestHistoryRequest structure as a key-value pair table
function M.DescribeSpotFleetRequestHistoryRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotFleetRequestHistoryRequest")
	local t = { 
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["DryRun"] = args["DryRun"],
		["EventType"] = args["EventType"],
		["MaxResults"] = args["MaxResults"],
		["StartTime"] = args["StartTime"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeSpotFleetRequestHistoryRequest(t)
	return t
end

keys.InstanceIpv6Address = { ["Ipv6Address"] = true, nil }

function asserts.AssertInstanceIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertString(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceIpv6Address[k], "InstanceIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceIpv6Address
-- <p>Describes an IPv6 address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Address [String] <p>The IPv6 address.</p>
-- @return InstanceIpv6Address structure as a key-value pair table
function M.InstanceIpv6Address(args)
	assert(args, "You must provdide an argument table when creating InstanceIpv6Address")
	local t = { 
		["Ipv6Address"] = args["Ipv6Address"],
	}
	asserts.AssertInstanceIpv6Address(t)
	return t
end

keys.Ipv6CidrBlock = { ["Ipv6CidrBlock"] = true, nil }

function asserts.AssertIpv6CidrBlock(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Ipv6CidrBlock to be of type 'table'")
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.Ipv6CidrBlock[k], "Ipv6CidrBlock contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Ipv6CidrBlock
-- <p>Describes an IPv6 CIDR block.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- @return Ipv6CidrBlock structure as a key-value pair table
function M.Ipv6CidrBlock(args)
	assert(args, "You must provdide an argument table when creating Ipv6CidrBlock")
	local t = { 
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
	}
	asserts.AssertIpv6CidrBlock(t)
	return t
end

keys.ModifyVpcEndpointRequest = { ["DryRun"] = true, ["AddRouteTableIds"] = true, ["ResetPolicy"] = true, ["RemoveRouteTableIds"] = true, ["PolicyDocument"] = true, ["VpcEndpointId"] = true, nil }

function asserts.AssertModifyVpcEndpointRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointRequest to be of type 'table'")
	assert(struct["VpcEndpointId"], "Expected key VpcEndpointId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AddRouteTableIds"] then asserts.AssertValueStringList(struct["AddRouteTableIds"]) end
	if struct["ResetPolicy"] then asserts.AssertBoolean(struct["ResetPolicy"]) end
	if struct["RemoveRouteTableIds"] then asserts.AssertValueStringList(struct["RemoveRouteTableIds"]) end
	if struct["PolicyDocument"] then asserts.AssertString(struct["PolicyDocument"]) end
	if struct["VpcEndpointId"] then asserts.AssertString(struct["VpcEndpointId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointRequest[k], "ModifyVpcEndpointRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointRequest
-- <p>Contains the parameters for ModifyVpcEndpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AddRouteTableIds [ValueStringList] <p>One or more route tables IDs to associate with the endpoint.</p>
-- * ResetPolicy [Boolean] <p>Specify <code>true</code> to reset the policy document to the default policy. The default policy allows access to the service.</p>
-- * RemoveRouteTableIds [ValueStringList] <p>One or more route table IDs to disassociate from the endpoint.</p>
-- * PolicyDocument [String] <p>A policy document to attach to the endpoint. The policy must be in valid JSON format.</p>
-- * VpcEndpointId [String] <p>The ID of the endpoint.</p>
-- Required key: VpcEndpointId
-- @return ModifyVpcEndpointRequest structure as a key-value pair table
function M.ModifyVpcEndpointRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyVpcEndpointRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["AddRouteTableIds"] = args["AddRouteTableIds"],
		["ResetPolicy"] = args["ResetPolicy"],
		["RemoveRouteTableIds"] = args["RemoveRouteTableIds"],
		["PolicyDocument"] = args["PolicyDocument"],
		["VpcEndpointId"] = args["VpcEndpointId"],
	}
	asserts.AssertModifyVpcEndpointRequest(t)
	return t
end

keys.ReservedInstancesListing = { ["ReservedInstancesId"] = true, ["Status"] = true, ["Tags"] = true, ["PriceSchedules"] = true, ["CreateDate"] = true, ["ClientToken"] = true, ["ReservedInstancesListingId"] = true, ["UpdateDate"] = true, ["InstanceCounts"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertReservedInstancesListing(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesListing to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["Status"] then asserts.AssertListingStatus(struct["Status"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["PriceSchedules"] then asserts.AssertPriceScheduleList(struct["PriceSchedules"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ReservedInstancesListingId"] then asserts.AssertString(struct["ReservedInstancesListingId"]) end
	if struct["UpdateDate"] then asserts.AssertDateTime(struct["UpdateDate"]) end
	if struct["InstanceCounts"] then asserts.AssertInstanceCountList(struct["InstanceCounts"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesListing[k], "ReservedInstancesListing contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesListing
-- <p>Describes a Reserved Instance listing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- * Status [ListingStatus] <p>The status of the Reserved Instance listing.</p>
-- * Tags [TagList] <p>Any tags assigned to the resource.</p>
-- * PriceSchedules [PriceScheduleList] <p>The price of the Reserved Instance listing.</p>
-- * CreateDate [DateTime] <p>The time the listing was created.</p>
-- * ClientToken [String] <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * ReservedInstancesListingId [String] <p>The ID of the Reserved Instance listing.</p>
-- * UpdateDate [DateTime] <p>The last modified timestamp of the listing.</p>
-- * InstanceCounts [InstanceCountList] <p>The number of instances in this state.</p>
-- * StatusMessage [String] <p>The reason for the current status of the Reserved Instance listing. The response can be blank.</p>
-- @return ReservedInstancesListing structure as a key-value pair table
function M.ReservedInstancesListing(args)
	assert(args, "You must provdide an argument table when creating ReservedInstancesListing")
	local t = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["Status"] = args["Status"],
		["Tags"] = args["Tags"],
		["PriceSchedules"] = args["PriceSchedules"],
		["CreateDate"] = args["CreateDate"],
		["ClientToken"] = args["ClientToken"],
		["ReservedInstancesListingId"] = args["ReservedInstancesListingId"],
		["UpdateDate"] = args["UpdateDate"],
		["InstanceCounts"] = args["InstanceCounts"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertReservedInstancesListing(t)
	return t
end

keys.Route = { ["Origin"] = true, ["DestinationCidrBlock"] = true, ["EgressOnlyInternetGatewayId"] = true, ["DestinationPrefixListId"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["State"] = true, ["NatGatewayId"] = true, ["VpcPeeringConnectionId"] = true, ["GatewayId"] = true, ["DestinationIpv6CidrBlock"] = true, ["InstanceOwnerId"] = true, nil }

function asserts.AssertRoute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Route to be of type 'table'")
	if struct["Origin"] then asserts.AssertRouteOrigin(struct["Origin"]) end
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DestinationPrefixListId"] then asserts.AssertString(struct["DestinationPrefixListId"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["State"] then asserts.AssertRouteState(struct["State"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	if struct["InstanceOwnerId"] then asserts.AssertString(struct["InstanceOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.Route[k], "Route contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Route
-- <p>Describes a route in a route table.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Origin [RouteOrigin] <p>Describes how the route was created.</p> <ul> <li> <p> <code>CreateRouteTable</code> - The route was automatically created when the route table was created.</p> </li> <li> <p> <code>CreateRoute</code> - The route was manually added to the route table.</p> </li> <li> <p> <code>EnableVgwRoutePropagation</code> - The route was propagated by route propagation.</p> </li> </ul>
-- * DestinationCidrBlock [String] <p>The IPv4 CIDR block used for the destination match.</p>
-- * EgressOnlyInternetGatewayId [String] <p>The ID of the egress-only Internet gateway.</p>
-- * DestinationPrefixListId [String] <p>The prefix of the AWS service.</p>
-- * InstanceId [String] <p>The ID of a NAT instance in your VPC.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * State [RouteState] <p>The state of the route. The <code>blackhole</code> state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, or the specified NAT instance has been terminated).</p>
-- * NatGatewayId [String] <p>The ID of a NAT gateway.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- * GatewayId [String] <p>The ID of a gateway attached to your VPC.</p>
-- * DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR block used for the destination match.</p>
-- * InstanceOwnerId [String] <p>The AWS account ID of the owner of the instance.</p>
-- @return Route structure as a key-value pair table
function M.Route(args)
	assert(args, "You must provdide an argument table when creating Route")
	local t = { 
		["Origin"] = args["Origin"],
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["DestinationPrefixListId"] = args["DestinationPrefixListId"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["State"] = args["State"],
		["NatGatewayId"] = args["NatGatewayId"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["GatewayId"] = args["GatewayId"],
		["DestinationIpv6CidrBlock"] = args["DestinationIpv6CidrBlock"],
		["InstanceOwnerId"] = args["InstanceOwnerId"],
	}
	asserts.AssertRoute(t)
	return t
end

keys.ProductCode = { ["ProductCodeId"] = true, ["ProductCodeType"] = true, nil }

function asserts.AssertProductCode(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProductCode to be of type 'table'")
	if struct["ProductCodeId"] then asserts.AssertString(struct["ProductCodeId"]) end
	if struct["ProductCodeType"] then asserts.AssertProductCodeValues(struct["ProductCodeType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ProductCode[k], "ProductCode contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProductCode
-- <p>Describes a product code.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodeId [String] <p>The product code.</p>
-- * ProductCodeType [ProductCodeValues] <p>The type of product code.</p>
-- @return ProductCode structure as a key-value pair table
function M.ProductCode(args)
	assert(args, "You must provdide an argument table when creating ProductCode")
	local t = { 
		["ProductCodeId"] = args["ProductCodeId"],
		["ProductCodeType"] = args["ProductCodeType"],
	}
	asserts.AssertProductCode(t)
	return t
end

keys.Ipv6Range = { ["CidrIpv6"] = true, nil }

function asserts.AssertIpv6Range(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Ipv6Range to be of type 'table'")
	if struct["CidrIpv6"] then asserts.AssertString(struct["CidrIpv6"]) end
	for k,_ in pairs(struct) do
		assert(keys.Ipv6Range[k], "Ipv6Range contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Ipv6Range
-- <p>[EC2-VPC only] Describes an IPv6 range.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CidrIpv6 [String] <p>The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix.</p>
-- @return Ipv6Range structure as a key-value pair table
function M.Ipv6Range(args)
	assert(args, "You must provdide an argument table when creating Ipv6Range")
	local t = { 
		["CidrIpv6"] = args["CidrIpv6"],
	}
	asserts.AssertIpv6Range(t)
	return t
end

keys.AcceptReservedInstancesExchangeQuoteResult = { ["ExchangeId"] = true, nil }

function asserts.AssertAcceptReservedInstancesExchangeQuoteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptReservedInstancesExchangeQuoteResult to be of type 'table'")
	if struct["ExchangeId"] then asserts.AssertString(struct["ExchangeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptReservedInstancesExchangeQuoteResult[k], "AcceptReservedInstancesExchangeQuoteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptReservedInstancesExchangeQuoteResult
-- <p>The result of the exchange and whether it was <code>successful</code>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExchangeId [String] <p>The ID of the successful exchange.</p>
-- @return AcceptReservedInstancesExchangeQuoteResult structure as a key-value pair table
function M.AcceptReservedInstancesExchangeQuoteResult(args)
	assert(args, "You must provdide an argument table when creating AcceptReservedInstancesExchangeQuoteResult")
	local t = { 
		["ExchangeId"] = args["ExchangeId"],
	}
	asserts.AssertAcceptReservedInstancesExchangeQuoteResult(t)
	return t
end

keys.AssociateSubnetCidrBlockResult = { ["SubnetId"] = true, ["Ipv6CidrBlockAssociation"] = true, nil }

function asserts.AssertAssociateSubnetCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateSubnetCidrBlockResult to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertSubnetIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateSubnetCidrBlockResult[k], "AssociateSubnetCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateSubnetCidrBlockResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * Ipv6CidrBlockAssociation [SubnetIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- @return AssociateSubnetCidrBlockResult structure as a key-value pair table
function M.AssociateSubnetCidrBlockResult(args)
	assert(args, "You must provdide an argument table when creating AssociateSubnetCidrBlockResult")
	local t = { 
		["SubnetId"] = args["SubnetId"],
		["Ipv6CidrBlockAssociation"] = args["Ipv6CidrBlockAssociation"],
	}
	asserts.AssertAssociateSubnetCidrBlockResult(t)
	return t
end

keys.SpotPrice = { ["Timestamp"] = true, ["AvailabilityZone"] = true, ["InstanceType"] = true, ["ProductDescription"] = true, ["SpotPrice"] = true, nil }

function asserts.AssertSpotPrice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotPrice to be of type 'table'")
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotPrice[k], "SpotPrice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotPrice
-- <p>Describes the maximum hourly price (bid) for any Spot instance launched to fulfill the request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Timestamp [DateTime] <p>The date and time the request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- * InstanceType [InstanceType] <p>The instance type. Note that T2 and HS1 instance types are not supported.</p>
-- * ProductDescription [RIProductDescription] <p>A general description of the AMI.</p>
-- * SpotPrice [String] <p>The maximum price (bid) that you are willing to pay for a Spot instance.</p>
-- @return SpotPrice structure as a key-value pair table
function M.SpotPrice(args)
	assert(args, "You must provdide an argument table when creating SpotPrice")
	local t = { 
		["Timestamp"] = args["Timestamp"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["InstanceType"] = args["InstanceType"],
		["ProductDescription"] = args["ProductDescription"],
		["SpotPrice"] = args["SpotPrice"],
	}
	asserts.AssertSpotPrice(t)
	return t
end

keys.PrefixList = { ["PrefixListName"] = true, ["Cidrs"] = true, ["PrefixListId"] = true, nil }

function asserts.AssertPrefixList(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrefixList to be of type 'table'")
	if struct["PrefixListName"] then asserts.AssertString(struct["PrefixListName"]) end
	if struct["Cidrs"] then asserts.AssertValueStringList(struct["Cidrs"]) end
	if struct["PrefixListId"] then asserts.AssertString(struct["PrefixListId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrefixList[k], "PrefixList contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrefixList
-- <p>Describes prefixes for AWS services.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrefixListName [String] <p>The name of the prefix.</p>
-- * Cidrs [ValueStringList] <p>The IP address range of the AWS service.</p>
-- * PrefixListId [String] <p>The ID of the prefix.</p>
-- @return PrefixList structure as a key-value pair table
function M.PrefixList(args)
	assert(args, "You must provdide an argument table when creating PrefixList")
	local t = { 
		["PrefixListName"] = args["PrefixListName"],
		["Cidrs"] = args["Cidrs"],
		["PrefixListId"] = args["PrefixListId"],
	}
	asserts.AssertPrefixList(t)
	return t
end

keys.DeleteVpcEndpointsRequest = { ["VpcEndpointIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpcEndpointsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointsRequest to be of type 'table'")
	assert(struct["VpcEndpointIds"], "Expected key VpcEndpointIds to exist in table")
	if struct["VpcEndpointIds"] then asserts.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointsRequest[k], "DeleteVpcEndpointsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointsRequest
-- <p>Contains the parameters for DeleteVpcEndpoints.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpointIds [ValueStringList] <p>One or more endpoint IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcEndpointIds
-- @return DeleteVpcEndpointsRequest structure as a key-value pair table
function M.DeleteVpcEndpointsRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteVpcEndpointsRequest")
	local t = { 
		["VpcEndpointIds"] = args["VpcEndpointIds"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteVpcEndpointsRequest(t)
	return t
end

keys.Image = { ["RootDeviceType"] = true, ["State"] = true, ["ImageLocation"] = true, ["RamdiskId"] = true, ["Public"] = true, ["ProductCodes"] = true, ["Description"] = true, ["Tags"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["ImageId"] = true, ["KernelId"] = true, ["Name"] = true, ["Hypervisor"] = true, ["BlockDeviceMappings"] = true, ["Architecture"] = true, ["ImageOwnerAlias"] = true, ["StateReason"] = true, ["RootDeviceName"] = true, ["ImageType"] = true, ["VirtualizationType"] = true, ["Platform"] = true, ["OwnerId"] = true, ["CreationDate"] = true, nil }

function asserts.AssertImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Image to be of type 'table'")
	if struct["RootDeviceType"] then asserts.AssertDeviceType(struct["RootDeviceType"]) end
	if struct["State"] then asserts.AssertImageState(struct["State"]) end
	if struct["ImageLocation"] then asserts.AssertString(struct["ImageLocation"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["Public"] then asserts.AssertBoolean(struct["Public"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["EnaSupport"] then asserts.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertString(struct["SriovNetSupport"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Hypervisor"] then asserts.AssertHypervisorType(struct["Hypervisor"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["ImageOwnerAlias"] then asserts.AssertString(struct["ImageOwnerAlias"]) end
	if struct["StateReason"] then asserts.AssertStateReason(struct["StateReason"]) end
	if struct["RootDeviceName"] then asserts.AssertString(struct["RootDeviceName"]) end
	if struct["ImageType"] then asserts.AssertImageTypeValues(struct["ImageType"]) end
	if struct["VirtualizationType"] then asserts.AssertVirtualizationType(struct["VirtualizationType"]) end
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["CreationDate"] then asserts.AssertString(struct["CreationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.Image[k], "Image contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Image
-- <p>Describes an image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RootDeviceType [DeviceType] <p>The type of root device used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
-- * State [ImageState] <p>The current state of the AMI. If the state is <code>available</code>, the image is successfully registered and can be used to launch an instance.</p>
-- * ImageLocation [String] <p>The location of the AMI.</p>
-- * RamdiskId [String] <p>The RAM disk associated with the image, if any. Only applicable for machine images.</p>
-- * Public [Boolean] <p>Indicates whether the image has public launch permissions. The value is <code>true</code> if this image has public launch permissions or <code>false</code> if it has only implicit and explicit launch permissions.</p>
-- * ProductCodes [ProductCodeList] <p>Any product codes associated with the AMI.</p>
-- * Description [String] <p>The description of the AMI that was provided during image creation.</p>
-- * Tags [TagList] <p>Any tags assigned to the image.</p>
-- * EnaSupport [Boolean] <p>Specifies whether enhanced networking with ENA is enabled.</p>
-- * SriovNetSupport [String] <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * KernelId [String] <p>The kernel associated with the image, if any. Only applicable for machine images.</p>
-- * Name [String] <p>The name of the AMI that was provided during image creation.</p>
-- * Hypervisor [HypervisorType] <p>The hypervisor type of the image.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>Any block device mapping entries.</p>
-- * Architecture [ArchitectureValues] <p>The architecture of the image.</p>
-- * ImageOwnerAlias [String] <p>The AWS account alias (for example, <code>amazon</code>, <code>self</code>) or the AWS account ID of the AMI owner.</p>
-- * StateReason [StateReason] <p>The reason for the state change.</p>
-- * RootDeviceName [String] <p>The device name of the root device (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p>
-- * ImageType [ImageTypeValues] <p>The type of image.</p>
-- * VirtualizationType [VirtualizationType] <p>The type of virtualization of the AMI.</p>
-- * Platform [PlatformValues] <p>The value is <code>Windows</code> for Windows AMIs; otherwise blank.</p>
-- * OwnerId [String] <p>The AWS account ID of the image owner.</p>
-- * CreationDate [String] <p>The date and time the image was created.</p>
-- @return Image structure as a key-value pair table
function M.Image(args)
	assert(args, "You must provdide an argument table when creating Image")
	local t = { 
		["RootDeviceType"] = args["RootDeviceType"],
		["State"] = args["State"],
		["ImageLocation"] = args["ImageLocation"],
		["RamdiskId"] = args["RamdiskId"],
		["Public"] = args["Public"],
		["ProductCodes"] = args["ProductCodes"],
		["Description"] = args["Description"],
		["Tags"] = args["Tags"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["ImageId"] = args["ImageId"],
		["KernelId"] = args["KernelId"],
		["Name"] = args["Name"],
		["Hypervisor"] = args["Hypervisor"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["Architecture"] = args["Architecture"],
		["ImageOwnerAlias"] = args["ImageOwnerAlias"],
		["StateReason"] = args["StateReason"],
		["RootDeviceName"] = args["RootDeviceName"],
		["ImageType"] = args["ImageType"],
		["VirtualizationType"] = args["VirtualizationType"],
		["Platform"] = args["Platform"],
		["OwnerId"] = args["OwnerId"],
		["CreationDate"] = args["CreationDate"],
	}
	asserts.AssertImage(t)
	return t
end

keys.DetachNetworkInterfaceRequest = { ["DryRun"] = true, ["AttachmentId"] = true, ["Force"] = true, nil }

function asserts.AssertDetachNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachNetworkInterfaceRequest to be of type 'table'")
	assert(struct["AttachmentId"], "Expected key AttachmentId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachNetworkInterfaceRequest[k], "DetachNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachNetworkInterfaceRequest
-- <p>Contains the parameters for DetachNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AttachmentId [String] <p>The ID of the attachment.</p>
-- * Force [Boolean] <p>Specifies whether to force a detachment.</p>
-- Required key: AttachmentId
-- @return DetachNetworkInterfaceRequest structure as a key-value pair table
function M.DetachNetworkInterfaceRequest(args)
	assert(args, "You must provdide an argument table when creating DetachNetworkInterfaceRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["AttachmentId"] = args["AttachmentId"],
		["Force"] = args["Force"],
	}
	asserts.AssertDetachNetworkInterfaceRequest(t)
	return t
end

keys.AttachNetworkInterfaceResult = { ["AttachmentId"] = true, nil }

function asserts.AssertAttachNetworkInterfaceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachNetworkInterfaceResult to be of type 'table'")
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachNetworkInterfaceResult[k], "AttachNetworkInterfaceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachNetworkInterfaceResult
-- <p>Contains the output of AttachNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- @return AttachNetworkInterfaceResult structure as a key-value pair table
function M.AttachNetworkInterfaceResult(args)
	assert(args, "You must provdide an argument table when creating AttachNetworkInterfaceResult")
	local t = { 
		["AttachmentId"] = args["AttachmentId"],
	}
	asserts.AssertAttachNetworkInterfaceResult(t)
	return t
end

keys.DescribeReservedInstancesListingsResult = { ["ReservedInstancesListings"] = true, nil }

function asserts.AssertDescribeReservedInstancesListingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesListingsResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then asserts.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesListingsResult[k], "DescribeReservedInstancesListingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesListingsResult
-- <p>Contains the output of DescribeReservedInstancesListings.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesListings [ReservedInstancesListingList] <p>Information about the Reserved Instance listing.</p>
-- @return DescribeReservedInstancesListingsResult structure as a key-value pair table
function M.DescribeReservedInstancesListingsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeReservedInstancesListingsResult")
	local t = { 
		["ReservedInstancesListings"] = args["ReservedInstancesListings"],
	}
	asserts.AssertDescribeReservedInstancesListingsResult(t)
	return t
end

keys.DisassociateIamInstanceProfileRequest = { ["AssociationId"] = true, nil }

function asserts.AssertDisassociateIamInstanceProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateIamInstanceProfileRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateIamInstanceProfileRequest[k], "DisassociateIamInstanceProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateIamInstanceProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The ID of the IAM instance profile association.</p>
-- Required key: AssociationId
-- @return DisassociateIamInstanceProfileRequest structure as a key-value pair table
function M.DisassociateIamInstanceProfileRequest(args)
	assert(args, "You must provdide an argument table when creating DisassociateIamInstanceProfileRequest")
	local t = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertDisassociateIamInstanceProfileRequest(t)
	return t
end

keys.AllocateAddressRequest = { ["Domain"] = true, ["DryRun"] = true, nil }

function asserts.AssertAllocateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateAddressRequest to be of type 'table'")
	if struct["Domain"] then asserts.AssertDomainType(struct["Domain"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateAddressRequest[k], "AllocateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateAddressRequest
-- <p>Contains the parameters for AllocateAddress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Domain [DomainType] <p>Set to <code>vpc</code> to allocate the address for use with instances in a VPC.</p> <p>Default: The address is for use with instances in EC2-Classic.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return AllocateAddressRequest structure as a key-value pair table
function M.AllocateAddressRequest(args)
	assert(args, "You must provdide an argument table when creating AllocateAddressRequest")
	local t = { 
		["Domain"] = args["Domain"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertAllocateAddressRequest(t)
	return t
end

keys.DescribeIamInstanceProfileAssociationsResult = { ["IamInstanceProfileAssociations"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeIamInstanceProfileAssociationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIamInstanceProfileAssociationsResult to be of type 'table'")
	if struct["IamInstanceProfileAssociations"] then asserts.AssertIamInstanceProfileAssociationSet(struct["IamInstanceProfileAssociations"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIamInstanceProfileAssociationsResult[k], "DescribeIamInstanceProfileAssociationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIamInstanceProfileAssociationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IamInstanceProfileAssociations [IamInstanceProfileAssociationSet] <p>Information about one or more IAM instance profile associations.</p>
-- * NextToken [NextToken] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeIamInstanceProfileAssociationsResult structure as a key-value pair table
function M.DescribeIamInstanceProfileAssociationsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeIamInstanceProfileAssociationsResult")
	local t = { 
		["IamInstanceProfileAssociations"] = args["IamInstanceProfileAssociations"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeIamInstanceProfileAssociationsResult(t)
	return t
end

keys.AttributeBooleanValue = { ["Value"] = true, nil }

function asserts.AssertAttributeBooleanValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttributeBooleanValue to be of type 'table'")
	if struct["Value"] then asserts.AssertBoolean(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttributeBooleanValue[k], "AttributeBooleanValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttributeBooleanValue
-- <p>Describes a value for a resource attribute that is a Boolean value.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [Boolean] <p>The attribute value. The valid values are <code>true</code> or <code>false</code>.</p>
-- @return AttributeBooleanValue structure as a key-value pair table
function M.AttributeBooleanValue(args)
	assert(args, "You must provdide an argument table when creating AttributeBooleanValue")
	local t = { 
		["Value"] = args["Value"],
	}
	asserts.AssertAttributeBooleanValue(t)
	return t
end

keys.DescribeSnapshotAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertDescribeSnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["Attribute"] then asserts.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotAttributeRequest[k], "DescribeSnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotAttributeRequest
-- <p>Contains the parameters for DescribeSnapshotAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [SnapshotAttributeName] <p>The snapshot attribute you would like to view.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- Required key: Attribute
-- Required key: SnapshotId
-- @return DescribeSnapshotAttributeRequest structure as a key-value pair table
function M.DescribeSnapshotAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeSnapshotAttributeRequest")
	local t = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertDescribeSnapshotAttributeRequest(t)
	return t
end

keys.DescribeAvailabilityZonesRequest = { ["DryRun"] = true, ["Filters"] = true, ["ZoneNames"] = true, nil }

function asserts.AssertDescribeAvailabilityZonesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailabilityZonesRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ZoneNames"] then asserts.AssertZoneNameStringList(struct["ZoneNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAvailabilityZonesRequest[k], "DescribeAvailabilityZonesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailabilityZonesRequest
-- <p>Contains the parameters for DescribeAvailabilityZones.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>message</code> - Information about the Availability Zone.</p> </li> <li> <p> <code>region-name</code> - The name of the region for the Availability Zone (for example, <code>us-east-1</code>).</p> </li> <li> <p> <code>state</code> - The state of the Availability Zone (<code>available</code> | <code>information</code> | <code>impaired</code> | <code>unavailable</code>).</p> </li> <li> <p> <code>zone-name</code> - The name of the Availability Zone (for example, <code>us-east-1a</code>).</p> </li> </ul>
-- * ZoneNames [ZoneNameStringList] <p>The names of one or more Availability Zones.</p>
-- @return DescribeAvailabilityZonesRequest structure as a key-value pair table
function M.DescribeAvailabilityZonesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeAvailabilityZonesRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["ZoneNames"] = args["ZoneNames"],
	}
	asserts.AssertDescribeAvailabilityZonesRequest(t)
	return t
end

keys.DetachVolumeRequest = { ["Device"] = true, ["InstanceId"] = true, ["DryRun"] = true, ["Force"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDetachVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Device"] then asserts.AssertString(struct["Device"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachVolumeRequest[k], "DetachVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachVolumeRequest
-- <p>Contains the parameters for DetachVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Device [String] <p>The device name.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Force [Boolean] <p>Forces detachment if the previous detachment attempt did not occur cleanly (for example, logging into an instance, unmounting the volume, and detaching normally). This option can lead to data loss or a corrupted file system. Use this option only as a last resort to detach a volume from a failed instance. The instance won't have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: VolumeId
-- @return DetachVolumeRequest structure as a key-value pair table
function M.DetachVolumeRequest(args)
	assert(args, "You must provdide an argument table when creating DetachVolumeRequest")
	local t = { 
		["Device"] = args["Device"],
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
		["Force"] = args["Force"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertDetachVolumeRequest(t)
	return t
end

keys.ResetInstanceAttributeRequest = { ["InstanceId"] = true, ["Attribute"] = true, ["DryRun"] = true, nil }

function asserts.AssertResetInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetInstanceAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then asserts.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetInstanceAttributeRequest[k], "ResetInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetInstanceAttributeRequest
-- <p>Contains the parameters for ResetInstanceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Attribute [InstanceAttributeName] <p>The attribute to reset.</p> <important> <p>You can only reset the following attributes: <code>kernel</code> | <code>ramdisk</code> | <code>sourceDestCheck</code>. To change an instance attribute, use <a>ModifyInstanceAttribute</a>.</p> </important>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: Attribute
-- Required key: InstanceId
-- @return ResetInstanceAttributeRequest structure as a key-value pair table
function M.ResetInstanceAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ResetInstanceAttributeRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertResetInstanceAttributeRequest(t)
	return t
end

keys.RestoreAddressToClassicRequest = { ["PublicIp"] = true, ["DryRun"] = true, nil }

function asserts.AssertRestoreAddressToClassicRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RestoreAddressToClassicRequest to be of type 'table'")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.RestoreAddressToClassicRequest[k], "RestoreAddressToClassicRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RestoreAddressToClassicRequest
-- <p>Contains the parameters for RestoreAddressToClassic.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: PublicIp
-- @return RestoreAddressToClassicRequest structure as a key-value pair table
function M.RestoreAddressToClassicRequest(args)
	assert(args, "You must provdide an argument table when creating RestoreAddressToClassicRequest")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertRestoreAddressToClassicRequest(t)
	return t
end

keys.HistoryRecord = { ["EventType"] = true, ["EventInformation"] = true, ["Timestamp"] = true, nil }

function asserts.AssertHistoryRecord(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HistoryRecord to be of type 'table'")
	assert(struct["EventInformation"], "Expected key EventInformation to exist in table")
	assert(struct["EventType"], "Expected key EventType to exist in table")
	assert(struct["Timestamp"], "Expected key Timestamp to exist in table")
	if struct["EventType"] then asserts.AssertEventType(struct["EventType"]) end
	if struct["EventInformation"] then asserts.AssertEventInformation(struct["EventInformation"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	for k,_ in pairs(struct) do
		assert(keys.HistoryRecord[k], "HistoryRecord contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HistoryRecord
-- <p>Describes an event in the history of the Spot fleet request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EventType [EventType] <p>The event type.</p> <ul> <li> <p> <code>error</code> - Indicates an error with the Spot fleet request.</p> </li> <li> <p> <code>fleetRequestChange</code> - Indicates a change in the status or configuration of the Spot fleet request.</p> </li> <li> <p> <code>instanceChange</code> - Indicates that an instance was launched or terminated.</p> </li> </ul>
-- * EventInformation [EventInformation] <p>Information about the event.</p>
-- * Timestamp [DateTime] <p>The date and time of the event, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- Required key: EventInformation
-- Required key: EventType
-- Required key: Timestamp
-- @return HistoryRecord structure as a key-value pair table
function M.HistoryRecord(args)
	assert(args, "You must provdide an argument table when creating HistoryRecord")
	local t = { 
		["EventType"] = args["EventType"],
		["EventInformation"] = args["EventInformation"],
		["Timestamp"] = args["Timestamp"],
	}
	asserts.AssertHistoryRecord(t)
	return t
end

keys.PrivateIpAddressSpecification = { ["Primary"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertPrivateIpAddressSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrivateIpAddressSpecification to be of type 'table'")
	assert(struct["PrivateIpAddress"], "Expected key PrivateIpAddress to exist in table")
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrivateIpAddressSpecification[k], "PrivateIpAddressSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrivateIpAddressSpecification
-- <p>Describes a secondary private IPv4 address for a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Primary [Boolean] <p>Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 addresses.</p>
-- Required key: PrivateIpAddress
-- @return PrivateIpAddressSpecification structure as a key-value pair table
function M.PrivateIpAddressSpecification(args)
	assert(args, "You must provdide an argument table when creating PrivateIpAddressSpecification")
	local t = { 
		["Primary"] = args["Primary"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertPrivateIpAddressSpecification(t)
	return t
end

keys.AcceptReservedInstancesExchangeQuoteRequest = { ["ReservedInstanceIds"] = true, ["DryRun"] = true, ["TargetConfigurations"] = true, nil }

function asserts.AssertAcceptReservedInstancesExchangeQuoteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptReservedInstancesExchangeQuoteRequest to be of type 'table'")
	assert(struct["ReservedInstanceIds"], "Expected key ReservedInstanceIds to exist in table")
	if struct["ReservedInstanceIds"] then asserts.AssertReservedInstanceIdSet(struct["ReservedInstanceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TargetConfigurations"] then asserts.AssertTargetConfigurationRequestSet(struct["TargetConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptReservedInstancesExchangeQuoteRequest[k], "AcceptReservedInstancesExchangeQuoteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptReservedInstancesExchangeQuoteRequest
-- <p>Contains the parameters for accepting the quote.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstanceIds [ReservedInstanceIdSet] <p>The IDs of the Convertible Reserved Instances to exchange for other Convertible Reserved Instances of the same or higher value.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TargetConfigurations [TargetConfigurationRequestSet] <p>The configurations of the Convertible Reserved Instance offerings that you are purchasing in this exchange.</p>
-- Required key: ReservedInstanceIds
-- @return AcceptReservedInstancesExchangeQuoteRequest structure as a key-value pair table
function M.AcceptReservedInstancesExchangeQuoteRequest(args)
	assert(args, "You must provdide an argument table when creating AcceptReservedInstancesExchangeQuoteRequest")
	local t = { 
		["ReservedInstanceIds"] = args["ReservedInstanceIds"],
		["DryRun"] = args["DryRun"],
		["TargetConfigurations"] = args["TargetConfigurations"],
	}
	asserts.AssertAcceptReservedInstancesExchangeQuoteRequest(t)
	return t
end

keys.AttachVpnGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["VpnGatewayId"] = true, nil }

function asserts.AssertAttachVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVpnGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachVpnGatewayRequest[k], "AttachVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVpnGatewayRequest
-- <p>Contains the parameters for AttachVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required key: VpcId
-- Required key: VpnGatewayId
-- @return AttachVpnGatewayRequest structure as a key-value pair table
function M.AttachVpnGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating AttachVpnGatewayRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["VpnGatewayId"] = args["VpnGatewayId"],
	}
	asserts.AssertAttachVpnGatewayRequest(t)
	return t
end

keys.CreateVpcEndpointRequest = { ["VpcId"] = true, ["DryRun"] = true, ["ServiceName"] = true, ["PolicyDocument"] = true, ["RouteTableIds"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateVpcEndpointRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointRequest to be of type 'table'")
	assert(struct["ServiceName"], "Expected key ServiceName to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ServiceName"] then asserts.AssertString(struct["ServiceName"]) end
	if struct["PolicyDocument"] then asserts.AssertString(struct["PolicyDocument"]) end
	if struct["RouteTableIds"] then asserts.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointRequest[k], "CreateVpcEndpointRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointRequest
-- <p>Contains the parameters for CreateVpcEndpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC in which the endpoint will be used.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ServiceName [String] <p>The AWS service name, in the form <code>com.amazonaws.<i>region</i>.<i>service</i> </code>. To get a list of available services, use the <a>DescribeVpcEndpointServices</a> request.</p>
-- * PolicyDocument [String] <p>A policy to attach to the endpoint that controls access to the service. The policy must be in valid JSON format. If this parameter is not specified, we attach a default policy that allows full access to the service.</p>
-- * RouteTableIds [ValueStringList] <p>One or more route table IDs.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required key: ServiceName
-- Required key: VpcId
-- @return CreateVpcEndpointRequest structure as a key-value pair table
function M.CreateVpcEndpointRequest(args)
	assert(args, "You must provdide an argument table when creating CreateVpcEndpointRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["ServiceName"] = args["ServiceName"],
		["PolicyDocument"] = args["PolicyDocument"],
		["RouteTableIds"] = args["RouteTableIds"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateVpcEndpointRequest(t)
	return t
end

keys.AssociateAddressRequest = { ["DryRun"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["PublicIp"] = true, ["AllowReassociation"] = true, ["AllocationId"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertAssociateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateAddressRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AllowReassociation"] then asserts.AssertBoolean(struct["AllowReassociation"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateAddressRequest[k], "AssociateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateAddressRequest
-- <p>Contains the parameters for AssociateAddress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceId [String] <p>The ID of the instance. This is required for EC2-Classic. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. The operation fails if you specify an instance ID unless exactly one network interface is attached.</p>
-- * NetworkInterfaceId [String] <p>[EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID.</p>
-- * PublicIp [String] <p>The Elastic IP address. This is required for EC2-Classic.</p>
-- * AllowReassociation [Boolean] <p>[EC2-VPC] For a VPC in an EC2-Classic account, specify true to allow an Elastic IP address that is already associated with an instance or network interface to be reassociated with the specified instance or network interface. Otherwise, the operation fails. In a VPC in an EC2-VPC-only account, reassociation is automatic, therefore you can specify false to ensure the operation fails if the Elastic IP address is already associated with another resource.</p>
-- * AllocationId [String] <p>[EC2-VPC] The allocation ID. This is required for EC2-VPC.</p>
-- * PrivateIpAddress [String] <p>[EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.</p>
-- @return AssociateAddressRequest structure as a key-value pair table
function M.AssociateAddressRequest(args)
	assert(args, "You must provdide an argument table when creating AssociateAddressRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["PublicIp"] = args["PublicIp"],
		["AllowReassociation"] = args["AllowReassociation"],
		["AllocationId"] = args["AllocationId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertAssociateAddressRequest(t)
	return t
end

keys.DeleteNatGatewayResult = { ["NatGatewayId"] = true, nil }

function asserts.AssertDeleteNatGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNatGatewayResult to be of type 'table'")
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNatGatewayResult[k], "DeleteNatGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNatGatewayResult
-- <p>Contains the output of DeleteNatGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- @return DeleteNatGatewayResult structure as a key-value pair table
function M.DeleteNatGatewayResult(args)
	assert(args, "You must provdide an argument table when creating DeleteNatGatewayResult")
	local t = { 
		["NatGatewayId"] = args["NatGatewayId"],
	}
	asserts.AssertDeleteNatGatewayResult(t)
	return t
end

keys.ImportImageTask = { ["Status"] = true, ["LicenseType"] = true, ["Description"] = true, ["Hypervisor"] = true, ["ImageId"] = true, ["Platform"] = true, ["Architecture"] = true, ["SnapshotDetails"] = true, ["Progress"] = true, ["StatusMessage"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportImageTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageTask to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["LicenseType"] then asserts.AssertString(struct["LicenseType"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Hypervisor"] then asserts.AssertString(struct["Hypervisor"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["Architecture"] then asserts.AssertString(struct["Architecture"]) end
	if struct["SnapshotDetails"] then asserts.AssertSnapshotDetailList(struct["SnapshotDetails"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportImageTask[k], "ImportImageTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageTask
-- <p>Describes an import image task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>A brief status for the import image task.</p>
-- * LicenseType [String] <p>The license type of the virtual machine.</p>
-- * Description [String] <p>A description of the import task.</p>
-- * Hypervisor [String] <p>The target hypervisor for the import task.</p> <p>Valid values: <code>xen</code> </p>
-- * ImageId [String] <p>The ID of the Amazon Machine Image (AMI) of the imported virtual machine.</p>
-- * Platform [String] <p>The description string for the import image task.</p>
-- * Architecture [String] <p>The architecture of the virtual machine.</p> <p>Valid values: <code>i386</code> | <code>x86_64</code> </p>
-- * SnapshotDetails [SnapshotDetailList] <p>Information about the snapshots.</p>
-- * Progress [String] <p>The percentage of progress of the import image task.</p>
-- * StatusMessage [String] <p>A descriptive status message for the import image task.</p>
-- * ImportTaskId [String] <p>The ID of the import image task.</p>
-- @return ImportImageTask structure as a key-value pair table
function M.ImportImageTask(args)
	assert(args, "You must provdide an argument table when creating ImportImageTask")
	local t = { 
		["Status"] = args["Status"],
		["LicenseType"] = args["LicenseType"],
		["Description"] = args["Description"],
		["Hypervisor"] = args["Hypervisor"],
		["ImageId"] = args["ImageId"],
		["Platform"] = args["Platform"],
		["Architecture"] = args["Architecture"],
		["SnapshotDetails"] = args["SnapshotDetails"],
		["Progress"] = args["Progress"],
		["StatusMessage"] = args["StatusMessage"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertImportImageTask(t)
	return t
end

keys.DeregisterImageRequest = { ["DryRun"] = true, ["ImageId"] = true, nil }

function asserts.AssertDeregisterImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterImageRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterImageRequest[k], "DeregisterImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterImageRequest
-- <p>Contains the parameters for DeregisterImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- Required key: ImageId
-- @return DeregisterImageRequest structure as a key-value pair table
function M.DeregisterImageRequest(args)
	assert(args, "You must provdide an argument table when creating DeregisterImageRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertDeregisterImageRequest(t)
	return t
end

keys.CreateInternetGatewayResult = { ["InternetGateway"] = true, nil }

function asserts.AssertCreateInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInternetGatewayResult to be of type 'table'")
	if struct["InternetGateway"] then asserts.AssertInternetGateway(struct["InternetGateway"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInternetGatewayResult[k], "CreateInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInternetGatewayResult
-- <p>Contains the output of CreateInternetGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InternetGateway [InternetGateway] <p>Information about the Internet gateway.</p>
-- @return CreateInternetGatewayResult structure as a key-value pair table
function M.CreateInternetGatewayResult(args)
	assert(args, "You must provdide an argument table when creating CreateInternetGatewayResult")
	local t = { 
		["InternetGateway"] = args["InternetGateway"],
	}
	asserts.AssertCreateInternetGatewayResult(t)
	return t
end

keys.ReservedInstanceLimitPrice = { ["Amount"] = true, ["CurrencyCode"] = true, nil }

function asserts.AssertReservedInstanceLimitPrice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstanceLimitPrice to be of type 'table'")
	if struct["Amount"] then asserts.AssertDouble(struct["Amount"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstanceLimitPrice[k], "ReservedInstanceLimitPrice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstanceLimitPrice
-- <p>Describes the limit price of a Reserved Instance offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Amount [Double] <p>Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>limitPrice</code> amount is specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @return ReservedInstanceLimitPrice structure as a key-value pair table
function M.ReservedInstanceLimitPrice(args)
	assert(args, "You must provdide an argument table when creating ReservedInstanceLimitPrice")
	local t = { 
		["Amount"] = args["Amount"],
		["CurrencyCode"] = args["CurrencyCode"],
	}
	asserts.AssertReservedInstanceLimitPrice(t)
	return t
end

keys.DescribeInstanceStatusResult = { ["InstanceStatuses"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstanceStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceStatusResult to be of type 'table'")
	if struct["InstanceStatuses"] then asserts.AssertInstanceStatusList(struct["InstanceStatuses"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceStatusResult[k], "DescribeInstanceStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceStatusResult
-- <p>Contains the output of DescribeInstanceStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceStatuses [InstanceStatusList] <p>One or more instance status descriptions.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeInstanceStatusResult structure as a key-value pair table
function M.DescribeInstanceStatusResult(args)
	assert(args, "You must provdide an argument table when creating DescribeInstanceStatusResult")
	local t = { 
		["InstanceStatuses"] = args["InstanceStatuses"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeInstanceStatusResult(t)
	return t
end

keys.RunScheduledInstancesResult = { ["InstanceIdSet"] = true, nil }

function asserts.AssertRunScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunScheduledInstancesResult to be of type 'table'")
	if struct["InstanceIdSet"] then asserts.AssertInstanceIdSet(struct["InstanceIdSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunScheduledInstancesResult[k], "RunScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunScheduledInstancesResult
-- <p>Contains the output of RunScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceIdSet [InstanceIdSet] <p>The IDs of the newly launched instances.</p>
-- @return RunScheduledInstancesResult structure as a key-value pair table
function M.RunScheduledInstancesResult(args)
	assert(args, "You must provdide an argument table when creating RunScheduledInstancesResult")
	local t = { 
		["InstanceIdSet"] = args["InstanceIdSet"],
	}
	asserts.AssertRunScheduledInstancesResult(t)
	return t
end

keys.GetConsoleOutputResult = { ["InstanceId"] = true, ["Output"] = true, ["Timestamp"] = true, nil }

function asserts.AssertGetConsoleOutputResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleOutputResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Output"] then asserts.AssertString(struct["Output"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleOutputResult[k], "GetConsoleOutputResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleOutputResult
-- <p>Contains the output of GetConsoleOutput.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Output [String] <p>The console output, Base64-encoded. If using a command line tool, the tool decodes the output for you.</p>
-- * Timestamp [DateTime] <p>The time the output was last updated.</p>
-- @return GetConsoleOutputResult structure as a key-value pair table
function M.GetConsoleOutputResult(args)
	assert(args, "You must provdide an argument table when creating GetConsoleOutputResult")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["Output"] = args["Output"],
		["Timestamp"] = args["Timestamp"],
	}
	asserts.AssertGetConsoleOutputResult(t)
	return t
end

keys.ClassicLinkInstance = { ["InstanceId"] = true, ["VpcId"] = true, ["Groups"] = true, ["Tags"] = true, nil }

function asserts.AssertClassicLinkInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLinkInstance to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClassicLinkInstance[k], "ClassicLinkInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLinkInstance
-- <p>Describes a linked EC2-Classic instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * Groups [GroupIdentifierList] <p>A list of security groups.</p>
-- * Tags [TagList] <p>Any tags assigned to the instance.</p>
-- @return ClassicLinkInstance structure as a key-value pair table
function M.ClassicLinkInstance(args)
	assert(args, "You must provdide an argument table when creating ClassicLinkInstance")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["VpcId"] = args["VpcId"],
		["Groups"] = args["Groups"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertClassicLinkInstance(t)
	return t
end

keys.NetworkInterfaceAttachment = { ["Status"] = true, ["DeviceIndex"] = true, ["AttachTime"] = true, ["InstanceId"] = true, ["DeleteOnTermination"] = true, ["AttachmentId"] = true, ["InstanceOwnerId"] = true, nil }

function asserts.AssertNetworkInterfaceAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAttachment to be of type 'table'")
	if struct["Status"] then asserts.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	if struct["InstanceOwnerId"] then asserts.AssertString(struct["InstanceOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceAttachment[k], "NetworkInterfaceAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAttachment
-- <p>Describes a network interface attachment.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [AttachmentStatus] <p>The attachment state.</p>
-- * DeviceIndex [Integer] <p>The device index of the network interface attachment on the instance.</p>
-- * AttachTime [DateTime] <p>The timestamp indicating when the attachment initiated.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- * AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- * InstanceOwnerId [String] <p>The AWS account ID of the owner of the instance.</p>
-- @return NetworkInterfaceAttachment structure as a key-value pair table
function M.NetworkInterfaceAttachment(args)
	assert(args, "You must provdide an argument table when creating NetworkInterfaceAttachment")
	local t = { 
		["Status"] = args["Status"],
		["DeviceIndex"] = args["DeviceIndex"],
		["AttachTime"] = args["AttachTime"],
		["InstanceId"] = args["InstanceId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["AttachmentId"] = args["AttachmentId"],
		["InstanceOwnerId"] = args["InstanceOwnerId"],
	}
	asserts.AssertNetworkInterfaceAttachment(t)
	return t
end

keys.ModifyNetworkInterfaceAttributeRequest = { ["SourceDestCheck"] = true, ["DryRun"] = true, ["Description"] = true, ["NetworkInterfaceId"] = true, ["Attachment"] = true, ["Groups"] = true, nil }

function asserts.AssertModifyNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["Attachment"] then asserts.AssertNetworkInterfaceAttachmentChanges(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyNetworkInterfaceAttributeRequest[k], "ModifyNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for ModifyNetworkInterfaceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT. For more information, see <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html">NAT Instances</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [AttributeValue] <p>A description for the network interface.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * Attachment [NetworkInterfaceAttachmentChanges] <p>Information about the interface attachment. If modifying the 'delete on termination' attribute, you must specify the ID of the interface attachment.</p>
-- * Groups [SecurityGroupIdStringList] <p>Changes the security groups for the network interface. The new set of groups you specify replaces the current set. You must specify at least one group, even if it's just the default security group in the VPC. You must specify the ID of the security group, not the name.</p>
-- Required key: NetworkInterfaceId
-- @return ModifyNetworkInterfaceAttributeRequest structure as a key-value pair table
function M.ModifyNetworkInterfaceAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyNetworkInterfaceAttributeRequest")
	local t = { 
		["SourceDestCheck"] = args["SourceDestCheck"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["Attachment"] = args["Attachment"],
		["Groups"] = args["Groups"],
	}
	asserts.AssertModifyNetworkInterfaceAttributeRequest(t)
	return t
end

keys.InstanceStatus = { ["InstanceStatus"] = true, ["AvailabilityZone"] = true, ["InstanceId"] = true, ["InstanceState"] = true, ["Events"] = true, ["SystemStatus"] = true, nil }

function asserts.AssertInstanceStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatus to be of type 'table'")
	if struct["InstanceStatus"] then asserts.AssertInstanceStatusSummary(struct["InstanceStatus"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["InstanceState"] then asserts.AssertInstanceState(struct["InstanceState"]) end
	if struct["Events"] then asserts.AssertInstanceStatusEventList(struct["Events"]) end
	if struct["SystemStatus"] then asserts.AssertInstanceStatusSummary(struct["SystemStatus"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatus[k], "InstanceStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatus
-- <p>Describes the status of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceStatus [InstanceStatusSummary] <p>Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.</p>
-- * AvailabilityZone [String] <p>The Availability Zone of the instance.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * InstanceState [InstanceState] <p>The intended state of the instance. <a>DescribeInstanceStatus</a> requires that an instance be in the <code>running</code> state.</p>
-- * Events [InstanceStatusEventList] <p>Any scheduled events associated with the instance.</p>
-- * SystemStatus [InstanceStatusSummary] <p>Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.</p>
-- @return InstanceStatus structure as a key-value pair table
function M.InstanceStatus(args)
	assert(args, "You must provdide an argument table when creating InstanceStatus")
	local t = { 
		["InstanceStatus"] = args["InstanceStatus"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["InstanceId"] = args["InstanceId"],
		["InstanceState"] = args["InstanceState"],
		["Events"] = args["Events"],
		["SystemStatus"] = args["SystemStatus"],
	}
	asserts.AssertInstanceStatus(t)
	return t
end

keys.EgressOnlyInternetGateway = { ["EgressOnlyInternetGatewayId"] = true, ["Attachments"] = true, nil }

function asserts.AssertEgressOnlyInternetGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EgressOnlyInternetGateway to be of type 'table'")
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertEgressOnlyInternetGatewayId(struct["EgressOnlyInternetGatewayId"]) end
	if struct["Attachments"] then asserts.AssertInternetGatewayAttachmentList(struct["Attachments"]) end
	for k,_ in pairs(struct) do
		assert(keys.EgressOnlyInternetGateway[k], "EgressOnlyInternetGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EgressOnlyInternetGateway
-- <p>Describes an egress-only Internet gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EgressOnlyInternetGatewayId [EgressOnlyInternetGatewayId] <p>The ID of the egress-only Internet gateway.</p>
-- * Attachments [InternetGatewayAttachmentList] <p>Information about the attachment of the egress-only Internet gateway.</p>
-- @return EgressOnlyInternetGateway structure as a key-value pair table
function M.EgressOnlyInternetGateway(args)
	assert(args, "You must provdide an argument table when creating EgressOnlyInternetGateway")
	local t = { 
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["Attachments"] = args["Attachments"],
	}
	asserts.AssertEgressOnlyInternetGateway(t)
	return t
end

keys.UnassignPrivateIpAddressesRequest = { ["NetworkInterfaceId"] = true, ["PrivateIpAddresses"] = true, nil }

function asserts.AssertUnassignPrivateIpAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignPrivateIpAddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	assert(struct["PrivateIpAddresses"], "Expected key PrivateIpAddresses to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressStringList(struct["PrivateIpAddresses"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnassignPrivateIpAddressesRequest[k], "UnassignPrivateIpAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignPrivateIpAddressesRequest
-- <p>Contains the parameters for UnassignPrivateIpAddresses.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * PrivateIpAddresses [PrivateIpAddressStringList] <p>The secondary private IP addresses to unassign from the network interface. You can specify this option multiple times to unassign more than one IP address.</p>
-- Required key: NetworkInterfaceId
-- Required key: PrivateIpAddresses
-- @return UnassignPrivateIpAddressesRequest structure as a key-value pair table
function M.UnassignPrivateIpAddressesRequest(args)
	assert(args, "You must provdide an argument table when creating UnassignPrivateIpAddressesRequest")
	local t = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
	}
	asserts.AssertUnassignPrivateIpAddressesRequest(t)
	return t
end

keys.Filter = { ["Values"] = true, ["Name"] = true, nil }

function asserts.AssertFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Filter to be of type 'table'")
	if struct["Values"] then asserts.AssertValueStringList(struct["Values"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.Filter[k], "Filter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Filter
-- <p>A filter name and value pair that is used to return a more specific list of results. Filters can be used to match a set of resources by various criteria, such as tags, attributes, or IDs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [ValueStringList] <p>One or more filter values. Filter values are case-sensitive.</p>
-- * Name [String] <p>The name of the filter. Filter names are case-sensitive.</p>
-- @return Filter structure as a key-value pair table
function M.Filter(args)
	assert(args, "You must provdide an argument table when creating Filter")
	local t = { 
		["Values"] = args["Values"],
		["Name"] = args["Name"],
	}
	asserts.AssertFilter(t)
	return t
end

keys.TargetReservationValue = { ["TargetConfiguration"] = true, ["ReservationValue"] = true, nil }

function asserts.AssertTargetReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetReservationValue to be of type 'table'")
	if struct["TargetConfiguration"] then asserts.AssertTargetConfiguration(struct["TargetConfiguration"]) end
	if struct["ReservationValue"] then asserts.AssertReservationValue(struct["ReservationValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetReservationValue[k], "TargetReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetReservationValue
-- <p>The total value of the new Convertible Reserved Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetConfiguration [TargetConfiguration] <p>The configuration of the Convertible Reserved Instances that make up the exchange.</p>
-- * ReservationValue [ReservationValue] <p>The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of the list value, remaining upfront price, and additional upfront cost of the exchange.</p>
-- @return TargetReservationValue structure as a key-value pair table
function M.TargetReservationValue(args)
	assert(args, "You must provdide an argument table when creating TargetReservationValue")
	local t = { 
		["TargetConfiguration"] = args["TargetConfiguration"],
		["ReservationValue"] = args["ReservationValue"],
	}
	asserts.AssertTargetReservationValue(t)
	return t
end

keys.ModifyIdFormatRequest = { ["UseLongIds"] = true, ["Resource"] = true, nil }

function asserts.AssertModifyIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyIdFormatRequest to be of type 'table'")
	assert(struct["Resource"], "Expected key Resource to exist in table")
	assert(struct["UseLongIds"], "Expected key UseLongIds to exist in table")
	if struct["UseLongIds"] then asserts.AssertBoolean(struct["UseLongIds"]) end
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyIdFormatRequest[k], "ModifyIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyIdFormatRequest
-- <p>Contains the parameters of ModifyIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UseLongIds [Boolean] <p>Indicate whether the resource should use longer IDs (17-character IDs).</p>
-- * Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- Required key: Resource
-- Required key: UseLongIds
-- @return ModifyIdFormatRequest structure as a key-value pair table
function M.ModifyIdFormatRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyIdFormatRequest")
	local t = { 
		["UseLongIds"] = args["UseLongIds"],
		["Resource"] = args["Resource"],
	}
	asserts.AssertModifyIdFormatRequest(t)
	return t
end

keys.DescribeIdentityIdFormatResult = { ["Statuses"] = true, nil }

function asserts.AssertDescribeIdentityIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdentityIdFormatResult to be of type 'table'")
	if struct["Statuses"] then asserts.AssertIdFormatList(struct["Statuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdentityIdFormatResult[k], "DescribeIdentityIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdentityIdFormatResult
-- <p>Contains the output of DescribeIdentityIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Statuses [IdFormatList] <p>Information about the ID format for the resources.</p>
-- @return DescribeIdentityIdFormatResult structure as a key-value pair table
function M.DescribeIdentityIdFormatResult(args)
	assert(args, "You must provdide an argument table when creating DescribeIdentityIdFormatResult")
	local t = { 
		["Statuses"] = args["Statuses"],
	}
	asserts.AssertDescribeIdentityIdFormatResult(t)
	return t
end

keys.ImportVolumeResult = { ["ConversionTask"] = true, nil }

function asserts.AssertImportVolumeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeResult to be of type 'table'")
	if struct["ConversionTask"] then asserts.AssertConversionTask(struct["ConversionTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportVolumeResult[k], "ImportVolumeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeResult
-- <p>Contains the output for ImportVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTask [ConversionTask] <p>Information about the conversion task.</p>
-- @return ImportVolumeResult structure as a key-value pair table
function M.ImportVolumeResult(args)
	assert(args, "You must provdide an argument table when creating ImportVolumeResult")
	local t = { 
		["ConversionTask"] = args["ConversionTask"],
	}
	asserts.AssertImportVolumeResult(t)
	return t
end

keys.DescribeKeyPairsResult = { ["KeyPairs"] = true, nil }

function asserts.AssertDescribeKeyPairsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeKeyPairsResult to be of type 'table'")
	if struct["KeyPairs"] then asserts.AssertKeyPairList(struct["KeyPairs"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeKeyPairsResult[k], "DescribeKeyPairsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeKeyPairsResult
-- <p>Contains the output of DescribeKeyPairs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyPairs [KeyPairList] <p>Information about one or more key pairs.</p>
-- @return DescribeKeyPairsResult structure as a key-value pair table
function M.DescribeKeyPairsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeKeyPairsResult")
	local t = { 
		["KeyPairs"] = args["KeyPairs"],
	}
	asserts.AssertDescribeKeyPairsResult(t)
	return t
end

keys.VolumeAttachment = { ["AttachTime"] = true, ["InstanceId"] = true, ["VolumeId"] = true, ["State"] = true, ["DeleteOnTermination"] = true, ["Device"] = true, nil }

function asserts.AssertVolumeAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeAttachment to be of type 'table'")
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["State"] then asserts.AssertVolumeAttachmentState(struct["State"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["Device"] then asserts.AssertString(struct["Device"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeAttachment[k], "VolumeAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeAttachment
-- <p>Describes volume attachment details.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- * State [VolumeAttachmentState] <p>The attachment state of the volume.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- * Device [String] <p>The device name.</p>
-- @return VolumeAttachment structure as a key-value pair table
function M.VolumeAttachment(args)
	assert(args, "You must provdide an argument table when creating VolumeAttachment")
	local t = { 
		["AttachTime"] = args["AttachTime"],
		["InstanceId"] = args["InstanceId"],
		["VolumeId"] = args["VolumeId"],
		["State"] = args["State"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["Device"] = args["Device"],
	}
	asserts.AssertVolumeAttachment(t)
	return t
end

keys.DescribeReservedInstancesRequest = { ["OfferingType"] = true, ["OfferingClass"] = true, ["DryRun"] = true, ["ReservedInstancesIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeReservedInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesRequest to be of type 'table'")
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ReservedInstancesIds"] then asserts.AssertReservedInstancesIdStringList(struct["ReservedInstancesIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesRequest[k], "DescribeReservedInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesRequest
-- <p>Contains the parameters for DescribeReservedInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the <code>Medium Utilization</code> Reserved Instance offering type.</p>
-- * OfferingClass [OfferingClassType] <p>Describes whether the Reserved Instance is Standard or Convertible.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ReservedInstancesIds [ReservedInstancesIdStringList] <p>One or more Reserved Instance IDs.</p> <p>Default: Describes all your Reserved Instances, or only those otherwise specified.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be used.</p> </li> <li> <p> <code>duration</code> - The duration of the Reserved Instance (one year or three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p> </li> <li> <p> <code>end</code> - The time when the Reserved Instance expires (for example, 2015-08-07T11:54:42.000Z).</p> </li> <li> <p> <code>fixed-price</code> - The purchase price of the Reserved Instance (for example, 9800.0).</p> </li> <li> <p> <code>instance-type</code> - The instance type that is covered by the reservation.</p> </li> <li> <p> <code>scope</code> - The scope of the Reserved Instance (<code>Region</code> or <code>Availability Zone</code>).</p> </li> <li> <p> <code>product-description</code> - The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Windows</code> | <code>Windows (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> | <code>Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon VPC)</code>).</p> </li> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instance.</p> </li> <li> <p> <code>start</code> - The time at which the Reserved Instance purchase request was placed (for example, 2014-08-07T11:54:42.000Z).</p> </li> <li> <p> <code>state</code> - The state of the Reserved Instance (<code>payment-pending</code> | <code>active</code> | <code>payment-failed</code> | <code>retired</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for example, 0.84).</p> </li> </ul>
-- @return DescribeReservedInstancesRequest structure as a key-value pair table
function M.DescribeReservedInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeReservedInstancesRequest")
	local t = { 
		["OfferingType"] = args["OfferingType"],
		["OfferingClass"] = args["OfferingClass"],
		["DryRun"] = args["DryRun"],
		["ReservedInstancesIds"] = args["ReservedInstancesIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeReservedInstancesRequest(t)
	return t
end

keys.CreateCustomerGatewayRequest = { ["PublicIp"] = true, ["BgpAsn"] = true, ["DryRun"] = true, ["Type"] = true, nil }

function asserts.AssertCreateCustomerGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCustomerGatewayRequest to be of type 'table'")
	assert(struct["BgpAsn"], "Expected key BgpAsn to exist in table")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["BgpAsn"] then asserts.AssertInteger(struct["BgpAsn"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCustomerGatewayRequest[k], "CreateCustomerGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCustomerGatewayRequest
-- <p>Contains the parameters for CreateCustomerGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Internet-routable IP address for the customer gateway's outside interface. The address must be static.</p>
-- * BgpAsn [Integer] <p>For devices that support BGP, the customer gateway's BGP ASN.</p> <p>Default: 65000</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Type [GatewayType] <p>The type of VPN connection that this customer gateway supports (<code>ipsec.1</code>).</p>
-- Required key: BgpAsn
-- Required key: PublicIp
-- Required key: Type
-- @return CreateCustomerGatewayRequest structure as a key-value pair table
function M.CreateCustomerGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating CreateCustomerGatewayRequest")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["BgpAsn"] = args["BgpAsn"],
		["DryRun"] = args["DryRun"],
		["Type"] = args["Type"],
	}
	asserts.AssertCreateCustomerGatewayRequest(t)
	return t
end

keys.DeleteSecurityGroupRequest = { ["GroupName"] = true, ["DryRun"] = true, ["GroupId"] = true, nil }

function asserts.AssertDeleteSecurityGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSecurityGroupRequest to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSecurityGroupRequest[k], "DeleteSecurityGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSecurityGroupRequest
-- <p>Contains the parameters for DeleteSecurityGroup.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group. You can specify either the security group name or the security group ID.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupId [String] <p>The ID of the security group. Required for a nondefault VPC.</p>
-- @return DeleteSecurityGroupRequest structure as a key-value pair table
function M.DeleteSecurityGroupRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteSecurityGroupRequest")
	local t = { 
		["GroupName"] = args["GroupName"],
		["DryRun"] = args["DryRun"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertDeleteSecurityGroupRequest(t)
	return t
end

keys.NatGatewayAddress = { ["PublicIp"] = true, ["NetworkInterfaceId"] = true, ["AllocationId"] = true, ["PrivateIp"] = true, nil }

function asserts.AssertNatGatewayAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NatGatewayAddress to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PrivateIp"] then asserts.AssertString(struct["PrivateIp"]) end
	for k,_ in pairs(struct) do
		assert(keys.NatGatewayAddress[k], "NatGatewayAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NatGatewayAddress
-- <p>Describes the IP addresses and network interface associated with a NAT gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address associated with the NAT gateway.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface associated with the NAT gateway.</p>
-- * AllocationId [String] <p>The allocation ID of the Elastic IP address that's associated with the NAT gateway.</p>
-- * PrivateIp [String] <p>The private IP address associated with the Elastic IP address.</p>
-- @return NatGatewayAddress structure as a key-value pair table
function M.NatGatewayAddress(args)
	assert(args, "You must provdide an argument table when creating NatGatewayAddress")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AllocationId"] = args["AllocationId"],
		["PrivateIp"] = args["PrivateIp"],
	}
	asserts.AssertNatGatewayAddress(t)
	return t
end

keys.DescribeSnapshotAttributeResult = { ["ProductCodes"] = true, ["CreateVolumePermissions"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertDescribeSnapshotAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotAttributeResult to be of type 'table'")
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["CreateVolumePermissions"] then asserts.AssertCreateVolumePermissionList(struct["CreateVolumePermissions"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotAttributeResult[k], "DescribeSnapshotAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotAttributeResult
-- <p>Contains the output of DescribeSnapshotAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- * CreateVolumePermissions [CreateVolumePermissionList] <p>A list of permissions for creating volumes from the snapshot.</p>
-- * SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- @return DescribeSnapshotAttributeResult structure as a key-value pair table
function M.DescribeSnapshotAttributeResult(args)
	assert(args, "You must provdide an argument table when creating DescribeSnapshotAttributeResult")
	local t = { 
		["ProductCodes"] = args["ProductCodes"],
		["CreateVolumePermissions"] = args["CreateVolumePermissions"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertDescribeSnapshotAttributeResult(t)
	return t
end

keys.ActiveInstance = { ["InstanceId"] = true, ["InstanceHealth"] = true, ["InstanceType"] = true, ["SpotInstanceRequestId"] = true, nil }

function asserts.AssertActiveInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ActiveInstance to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["InstanceHealth"] then asserts.AssertInstanceHealthStatus(struct["InstanceHealth"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ActiveInstance[k], "ActiveInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ActiveInstance
-- <p>Describes a running instance in a Spot fleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * InstanceHealth [InstanceHealthStatus] <p>The health status of the instance. If the status of either the instance status check or the system status check is <code>impaired</code>, the health status of the instance is <code>unhealthy</code>. Otherwise, the health status is <code>healthy</code>.</p>
-- * InstanceType [String] <p>The instance type.</p>
-- * SpotInstanceRequestId [String] <p>The ID of the Spot instance request.</p>
-- @return ActiveInstance structure as a key-value pair table
function M.ActiveInstance(args)
	assert(args, "You must provdide an argument table when creating ActiveInstance")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["InstanceHealth"] = args["InstanceHealth"],
		["InstanceType"] = args["InstanceType"],
		["SpotInstanceRequestId"] = args["SpotInstanceRequestId"],
	}
	asserts.AssertActiveInstance(t)
	return t
end

keys.ModifyVolumeRequest = { ["VolumeType"] = true, ["Iops"] = true, ["DryRun"] = true, ["VolumeId"] = true, ["Size"] = true, nil }

function asserts.AssertModifyVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["Size"] then asserts.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVolumeRequest[k], "ModifyVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeType [VolumeType] <p>Target EBS volume type of the volume to be modified</p> <p> The API does not support modifications for volume type <code>standard</code>. You also cannot change the type of a volume to <code>standard</code>. </p> <p>Default: If no type is specified, the existing type is retained. </p>
-- * Iops [Integer] <p>Target IOPS rate of the volume to be modified.</p> <p>Only valid for Provisioned IOPS SSD (<code>io1</code>) volumes. For more information about <code>io1</code> IOPS configuration, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops">http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops</a>.</p> <p>Default: If no IOPS value is specified, the existing value is retained. </p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] 
-- * Size [Integer] <p>Target size in GiB of the volume to be modified. Target volume size must be greater than or equal to than the existing size of the volume. For information about available EBS volume sizes, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html</a>.</p> <p>Default: If no size is specified, the existing size is retained. </p>
-- Required key: VolumeId
-- @return ModifyVolumeRequest structure as a key-value pair table
function M.ModifyVolumeRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyVolumeRequest")
	local t = { 
		["VolumeType"] = args["VolumeType"],
		["Iops"] = args["Iops"],
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
		["Size"] = args["Size"],
	}
	asserts.AssertModifyVolumeRequest(t)
	return t
end

keys.RevokeSecurityGroupIngressRequest = { ["DryRun"] = true, ["GroupName"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertRevokeSecurityGroupIngressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RevokeSecurityGroupIngressRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RevokeSecurityGroupIngressRequest[k], "RevokeSecurityGroupIngressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RevokeSecurityGroupIngressRequest
-- <p>Contains the parameters for RevokeSecurityGroupIngress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group.</p>
-- * CidrIp [String] <p>The CIDR IP address range. You can't specify this parameter when specifying a source security group.</p>
-- * IpPermissions [IpPermissionList] <p>A set of IP permissions. You can't specify a source security group and a CIDR IP address range.</p>
-- * FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. For the ICMP type number, use <code>-1</code> to specify all ICMP types.</p>
-- * SourceSecurityGroupOwnerId [String] <p>[EC2-Classic] The AWS account ID of the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
-- * SourceSecurityGroupName [String] <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. For EC2-VPC, the source security group must be in the same VPC. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
-- * ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP code number. For the ICMP code number, use <code>-1</code> to specify all ICMP codes for the ICMP type.</p>
-- * IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). Use <code>-1</code> to specify all.</p>
-- * GroupId [String] <p>The ID of the security group. Required for a security group in a nondefault VPC.</p>
-- @return RevokeSecurityGroupIngressRequest structure as a key-value pair table
function M.RevokeSecurityGroupIngressRequest(args)
	assert(args, "You must provdide an argument table when creating RevokeSecurityGroupIngressRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["GroupName"] = args["GroupName"],
		["CidrIp"] = args["CidrIp"],
		["IpPermissions"] = args["IpPermissions"],
		["FromPort"] = args["FromPort"],
		["SourceSecurityGroupOwnerId"] = args["SourceSecurityGroupOwnerId"],
		["SourceSecurityGroupName"] = args["SourceSecurityGroupName"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertRevokeSecurityGroupIngressRequest(t)
	return t
end

keys.CreateSpotDatafeedSubscriptionResult = { ["SpotDatafeedSubscription"] = true, nil }

function asserts.AssertCreateSpotDatafeedSubscriptionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSpotDatafeedSubscriptionResult to be of type 'table'")
	if struct["SpotDatafeedSubscription"] then asserts.AssertSpotDatafeedSubscription(struct["SpotDatafeedSubscription"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSpotDatafeedSubscriptionResult[k], "CreateSpotDatafeedSubscriptionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSpotDatafeedSubscriptionResult
-- <p>Contains the output of CreateSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotDatafeedSubscription [SpotDatafeedSubscription] <p>The Spot instance data feed subscription.</p>
-- @return CreateSpotDatafeedSubscriptionResult structure as a key-value pair table
function M.CreateSpotDatafeedSubscriptionResult(args)
	assert(args, "You must provdide an argument table when creating CreateSpotDatafeedSubscriptionResult")
	local t = { 
		["SpotDatafeedSubscription"] = args["SpotDatafeedSubscription"],
	}
	asserts.AssertCreateSpotDatafeedSubscriptionResult(t)
	return t
end

keys.DescribeClassicLinkInstancesRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["InstanceIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeClassicLinkInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeClassicLinkInstancesRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeClassicLinkInstancesRequest[k], "DescribeClassicLinkInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeClassicLinkInstancesRequest
-- <p>Contains the parameters for DescribeClassicLinkInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the instance IDs parameter in the same request.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs. Must be instances linked to a VPC through ClassicLink.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>group-id</code> - The ID of a VPC security group that's associated with the instance.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC that the instance is linked to.</p> </li> </ul>
-- @return DescribeClassicLinkInstancesRequest structure as a key-value pair table
function M.DescribeClassicLinkInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeClassicLinkInstancesRequest")
	local t = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeClassicLinkInstancesRequest(t)
	return t
end

keys.DescribeReservedInstancesOfferingsRequest = { ["MaxInstanceCount"] = true, ["OfferingType"] = true, ["AvailabilityZone"] = true, ["DryRun"] = true, ["ProductDescription"] = true, ["IncludeMarketplace"] = true, ["ReservedInstancesOfferingIds"] = true, ["MaxResults"] = true, ["InstanceType"] = true, ["OfferingClass"] = true, ["Filters"] = true, ["MinDuration"] = true, ["InstanceTenancy"] = true, ["NextToken"] = true, ["MaxDuration"] = true, nil }

function asserts.AssertDescribeReservedInstancesOfferingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesOfferingsRequest to be of type 'table'")
	if struct["MaxInstanceCount"] then asserts.AssertInteger(struct["MaxInstanceCount"]) end
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["IncludeMarketplace"] then asserts.AssertBoolean(struct["IncludeMarketplace"]) end
	if struct["ReservedInstancesOfferingIds"] then asserts.AssertReservedInstancesOfferingIdStringList(struct["ReservedInstancesOfferingIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MinDuration"] then asserts.AssertLong(struct["MinDuration"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxDuration"] then asserts.AssertLong(struct["MaxDuration"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesOfferingsRequest[k], "DescribeReservedInstancesOfferingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesOfferingsRequest
-- <p>Contains the parameters for DescribeReservedInstancesOfferings.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxInstanceCount [Integer] <p>The maximum number of instances to filter when searching for offerings.</p> <p>Default: 20</p>
-- * OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the <code>Medium Utilization</code> Reserved Instance offering type. </p>
-- * AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the description are for use with Amazon VPC.</p>
-- * IncludeMarketplace [Boolean] <p>Include Reserved Instance Marketplace offerings in the response.</p>
-- * ReservedInstancesOfferingIds [ReservedInstancesOfferingIdStringList] <p>One or more Reserved Instances offering IDs.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. The maximum is 100.</p> <p>Default: 100</p>
-- * InstanceType [InstanceType] <p>The instance type that the reservation will cover (for example, <code>m1.small</code>). For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * OfferingClass [OfferingClassType] <p>The offering class of the Reserved Instance. Can be <code>standard</code> or <code>convertible</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be used.</p> </li> <li> <p> <code>duration</code> - The duration of the Reserved Instance (for example, one year or three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p> </li> <li> <p> <code>fixed-price</code> - The purchase price of the Reserved Instance (for example, 9800.0).</p> </li> <li> <p> <code>instance-type</code> - The instance type that is covered by the reservation.</p> </li> <li> <p> <code>marketplace</code> - Set to <code>true</code> to show only Reserved Instance Marketplace offerings. When this filter is not used, which is the default behavior, all offerings from both AWS and the Reserved Instance Marketplace are listed.</p> </li> <li> <p> <code>product-description</code> - The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC. (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Windows</code> | <code>Windows (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> | <code> Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon VPC)</code>) </p> </li> <li> <p> <code>reserved-instances-offering-id</code> - The Reserved Instances offering ID.</p> </li> <li> <p> <code>scope</code> - The scope of the Reserved Instance (<code>Availability Zone</code> or <code>Region</code>).</p> </li> <li> <p> <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for example, 0.84).</p> </li> </ul>
-- * MinDuration [Long] <p>The minimum duration (in seconds) to filter when searching for offerings.</p> <p>Default: 2592000 (1 month)</p>
-- * InstanceTenancy [Tenancy] <p>The tenancy of the instances covered by the reservation. A Reserved Instance with a tenancy of <code>dedicated</code> is applied to instances that run in a VPC on single-tenant hardware (i.e., Dedicated Instances).</p> <p> <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p> <p>Default: <code>default</code> </p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * MaxDuration [Long] <p>The maximum duration (in seconds) to filter when searching for offerings.</p> <p>Default: 94608000 (3 years)</p>
-- @return DescribeReservedInstancesOfferingsRequest structure as a key-value pair table
function M.DescribeReservedInstancesOfferingsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeReservedInstancesOfferingsRequest")
	local t = { 
		["MaxInstanceCount"] = args["MaxInstanceCount"],
		["OfferingType"] = args["OfferingType"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["DryRun"] = args["DryRun"],
		["ProductDescription"] = args["ProductDescription"],
		["IncludeMarketplace"] = args["IncludeMarketplace"],
		["ReservedInstancesOfferingIds"] = args["ReservedInstancesOfferingIds"],
		["MaxResults"] = args["MaxResults"],
		["InstanceType"] = args["InstanceType"],
		["OfferingClass"] = args["OfferingClass"],
		["Filters"] = args["Filters"],
		["MinDuration"] = args["MinDuration"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["NextToken"] = args["NextToken"],
		["MaxDuration"] = args["MaxDuration"],
	}
	asserts.AssertDescribeReservedInstancesOfferingsRequest(t)
	return t
end

keys.GetReservedInstancesExchangeQuoteResult = { ["CurrencyCode"] = true, ["ReservedInstanceValueSet"] = true, ["PaymentDue"] = true, ["TargetConfigurationValueSet"] = true, ["IsValidExchange"] = true, ["ValidationFailureReason"] = true, ["OutputReservedInstancesWillExpireAt"] = true, ["ReservedInstanceValueRollup"] = true, ["TargetConfigurationValueRollup"] = true, nil }

function asserts.AssertGetReservedInstancesExchangeQuoteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetReservedInstancesExchangeQuoteResult to be of type 'table'")
	if struct["CurrencyCode"] then asserts.AssertString(struct["CurrencyCode"]) end
	if struct["ReservedInstanceValueSet"] then asserts.AssertReservedInstanceReservationValueSet(struct["ReservedInstanceValueSet"]) end
	if struct["PaymentDue"] then asserts.AssertString(struct["PaymentDue"]) end
	if struct["TargetConfigurationValueSet"] then asserts.AssertTargetReservationValueSet(struct["TargetConfigurationValueSet"]) end
	if struct["IsValidExchange"] then asserts.AssertBoolean(struct["IsValidExchange"]) end
	if struct["ValidationFailureReason"] then asserts.AssertString(struct["ValidationFailureReason"]) end
	if struct["OutputReservedInstancesWillExpireAt"] then asserts.AssertDateTime(struct["OutputReservedInstancesWillExpireAt"]) end
	if struct["ReservedInstanceValueRollup"] then asserts.AssertReservationValue(struct["ReservedInstanceValueRollup"]) end
	if struct["TargetConfigurationValueRollup"] then asserts.AssertReservationValue(struct["TargetConfigurationValueRollup"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetReservedInstancesExchangeQuoteResult[k], "GetReservedInstancesExchangeQuoteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetReservedInstancesExchangeQuoteResult
-- <p>Contains the output of GetReservedInstancesExchangeQuote.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CurrencyCode [String] <p>The currency of the transaction.</p>
-- * ReservedInstanceValueSet [ReservedInstanceReservationValueSet] <p>The configuration of your Convertible Reserved Instances.</p>
-- * PaymentDue [String] <p>The total true upfront charge for the exchange.</p>
-- * TargetConfigurationValueSet [TargetReservationValueSet] <p>The values of the target Convertible Reserved Instances.</p>
-- * IsValidExchange [Boolean] <p>If <code>true</code>, the exchange is valid. If <code>false</code>, the exchange cannot be completed.</p>
-- * ValidationFailureReason [String] <p>Describes the reason why the exchange cannot be completed.</p>
-- * OutputReservedInstancesWillExpireAt [DateTime] <p>The new end date of the reservation term.</p>
-- * ReservedInstanceValueRollup [ReservationValue] <p>The cost associated with the Reserved Instance.</p>
-- * TargetConfigurationValueRollup [ReservationValue] <p>The cost associated with the Reserved Instance.</p>
-- @return GetReservedInstancesExchangeQuoteResult structure as a key-value pair table
function M.GetReservedInstancesExchangeQuoteResult(args)
	assert(args, "You must provdide an argument table when creating GetReservedInstancesExchangeQuoteResult")
	local t = { 
		["CurrencyCode"] = args["CurrencyCode"],
		["ReservedInstanceValueSet"] = args["ReservedInstanceValueSet"],
		["PaymentDue"] = args["PaymentDue"],
		["TargetConfigurationValueSet"] = args["TargetConfigurationValueSet"],
		["IsValidExchange"] = args["IsValidExchange"],
		["ValidationFailureReason"] = args["ValidationFailureReason"],
		["OutputReservedInstancesWillExpireAt"] = args["OutputReservedInstancesWillExpireAt"],
		["ReservedInstanceValueRollup"] = args["ReservedInstanceValueRollup"],
		["TargetConfigurationValueRollup"] = args["TargetConfigurationValueRollup"],
	}
	asserts.AssertGetReservedInstancesExchangeQuoteResult(t)
	return t
end

keys.CreateImageResult = { ["ImageId"] = true, nil }

function asserts.AssertCreateImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateImageResult to be of type 'table'")
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateImageResult[k], "CreateImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateImageResult
-- <p>Contains the output of CreateImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ImageId [String] <p>The ID of the new AMI.</p>
-- @return CreateImageResult structure as a key-value pair table
function M.CreateImageResult(args)
	assert(args, "You must provdide an argument table when creating CreateImageResult")
	local t = { 
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertCreateImageResult(t)
	return t
end

keys.DhcpOptions = { ["Tags"] = true, ["DhcpConfigurations"] = true, ["DhcpOptionsId"] = true, nil }

function asserts.AssertDhcpOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DhcpOptions to be of type 'table'")
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["DhcpConfigurations"] then asserts.AssertDhcpConfigurationList(struct["DhcpConfigurations"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DhcpOptions[k], "DhcpOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DhcpOptions
-- <p>Describes a set of DHCP options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Tags [TagList] <p>Any tags assigned to the DHCP options set.</p>
-- * DhcpConfigurations [DhcpConfigurationList] <p>One or more DHCP options in the set.</p>
-- * DhcpOptionsId [String] <p>The ID of the set of DHCP options.</p>
-- @return DhcpOptions structure as a key-value pair table
function M.DhcpOptions(args)
	assert(args, "You must provdide an argument table when creating DhcpOptions")
	local t = { 
		["Tags"] = args["Tags"],
		["DhcpConfigurations"] = args["DhcpConfigurations"],
		["DhcpOptionsId"] = args["DhcpOptionsId"],
	}
	asserts.AssertDhcpOptions(t)
	return t
end

keys.ReservedInstances = { ["ReservedInstancesId"] = true, ["OfferingType"] = true, ["AvailabilityZone"] = true, ["End"] = true, ["ProductDescription"] = true, ["Tags"] = true, ["Scope"] = true, ["UsagePrice"] = true, ["RecurringCharges"] = true, ["OfferingClass"] = true, ["Start"] = true, ["State"] = true, ["FixedPrice"] = true, ["CurrencyCode"] = true, ["Duration"] = true, ["InstanceTenancy"] = true, ["InstanceType"] = true, ["InstanceCount"] = true, nil }

function asserts.AssertReservedInstances(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstances to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["End"] then asserts.AssertDateTime(struct["End"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Scope"] then asserts.Assertscope(struct["Scope"]) end
	if struct["UsagePrice"] then asserts.AssertFloat(struct["UsagePrice"]) end
	if struct["RecurringCharges"] then asserts.AssertRecurringChargesList(struct["RecurringCharges"]) end
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Start"] then asserts.AssertDateTime(struct["Start"]) end
	if struct["State"] then asserts.AssertReservedInstanceState(struct["State"]) end
	if struct["FixedPrice"] then asserts.AssertFloat(struct["FixedPrice"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Duration"] then asserts.AssertLong(struct["Duration"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstances[k], "ReservedInstances contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstances
-- <p>Describes a Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- * OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type.</p>
-- * AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- * End [DateTime] <p>The time when the Reserved Instance expires.</p>
-- * ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description.</p>
-- * Tags [TagList] <p>Any tags assigned to the resource.</p>
-- * Scope [scope] <p>The scope of the Reserved Instance.</p>
-- * UsagePrice [Float] <p>The usage price of the Reserved Instance, per hour.</p>
-- * RecurringCharges [RecurringChargesList] <p>The recurring charge tag assigned to the resource.</p>
-- * OfferingClass [OfferingClassType] <p>The offering class of the Reserved Instance.</p>
-- * Start [DateTime] <p>The date and time the Reserved Instance started.</p>
-- * State [ReservedInstanceState] <p>The state of the Reserved Instance purchase.</p>
-- * FixedPrice [Float] <p>The purchase price of the Reserved Instance.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>
-- * Duration [Long] <p>The duration of the Reserved Instance, in seconds.</p>
-- * InstanceTenancy [Tenancy] <p>The tenancy of the instance.</p>
-- * InstanceType [InstanceType] <p>The instance type on which the Reserved Instance can be used.</p>
-- * InstanceCount [Integer] <p>The number of reservations purchased.</p>
-- @return ReservedInstances structure as a key-value pair table
function M.ReservedInstances(args)
	assert(args, "You must provdide an argument table when creating ReservedInstances")
	local t = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["OfferingType"] = args["OfferingType"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["End"] = args["End"],
		["ProductDescription"] = args["ProductDescription"],
		["Tags"] = args["Tags"],
		["Scope"] = args["Scope"],
		["UsagePrice"] = args["UsagePrice"],
		["RecurringCharges"] = args["RecurringCharges"],
		["OfferingClass"] = args["OfferingClass"],
		["Start"] = args["Start"],
		["State"] = args["State"],
		["FixedPrice"] = args["FixedPrice"],
		["CurrencyCode"] = args["CurrencyCode"],
		["Duration"] = args["Duration"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["InstanceType"] = args["InstanceType"],
		["InstanceCount"] = args["InstanceCount"],
	}
	asserts.AssertReservedInstances(t)
	return t
end

keys.DescribeCustomerGatewaysResult = { ["CustomerGateways"] = true, nil }

function asserts.AssertDescribeCustomerGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCustomerGatewaysResult to be of type 'table'")
	if struct["CustomerGateways"] then asserts.AssertCustomerGatewayList(struct["CustomerGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCustomerGatewaysResult[k], "DescribeCustomerGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCustomerGatewaysResult
-- <p>Contains the output of DescribeCustomerGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGateways [CustomerGatewayList] <p>Information about one or more customer gateways.</p>
-- @return DescribeCustomerGatewaysResult structure as a key-value pair table
function M.DescribeCustomerGatewaysResult(args)
	assert(args, "You must provdide an argument table when creating DescribeCustomerGatewaysResult")
	local t = { 
		["CustomerGateways"] = args["CustomerGateways"],
	}
	asserts.AssertDescribeCustomerGatewaysResult(t)
	return t
end

keys.AvailabilityZoneMessage = { ["Message"] = true, nil }

function asserts.AssertAvailabilityZoneMessage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailabilityZoneMessage to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	for k,_ in pairs(struct) do
		assert(keys.AvailabilityZoneMessage[k], "AvailabilityZoneMessage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailabilityZoneMessage
-- <p>Describes a message about an Availability Zone.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The message about the Availability Zone.</p>
-- @return AvailabilityZoneMessage structure as a key-value pair table
function M.AvailabilityZoneMessage(args)
	assert(args, "You must provdide an argument table when creating AvailabilityZoneMessage")
	local t = { 
		["Message"] = args["Message"],
	}
	asserts.AssertAvailabilityZoneMessage(t)
	return t
end

keys.GetConsoleScreenshotResult = { ["InstanceId"] = true, ["ImageData"] = true, nil }

function asserts.AssertGetConsoleScreenshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleScreenshotResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["ImageData"] then asserts.AssertString(struct["ImageData"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleScreenshotResult[k], "GetConsoleScreenshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleScreenshotResult
-- <p>Contains the output of the request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * ImageData [String] <p>The data that comprises the image.</p>
-- @return GetConsoleScreenshotResult structure as a key-value pair table
function M.GetConsoleScreenshotResult(args)
	assert(args, "You must provdide an argument table when creating GetConsoleScreenshotResult")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["ImageData"] = args["ImageData"],
	}
	asserts.AssertGetConsoleScreenshotResult(t)
	return t
end

keys.DescribeVpcPeeringConnectionsRequest = { ["VpcPeeringConnectionIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpcPeeringConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcPeeringConnectionsRequest to be of type 'table'")
	if struct["VpcPeeringConnectionIds"] then asserts.AssertValueStringList(struct["VpcPeeringConnectionIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcPeeringConnectionsRequest[k], "DescribeVpcPeeringConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcPeeringConnectionsRequest
-- <p>Contains the parameters for DescribeVpcPeeringConnections.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcPeeringConnectionIds [ValueStringList] <p>One or more VPC peering connection IDs.</p> <p>Default: Describes all your VPC peering connections.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>accepter-vpc-info.cidr-block</code> - The IPv4 CIDR block of the peer VPC.</p> </li> <li> <p> <code>accepter-vpc-info.owner-id</code> - The AWS account ID of the owner of the peer VPC.</p> </li> <li> <p> <code>accepter-vpc-info.vpc-id</code> - The ID of the peer VPC.</p> </li> <li> <p> <code>expiration-time</code> - The expiration date and time for the VPC peering connection.</p> </li> <li> <p> <code>requester-vpc-info.cidr-block</code> - The IPv4 CIDR block of the requester's VPC.</p> </li> <li> <p> <code>requester-vpc-info.owner-id</code> - The AWS account ID of the owner of the requester VPC.</p> </li> <li> <p> <code>requester-vpc-info.vpc-id</code> - The ID of the requester VPC.</p> </li> <li> <p> <code>status-code</code> - The status of the VPC peering connection (<code>pending-acceptance</code> | <code>failed</code> | <code>expired</code> | <code>provisioning</code> | <code>active</code> | <code>deleted</code> | <code>rejected</code>).</p> </li> <li> <p> <code>status-message</code> - A message that provides more information about the status of the VPC peering connection, if applicable.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-peering-connection-id</code> - The ID of the VPC peering connection.</p> </li> </ul>
-- @return DescribeVpcPeeringConnectionsRequest structure as a key-value pair table
function M.DescribeVpcPeeringConnectionsRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcPeeringConnectionsRequest")
	local t = { 
		["VpcPeeringConnectionIds"] = args["VpcPeeringConnectionIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpcPeeringConnectionsRequest(t)
	return t
end

keys.AuthorizeSecurityGroupEgressRequest = { ["DryRun"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertAuthorizeSecurityGroupEgressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizeSecurityGroupEgressRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthorizeSecurityGroupEgressRequest[k], "AuthorizeSecurityGroupEgressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizeSecurityGroupEgressRequest
-- <p>Contains the parameters for AuthorizeSecurityGroupEgress.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * CidrIp [String] <p>The CIDR IPv4 address range. We recommend that you specify the CIDR range in a set of IP permissions instead.</p>
-- * IpPermissions [IpPermissionList] <p>A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.</p>
-- * FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- * SourceSecurityGroupOwnerId [String] <p>The AWS account number for a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- * SourceSecurityGroupName [String] <p>The name of a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- * ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- * IpProtocol [String] <p>The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- Required key: GroupId
-- @return AuthorizeSecurityGroupEgressRequest structure as a key-value pair table
function M.AuthorizeSecurityGroupEgressRequest(args)
	assert(args, "You must provdide an argument table when creating AuthorizeSecurityGroupEgressRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["CidrIp"] = args["CidrIp"],
		["IpPermissions"] = args["IpPermissions"],
		["FromPort"] = args["FromPort"],
		["SourceSecurityGroupOwnerId"] = args["SourceSecurityGroupOwnerId"],
		["SourceSecurityGroupName"] = args["SourceSecurityGroupName"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertAuthorizeSecurityGroupEgressRequest(t)
	return t
end

keys.DeleteCustomerGatewayRequest = { ["CustomerGatewayId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteCustomerGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteCustomerGatewayRequest to be of type 'table'")
	assert(struct["CustomerGatewayId"], "Expected key CustomerGatewayId to exist in table")
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteCustomerGatewayRequest[k], "DeleteCustomerGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteCustomerGatewayRequest
-- <p>Contains the parameters for DeleteCustomerGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: CustomerGatewayId
-- @return DeleteCustomerGatewayRequest structure as a key-value pair table
function M.DeleteCustomerGatewayRequest(args)
	assert(args, "You must provdide an argument table when creating DeleteCustomerGatewayRequest")
	local t = { 
		["CustomerGatewayId"] = args["CustomerGatewayId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteCustomerGatewayRequest(t)
	return t
end

keys.CreateReservedInstancesListingRequest = { ["ReservedInstancesId"] = true, ["PriceSchedules"] = true, ["InstanceCount"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateReservedInstancesListingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateReservedInstancesListingRequest to be of type 'table'")
	assert(struct["ClientToken"], "Expected key ClientToken to exist in table")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["PriceSchedules"], "Expected key PriceSchedules to exist in table")
	assert(struct["ReservedInstancesId"], "Expected key ReservedInstancesId to exist in table")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["PriceSchedules"] then asserts.AssertPriceScheduleSpecificationList(struct["PriceSchedules"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateReservedInstancesListingRequest[k], "CreateReservedInstancesListingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateReservedInstancesListingRequest
-- <p>Contains the parameters for CreateReservedInstancesListing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID of the active Standard Reserved Instance.</p>
-- * PriceSchedules [PriceScheduleSpecificationList] <p>A list specifying the price of the Standard Reserved Instance for each month remaining in the Reserved Instance term.</p>
-- * InstanceCount [Integer] <p>The number of instances that are a part of a Reserved Instance account to be listed in the Reserved Instance Marketplace. This number should be less than or equal to the instance count associated with the Reserved Instance ID specified in this call.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: ClientToken
-- Required key: InstanceCount
-- Required key: PriceSchedules
-- Required key: ReservedInstancesId
-- @return CreateReservedInstancesListingRequest structure as a key-value pair table
function M.CreateReservedInstancesListingRequest(args)
	assert(args, "You must provdide an argument table when creating CreateReservedInstancesListingRequest")
	local t = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["PriceSchedules"] = args["PriceSchedules"],
		["InstanceCount"] = args["InstanceCount"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateReservedInstancesListingRequest(t)
	return t
end

keys.NetworkInterfaceAssociation = { ["PublicIp"] = true, ["AssociationId"] = true, ["PublicDnsName"] = true, ["AllocationId"] = true, ["IpOwnerId"] = true, nil }

function asserts.AssertNetworkInterfaceAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAssociation to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["PublicDnsName"] then asserts.AssertString(struct["PublicDnsName"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["IpOwnerId"] then asserts.AssertString(struct["IpOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceAssociation[k], "NetworkInterfaceAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAssociation
-- <p>Describes association information for an Elastic IP address (IPv4 only).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The address of the Elastic IP address bound to the network interface.</p>
-- * AssociationId [String] <p>The association ID.</p>
-- * PublicDnsName [String] <p>The public DNS name.</p>
-- * AllocationId [String] <p>The allocation ID.</p>
-- * IpOwnerId [String] <p>The ID of the Elastic IP address owner.</p>
-- @return NetworkInterfaceAssociation structure as a key-value pair table
function M.NetworkInterfaceAssociation(args)
	assert(args, "You must provdide an argument table when creating NetworkInterfaceAssociation")
	local t = { 
		["PublicIp"] = args["PublicIp"],
		["AssociationId"] = args["AssociationId"],
		["PublicDnsName"] = args["PublicDnsName"],
		["AllocationId"] = args["AllocationId"],
		["IpOwnerId"] = args["IpOwnerId"],
	}
	asserts.AssertNetworkInterfaceAssociation(t)
	return t
end

keys.ReservedInstancesOffering = { ["OfferingClass"] = true, ["Marketplace"] = true, ["ProductDescription"] = true, ["CurrencyCode"] = true, ["PricingDetails"] = true, ["UsagePrice"] = true, ["RecurringCharges"] = true, ["OfferingType"] = true, ["AvailabilityZone"] = true, ["FixedPrice"] = true, ["Scope"] = true, ["Duration"] = true, ["InstanceTenancy"] = true, ["ReservedInstancesOfferingId"] = true, ["InstanceType"] = true, nil }

function asserts.AssertReservedInstancesOffering(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesOffering to be of type 'table'")
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Marketplace"] then asserts.AssertBoolean(struct["Marketplace"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["PricingDetails"] then asserts.AssertPricingDetailsList(struct["PricingDetails"]) end
	if struct["UsagePrice"] then asserts.AssertFloat(struct["UsagePrice"]) end
	if struct["RecurringCharges"] then asserts.AssertRecurringChargesList(struct["RecurringCharges"]) end
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["FixedPrice"] then asserts.AssertFloat(struct["FixedPrice"]) end
	if struct["Scope"] then asserts.Assertscope(struct["Scope"]) end
	if struct["Duration"] then asserts.AssertLong(struct["Duration"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["ReservedInstancesOfferingId"] then asserts.AssertString(struct["ReservedInstancesOfferingId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesOffering[k], "ReservedInstancesOffering contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesOffering
-- <p>Describes a Reserved Instance offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OfferingClass [OfferingClassType] <p>If <code>convertible</code> it can be exchanged for Reserved Instances of the same or higher monetary value, with different configurations. If <code>standard</code>, it is not possible to perform an exchange.</p>
-- * Marketplace [Boolean] <p>Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or AWS. If it's a Reserved Instance Marketplace offering, this is <code>true</code>.</p>
-- * ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency of the Reserved Instance offering you are purchasing. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>
-- * PricingDetails [PricingDetailsList] <p>The pricing details of the Reserved Instance offering.</p>
-- * UsagePrice [Float] <p>The usage price of the Reserved Instance, per hour.</p>
-- * RecurringCharges [RecurringChargesList] <p>The recurring charge tag assigned to the resource.</p>
-- * OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type.</p>
-- * AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- * FixedPrice [Float] <p>The purchase price of the Reserved Instance.</p>
-- * Scope [scope] <p>Whether the Reserved Instance is applied to instances in a region or an Availability Zone.</p>
-- * Duration [Long] <p>The duration of the Reserved Instance, in seconds.</p>
-- * InstanceTenancy [Tenancy] <p>The tenancy of the instance.</p>
-- * ReservedInstancesOfferingId [String] <p>The ID of the Reserved Instance offering. This is the offering ID used in <a>GetReservedInstancesExchangeQuote</a> to confirm that an exchange can be made.</p>
-- * InstanceType [InstanceType] <p>The instance type on which the Reserved Instance can be used.</p>
-- @return ReservedInstancesOffering structure as a key-value pair table
function M.ReservedInstancesOffering(args)
	assert(args, "You must provdide an argument table when creating ReservedInstancesOffering")
	local t = { 
		["OfferingClass"] = args["OfferingClass"],
		["Marketplace"] = args["Marketplace"],
		["ProductDescription"] = args["ProductDescription"],
		["CurrencyCode"] = args["CurrencyCode"],
		["PricingDetails"] = args["PricingDetails"],
		["UsagePrice"] = args["UsagePrice"],
		["RecurringCharges"] = args["RecurringCharges"],
		["OfferingType"] = args["OfferingType"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["FixedPrice"] = args["FixedPrice"],
		["Scope"] = args["Scope"],
		["Duration"] = args["Duration"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["ReservedInstancesOfferingId"] = args["ReservedInstancesOfferingId"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertReservedInstancesOffering(t)
	return t
end

keys.IpPermission = { ["PrefixListIds"] = true, ["FromPort"] = true, ["IpRanges"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["UserIdGroupPairs"] = true, ["Ipv6Ranges"] = true, nil }

function asserts.AssertIpPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IpPermission to be of type 'table'")
	if struct["PrefixListIds"] then asserts.AssertPrefixListIdList(struct["PrefixListIds"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["IpRanges"] then asserts.AssertIpRangeList(struct["IpRanges"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["UserIdGroupPairs"] then asserts.AssertUserIdGroupPairList(struct["UserIdGroupPairs"]) end
	if struct["Ipv6Ranges"] then asserts.AssertIpv6RangeList(struct["Ipv6Ranges"]) end
	for k,_ in pairs(struct) do
		assert(keys.IpPermission[k], "IpPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IpPermission
-- <p>Describes a security group rule.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrefixListIds [PrefixListIdList] <p>(Valid for <a>AuthorizeSecurityGroupEgress</a>, <a>RevokeSecurityGroupEgress</a> and <a>DescribeSecurityGroups</a> only) One or more prefix list IDs for an AWS service. In an <a>AuthorizeSecurityGroupEgress</a> request, this is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.</p>
-- * FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of <code>-1</code> indicates all ICMP/ICMPv6 types.</p>
-- * IpRanges [IpRangeList] <p>One or more IPv4 ranges.</p>
-- * ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes for the specified ICMP type.</p>
-- * IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). </p> <p>[EC2-VPC only] Use <code>-1</code> to specify all protocols. When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>58</code> (ICMPv6) allows traffic on all ports, regardless of any port range you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For <code>58</code> (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed when authorizing rules. </p>
-- * UserIdGroupPairs [UserIdGroupPairList] <p>One or more security group and AWS account ID pairs.</p>
-- * Ipv6Ranges [Ipv6RangeList] <p>[EC2-VPC only] One or more IPv6 ranges.</p>
-- @return IpPermission structure as a key-value pair table
function M.IpPermission(args)
	assert(args, "You must provdide an argument table when creating IpPermission")
	local t = { 
		["PrefixListIds"] = args["PrefixListIds"],
		["FromPort"] = args["FromPort"],
		["IpRanges"] = args["IpRanges"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["UserIdGroupPairs"] = args["UserIdGroupPairs"],
		["Ipv6Ranges"] = args["Ipv6Ranges"],
	}
	asserts.AssertIpPermission(t)
	return t
end

keys.MonitorInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertMonitorInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MonitorInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.MonitorInstancesRequest[k], "MonitorInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MonitorInstancesRequest
-- <p>Contains the parameters for MonitorInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return MonitorInstancesRequest structure as a key-value pair table
function M.MonitorInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating MonitorInstancesRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertMonitorInstancesRequest(t)
	return t
end

keys.AcceptVpcPeeringConnectionRequest = { ["DryRun"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertAcceptVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcPeeringConnectionRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptVpcPeeringConnectionRequest[k], "AcceptVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcPeeringConnectionRequest
-- <p>Contains the parameters for AcceptVpcPeeringConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- @return AcceptVpcPeeringConnectionRequest structure as a key-value pair table
function M.AcceptVpcPeeringConnectionRequest(args)
	assert(args, "You must provdide an argument table when creating AcceptVpcPeeringConnectionRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
	}
	asserts.AssertAcceptVpcPeeringConnectionRequest(t)
	return t
end

keys.Volume = { ["AvailabilityZone"] = true, ["Attachments"] = true, ["Tags"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["VolumeId"] = true, ["State"] = true, ["KmsKeyId"] = true, ["SnapshotId"] = true, ["Iops"] = true, ["CreateTime"] = true, ["Size"] = true, nil }

function asserts.AssertVolume(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Volume to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Attachments"] then asserts.AssertVolumeAttachmentList(struct["Attachments"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["State"] then asserts.AssertVolumeState(struct["State"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["Size"] then asserts.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.Volume[k], "Volume contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Volume
-- <p>Describes a volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone for the volume.</p>
-- * Attachments [VolumeAttachmentList] <p>Information about the volume attachments.</p>
-- * Tags [TagList] <p>Any tags assigned to the volume.</p>
-- * Encrypted [Boolean] <p>Indicates whether the volume will be encrypted.</p>
-- * VolumeType [VolumeType] <p>The volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- * State [VolumeState] <p>The volume state.</p>
-- * KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the volume.</p>
-- * SnapshotId [String] <p>The snapshot from which the volume was created, if applicable.</p>
-- * Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For Provisioned IOPS SSD volumes, this represents the number of IOPS that are provisioned for the volume. For General Purpose SSD volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information on General Purpose SSD baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
-- * CreateTime [DateTime] <p>The time stamp when volume creation was initiated.</p>
-- * Size [Integer] <p>The size of the volume, in GiBs.</p>
-- @return Volume structure as a key-value pair table
function M.Volume(args)
	assert(args, "You must provdide an argument table when creating Volume")
	local t = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Attachments"] = args["Attachments"],
		["Tags"] = args["Tags"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["VolumeId"] = args["VolumeId"],
		["State"] = args["State"],
		["KmsKeyId"] = args["KmsKeyId"],
		["SnapshotId"] = args["SnapshotId"],
		["Iops"] = args["Iops"],
		["CreateTime"] = args["CreateTime"],
		["Size"] = args["Size"],
	}
	asserts.AssertVolume(t)
	return t
end

keys.CreateVpcResult = { ["Vpc"] = true, nil }

function asserts.AssertCreateVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcResult to be of type 'table'")
	if struct["Vpc"] then asserts.AssertVpc(struct["Vpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcResult[k], "CreateVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcResult
-- <p>Contains the output of CreateVpc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Vpc [Vpc] <p>Information about the VPC.</p>
-- @return CreateVpcResult structure as a key-value pair table
function M.CreateVpcResult(args)
	assert(args, "You must provdide an argument table when creating CreateVpcResult")
	local t = { 
		["Vpc"] = args["Vpc"],
	}
	asserts.AssertCreateVpcResult(t)
	return t
end

keys.EnableVpcClassicLinkRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertEnableVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkRequest[k], "EnableVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkRequest
-- <p>Contains the parameters for EnableVpcClassicLink.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return EnableVpcClassicLinkRequest structure as a key-value pair table
function M.EnableVpcClassicLinkRequest(args)
	assert(args, "You must provdide an argument table when creating EnableVpcClassicLinkRequest")
	local t = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertEnableVpcClassicLinkRequest(t)
	return t
end

keys.DescribeVolumeStatusRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["VolumeIds"] = true, nil }

function asserts.AssertDescribeVolumeStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeStatusRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["VolumeIds"] then asserts.AssertVolumeIdStringList(struct["VolumeIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeStatusRequest[k], "DescribeVolumeStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeStatusRequest
-- <p>Contains the parameters for DescribeVolumeStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeVolumeStatus</code> request. When the results of the request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of volume results returned by <code>DescribeVolumeStatus</code> in paginated output. When this parameter is used, the request only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then <code>DescribeVolumeStatus</code> returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>action.code</code> - The action code for the event (for example, <code>enable-volume-io</code>).</p> </li> <li> <p> <code>action.description</code> - A description of the action.</p> </li> <li> <p> <code>action.event-id</code> - The event ID associated with the action.</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>event.description</code> - A description of the event.</p> </li> <li> <p> <code>event.event-id</code> - The event ID.</p> </li> <li> <p> <code>event.event-type</code> - The event type (for <code>io-enabled</code>: <code>passed</code> | <code>failed</code>; for <code>io-performance</code>: <code>io-performance:degraded</code> | <code>io-performance:severely-degraded</code> | <code>io-performance:stalled</code>).</p> </li> <li> <p> <code>event.not-after</code> - The latest end time for the event.</p> </li> <li> <p> <code>event.not-before</code> - The earliest start time for the event.</p> </li> <li> <p> <code>volume-status.details-name</code> - The cause for <code>volume-status.status</code> (<code>io-enabled</code> | <code>io-performance</code>).</p> </li> <li> <p> <code>volume-status.details-status</code> - The status of <code>volume-status.details-name</code> (for <code>io-enabled</code>: <code>passed</code> | <code>failed</code>; for <code>io-performance</code>: <code>normal</code> | <code>degraded</code> | <code>severely-degraded</code> | <code>stalled</code>).</p> </li> <li> <p> <code>volume-status.status</code> - The status of the volume (<code>ok</code> | <code>impaired</code> | <code>warning</code> | <code>insufficient-data</code>).</p> </li> </ul>
-- * VolumeIds [VolumeIdStringList] <p>One or more volume IDs.</p> <p>Default: Describes all your volumes.</p>
-- @return DescribeVolumeStatusRequest structure as a key-value pair table
function M.DescribeVolumeStatusRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVolumeStatusRequest")
	local t = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["VolumeIds"] = args["VolumeIds"],
	}
	asserts.AssertDescribeVolumeStatusRequest(t)
	return t
end

keys.AssignPrivateIpAddressesRequest = { ["NetworkInterfaceId"] = true, ["SecondaryPrivateIpAddressCount"] = true, ["PrivateIpAddresses"] = true, ["AllowReassignment"] = true, nil }

function asserts.AssertAssignPrivateIpAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignPrivateIpAddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressStringList(struct["PrivateIpAddresses"]) end
	if struct["AllowReassignment"] then asserts.AssertBoolean(struct["AllowReassignment"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssignPrivateIpAddressesRequest[k], "AssignPrivateIpAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignPrivateIpAddressesRequest
-- <p>Contains the parameters for AssignPrivateIpAddresses.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary IP addresses to assign to the network interface. You can't specify this parameter when also specifying private IP addresses.</p>
-- * PrivateIpAddresses [PrivateIpAddressStringList] <p>One or more IP addresses to be assigned as a secondary private IP address to the network interface. You can't specify this parameter when also specifying a number of secondary IP addresses.</p> <p>If you don't specify an IP address, Amazon EC2 automatically selects an IP address within the subnet range.</p>
-- * AllowReassignment [Boolean] <p>Indicates whether to allow an IP address that is already assigned to another network interface or instance to be reassigned to the specified network interface.</p>
-- Required key: NetworkInterfaceId
-- @return AssignPrivateIpAddressesRequest structure as a key-value pair table
function M.AssignPrivateIpAddressesRequest(args)
	assert(args, "You must provdide an argument table when creating AssignPrivateIpAddressesRequest")
	local t = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["AllowReassignment"] = args["AllowReassignment"],
	}
	asserts.AssertAssignPrivateIpAddressesRequest(t)
	return t
end

keys.RequestSpotFleetRequest = { ["SpotFleetRequestConfig"] = true, ["DryRun"] = true, nil }

function asserts.AssertRequestSpotFleetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotFleetRequest to be of type 'table'")
	assert(struct["SpotFleetRequestConfig"], "Expected key SpotFleetRequestConfig to exist in table")
	if struct["SpotFleetRequestConfig"] then asserts.AssertSpotFleetRequestConfigData(struct["SpotFleetRequestConfig"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotFleetRequest[k], "RequestSpotFleetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotFleetRequest
-- <p>Contains the parameters for RequestSpotFleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestConfig [SpotFleetRequestConfigData] <p>The configuration for the Spot fleet request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: SpotFleetRequestConfig
-- @return RequestSpotFleetRequest structure as a key-value pair table
function M.RequestSpotFleetRequest(args)
	assert(args, "You must provdide an argument table when creating RequestSpotFleetRequest")
	local t = { 
		["SpotFleetRequestConfig"] = args["SpotFleetRequestConfig"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertRequestSpotFleetRequest(t)
	return t
end

keys.CreateVpcRequest = { ["AmazonProvidedIpv6CidrBlock"] = true, ["DryRun"] = true, ["InstanceTenancy"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertCreateVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcRequest to be of type 'table'")
	assert(struct["CidrBlock"], "Expected key CidrBlock to exist in table")
	if struct["AmazonProvidedIpv6CidrBlock"] then asserts.AssertBoolean(struct["AmazonProvidedIpv6CidrBlock"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcRequest[k], "CreateVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcRequest
-- <p>Contains the parameters for CreateVpc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AmazonProvidedIpv6CidrBlock [Boolean] <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceTenancy [Tenancy] <p>The tenancy options for instances launched into the VPC. For <code>default</code>, instances are launched with shared tenancy by default. You can launch instances with any tenancy into a shared tenancy VPC. For <code>dedicated</code>, instances are launched as dedicated tenancy instances by default. You can only launch instances with a tenancy of <code>dedicated</code> or <code>host</code> into a dedicated tenancy VPC. </p> <p> <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p> <p>Default: <code>default</code> </p>
-- * CidrBlock [String] <p>The IPv4 network range for the VPC, in CIDR notation. For example, <code>10.0.0.0/16</code>.</p>
-- Required key: CidrBlock
-- @return CreateVpcRequest structure as a key-value pair table
function M.CreateVpcRequest(args)
	assert(args, "You must provdide an argument table when creating CreateVpcRequest")
	local t = { 
		["AmazonProvidedIpv6CidrBlock"] = args["AmazonProvidedIpv6CidrBlock"],
		["DryRun"] = args["DryRun"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertCreateVpcRequest(t)
	return t
end

keys.CancelSpotFleetRequestsError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsError to be of type 'table'")
	assert(struct["Code"], "Expected key Code to exist in table")
	assert(struct["Message"], "Expected key Message to exist in table")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertCancelBatchErrorCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsError[k], "CancelSpotFleetRequestsError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsError
-- <p>Describes a Spot fleet error.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The description for the error code.</p>
-- * Code [CancelBatchErrorCode] <p>The error code.</p>
-- Required key: Code
-- Required key: Message
-- @return CancelSpotFleetRequestsError structure as a key-value pair table
function M.CancelSpotFleetRequestsError(args)
	assert(args, "You must provdide an argument table when creating CancelSpotFleetRequestsError")
	local t = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertCancelSpotFleetRequestsError(t)
	return t
end

keys.ClassicLinkDnsSupport = { ["VpcId"] = true, ["ClassicLinkDnsSupported"] = true, nil }

function asserts.AssertClassicLinkDnsSupport(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLinkDnsSupport to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["ClassicLinkDnsSupported"] then asserts.AssertBoolean(struct["ClassicLinkDnsSupported"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClassicLinkDnsSupport[k], "ClassicLinkDnsSupport contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLinkDnsSupport
-- <p>Describes the ClassicLink DNS support status of a VPC.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * ClassicLinkDnsSupported [Boolean] <p>Indicates whether ClassicLink DNS support is enabled for the VPC.</p>
-- @return ClassicLinkDnsSupport structure as a key-value pair table
function M.ClassicLinkDnsSupport(args)
	assert(args, "You must provdide an argument table when creating ClassicLinkDnsSupport")
	local t = { 
		["VpcId"] = args["VpcId"],
		["ClassicLinkDnsSupported"] = args["ClassicLinkDnsSupported"],
	}
	asserts.AssertClassicLinkDnsSupport(t)
	return t
end

keys.RebootInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertRebootInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RebootInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.RebootInstancesRequest[k], "RebootInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RebootInstancesRequest
-- <p>Contains the parameters for RebootInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return RebootInstancesRequest structure as a key-value pair table
function M.RebootInstancesRequest(args)
	assert(args, "You must provdide an argument table when creating RebootInstancesRequest")
	local t = { 
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertRebootInstancesRequest(t)
	return t
end

keys.CreateNetworkAclEntryRequest = { ["IcmpTypeCode"] = true, ["NetworkAclId"] = true, ["RuleNumber"] = true, ["DryRun"] = true, ["Ipv6CidrBlock"] = true, ["Egress"] = true, ["RuleAction"] = true, ["PortRange"] = true, ["Protocol"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertCreateNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["Protocol"], "Expected key Protocol to exist in table")
	assert(struct["RuleAction"], "Expected key RuleAction to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["IcmpTypeCode"] then asserts.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then asserts.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then asserts.AssertPortRange(struct["PortRange"]) end
	if struct["Protocol"] then asserts.AssertString(struct["Protocol"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkAclEntryRequest[k], "CreateNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclEntryRequest
-- <p>Contains the parameters for CreateNetworkAclEntry.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * RuleNumber [Integer] <p>The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number.</p> <p>Constraints: Positive integer from 1 to 32766. The range 32767 to 65535 is reserved for internal use.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation (for example <code>2001:db8:1234:1a00::/64</code>).</p>
-- * Egress [Boolean] <p>Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet).</p>
-- * RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- * PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
-- * Protocol [String] <p>The protocol. A value of <code>-1</code> or <code>all</code> means all protocols. If you specify <code>all</code>, <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, or <code>icmp</code>, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
-- * CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation (for example <code>172.16.0.0/24</code>).</p>
-- Required key: Egress
-- Required key: NetworkAclId
-- Required key: Protocol
-- Required key: RuleAction
-- Required key: RuleNumber
-- @return CreateNetworkAclEntryRequest structure as a key-value pair table
function M.CreateNetworkAclEntryRequest(args)
	assert(args, "You must provdide an argument table when creating CreateNetworkAclEntryRequest")
	local t = { 
		["IcmpTypeCode"] = args["IcmpTypeCode"],
		["NetworkAclId"] = args["NetworkAclId"],
		["RuleNumber"] = args["RuleNumber"],
		["DryRun"] = args["DryRun"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["Egress"] = args["Egress"],
		["RuleAction"] = args["RuleAction"],
		["PortRange"] = args["PortRange"],
		["Protocol"] = args["Protocol"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertCreateNetworkAclEntryRequest(t)
	return t
end

keys.AttachNetworkInterfaceRequest = { ["InstanceId"] = true, ["DeviceIndex"] = true, ["NetworkInterfaceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertAttachNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachNetworkInterfaceRequest to be of type 'table'")
	assert(struct["DeviceIndex"], "Expected key DeviceIndex to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachNetworkInterfaceRequest[k], "AttachNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachNetworkInterfaceRequest
-- <p>Contains the parameters for AttachNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DeviceIndex [Integer] <p>The index of the device for the network interface attachment.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: DeviceIndex
-- Required key: InstanceId
-- Required key: NetworkInterfaceId
-- @return AttachNetworkInterfaceRequest structure as a key-value pair table
function M.AttachNetworkInterfaceRequest(args)
	assert(args, "You must provdide an argument table when creating AttachNetworkInterfaceRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["DeviceIndex"] = args["DeviceIndex"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertAttachNetworkInterfaceRequest(t)
	return t
end

keys.ImportKeyPairResult = { ["KeyName"] = true, ["KeyFingerprint"] = true, nil }

function asserts.AssertImportKeyPairResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportKeyPairResult to be of type 'table'")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then asserts.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportKeyPairResult[k], "ImportKeyPairResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportKeyPairResult
-- <p>Contains the output of ImportKeyPair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyName [String] <p>The key pair name you provided.</p>
-- * KeyFingerprint [String] <p>The MD5 public key fingerprint as specified in section 4 of RFC 4716.</p>
-- @return ImportKeyPairResult structure as a key-value pair table
function M.ImportKeyPairResult(args)
	assert(args, "You must provdide an argument table when creating ImportKeyPairResult")
	local t = { 
		["KeyName"] = args["KeyName"],
		["KeyFingerprint"] = args["KeyFingerprint"],
	}
	asserts.AssertImportKeyPairResult(t)
	return t
end

keys.DescribeSpotInstanceRequestsResult = { ["SpotInstanceRequests"] = true, nil }

function asserts.AssertDescribeSpotInstanceRequestsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotInstanceRequestsResult to be of type 'table'")
	if struct["SpotInstanceRequests"] then asserts.AssertSpotInstanceRequestList(struct["SpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotInstanceRequestsResult[k], "DescribeSpotInstanceRequestsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotInstanceRequestsResult
-- <p>Contains the output of DescribeSpotInstanceRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceRequests [SpotInstanceRequestList] <p>One or more Spot instance requests.</p>
-- @return DescribeSpotInstanceRequestsResult structure as a key-value pair table
function M.DescribeSpotInstanceRequestsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeSpotInstanceRequestsResult")
	local t = { 
		["SpotInstanceRequests"] = args["SpotInstanceRequests"],
	}
	asserts.AssertDescribeSpotInstanceRequestsResult(t)
	return t
end

keys.ClientData = { ["Comment"] = true, ["UploadSize"] = true, ["UploadEnd"] = true, ["UploadStart"] = true, nil }

function asserts.AssertClientData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClientData to be of type 'table'")
	if struct["Comment"] then asserts.AssertString(struct["Comment"]) end
	if struct["UploadSize"] then asserts.AssertDouble(struct["UploadSize"]) end
	if struct["UploadEnd"] then asserts.AssertDateTime(struct["UploadEnd"]) end
	if struct["UploadStart"] then asserts.AssertDateTime(struct["UploadStart"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClientData[k], "ClientData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClientData
-- <p>Describes the client-specific data.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Comment [String] <p>A user-defined comment about the disk upload.</p>
-- * UploadSize [Double] <p>The size of the uploaded disk image, in GiB.</p>
-- * UploadEnd [DateTime] <p>The time that the disk upload ends.</p>
-- * UploadStart [DateTime] <p>The time that the disk upload starts.</p>
-- @return ClientData structure as a key-value pair table
function M.ClientData(args)
	assert(args, "You must provdide an argument table when creating ClientData")
	local t = { 
		["Comment"] = args["Comment"],
		["UploadSize"] = args["UploadSize"],
		["UploadEnd"] = args["UploadEnd"],
		["UploadStart"] = args["UploadStart"],
	}
	asserts.AssertClientData(t)
	return t
end

keys.DescribeNetworkInterfaceAttributeResult = { ["SourceDestCheck"] = true, ["NetworkInterfaceId"] = true, ["Attachment"] = true, ["Groups"] = true, ["Description"] = true, nil }

function asserts.AssertDescribeNetworkInterfaceAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfaceAttributeResult to be of type 'table'")
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["Attachment"] then asserts.AssertNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfaceAttributeResult[k], "DescribeNetworkInterfaceAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfaceAttributeResult
-- <p>Contains the output of DescribeNetworkInterfaceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * Attachment [NetworkInterfaceAttachment] <p>The attachment (if any) of the network interface.</p>
-- * Groups [GroupIdentifierList] <p>The security groups associated with the network interface.</p>
-- * Description [AttributeValue] <p>The description of the network interface.</p>
-- @return DescribeNetworkInterfaceAttributeResult structure as a key-value pair table
function M.DescribeNetworkInterfaceAttributeResult(args)
	assert(args, "You must provdide an argument table when creating DescribeNetworkInterfaceAttributeResult")
	local t = { 
		["SourceDestCheck"] = args["SourceDestCheck"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["Attachment"] = args["Attachment"],
		["Groups"] = args["Groups"],
		["Description"] = args["Description"],
	}
	asserts.AssertDescribeNetworkInterfaceAttributeResult(t)
	return t
end

keys.ModifyInstancePlacementRequest = { ["InstanceId"] = true, ["Tenancy"] = true, ["HostId"] = true, ["Affinity"] = true, nil }

function asserts.AssertModifyInstancePlacementRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstancePlacementRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Tenancy"] then asserts.AssertHostTenancy(struct["Tenancy"]) end
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["Affinity"] then asserts.AssertAffinity(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstancePlacementRequest[k], "ModifyInstancePlacementRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstancePlacementRequest
-- <p>Contains the parameters for ModifyInstancePlacement.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance that you are modifying.</p>
-- * Tenancy [HostTenancy] <p>The tenancy of the instance that you are modifying.</p>
-- * HostId [String] <p>The ID of the Dedicated Host that the instance will have affinity with.</p>
-- * Affinity [Affinity] <p>The new affinity setting for the instance.</p>
-- Required key: InstanceId
-- @return ModifyInstancePlacementRequest structure as a key-value pair table
function M.ModifyInstancePlacementRequest(args)
	assert(args, "You must provdide an argument table when creating ModifyInstancePlacementRequest")
	local t = { 
		["InstanceId"] = args["InstanceId"],
		["Tenancy"] = args["Tenancy"],
		["HostId"] = args["HostId"],
		["Affinity"] = args["Affinity"],
	}
	asserts.AssertModifyInstancePlacementRequest(t)
	return t
end

keys.SpotFleetRequestConfig = { ["SpotFleetRequestState"] = true, ["SpotFleetRequestId"] = true, ["ActivityStatus"] = true, ["CreateTime"] = true, ["SpotFleetRequestConfig"] = true, nil }

function asserts.AssertSpotFleetRequestConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetRequestConfig to be of type 'table'")
	assert(struct["CreateTime"], "Expected key CreateTime to exist in table")
	assert(struct["SpotFleetRequestConfig"], "Expected key SpotFleetRequestConfig to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["SpotFleetRequestState"], "Expected key SpotFleetRequestState to exist in table")
	if struct["SpotFleetRequestState"] then asserts.AssertBatchState(struct["SpotFleetRequestState"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["ActivityStatus"] then asserts.AssertActivityStatus(struct["ActivityStatus"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["SpotFleetRequestConfig"] then asserts.AssertSpotFleetRequestConfigData(struct["SpotFleetRequestConfig"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetRequestConfig[k], "SpotFleetRequestConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetRequestConfig
-- <p>Describes a Spot fleet request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestState [BatchState] <p>The state of the Spot fleet request.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- * ActivityStatus [ActivityStatus] <p>The progress of the Spot fleet request. If there is an error, the status is <code>error</code>. After all bids are placed, the status is <code>pending_fulfillment</code>. If the size of the fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>. If the size of the fleet is decreased, the status is <code>pending_termination</code> while Spot instances are terminating.</p>
-- * CreateTime [DateTime] <p>The creation date and time of the request.</p>
-- * SpotFleetRequestConfig [SpotFleetRequestConfigData] <p>Information about the configuration of the Spot fleet request.</p>
-- Required key: CreateTime
-- Required key: SpotFleetRequestConfig
-- Required key: SpotFleetRequestId
-- Required key: SpotFleetRequestState
-- @return SpotFleetRequestConfig structure as a key-value pair table
function M.SpotFleetRequestConfig(args)
	assert(args, "You must provdide an argument table when creating SpotFleetRequestConfig")
	local t = { 
		["SpotFleetRequestState"] = args["SpotFleetRequestState"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["ActivityStatus"] = args["ActivityStatus"],
		["CreateTime"] = args["CreateTime"],
		["SpotFleetRequestConfig"] = args["SpotFleetRequestConfig"],
	}
	asserts.AssertSpotFleetRequestConfig(t)
	return t
end

keys.ExportToS3TaskSpecification = { ["S3Bucket"] = true, ["DiskImageFormat"] = true, ["S3Prefix"] = true, ["ContainerFormat"] = true, nil }

function asserts.AssertExportToS3TaskSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportToS3TaskSpecification to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["DiskImageFormat"] then asserts.AssertDiskImageFormat(struct["DiskImageFormat"]) end
	if struct["S3Prefix"] then asserts.AssertString(struct["S3Prefix"]) end
	if struct["ContainerFormat"] then asserts.AssertContainerFormat(struct["ContainerFormat"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExportToS3TaskSpecification[k], "ExportToS3TaskSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportToS3TaskSpecification
-- <p>Describes an instance export task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3Bucket [String] <p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>
-- * DiskImageFormat [DiskImageFormat] <p>The format for the exported image.</p>
-- * S3Prefix [String] <p>The image is written to a single object in the S3 bucket at the S3 key s3prefix + exportTaskId + '.' + diskImageFormat.</p>
-- * ContainerFormat [ContainerFormat] <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>
-- @return ExportToS3TaskSpecification structure as a key-value pair table
function M.ExportToS3TaskSpecification(args)
	assert(args, "You must provdide an argument table when creating ExportToS3TaskSpecification")
	local t = { 
		["S3Bucket"] = args["S3Bucket"],
		["DiskImageFormat"] = args["DiskImageFormat"],
		["S3Prefix"] = args["S3Prefix"],
		["ContainerFormat"] = args["ContainerFormat"],
	}
	asserts.AssertExportToS3TaskSpecification(t)
	return t
end

keys.DescribeHostReservationOfferingsResult = { ["NextToken"] = true, ["OfferingSet"] = true, nil }

function asserts.AssertDescribeHostReservationOfferingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationOfferingsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["OfferingSet"] then asserts.AssertHostOfferingSet(struct["OfferingSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationOfferingsResult[k], "DescribeHostReservationOfferingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationOfferingsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * OfferingSet [HostOfferingSet] <p>Information about the offerings.</p>
-- @return DescribeHostReservationOfferingsResult structure as a key-value pair table
function M.DescribeHostReservationOfferingsResult(args)
	assert(args, "You must provdide an argument table when creating DescribeHostReservationOfferingsResult")
	local t = { 
		["NextToken"] = args["NextToken"],
		["OfferingSet"] = args["OfferingSet"],
	}
	asserts.AssertDescribeHostReservationOfferingsResult(t)
	return t
end

keys.DescribeVpcAttributeRequest = { ["Attribute"] = true, ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeVpcAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["Attribute"] then asserts.AssertVpcAttributeName(struct["Attribute"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcAttributeRequest[k], "DescribeVpcAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcAttributeRequest
-- <p>Contains the parameters for DescribeVpcAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [VpcAttributeName] <p>The VPC attribute.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: Attribute
-- Required key: VpcId
-- @return DescribeVpcAttributeRequest structure as a key-value pair table
function M.DescribeVpcAttributeRequest(args)
	assert(args, "You must provdide an argument table when creating DescribeVpcAttributeRequest")
	local t = { 
		["Attribute"] = args["Attribute"],
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeVpcAttributeRequest(t)
	return t
end

function asserts.AssertEgressOnlyInternetGatewayId(str)
	assert(str)
	assert(type(str) == "string", "Expected EgressOnlyInternetGatewayId to be of type 'string'")
end

--  
function M.EgressOnlyInternetGatewayId(str)
	asserts.AssertEgressOnlyInternetGatewayId(str)
	return str
end

function asserts.AssertIpv6Address(str)
	assert(str)
	assert(type(str) == "string", "Expected Ipv6Address to be of type 'string'")
end

--  
function M.Ipv6Address(str)
	asserts.AssertIpv6Address(str)
	return str
end

function asserts.AssertVolumeModificationState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeModificationState to be of type 'string'")
end

--  
function M.VolumeModificationState(str)
	asserts.AssertVolumeModificationState(str)
	return str
end

function asserts.AssertVpnState(str)
	assert(str)
	assert(type(str) == "string", "Expected VpnState to be of type 'string'")
end

--  
function M.VpnState(str)
	asserts.AssertVpnState(str)
	return str
end

function asserts.AssertSubnetState(str)
	assert(str)
	assert(type(str) == "string", "Expected SubnetState to be of type 'string'")
end

--  
function M.SubnetState(str)
	asserts.AssertSubnetState(str)
	return str
end

function asserts.AssertOfferingTypeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected OfferingTypeValues to be of type 'string'")
end

--  
function M.OfferingTypeValues(str)
	asserts.AssertOfferingTypeValues(str)
	return str
end

function asserts.AssertState(str)
	assert(str)
	assert(type(str) == "string", "Expected State to be of type 'string'")
end

--  
function M.State(str)
	asserts.AssertState(str)
	return str
end

function asserts.AssertSpotInstanceState(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotInstanceState to be of type 'string'")
end

--  
function M.SpotInstanceState(str)
	asserts.AssertSpotInstanceState(str)
	return str
end

function asserts.AssertEventCode(str)
	assert(str)
	assert(type(str) == "string", "Expected EventCode to be of type 'string'")
end

--  
function M.EventCode(str)
	asserts.AssertEventCode(str)
	return str
end

function asserts.AssertMonitoringState(str)
	assert(str)
	assert(type(str) == "string", "Expected MonitoringState to be of type 'string'")
end

--  
function M.MonitoringState(str)
	asserts.AssertMonitoringState(str)
	return str
end

function asserts.AssertVpcState(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcState to be of type 'string'")
end

--  
function M.VpcState(str)
	asserts.AssertVpcState(str)
	return str
end

function asserts.AssertSubnetCidrBlockStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected SubnetCidrBlockStateCode to be of type 'string'")
end

--  
function M.SubnetCidrBlockStateCode(str)
	asserts.AssertSubnetCidrBlockStateCode(str)
	return str
end

function asserts.AssertRouteState(str)
	assert(str)
	assert(type(str) == "string", "Expected RouteState to be of type 'string'")
end

--  
function M.RouteState(str)
	asserts.AssertRouteState(str)
	return str
end

function asserts.AssertVpcCidrBlockStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcCidrBlockStateCode to be of type 'string'")
end

--  
function M.VpcCidrBlockStateCode(str)
	asserts.AssertVpcCidrBlockStateCode(str)
	return str
end

function asserts.AssertPlacementGroupState(str)
	assert(str)
	assert(type(str) == "string", "Expected PlacementGroupState to be of type 'string'")
end

--  
function M.PlacementGroupState(str)
	asserts.AssertPlacementGroupState(str)
	return str
end

function asserts.AssertPlatformValues(str)
	assert(str)
	assert(type(str) == "string", "Expected PlatformValues to be of type 'string'")
end

--  
function M.PlatformValues(str)
	asserts.AssertPlatformValues(str)
	return str
end

function asserts.AssertStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected Status to be of type 'string'")
end

--  
function M.Status(str)
	asserts.AssertStatus(str)
	return str
end

function asserts.AssertEventType(str)
	assert(str)
	assert(type(str) == "string", "Expected EventType to be of type 'string'")
end

--  
function M.EventType(str)
	asserts.AssertEventType(str)
	return str
end

function asserts.AssertNetworkInterfaceType(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceType to be of type 'string'")
end

--  
function M.NetworkInterfaceType(str)
	asserts.AssertNetworkInterfaceType(str)
	return str
end

function asserts.AssertVolumeState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeState to be of type 'string'")
end

--  
function M.VolumeState(str)
	asserts.AssertVolumeState(str)
	return str
end

function asserts.Assertscope(str)
	assert(str)
	assert(type(str) == "string", "Expected scope to be of type 'string'")
end

--  
function M.scope(str)
	asserts.Assertscope(str)
	return str
end

function asserts.AssertReportStatusType(str)
	assert(str)
	assert(type(str) == "string", "Expected ReportStatusType to be of type 'string'")
end

--  
function M.ReportStatusType(str)
	asserts.AssertReportStatusType(str)
	return str
end

function asserts.AssertInstanceLifecycleType(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceLifecycleType to be of type 'string'")
end

--  
function M.InstanceLifecycleType(str)
	asserts.AssertInstanceLifecycleType(str)
	return str
end

function asserts.AssertSpotInstanceType(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotInstanceType to be of type 'string'")
end

--  
function M.SpotInstanceType(str)
	asserts.AssertSpotInstanceType(str)
	return str
end

function asserts.AssertReservedInstanceState(str)
	assert(str)
	assert(type(str) == "string", "Expected ReservedInstanceState to be of type 'string'")
end

--  
function M.ReservedInstanceState(str)
	asserts.AssertReservedInstanceState(str)
	return str
end

function asserts.AssertPlacementStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected PlacementStrategy to be of type 'string'")
end

--  
function M.PlacementStrategy(str)
	asserts.AssertPlacementStrategy(str)
	return str
end

function asserts.AssertNextToken(str)
	assert(str)
	assert(type(str) == "string", "Expected NextToken to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.NextToken(str)
	asserts.AssertNextToken(str)
	return str
end

function asserts.AssertVpcPeeringConnectionStateReasonCode(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcPeeringConnectionStateReasonCode to be of type 'string'")
end

--  
function M.VpcPeeringConnectionStateReasonCode(str)
	asserts.AssertVpcPeeringConnectionStateReasonCode(str)
	return str
end

function asserts.AssertSnapshotState(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotState to be of type 'string'")
end

--  
function M.SnapshotState(str)
	asserts.AssertSnapshotState(str)
	return str
end

function asserts.AssertFleetType(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetType to be of type 'string'")
end

--  
function M.FleetType(str)
	asserts.AssertFleetType(str)
	return str
end

function asserts.AssertString(str)
	assert(str)
	assert(type(str) == "string", "Expected String to be of type 'string'")
end

--  
function M.String(str)
	asserts.AssertString(str)
	return str
end

function asserts.AssertListingStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ListingStatus to be of type 'string'")
end

--  
function M.ListingStatus(str)
	asserts.AssertListingStatus(str)
	return str
end

function asserts.AssertSnapshotAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotAttributeName to be of type 'string'")
end

--  
function M.SnapshotAttributeName(str)
	asserts.AssertSnapshotAttributeName(str)
	return str
end

function asserts.AssertInstanceHealthStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceHealthStatus to be of type 'string'")
end

--  
function M.InstanceHealthStatus(str)
	asserts.AssertInstanceHealthStatus(str)
	return str
end

function asserts.AssertNetworkInterfaceAttribute(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceAttribute to be of type 'string'")
end

--  
function M.NetworkInterfaceAttribute(str)
	asserts.AssertNetworkInterfaceAttribute(str)
	return str
end

function asserts.AssertVirtualizationType(str)
	assert(str)
	assert(type(str) == "string", "Expected VirtualizationType to be of type 'string'")
end

--  
function M.VirtualizationType(str)
	asserts.AssertVirtualizationType(str)
	return str
end

function asserts.AssertVolumeAttachmentState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeAttachmentState to be of type 'string'")
end

--  
function M.VolumeAttachmentState(str)
	asserts.AssertVolumeAttachmentState(str)
	return str
end

function asserts.AssertInstanceType(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceType to be of type 'string'")
end

--  
function M.InstanceType(str)
	asserts.AssertInstanceType(str)
	return str
end

function asserts.AssertShutdownBehavior(str)
	assert(str)
	assert(type(str) == "string", "Expected ShutdownBehavior to be of type 'string'")
end

--  
function M.ShutdownBehavior(str)
	asserts.AssertShutdownBehavior(str)
	return str
end

function asserts.AssertInstanceAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceAttributeName to be of type 'string'")
end

--  
function M.InstanceAttributeName(str)
	asserts.AssertInstanceAttributeName(str)
	return str
end

function asserts.AssertActivityStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ActivityStatus to be of type 'string'")
end

--  
function M.ActivityStatus(str)
	asserts.AssertActivityStatus(str)
	return str
end

function asserts.AssertPaymentOption(str)
	assert(str)
	assert(type(str) == "string", "Expected PaymentOption to be of type 'string'")
end

--  
function M.PaymentOption(str)
	asserts.AssertPaymentOption(str)
	return str
end

function asserts.AssertVolumeType(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeType to be of type 'string'")
end

--  
function M.VolumeType(str)
	asserts.AssertVolumeType(str)
	return str
end

function asserts.AssertCancelBatchErrorCode(str)
	assert(str)
	assert(type(str) == "string", "Expected CancelBatchErrorCode to be of type 'string'")
end

--  
function M.CancelBatchErrorCode(str)
	asserts.AssertCancelBatchErrorCode(str)
	return str
end

function asserts.AssertImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageAttributeName to be of type 'string'")
end

--  
function M.ImageAttributeName(str)
	asserts.AssertImageAttributeName(str)
	return str
end

function asserts.AssertBundleTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected BundleTaskState to be of type 'string'")
end

--  
function M.BundleTaskState(str)
	asserts.AssertBundleTaskState(str)
	return str
end

function asserts.AssertAvailabilityZoneState(str)
	assert(str)
	assert(type(str) == "string", "Expected AvailabilityZoneState to be of type 'string'")
end

--  
function M.AvailabilityZoneState(str)
	asserts.AssertAvailabilityZoneState(str)
	return str
end

function asserts.AssertHostTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected HostTenancy to be of type 'string'")
end

--  
function M.HostTenancy(str)
	asserts.AssertHostTenancy(str)
	return str
end

function asserts.AssertDomainType(str)
	assert(str)
	assert(type(str) == "string", "Expected DomainType to be of type 'string'")
end

--  
function M.DomainType(str)
	asserts.AssertDomainType(str)
	return str
end

function asserts.AssertCancelSpotInstanceRequestState(str)
	assert(str)
	assert(type(str) == "string", "Expected CancelSpotInstanceRequestState to be of type 'string'")
end

--  
function M.CancelSpotInstanceRequestState(str)
	asserts.AssertCancelSpotInstanceRequestState(str)
	return str
end

function asserts.AssertArchitectureValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ArchitectureValues to be of type 'string'")
end

--  
function M.ArchitectureValues(str)
	asserts.AssertArchitectureValues(str)
	return str
end

function asserts.AssertAllocationState(str)
	assert(str)
	assert(type(str) == "string", "Expected AllocationState to be of type 'string'")
end

--  
function M.AllocationState(str)
	asserts.AssertAllocationState(str)
	return str
end

function asserts.AssertIamInstanceProfileAssociationState(str)
	assert(str)
	assert(type(str) == "string", "Expected IamInstanceProfileAssociationState to be of type 'string'")
end

--  
function M.IamInstanceProfileAssociationState(str)
	asserts.AssertIamInstanceProfileAssociationState(str)
	return str
end

function asserts.AssertResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceType to be of type 'string'")
end

--  
function M.ResourceType(str)
	asserts.AssertResourceType(str)
	return str
end

function asserts.AssertRouteOrigin(str)
	assert(str)
	assert(type(str) == "string", "Expected RouteOrigin to be of type 'string'")
end

--  
function M.RouteOrigin(str)
	asserts.AssertRouteOrigin(str)
	return str
end

function asserts.AssertOfferingClassType(str)
	assert(str)
	assert(type(str) == "string", "Expected OfferingClassType to be of type 'string'")
end

--  
function M.OfferingClassType(str)
	asserts.AssertOfferingClassType(str)
	return str
end

function asserts.AssertSummaryStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected SummaryStatus to be of type 'string'")
end

--  
function M.SummaryStatus(str)
	asserts.AssertSummaryStatus(str)
	return str
end

function asserts.AssertExcessCapacityTerminationPolicy(str)
	assert(str)
	assert(type(str) == "string", "Expected ExcessCapacityTerminationPolicy to be of type 'string'")
end

--  
function M.ExcessCapacityTerminationPolicy(str)
	asserts.AssertExcessCapacityTerminationPolicy(str)
	return str
end

function asserts.AssertAccountAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected AccountAttributeName to be of type 'string'")
end

--  
function M.AccountAttributeName(str)
	asserts.AssertAccountAttributeName(str)
	return str
end

function asserts.AssertMoveStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected MoveStatus to be of type 'string'")
end

--  
function M.MoveStatus(str)
	asserts.AssertMoveStatus(str)
	return str
end

function asserts.AssertVpcAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcAttributeName to be of type 'string'")
end

--  
function M.VpcAttributeName(str)
	asserts.AssertVpcAttributeName(str)
	return str
end

function asserts.AssertTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected Tenancy to be of type 'string'")
end

--  
function M.Tenancy(str)
	asserts.AssertTenancy(str)
	return str
end

function asserts.AssertVolumeStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeStatusName to be of type 'string'")
end

--  
function M.VolumeStatusName(str)
	asserts.AssertVolumeStatusName(str)
	return str
end

function asserts.AssertVolumeStatusInfoStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeStatusInfoStatus to be of type 'string'")
end

--  
function M.VolumeStatusInfoStatus(str)
	asserts.AssertVolumeStatusInfoStatus(str)
	return str
end

function asserts.AssertDeviceType(str)
	assert(str)
	assert(type(str) == "string", "Expected DeviceType to be of type 'string'")
end

--  
function M.DeviceType(str)
	asserts.AssertDeviceType(str)
	return str
end

function asserts.AssertOperationType(str)
	assert(str)
	assert(type(str) == "string", "Expected OperationType to be of type 'string'")
end

--  
function M.OperationType(str)
	asserts.AssertOperationType(str)
	return str
end

function asserts.AssertResetImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ResetImageAttributeName to be of type 'string'")
end

--  
function M.ResetImageAttributeName(str)
	asserts.AssertResetImageAttributeName(str)
	return str
end

function asserts.AssertInstanceStateName(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceStateName to be of type 'string'")
end

--  
function M.InstanceStateName(str)
	asserts.AssertInstanceStateName(str)
	return str
end

function asserts.AssertDiskImageFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected DiskImageFormat to be of type 'string'")
end

--  
function M.DiskImageFormat(str)
	asserts.AssertDiskImageFormat(str)
	return str
end

function asserts.AssertBatchState(str)
	assert(str)
	assert(type(str) == "string", "Expected BatchState to be of type 'string'")
end

--  
function M.BatchState(str)
	asserts.AssertBatchState(str)
	return str
end

function asserts.AssertProductCodeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ProductCodeValues to be of type 'string'")
end

--  
function M.ProductCodeValues(str)
	asserts.AssertProductCodeValues(str)
	return str
end

function asserts.AssertRuleAction(str)
	assert(str)
	assert(type(str) == "string", "Expected RuleAction to be of type 'string'")
end

--  
function M.RuleAction(str)
	asserts.AssertRuleAction(str)
	return str
end

function asserts.AssertHypervisorType(str)
	assert(str)
	assert(type(str) == "string", "Expected HypervisorType to be of type 'string'")
end

--  
function M.HypervisorType(str)
	asserts.AssertHypervisorType(str)
	return str
end

function asserts.AssertGatewayType(str)
	assert(str)
	assert(type(str) == "string", "Expected GatewayType to be of type 'string'")
end

--  
function M.GatewayType(str)
	asserts.AssertGatewayType(str)
	return str
end

function asserts.AssertCurrencyCodeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected CurrencyCodeValues to be of type 'string'")
end

--  
function M.CurrencyCodeValues(str)
	asserts.AssertCurrencyCodeValues(str)
	return str
end

function asserts.AssertStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusName to be of type 'string'")
end

--  
function M.StatusName(str)
	asserts.AssertStatusName(str)
	return str
end

function asserts.AssertReservationState(str)
	assert(str)
	assert(type(str) == "string", "Expected ReservationState to be of type 'string'")
end

--  
function M.ReservationState(str)
	asserts.AssertReservationState(str)
	return str
end

function asserts.AssertStatusType(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusType to be of type 'string'")
end

--  
function M.StatusType(str)
	asserts.AssertStatusType(str)
	return str
end

function asserts.AssertVpnStaticRouteSource(str)
	assert(str)
	assert(type(str) == "string", "Expected VpnStaticRouteSource to be of type 'string'")
end

--  
function M.VpnStaticRouteSource(str)
	asserts.AssertVpnStaticRouteSource(str)
	return str
end

function asserts.AssertAllocationStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected AllocationStrategy to be of type 'string'")
end

--  
function M.AllocationStrategy(str)
	asserts.AssertAllocationStrategy(str)
	return str
end

function asserts.AssertExportEnvironment(str)
	assert(str)
	assert(type(str) == "string", "Expected ExportEnvironment to be of type 'string'")
end

--  
function M.ExportEnvironment(str)
	asserts.AssertExportEnvironment(str)
	return str
end

function asserts.AssertTelemetryStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected TelemetryStatus to be of type 'string'")
end

--  
function M.TelemetryStatus(str)
	asserts.AssertTelemetryStatus(str)
	return str
end

function asserts.AssertAttachmentStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected AttachmentStatus to be of type 'string'")
end

--  
function M.AttachmentStatus(str)
	asserts.AssertAttachmentStatus(str)
	return str
end

function asserts.AssertRecurringChargeFrequency(str)
	assert(str)
	assert(type(str) == "string", "Expected RecurringChargeFrequency to be of type 'string'")
end

--  
function M.RecurringChargeFrequency(str)
	asserts.AssertRecurringChargeFrequency(str)
	return str
end

function asserts.AssertDatafeedSubscriptionState(str)
	assert(str)
	assert(type(str) == "string", "Expected DatafeedSubscriptionState to be of type 'string'")
end

--  
function M.DatafeedSubscriptionState(str)
	asserts.AssertDatafeedSubscriptionState(str)
	return str
end

function asserts.AssertVolumeAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeAttributeName to be of type 'string'")
end

--  
function M.VolumeAttributeName(str)
	asserts.AssertVolumeAttributeName(str)
	return str
end

function asserts.AssertTrafficType(str)
	assert(str)
	assert(type(str) == "string", "Expected TrafficType to be of type 'string'")
end

--  
function M.TrafficType(str)
	asserts.AssertTrafficType(str)
	return str
end

function asserts.AssertContainerFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected ContainerFormat to be of type 'string'")
end

--  
function M.ContainerFormat(str)
	asserts.AssertContainerFormat(str)
	return str
end

function asserts.AssertListingState(str)
	assert(str)
	assert(type(str) == "string", "Expected ListingState to be of type 'string'")
end

--  
function M.ListingState(str)
	asserts.AssertListingState(str)
	return str
end

function asserts.AssertImageState(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageState to be of type 'string'")
end

--  
function M.ImageState(str)
	asserts.AssertImageState(str)
	return str
end

function asserts.AssertImageTypeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageTypeValues to be of type 'string'")
end

--  
function M.ImageTypeValues(str)
	asserts.AssertImageTypeValues(str)
	return str
end

function asserts.AssertNatGatewayState(str)
	assert(str)
	assert(type(str) == "string", "Expected NatGatewayState to be of type 'string'")
end

--  
function M.NatGatewayState(str)
	asserts.AssertNatGatewayState(str)
	return str
end

function asserts.AssertRIProductDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected RIProductDescription to be of type 'string'")
end

--  
function M.RIProductDescription(str)
	asserts.AssertRIProductDescription(str)
	return str
end

function asserts.AssertNetworkInterfaceStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceStatus to be of type 'string'")
end

--  
function M.NetworkInterfaceStatus(str)
	asserts.AssertNetworkInterfaceStatus(str)
	return str
end

function asserts.AssertAffinity(str)
	assert(str)
	assert(type(str) == "string", "Expected Affinity to be of type 'string'")
end

--  
function M.Affinity(str)
	asserts.AssertAffinity(str)
	return str
end

function asserts.AssertFlowLogsResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected FlowLogsResourceType to be of type 'string'")
end

--  
function M.FlowLogsResourceType(str)
	asserts.AssertFlowLogsResourceType(str)
	return str
end

function asserts.AssertPermissionGroup(str)
	assert(str)
	assert(type(str) == "string", "Expected PermissionGroup to be of type 'string'")
end

--  
function M.PermissionGroup(str)
	asserts.AssertPermissionGroup(str)
	return str
end

function asserts.AssertExportTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected ExportTaskState to be of type 'string'")
end

--  
function M.ExportTaskState(str)
	asserts.AssertExportTaskState(str)
	return str
end

function asserts.AssertFpgaImageStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected FpgaImageStateCode to be of type 'string'")
end

--  
function M.FpgaImageStateCode(str)
	asserts.AssertFpgaImageStateCode(str)
	return str
end

function asserts.AssertReportInstanceReasonCodes(str)
	assert(str)
	assert(type(str) == "string", "Expected ReportInstanceReasonCodes to be of type 'string'")
end

--  
function M.ReportInstanceReasonCodes(str)
	asserts.AssertReportInstanceReasonCodes(str)
	return str
end

function asserts.AssertConversionTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected ConversionTaskState to be of type 'string'")
end

--  
function M.ConversionTaskState(str)
	asserts.AssertConversionTaskState(str)
	return str
end

function asserts.AssertAutoPlacement(str)
	assert(str)
	assert(type(str) == "string", "Expected AutoPlacement to be of type 'string'")
end

--  
function M.AutoPlacement(str)
	asserts.AssertAutoPlacement(str)
	return str
end

function asserts.AssertFloat(float)
	assert(float)
	assert(type(float) == "number", "Expected Float to be of type 'number'")
end

function M.Float(float)
	asserts.AssertFloat(float)
	return float
end

function asserts.AssertDouble(double)
	assert(double)
	assert(type(double) == "number", "Expected Double to be of type 'number'")
end

function M.Double(double)
	asserts.AssertDouble(double)
	return double
end

function asserts.AssertLong(long)
	assert(long)
	assert(type(long) == "number", "Expected Long to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.Long(long)
	asserts.AssertLong(long)
	return long
end

function asserts.AssertInteger(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected Integer to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.Integer(integer)
	asserts.AssertInteger(integer)
	return integer
end

function asserts.AssertMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 255, "Expected integer to be max 255")
	assert(integer >= 5, "Expected integer to be min 5")
end

function M.MaxResults(integer)
	asserts.AssertMaxResults(integer)
	return integer
end

function asserts.AssertBoolean(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Boolean to be of type 'boolean'")
end

function M.Boolean(boolean)
	asserts.AssertBoolean(boolean)
	return boolean
end

function asserts.AssertDateTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected DateTime to be of type 'string'")
end

function M.DateTime(timestamp)
	asserts.AssertDateTime(timestamp)
	return timestamp
end

function asserts.AssertBlob(blob)
	assert(blob)
	assert(type(string) == "string", "Expected Blob to be of type 'string'")
end

function M.Blob(blob)
	asserts.AssertBlob(blob)
	return blob
end

function asserts.AssertOccurrenceDaySet(list)
	assert(list)
	assert(type(list) == "table", "Expected OccurrenceDaySet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInteger(v)
	end
end

--  
-- List of Integer objects
function M.OccurrenceDaySet(list)
	asserts.AssertOccurrenceDaySet(list)
	return list
end

function asserts.AssertInstanceStatusEventList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusEventList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStatusEvent(v)
	end
end

--  
-- List of InstanceStatusEvent objects
function M.InstanceStatusEventList(list)
	asserts.AssertInstanceStatusEventList(list)
	return list
end

function asserts.AssertInstanceStatusDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStatusDetails(v)
	end
end

--  
-- List of InstanceStatusDetails objects
function M.InstanceStatusDetailsList(list)
	asserts.AssertInstanceStatusDetailsList(list)
	return list
end

function asserts.AssertAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAddress(v)
	end
end

--  
-- List of Address objects
function M.AddressList(list)
	asserts.AssertAddressList(list)
	return list
end

function asserts.AssertResponseHostIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ResponseHostIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResponseHostIdSet(list)
	asserts.AssertResponseHostIdSet(list)
	return list
end

function asserts.AssertReservedInstancesModificationResultList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationResultList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesModificationResult(v)
	end
end

--  
-- List of ReservedInstancesModificationResult objects
function M.ReservedInstancesModificationResultList(list)
	asserts.AssertReservedInstancesModificationResultList(list)
	return list
end

function asserts.AssertPriceScheduleList(list)
	assert(list)
	assert(type(list) == "table", "Expected PriceScheduleList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPriceSchedule(v)
	end
end

--  
-- List of PriceSchedule objects
function M.PriceScheduleList(list)
	asserts.AssertPriceScheduleList(list)
	return list
end

function asserts.AssertStaleSecurityGroupSet(list)
	assert(list)
	assert(type(list) == "table", "Expected StaleSecurityGroupSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertStaleSecurityGroup(v)
	end
end

--  
-- List of StaleSecurityGroup objects
function M.StaleSecurityGroupSet(list)
	asserts.AssertStaleSecurityGroupSet(list)
	return list
end

function asserts.AssertCustomerGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected CustomerGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCustomerGateway(v)
	end
end

--  
-- List of CustomerGateway objects
function M.CustomerGatewayList(list)
	asserts.AssertCustomerGatewayList(list)
	return list
end

function asserts.AssertUserIdGroupPairSet(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdGroupPairSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUserIdGroupPair(v)
	end
end

--  
-- List of UserIdGroupPair objects
function M.UserIdGroupPairSet(list)
	asserts.AssertUserIdGroupPairSet(list)
	return list
end

function asserts.AssertUnsuccessfulItemSet(list)
	assert(list)
	assert(type(list) == "table", "Expected UnsuccessfulItemSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUnsuccessfulItem(v)
	end
end

--  
-- List of UnsuccessfulItem objects
function M.UnsuccessfulItemSet(list)
	asserts.AssertUnsuccessfulItemSet(list)
	return list
end

function asserts.AssertRouteList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRoute(v)
	end
end

--  
-- List of Route objects
function M.RouteList(list)
	asserts.AssertRouteList(list)
	return list
end

function asserts.AssertGroupIds(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIds to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupIds(list)
	asserts.AssertGroupIds(list)
	return list
end

function asserts.AssertSubnetIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SubnetIdStringList(list)
	asserts.AssertSubnetIdStringList(list)
	return list
end

function asserts.AssertTagSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTagSpecification(v)
	end
end

--  
-- List of TagSpecification objects
function M.TagSpecificationList(list)
	asserts.AssertTagSpecificationList(list)
	return list
end

function asserts.AssertSubnetList(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSubnet(v)
	end
end

--  
-- List of Subnet objects
function M.SubnetList(list)
	asserts.AssertSubnetList(list)
	return list
end

function asserts.AssertNetworkInterfaceList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterface(v)
	end
end

--  
-- List of NetworkInterface objects
function M.NetworkInterfaceList(list)
	asserts.AssertNetworkInterfaceList(list)
	return list
end

function asserts.AssertIpv6RangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6RangeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpv6Range(v)
	end
end

--  
-- List of Ipv6Range objects
function M.Ipv6RangeList(list)
	asserts.AssertIpv6RangeList(list)
	return list
end

function asserts.AssertPurchaseSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchaseSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPurchase(v)
	end
end

--  
-- List of Purchase objects
function M.PurchaseSet(list)
	asserts.AssertPurchaseSet(list)
	return list
end

function asserts.AssertImportInstanceVolumeDetailSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportInstanceVolumeDetailSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImportInstanceVolumeDetailItem(v)
	end
end

--  
-- List of ImportInstanceVolumeDetailItem objects
function M.ImportInstanceVolumeDetailSet(list)
	asserts.AssertImportInstanceVolumeDetailSet(list)
	return list
end

function asserts.AssertPlacementGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected PlacementGroupList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPlacementGroup(v)
	end
end

--  
-- List of PlacementGroup objects
function M.PlacementGroupList(list)
	asserts.AssertPlacementGroupList(list)
	return list
end

function asserts.AssertVpcAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcAttachment(v)
	end
end

--  
-- List of VpcAttachment objects
function M.VpcAttachmentList(list)
	asserts.AssertVpcAttachmentList(list)
	return list
end

function asserts.AssertDiskImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected DiskImageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDiskImage(v)
	end
end

--  
-- List of DiskImage objects
function M.DiskImageList(list)
	asserts.AssertDiskImageList(list)
	return list
end

function asserts.AssertReservedInstancesModificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesModification(v)
	end
end

--  
-- List of ReservedInstancesModification objects
function M.ReservedInstancesModificationList(list)
	asserts.AssertReservedInstancesModificationList(list)
	return list
end

function asserts.AssertSecurityGroupIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SecurityGroupIdStringList(list)
	asserts.AssertSecurityGroupIdStringList(list)
	return list
end

function asserts.AssertRestorableByStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected RestorableByStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RestorableByStringList(list)
	asserts.AssertRestorableByStringList(list)
	return list
end

function asserts.AssertNatGatewayAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected NatGatewayAddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNatGatewayAddress(v)
	end
end

--  
-- List of NatGatewayAddress objects
function M.NatGatewayAddressList(list)
	asserts.AssertNatGatewayAddressList(list)
	return list
end

function asserts.AssertCancelSpotFleetRequestsErrorSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelSpotFleetRequestsErrorSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCancelSpotFleetRequestsErrorItem(v)
	end
end

--  
-- List of CancelSpotFleetRequestsErrorItem objects
function M.CancelSpotFleetRequestsErrorSet(list)
	asserts.AssertCancelSpotFleetRequestsErrorSet(list)
	return list
end

function asserts.AssertInstanceIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIpv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceIpv6Address(v)
	end
end

--  
-- List of InstanceIpv6Address objects
function M.InstanceIpv6AddressList(list)
	asserts.AssertInstanceIpv6AddressList(list)
	return list
end

function asserts.AssertPropagatingVgwList(list)
	assert(list)
	assert(type(list) == "table", "Expected PropagatingVgwList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPropagatingVgw(v)
	end
end

--  
-- List of PropagatingVgw objects
function M.PropagatingVgwList(list)
	asserts.AssertPropagatingVgwList(list)
	return list
end

function asserts.AssertValueStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ValueStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ValueStringList(list)
	asserts.AssertValueStringList(list)
	return list
end

function asserts.AssertBlockDeviceMappingRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected BlockDeviceMappingRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertBlockDeviceMapping(v)
	end
end

--  
-- List of BlockDeviceMapping objects
function M.BlockDeviceMappingRequestList(list)
	asserts.AssertBlockDeviceMappingRequestList(list)
	return list
end

function asserts.AssertNewDhcpConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected NewDhcpConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNewDhcpConfiguration(v)
	end
end

--  
-- List of NewDhcpConfiguration objects
function M.NewDhcpConfigurationList(list)
	asserts.AssertNewDhcpConfigurationList(list)
	return list
end

function asserts.AssertVolumeStatusActionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusActionsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusAction(v)
	end
end

--  
-- List of VolumeStatusAction objects
function M.VolumeStatusActionsList(list)
	asserts.AssertVolumeStatusActionsList(list)
	return list
end

function asserts.AssertInternetGatewayAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected InternetGatewayAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInternetGatewayAttachment(v)
	end
end

--  
-- List of InternetGatewayAttachment objects
function M.InternetGatewayAttachmentList(list)
	asserts.AssertInternetGatewayAttachmentList(list)
	return list
end

function asserts.AssertInstancePrivateIpAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstancePrivateIpAddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstancePrivateIpAddress(v)
	end
end

--  
-- List of InstancePrivateIpAddress objects
function M.InstancePrivateIpAddressList(list)
	asserts.AssertInstancePrivateIpAddressList(list)
	return list
end

function asserts.AssertFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected FilterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFilter(v)
	end
end

--  
-- List of Filter objects
function M.FilterList(list)
	asserts.AssertFilterList(list)
	return list
end

function asserts.AssertInstanceMonitoringList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceMonitoringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceMonitoring(v)
	end
end

--  
-- List of InstanceMonitoring objects
function M.InstanceMonitoringList(list)
	asserts.AssertInstanceMonitoringList(list)
	return list
end

function asserts.AssertUnsuccessfulItemList(list)
	assert(list)
	assert(type(list) == "table", "Expected UnsuccessfulItemList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUnsuccessfulItem(v)
	end
end

--  
-- List of UnsuccessfulItem objects
function M.UnsuccessfulItemList(list)
	asserts.AssertUnsuccessfulItemList(list)
	return list
end

function asserts.AssertImportSnapshotTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportSnapshotTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImportSnapshotTask(v)
	end
end

--  
-- List of ImportSnapshotTask objects
function M.ImportSnapshotTaskList(list)
	asserts.AssertImportSnapshotTaskList(list)
	return list
end

function asserts.AssertPurchaseRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchaseRequestSet to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertPurchaseRequest(v)
	end
end

--  
-- List of PurchaseRequest objects
function M.PurchaseRequestSet(list)
	asserts.AssertPurchaseRequestSet(list)
	return list
end

function asserts.AssertScheduledInstancesBlockDeviceMappingSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesBlockDeviceMappingSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesBlockDeviceMapping(v)
	end
end

--  
-- List of ScheduledInstancesBlockDeviceMapping objects
function M.ScheduledInstancesBlockDeviceMappingSet(list)
	asserts.AssertScheduledInstancesBlockDeviceMappingSet(list)
	return list
end

function asserts.AssertVpnGatewayIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnGatewayIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpnGatewayIdStringList(list)
	asserts.AssertVpnGatewayIdStringList(list)
	return list
end

function asserts.AssertSubnetIpv6CidrBlockAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetIpv6CidrBlockAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSubnetIpv6CidrBlockAssociation(v)
	end
end

--  
-- List of SubnetIpv6CidrBlockAssociation objects
function M.SubnetIpv6CidrBlockAssociationSet(list)
	asserts.AssertSubnetIpv6CidrBlockAssociationSet(list)
	return list
end

function asserts.AssertOwnerStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected OwnerStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.OwnerStringList(list)
	asserts.AssertOwnerStringList(list)
	return list
end

function asserts.AssertEgressOnlyInternetGatewayIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected EgressOnlyInternetGatewayIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertEgressOnlyInternetGatewayId(v)
	end
end

--  
-- List of EgressOnlyInternetGatewayId objects
function M.EgressOnlyInternetGatewayIdList(list)
	asserts.AssertEgressOnlyInternetGatewayIdList(list)
	return list
end

function asserts.AssertScheduledInstanceIdRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceIdRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ScheduledInstanceIdRequestSet(list)
	asserts.AssertScheduledInstanceIdRequestSet(list)
	return list
end

function asserts.AssertInstanceCountList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceCountList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceCount(v)
	end
end

--  
-- List of InstanceCount objects
function M.InstanceCountList(list)
	asserts.AssertInstanceCountList(list)
	return list
end

function asserts.AssertImportTaskIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportTaskIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ImportTaskIdList(list)
	asserts.AssertImportTaskIdList(list)
	return list
end

function asserts.AssertZoneNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ZoneNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ZoneNameStringList(list)
	asserts.AssertZoneNameStringList(list)
	return list
end

function asserts.AssertGroupIdentifierList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIdentifierList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertGroupIdentifier(v)
	end
end

--  
-- List of GroupIdentifier objects
function M.GroupIdentifierList(list)
	asserts.AssertGroupIdentifierList(list)
	return list
end

function asserts.AssertBillingProductList(list)
	assert(list)
	assert(type(list) == "table", "Expected BillingProductList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.BillingProductList(list)
	asserts.AssertBillingProductList(list)
	return list
end

function asserts.AssertSecurityGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SecurityGroupStringList(list)
	asserts.AssertSecurityGroupStringList(list)
	return list
end

function asserts.AssertLaunchSpecsList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchSpecsList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertSpotFleetLaunchSpecification(v)
	end
end

--  
-- List of SpotFleetLaunchSpecification objects
function M.LaunchSpecsList(list)
	asserts.AssertLaunchSpecsList(list)
	return list
end

function asserts.AssertSpotInstanceRequestIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotInstanceRequestIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SpotInstanceRequestIdList(list)
	asserts.AssertSpotInstanceRequestIdList(list)
	return list
end

function asserts.AssertVpcEndpointSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcEndpointSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcEndpoint(v)
	end
end

--  
-- List of VpcEndpoint objects
function M.VpcEndpointSet(list)
	asserts.AssertVpcEndpointSet(list)
	return list
end

function asserts.AssertCancelledSpotInstanceRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelledSpotInstanceRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCancelledSpotInstanceRequest(v)
	end
end

--  
-- List of CancelledSpotInstanceRequest objects
function M.CancelledSpotInstanceRequestList(list)
	asserts.AssertCancelledSpotInstanceRequestList(list)
	return list
end

function asserts.AssertDhcpOptionsIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpOptionsIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.DhcpOptionsIdStringList(list)
	asserts.AssertDhcpOptionsIdStringList(list)
	return list
end

function asserts.AssertTagDescriptionList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagDescriptionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTagDescription(v)
	end
end

--  
-- List of TagDescription objects
function M.TagDescriptionList(list)
	asserts.AssertTagDescriptionList(list)
	return list
end

function asserts.AssertIpRangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected IpRangeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpRange(v)
	end
end

--  
-- List of IpRange objects
function M.IpRangeList(list)
	asserts.AssertIpRangeList(list)
	return list
end

function asserts.AssertImageDiskContainerList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageDiskContainerList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImageDiskContainer(v)
	end
end

--  
-- List of ImageDiskContainer objects
function M.ImageDiskContainerList(list)
	asserts.AssertImageDiskContainerList(list)
	return list
end

function asserts.AssertNetworkInterfacePrivateIpAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfacePrivateIpAddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterfacePrivateIpAddress(v)
	end
end

--  
-- List of NetworkInterfacePrivateIpAddress objects
function M.NetworkInterfacePrivateIpAddressList(list)
	asserts.AssertNetworkInterfacePrivateIpAddressList(list)
	return list
end

function asserts.AssertHostReservationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostReservationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHostReservation(v)
	end
end

--  
-- List of HostReservation objects
function M.HostReservationSet(list)
	asserts.AssertHostReservationSet(list)
	return list
end

function asserts.AssertNetworkAclEntryList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclEntryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkAclEntry(v)
	end
end

--  
-- List of NetworkAclEntry objects
function M.NetworkAclEntryList(list)
	asserts.AssertNetworkAclEntryList(list)
	return list
end

function asserts.AssertRequestHostIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected RequestHostIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RequestHostIdSet(list)
	asserts.AssertRequestHostIdSet(list)
	return list
end

function asserts.AssertReservedInstancesOfferingList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesOfferingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesOffering(v)
	end
end

--  
-- List of ReservedInstancesOffering objects
function M.ReservedInstancesOfferingList(list)
	asserts.AssertReservedInstancesOfferingList(list)
	return list
end

function asserts.AssertIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.Ipv6AddressList(list)
	asserts.AssertIpv6AddressList(list)
	return list
end

function asserts.AssertInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstance(v)
	end
end

--  
-- List of Instance objects
function M.InstanceList(list)
	asserts.AssertInstanceList(list)
	return list
end

function asserts.AssertVpcClassicLinkIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcClassicLinkIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpcClassicLinkIdList(list)
	asserts.AssertVpcClassicLinkIdList(list)
	return list
end

function asserts.AssertVolumeIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VolumeIdStringList(list)
	asserts.AssertVolumeIdStringList(list)
	return list
end

function asserts.AssertInstanceBlockDeviceMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceBlockDeviceMappingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceBlockDeviceMapping(v)
	end
end

--  
-- List of InstanceBlockDeviceMapping objects
function M.InstanceBlockDeviceMappingList(list)
	asserts.AssertInstanceBlockDeviceMappingList(list)
	return list
end

function asserts.AssertVpnConnectionIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnConnectionIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpnConnectionIdStringList(list)
	asserts.AssertVpnConnectionIdStringList(list)
	return list
end

function asserts.AssertUserGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.UserGroupStringList(list)
	asserts.AssertUserGroupStringList(list)
	return list
end

function asserts.AssertExportTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExportTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertExportTask(v)
	end
end

--  
-- List of ExportTask objects
function M.ExportTaskList(list)
	asserts.AssertExportTaskList(list)
	return list
end

function asserts.AssertVolumeList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolume(v)
	end
end

--  
-- List of Volume objects
function M.VolumeList(list)
	asserts.AssertVolumeList(list)
	return list
end

function asserts.AssertRegionList(list)
	assert(list)
	assert(type(list) == "table", "Expected RegionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRegion(v)
	end
end

--  
-- List of Region objects
function M.RegionList(list)
	asserts.AssertRegionList(list)
	return list
end

function asserts.AssertVolumeModificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeModificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeModification(v)
	end
end

--  
-- List of VolumeModification objects
function M.VolumeModificationList(list)
	asserts.AssertVolumeModificationList(list)
	return list
end

function asserts.AssertResponseHostIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResponseHostIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResponseHostIdList(list)
	asserts.AssertResponseHostIdList(list)
	return list
end

function asserts.AssertVpcPeeringConnectionList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcPeeringConnectionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcPeeringConnection(v)
	end
end

--  
-- List of VpcPeeringConnection objects
function M.VpcPeeringConnectionList(list)
	asserts.AssertVpcPeeringConnectionList(list)
	return list
end

function asserts.AssertProductCodeStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductCodeStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ProductCodeStringList(list)
	asserts.AssertProductCodeStringList(list)
	return list
end

function asserts.AssertFpgaImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected FpgaImageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFpgaImage(v)
	end
end

--  
-- List of FpgaImage objects
function M.FpgaImageList(list)
	asserts.AssertFpgaImageList(list)
	return list
end

function asserts.AssertBundleTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected BundleTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertBundleTask(v)
	end
end

--  
-- List of BundleTask objects
function M.BundleTaskList(list)
	asserts.AssertBundleTaskList(list)
	return list
end

function asserts.AssertAvailabilityZoneMessageList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailabilityZoneMessageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAvailabilityZoneMessage(v)
	end
end

--  
-- List of AvailabilityZoneMessage objects
function M.AvailabilityZoneMessageList(list)
	asserts.AssertAvailabilityZoneMessageList(list)
	return list
end

function asserts.AssertPricingDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected PricingDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPricingDetail(v)
	end
end

--  
-- List of PricingDetail objects
function M.PricingDetailsList(list)
	asserts.AssertPricingDetailsList(list)
	return list
end

function asserts.AssertHistoryRecords(list)
	assert(list)
	assert(type(list) == "table", "Expected HistoryRecords to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHistoryRecord(v)
	end
end

--  
-- List of HistoryRecord objects
function M.HistoryRecords(list)
	asserts.AssertHistoryRecords(list)
	return list
end

function asserts.AssertInstanceStateChangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStateChangeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStateChange(v)
	end
end

--  
-- List of InstanceStateChange objects
function M.InstanceStateChangeList(list)
	asserts.AssertInstanceStateChangeList(list)
	return list
end

function asserts.AssertReservationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservation(v)
	end
end

--  
-- List of Reservation objects
function M.ReservationList(list)
	asserts.AssertReservationList(list)
	return list
end

function asserts.AssertHostList(list)
	assert(list)
	assert(type(list) == "table", "Expected HostList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHost(v)
	end
end

--  
-- List of Host objects
function M.HostList(list)
	asserts.AssertHostList(list)
	return list
end

function asserts.AssertPrivateIpAddressStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PrivateIpAddressStringList(list)
	asserts.AssertPrivateIpAddressStringList(list)
	return list
end

function asserts.AssertNetworkInterfaceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.NetworkInterfaceIdList(list)
	asserts.AssertNetworkInterfaceIdList(list)
	return list
end

function asserts.AssertPurchasedScheduledInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchasedScheduledInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstance(v)
	end
end

--  
-- List of ScheduledInstance objects
function M.PurchasedScheduledInstanceSet(list)
	asserts.AssertPurchasedScheduledInstanceSet(list)
	return list
end

function asserts.AssertKeyNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected KeyNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.KeyNameStringList(list)
	asserts.AssertKeyNameStringList(list)
	return list
end

function asserts.AssertBundleIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected BundleIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.BundleIdStringList(list)
	asserts.AssertBundleIdStringList(list)
	return list
end

function asserts.AssertInstanceIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.InstanceIdStringList(list)
	asserts.AssertInstanceIdStringList(list)
	return list
end

function asserts.AssertRouteTableList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteTableList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRouteTable(v)
	end
end

--  
-- List of RouteTable objects
function M.RouteTableList(list)
	asserts.AssertRouteTableList(list)
	return list
end

function asserts.AssertIdFormatList(list)
	assert(list)
	assert(type(list) == "table", "Expected IdFormatList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIdFormat(v)
	end
end

--  
-- List of IdFormat objects
function M.IdFormatList(list)
	asserts.AssertIdFormatList(list)
	return list
end

function asserts.AssertRequestHostIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected RequestHostIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RequestHostIdList(list)
	asserts.AssertRequestHostIdList(list)
	return list
end

function asserts.AssertKeyPairList(list)
	assert(list)
	assert(type(list) == "table", "Expected KeyPairList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertKeyPairInfo(v)
	end
end

--  
-- List of KeyPairInfo objects
function M.KeyPairList(list)
	asserts.AssertKeyPairList(list)
	return list
end

function asserts.AssertScheduledInstancesSecurityGroupIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesSecurityGroupIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ScheduledInstancesSecurityGroupIdSet(list)
	asserts.AssertScheduledInstancesSecurityGroupIdSet(list)
	return list
end

function asserts.AssertSnapshotIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SnapshotIdStringList(list)
	asserts.AssertSnapshotIdStringList(list)
	return list
end

function asserts.AssertProductCodeList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductCodeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertProductCode(v)
	end
end

--  
-- List of ProductCode objects
function M.ProductCodeList(list)
	asserts.AssertProductCodeList(list)
	return list
end

function asserts.AssertCancelSpotFleetRequestsSuccessSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelSpotFleetRequestsSuccessSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCancelSpotFleetRequestsSuccessItem(v)
	end
end

--  
-- List of CancelSpotFleetRequestsSuccessItem objects
function M.CancelSpotFleetRequestsSuccessSet(list)
	asserts.AssertCancelSpotFleetRequestsSuccessSet(list)
	return list
end

function asserts.AssertAvailabilityZoneList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailabilityZoneList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAvailabilityZone(v)
	end
end

--  
-- List of AvailabilityZone objects
function M.AvailabilityZoneList(list)
	asserts.AssertAvailabilityZoneList(list)
	return list
end

function asserts.AssertFlowLogSet(list)
	assert(list)
	assert(type(list) == "table", "Expected FlowLogSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFlowLog(v)
	end
end

--  
-- List of FlowLog objects
function M.FlowLogSet(list)
	asserts.AssertFlowLogSet(list)
	return list
end

function asserts.AssertDhcpConfigurationValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpConfigurationValueList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAttributeValue(v)
	end
end

--  
-- List of AttributeValue objects
function M.DhcpConfigurationValueList(list)
	asserts.AssertDhcpConfigurationValueList(list)
	return list
end

function asserts.AssertImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImage(v)
	end
end

--  
-- List of Image objects
function M.ImageList(list)
	asserts.AssertImageList(list)
	return list
end

function asserts.AssertRecurringChargesList(list)
	assert(list)
	assert(type(list) == "table", "Expected RecurringChargesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRecurringCharge(v)
	end
end

--  
-- List of RecurringCharge objects
function M.RecurringChargesList(list)
	asserts.AssertRecurringChargesList(list)
	return list
end

function asserts.AssertHostReservationIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostReservationIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.HostReservationIdSet(list)
	asserts.AssertHostReservationIdSet(list)
	return list
end

function asserts.AssertClassicLinkInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected ClassicLinkInstanceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertClassicLinkInstance(v)
	end
end

--  
-- List of ClassicLinkInstance objects
function M.ClassicLinkInstanceList(list)
	asserts.AssertClassicLinkInstanceList(list)
	return list
end

function asserts.AssertVpcClassicLinkList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcClassicLinkList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcClassicLink(v)
	end
end

--  
-- List of VpcClassicLink objects
function M.VpcClassicLinkList(list)
	asserts.AssertVpcClassicLinkList(list)
	return list
end

function asserts.AssertSpotFleetRequestConfigSet(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotFleetRequestConfigSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotFleetRequestConfig(v)
	end
end

--  
-- List of SpotFleetRequestConfig objects
function M.SpotFleetRequestConfigSet(list)
	asserts.AssertSpotFleetRequestConfigSet(list)
	return list
end

function asserts.AssertTargetReservationValueSet(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetReservationValueSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTargetReservationValue(v)
	end
end

--  
-- List of TargetReservationValue objects
function M.TargetReservationValueSet(list)
	asserts.AssertTargetReservationValueSet(list)
	return list
end

function asserts.AssertPrivateIpAddressConfigSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressConfigSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesPrivateIpAddressConfig(v)
	end
end

--  
-- List of ScheduledInstancesPrivateIpAddressConfig objects
function M.PrivateIpAddressConfigSet(list)
	asserts.AssertPrivateIpAddressConfigSet(list)
	return list
end

function asserts.AssertInstanceTypeList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceTypeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceType(v)
	end
end

--  
-- List of InstanceType objects
function M.InstanceTypeList(list)
	asserts.AssertInstanceTypeList(list)
	return list
end

function asserts.AssertVpnConnectionList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnConnectionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnConnection(v)
	end
end

--  
-- List of VpnConnection objects
function M.VpnConnectionList(list)
	asserts.AssertVpnConnectionList(list)
	return list
end

function asserts.AssertDhcpConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDhcpConfiguration(v)
	end
end

--  
-- List of DhcpConfiguration objects
function M.DhcpConfigurationList(list)
	asserts.AssertDhcpConfigurationList(list)
	return list
end

function asserts.AssertNetworkAclAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkAclAssociation(v)
	end
end

--  
-- List of NetworkAclAssociation objects
function M.NetworkAclAssociationList(list)
	asserts.AssertNetworkAclAssociationList(list)
	return list
end

function asserts.AssertScheduledInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstance(v)
	end
end

--  
-- List of ScheduledInstance objects
function M.ScheduledInstanceSet(list)
	asserts.AssertScheduledInstanceSet(list)
	return list
end

function asserts.AssertExportTaskIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExportTaskIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ExportTaskIdStringList(list)
	asserts.AssertExportTaskIdStringList(list)
	return list
end

function asserts.AssertInstanceIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.InstanceIdSet(list)
	asserts.AssertInstanceIdSet(list)
	return list
end

function asserts.AssertAccountAttributeList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAccountAttribute(v)
	end
end

--  
-- List of AccountAttribute objects
function M.AccountAttributeList(list)
	asserts.AssertAccountAttributeList(list)
	return list
end

function asserts.AssertDescribeConversionTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected DescribeConversionTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertConversionTask(v)
	end
end

--  
-- List of ConversionTask objects
function M.DescribeConversionTaskList(list)
	asserts.AssertDescribeConversionTaskList(list)
	return list
end

function asserts.AssertReasonCodesList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReasonCodesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReportInstanceReasonCodes(v)
	end
end

--  
-- List of ReportInstanceReasonCodes objects
function M.ReasonCodesList(list)
	asserts.AssertReasonCodesList(list)
	return list
end

function asserts.AssertAccountAttributeValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeValueList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAccountAttributeValue(v)
	end
end

--  
-- List of AccountAttributeValue objects
function M.AccountAttributeValueList(list)
	asserts.AssertAccountAttributeValueList(list)
	return list
end

function asserts.AssertReservedInstanceIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstanceIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstanceIdSet(list)
	asserts.AssertReservedInstanceIdSet(list)
	return list
end

function asserts.AssertInstanceNetworkInterfaceList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceNetworkInterfaceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceNetworkInterface(v)
	end
end

--  
-- List of InstanceNetworkInterface objects
function M.InstanceNetworkInterfaceList(list)
	asserts.AssertInstanceNetworkInterfaceList(list)
	return list
end

function asserts.AssertAssociationIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.AssociationIdList(list)
	asserts.AssertAssociationIdList(list)
	return list
end

function asserts.AssertDhcpOptionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpOptionsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDhcpOptions(v)
	end
end

--  
-- List of DhcpOptions objects
function M.DhcpOptionsList(list)
	asserts.AssertDhcpOptionsList(list)
	return list
end

function asserts.AssertAllocationIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AllocationIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.AllocationIdList(list)
	asserts.AssertAllocationIdList(list)
	return list
end

function asserts.AssertEgressOnlyInternetGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected EgressOnlyInternetGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertEgressOnlyInternetGateway(v)
	end
end

--  
-- List of EgressOnlyInternetGateway objects
function M.EgressOnlyInternetGatewayList(list)
	asserts.AssertEgressOnlyInternetGatewayList(list)
	return list
end

function asserts.AssertExecutableByStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExecutableByStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ExecutableByStringList(list)
	asserts.AssertExecutableByStringList(list)
	return list
end

function asserts.AssertRouteTableAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteTableAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRouteTableAssociation(v)
	end
end

--  
-- List of RouteTableAssociation objects
function M.RouteTableAssociationList(list)
	asserts.AssertRouteTableAssociationList(list)
	return list
end

function asserts.AssertImportImageTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportImageTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImportImageTask(v)
	end
end

--  
-- List of ImportImageTask objects
function M.ImportImageTaskList(list)
	asserts.AssertImportImageTaskList(list)
	return list
end

function asserts.AssertInternetGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected InternetGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInternetGateway(v)
	end
end

--  
-- List of InternetGateway objects
function M.InternetGatewayList(list)
	asserts.AssertInternetGatewayList(list)
	return list
end

function asserts.AssertPublicIpStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PublicIpStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PublicIpStringList(list)
	asserts.AssertPublicIpStringList(list)
	return list
end

function asserts.AssertScheduledInstancesNetworkInterfaceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesNetworkInterfaceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesNetworkInterface(v)
	end
end

--  
-- List of ScheduledInstancesNetworkInterface objects
function M.ScheduledInstancesNetworkInterfaceSet(list)
	asserts.AssertScheduledInstancesNetworkInterfaceSet(list)
	return list
end

function asserts.AssertReservedInstancesConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesConfiguration(v)
	end
end

--  
-- List of ReservedInstancesConfiguration objects
function M.ReservedInstancesConfigurationList(list)
	asserts.AssertReservedInstancesConfigurationList(list)
	return list
end

function asserts.AssertSnapshotDetailList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotDetailList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSnapshotDetail(v)
	end
end

--  
-- List of SnapshotDetail objects
function M.SnapshotDetailList(list)
	asserts.AssertSnapshotDetailList(list)
	return list
end

function asserts.AssertNatGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected NatGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNatGateway(v)
	end
end

--  
-- List of NatGateway objects
function M.NatGatewayList(list)
	asserts.AssertNatGatewayList(list)
	return list
end

function asserts.AssertConversionIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ConversionIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ConversionIdStringList(list)
	asserts.AssertConversionIdStringList(list)
	return list
end

function asserts.AssertVpnStaticRouteList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnStaticRouteList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnStaticRoute(v)
	end
end

--  
-- List of VpnStaticRoute objects
function M.VpnStaticRouteList(list)
	asserts.AssertVpnStaticRouteList(list)
	return list
end

function asserts.AssertFpgaImageIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected FpgaImageIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.FpgaImageIdList(list)
	asserts.AssertFpgaImageIdList(list)
	return list
end

function asserts.AssertInstanceNetworkInterfaceSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceNetworkInterfaceSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceNetworkInterfaceSpecification(v)
	end
end

--  
-- List of InstanceNetworkInterfaceSpecification objects
function M.InstanceNetworkInterfaceSpecificationList(list)
	asserts.AssertInstanceNetworkInterfaceSpecificationList(list)
	return list
end

function asserts.AssertReservedInstancesIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesIdStringList(list)
	asserts.AssertReservedInstancesIdStringList(list)
	return list
end

function asserts.AssertInstanceBlockDeviceMappingSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceBlockDeviceMappingSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceBlockDeviceMappingSpecification(v)
	end
end

--  
-- List of InstanceBlockDeviceMappingSpecification objects
function M.InstanceBlockDeviceMappingSpecificationList(list)
	asserts.AssertInstanceBlockDeviceMappingSpecificationList(list)
	return list
end

function asserts.AssertReservedInstancesOfferingIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesOfferingIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesOfferingIdStringList(list)
	asserts.AssertReservedInstancesOfferingIdStringList(list)
	return list
end

function asserts.AssertTargetConfigurationRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetConfigurationRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTargetConfigurationRequest(v)
	end
end

--  
-- List of TargetConfigurationRequest objects
function M.TargetConfigurationRequestSet(list)
	asserts.AssertTargetConfigurationRequestSet(list)
	return list
end

function asserts.AssertUserIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.UserIdStringList(list)
	asserts.AssertUserIdStringList(list)
	return list
end

function asserts.AssertVolumeStatusDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusDetails(v)
	end
end

--  
-- List of VolumeStatusDetails objects
function M.VolumeStatusDetailsList(list)
	asserts.AssertVolumeStatusDetailsList(list)
	return list
end

function asserts.AssertLaunchPermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchPermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchPermission(v)
	end
end

--  
-- List of LaunchPermission objects
function M.LaunchPermissionList(list)
	asserts.AssertLaunchPermissionList(list)
	return list
end

function asserts.AssertRegionNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected RegionNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RegionNameStringList(list)
	asserts.AssertRegionNameStringList(list)
	return list
end

function asserts.AssertUserIdGroupPairList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdGroupPairList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUserIdGroupPair(v)
	end
end

--  
-- List of UserIdGroupPair objects
function M.UserIdGroupPairList(list)
	asserts.AssertUserIdGroupPairList(list)
	return list
end

function asserts.AssertVolumeStatusList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusItem(v)
	end
end

--  
-- List of VolumeStatusItem objects
function M.VolumeStatusList(list)
	asserts.AssertVolumeStatusList(list)
	return list
end

function asserts.AssertVpcIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpcIdStringList(list)
	asserts.AssertVpcIdStringList(list)
	return list
end

function asserts.AssertStaleIpPermissionSet(list)
	assert(list)
	assert(type(list) == "table", "Expected StaleIpPermissionSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertStaleIpPermission(v)
	end
end

--  
-- List of StaleIpPermission objects
function M.StaleIpPermissionSet(list)
	asserts.AssertStaleIpPermissionSet(list)
	return list
end

function asserts.AssertResourceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResourceIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResourceIdList(list)
	asserts.AssertResourceIdList(list)
	return list
end

function asserts.AssertSecurityGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityGroup(v)
	end
end

--  
-- List of SecurityGroup objects
function M.SecurityGroupList(list)
	asserts.AssertSecurityGroupList(list)
	return list
end

function asserts.AssertSnapshotList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSnapshot(v)
	end
end

--  
-- List of Snapshot objects
function M.SnapshotList(list)
	asserts.AssertSnapshotList(list)
	return list
end

function asserts.AssertPrefixListSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrefixList(v)
	end
end

--  
-- List of PrefixList objects
function M.PrefixListSet(list)
	asserts.AssertPrefixListSet(list)
	return list
end

function asserts.AssertIpv6CidrBlockSet(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6CidrBlockSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpv6CidrBlock(v)
	end
end

--  
-- List of Ipv6CidrBlock objects
function M.Ipv6CidrBlockSet(list)
	asserts.AssertIpv6CidrBlockSet(list)
	return list
end

function asserts.AssertPrefixListIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PrefixListIdSet(list)
	asserts.AssertPrefixListIdSet(list)
	return list
end

function asserts.AssertCustomerGatewayIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected CustomerGatewayIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.CustomerGatewayIdStringList(list)
	asserts.AssertCustomerGatewayIdStringList(list)
	return list
end

function asserts.AssertActiveInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ActiveInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertActiveInstance(v)
	end
end

--  
-- List of ActiveInstance objects
function M.ActiveInstanceSet(list)
	asserts.AssertActiveInstanceSet(list)
	return list
end

function asserts.AssertIamInstanceProfileAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected IamInstanceProfileAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIamInstanceProfileAssociation(v)
	end
end

--  
-- List of IamInstanceProfileAssociation objects
function M.IamInstanceProfileAssociationSet(list)
	asserts.AssertIamInstanceProfileAssociationSet(list)
	return list
end

function asserts.AssertIpRanges(list)
	assert(list)
	assert(type(list) == "table", "Expected IpRanges to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.IpRanges(list)
	asserts.AssertIpRanges(list)
	return list
end

function asserts.AssertGroupNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupNameStringList(list)
	asserts.AssertGroupNameStringList(list)
	return list
end

function asserts.AssertGroupIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupIdStringList(list)
	asserts.AssertGroupIdStringList(list)
	return list
end

function asserts.AssertProductDescriptionList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductDescriptionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ProductDescriptionList(list)
	asserts.AssertProductDescriptionList(list)
	return list
end

function asserts.AssertAvailableInstanceCapacityList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailableInstanceCapacityList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceCapacity(v)
	end
end

--  
-- List of InstanceCapacity objects
function M.AvailableInstanceCapacityList(list)
	asserts.AssertAvailableInstanceCapacityList(list)
	return list
end

function asserts.AssertReservedIntancesIds(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedIntancesIds to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesId(v)
	end
end

--  
-- List of ReservedInstancesId objects
function M.ReservedIntancesIds(list)
	asserts.AssertReservedIntancesIds(list)
	return list
end

function asserts.AssertScheduledInstanceAvailabilitySet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceAvailabilitySet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstanceAvailability(v)
	end
end

--  
-- List of ScheduledInstanceAvailability objects
function M.ScheduledInstanceAvailabilitySet(list)
	asserts.AssertScheduledInstanceAvailabilitySet(list)
	return list
end

function asserts.AssertScheduledInstancesIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesIpv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesIpv6Address(v)
	end
end

--  
-- List of ScheduledInstancesIpv6Address objects
function M.ScheduledInstancesIpv6AddressList(list)
	asserts.AssertScheduledInstancesIpv6AddressList(list)
	return list
end

function asserts.AssertPlacementGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PlacementGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PlacementGroupStringList(list)
	asserts.AssertPlacementGroupStringList(list)
	return list
end

function asserts.AssertAccountAttributeNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAccountAttributeName(v)
	end
end

--  
-- List of AccountAttributeName objects
function M.AccountAttributeNameStringList(list)
	asserts.AssertAccountAttributeNameStringList(list)
	return list
end

function asserts.AssertNetworkInterfaceIpv6AddressesList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceIpv6AddressesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterfaceIpv6Address(v)
	end
end

--  
-- List of NetworkInterfaceIpv6Address objects
function M.NetworkInterfaceIpv6AddressesList(list)
	asserts.AssertNetworkInterfaceIpv6AddressesList(list)
	return list
end

function asserts.AssertPriceScheduleSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected PriceScheduleSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPriceScheduleSpecification(v)
	end
end

--  
-- List of PriceScheduleSpecification objects
function M.PriceScheduleSpecificationList(list)
	asserts.AssertPriceScheduleSpecificationList(list)
	return list
end

function asserts.AssertPrivateIpAddressSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrivateIpAddressSpecification(v)
	end
end

--  
-- List of PrivateIpAddressSpecification objects
function M.PrivateIpAddressSpecificationList(list)
	asserts.AssertPrivateIpAddressSpecificationList(list)
	return list
end

function asserts.AssertVpcList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpc(v)
	end
end

--  
-- List of Vpc objects
function M.VpcList(list)
	asserts.AssertVpcList(list)
	return list
end

function asserts.AssertImageIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ImageIdStringList(list)
	asserts.AssertImageIdStringList(list)
	return list
end

function asserts.AssertBlockDeviceMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected BlockDeviceMappingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertBlockDeviceMapping(v)
	end
end

--  
-- List of BlockDeviceMapping objects
function M.BlockDeviceMappingList(list)
	asserts.AssertBlockDeviceMappingList(list)
	return list
end

function asserts.AssertSpotInstanceRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotInstanceRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotInstanceRequest(v)
	end
end

--  
-- List of SpotInstanceRequest objects
function M.SpotInstanceRequestList(list)
	asserts.AssertSpotInstanceRequestList(list)
	return list
end

function asserts.AssertReservedInstancesModificationIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesModificationIdStringList(list)
	asserts.AssertReservedInstancesModificationIdStringList(list)
	return list
end

function asserts.AssertClassicLinkDnsSupportList(list)
	assert(list)
	assert(type(list) == "table", "Expected ClassicLinkDnsSupportList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertClassicLinkDnsSupport(v)
	end
end

--  
-- List of ClassicLinkDnsSupport objects
function M.ClassicLinkDnsSupportList(list)
	asserts.AssertClassicLinkDnsSupportList(list)
	return list
end

function asserts.AssertHostOfferingSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostOfferingSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHostOffering(v)
	end
end

--  
-- List of HostOffering objects
function M.HostOfferingSet(list)
	asserts.AssertHostOfferingSet(list)
	return list
end

function asserts.AssertMovingAddressStatusSet(list)
	assert(list)
	assert(type(list) == "table", "Expected MovingAddressStatusSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMovingAddressStatus(v)
	end
end

--  
-- List of MovingAddressStatus objects
function M.MovingAddressStatusSet(list)
	asserts.AssertMovingAddressStatusSet(list)
	return list
end

function asserts.AssertInstanceStatusList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStatus(v)
	end
end

--  
-- List of InstanceStatus objects
function M.InstanceStatusList(list)
	asserts.AssertInstanceStatusList(list)
	return list
end

function asserts.AssertSpotPriceHistoryList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotPriceHistoryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotPrice(v)
	end
end

--  
-- List of SpotPrice objects
function M.SpotPriceHistoryList(list)
	asserts.AssertSpotPriceHistoryList(list)
	return list
end

function asserts.AssertCreateVolumePermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected CreateVolumePermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCreateVolumePermission(v)
	end
end

--  
-- List of CreateVolumePermission objects
function M.CreateVolumePermissionList(list)
	asserts.AssertCreateVolumePermissionList(list)
	return list
end

function asserts.AssertNetworkAclList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkAcl(v)
	end
end

--  
-- List of NetworkAcl objects
function M.NetworkAclList(list)
	asserts.AssertNetworkAclList(list)
	return list
end

function asserts.AssertVpnGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnGateway(v)
	end
end

--  
-- List of VpnGateway objects
function M.VpnGatewayList(list)
	asserts.AssertVpnGatewayList(list)
	return list
end

function asserts.AssertReservedInstanceReservationValueSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstanceReservationValueSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstanceReservationValue(v)
	end
end

--  
-- List of ReservedInstanceReservationValue objects
function M.ReservedInstanceReservationValueSet(list)
	asserts.AssertReservedInstanceReservationValueSet(list)
	return list
end

function asserts.AssertVolumeAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeAttachment(v)
	end
end

--  
-- List of VolumeAttachment objects
function M.VolumeAttachmentList(list)
	asserts.AssertVolumeAttachmentList(list)
	return list
end

function asserts.AssertReservedInstancesListingList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesListingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesListing(v)
	end
end

--  
-- List of ReservedInstancesListing objects
function M.ReservedInstancesListingList(list)
	asserts.AssertReservedInstancesListingList(list)
	return list
end

function asserts.AssertPrefixListIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrefixListId(v)
	end
end

--  
-- List of PrefixListId objects
function M.PrefixListIdList(list)
	asserts.AssertPrefixListIdList(list)
	return list
end

function asserts.AssertOccurrenceDayRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected OccurrenceDayRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInteger(v)
	end
end

--  
-- List of Integer objects
function M.OccurrenceDayRequestSet(list)
	asserts.AssertOccurrenceDayRequestSet(list)
	return list
end

function asserts.AssertHostInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected HostInstanceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHostInstance(v)
	end
end

--  
-- List of HostInstance objects
function M.HostInstanceList(list)
	asserts.AssertHostInstanceList(list)
	return list
end

function asserts.AssertVolumeStatusEventsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusEventsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusEvent(v)
	end
end

--  
-- List of VolumeStatusEvent objects
function M.VolumeStatusEventsList(list)
	asserts.AssertVolumeStatusEventsList(list)
	return list
end

function asserts.AssertIpPermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected IpPermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpPermission(v)
	end
end

--  
-- List of IpPermission objects
function M.IpPermissionList(list)
	asserts.AssertIpPermissionList(list)
	return list
end

function asserts.AssertSecurityGroupReferences(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupReferences to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityGroupReference(v)
	end
end

--  
-- List of SecurityGroupReference objects
function M.SecurityGroupReferences(list)
	asserts.AssertSecurityGroupReferences(list)
	return list
end

function asserts.AssertVpcIpv6CidrBlockAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcIpv6CidrBlockAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcIpv6CidrBlockAssociation(v)
	end
end

--  
-- List of VpcIpv6CidrBlockAssociation objects
function M.VpcIpv6CidrBlockAssociationSet(list)
	asserts.AssertVpcIpv6CidrBlockAssociationSet(list)
	return list
end

function asserts.AssertReservedInstancesList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstances(v)
	end
end

--  
-- List of ReservedInstances objects
function M.ReservedInstancesList(list)
	asserts.AssertReservedInstancesList(list)
	return list
end

function asserts.AssertTagList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTag(v)
	end
end

--  
-- List of Tag objects
function M.TagList(list)
	asserts.AssertTagList(list)
	return list
end

function asserts.AssertVgwTelemetryList(list)
	assert(list)
	assert(type(list) == "table", "Expected VgwTelemetryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVgwTelemetry(v)
	end
end

--  
-- List of VgwTelemetry objects
function M.VgwTelemetryList(list)
	asserts.AssertVgwTelemetryList(list)
	return list
end


local content_type = require "aws-sdk.core.content_type"
local request_headers = require "aws-sdk.core.request_headers"
local request_handlers = require "aws-sdk.core.request_handlers"

local settings = {}


local function endpoint_for_region(region, use_dualstack)
	if not use_dualstack then
		if region == "us-east-1" then
			return "ec2.amazonaws.com"
		end
	end
	local ss = { "ec2" }
	if use_dualstack then
		ss[#ss + 1] = "dualstack"
	end
	ss[#ss + 1] = region
	ss[#ss + 1] = "amazonaws.com"
	if region == "cn-north-1" then
		ss[#ss + 1] = "cn"
	end
	return table.concat(ss, ".")
end


function M.init(config)
	assert(config, "You must provide a config table")
	assert(config.region, "You must provide a region in the config table")

	settings.service = M.metadata.endpoint_prefix
	settings.protocol = M.metadata.protocol
	settings.region = config.region
	settings.endpoint = config.endpoint_override or endpoint_for_region(config.region, config.use_dualstack)
	settings.signature_version = M.metadata.signature_version
	settings.uri = (config.scheme or "https") .. "://" .. settings.endpoint
end


--
-- OPERATIONS
--
--- Call DeleteTags asynchronously, invoking a callback when done
-- @param DeleteTagsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteTagsAsync(DeleteTagsRequest, cb)
	assert(DeleteTagsRequest, "You must provide a DeleteTagsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteTags",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteTagsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteTags synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteTagsRequest
-- @return response
-- @return error_message
function M.DeleteTagsSync(DeleteTagsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteTagsAsync(DeleteTagsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetSnapshotAttribute asynchronously, invoking a callback when done
-- @param ResetSnapshotAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetSnapshotAttributeAsync(ResetSnapshotAttributeRequest, cb)
	assert(ResetSnapshotAttributeRequest, "You must provide a ResetSnapshotAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ResetSnapshotAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ResetSnapshotAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResetSnapshotAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetSnapshotAttributeRequest
-- @return response
-- @return error_message
function M.ResetSnapshotAttributeSync(ResetSnapshotAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetSnapshotAttributeAsync(ResetSnapshotAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeCustomerGateways asynchronously, invoking a callback when done
-- @param DescribeCustomerGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeCustomerGatewaysAsync(DescribeCustomerGatewaysRequest, cb)
	assert(DescribeCustomerGatewaysRequest, "You must provide a DescribeCustomerGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeCustomerGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeCustomerGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeCustomerGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeCustomerGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeCustomerGatewaysSync(DescribeCustomerGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeCustomerGatewaysAsync(DescribeCustomerGatewaysRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVpcClassicLinkDnsSupport asynchronously, invoking a callback when done
-- @param EnableVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVpcClassicLinkDnsSupportAsync(EnableVpcClassicLinkDnsSupportRequest, cb)
	assert(EnableVpcClassicLinkDnsSupportRequest, "You must provide a EnableVpcClassicLinkDnsSupportRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".EnableVpcClassicLinkDnsSupport",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", EnableVpcClassicLinkDnsSupportRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVpcClassicLinkDnsSupport synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVpcClassicLinkDnsSupportRequest
-- @return response
-- @return error_message
function M.EnableVpcClassicLinkDnsSupportSync(EnableVpcClassicLinkDnsSupportRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVpcClassicLinkDnsSupportAsync(EnableVpcClassicLinkDnsSupportRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkAcls asynchronously, invoking a callback when done
-- @param DescribeNetworkAclsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNetworkAclsAsync(DescribeNetworkAclsRequest, cb)
	assert(DescribeNetworkAclsRequest, "You must provide a DescribeNetworkAclsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeNetworkAcls",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeNetworkAclsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkAcls synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkAclsRequest
-- @return response
-- @return error_message
function M.DescribeNetworkAclsSync(DescribeNetworkAclsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkAclsAsync(DescribeNetworkAclsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImageAttribute asynchronously, invoking a callback when done
-- @param DescribeImageAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImageAttributeAsync(DescribeImageAttributeRequest, cb)
	assert(DescribeImageAttributeRequest, "You must provide a DescribeImageAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeImageAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeImageAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImageAttributeRequest
-- @return response
-- @return error_message
function M.DescribeImageAttributeSync(DescribeImageAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImageAttributeAsync(DescribeImageAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelConversionTask asynchronously, invoking a callback when done
-- @param CancelConversionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelConversionTaskAsync(CancelConversionRequest, cb)
	assert(CancelConversionRequest, "You must provide a CancelConversionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelConversionTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelConversionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelConversionTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelConversionRequest
-- @return response
-- @return error_message
function M.CancelConversionTaskSync(CancelConversionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelConversionTaskAsync(CancelConversionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelImportTask asynchronously, invoking a callback when done
-- @param CancelImportTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelImportTaskAsync(CancelImportTaskRequest, cb)
	assert(CancelImportTaskRequest, "You must provide a CancelImportTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelImportTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelImportTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelImportTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelImportTaskRequest
-- @return response
-- @return error_message
function M.CancelImportTaskSync(CancelImportTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelImportTaskAsync(CancelImportTaskRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpnConnectionRoute asynchronously, invoking a callback when done
-- @param CreateVpnConnectionRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpnConnectionRouteAsync(CreateVpnConnectionRouteRequest, cb)
	assert(CreateVpnConnectionRouteRequest, "You must provide a CreateVpnConnectionRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpnConnectionRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpnConnectionRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpnConnectionRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpnConnectionRouteRequest
-- @return response
-- @return error_message
function M.CreateVpnConnectionRouteSync(CreateVpnConnectionRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpnConnectionRouteAsync(CreateVpnConnectionRouteRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeRouteTables asynchronously, invoking a callback when done
-- @param DescribeRouteTablesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeRouteTablesAsync(DescribeRouteTablesRequest, cb)
	assert(DescribeRouteTablesRequest, "You must provide a DescribeRouteTablesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeRouteTables",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeRouteTablesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeRouteTables synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeRouteTablesRequest
-- @return response
-- @return error_message
function M.DescribeRouteTablesSync(DescribeRouteTablesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeRouteTablesAsync(DescribeRouteTablesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetImageAttribute asynchronously, invoking a callback when done
-- @param ResetImageAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetImageAttributeAsync(ResetImageAttributeRequest, cb)
	assert(ResetImageAttributeRequest, "You must provide a ResetImageAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ResetImageAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ResetImageAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResetImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetImageAttributeRequest
-- @return response
-- @return error_message
function M.ResetImageAttributeSync(ResetImageAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetImageAttributeAsync(ResetImageAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateRouteTable asynchronously, invoking a callback when done
-- @param CreateRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateRouteTableAsync(CreateRouteTableRequest, cb)
	assert(CreateRouteTableRequest, "You must provide a CreateRouteTableRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateRouteTableRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateRouteTableRequest
-- @return response
-- @return error_message
function M.CreateRouteTableSync(CreateRouteTableRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateRouteTableAsync(CreateRouteTableRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceRouteTableAssociation asynchronously, invoking a callback when done
-- @param ReplaceRouteTableAssociationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceRouteTableAssociationAsync(ReplaceRouteTableAssociationRequest, cb)
	assert(ReplaceRouteTableAssociationRequest, "You must provide a ReplaceRouteTableAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceRouteTableAssociation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceRouteTableAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceRouteTableAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceRouteTableAssociationRequest
-- @return response
-- @return error_message
function M.ReplaceRouteTableAssociationSync(ReplaceRouteTableAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceRouteTableAssociationAsync(ReplaceRouteTableAssociationRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpcEndpoint asynchronously, invoking a callback when done
-- @param CreateVpcEndpointRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpcEndpointAsync(CreateVpcEndpointRequest, cb)
	assert(CreateVpcEndpointRequest, "You must provide a CreateVpcEndpointRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpcEndpoint",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpcEndpointRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpcEndpoint synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcEndpointRequest
-- @return response
-- @return error_message
function M.CreateVpcEndpointSync(CreateVpcEndpointRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcEndpointAsync(CreateVpcEndpointRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterImage asynchronously, invoking a callback when done
-- @param RegisterImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RegisterImageAsync(RegisterImageRequest, cb)
	assert(RegisterImageRequest, "You must provide a RegisterImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RegisterImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RegisterImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterImageRequest
-- @return response
-- @return error_message
function M.RegisterImageSync(RegisterImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterImageAsync(RegisterImageRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateDhcpOptions asynchronously, invoking a callback when done
-- @param AssociateDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateDhcpOptionsAsync(AssociateDhcpOptionsRequest, cb)
	assert(AssociateDhcpOptionsRequest, "You must provide a AssociateDhcpOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateDhcpOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateDhcpOptionsRequest
-- @return response
-- @return error_message
function M.AssociateDhcpOptionsSync(AssociateDhcpOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateDhcpOptionsAsync(AssociateDhcpOptionsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportKeyPair asynchronously, invoking a callback when done
-- @param ImportKeyPairRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportKeyPairAsync(ImportKeyPairRequest, cb)
	assert(ImportKeyPairRequest, "You must provide a ImportKeyPairRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportKeyPair",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportKeyPairRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportKeyPair synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportKeyPairRequest
-- @return response
-- @return error_message
function M.ImportKeyPairSync(ImportKeyPairRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportKeyPairAsync(ImportKeyPairRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAvailabilityZones asynchronously, invoking a callback when done
-- @param DescribeAvailabilityZonesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeAvailabilityZonesAsync(DescribeAvailabilityZonesRequest, cb)
	assert(DescribeAvailabilityZonesRequest, "You must provide a DescribeAvailabilityZonesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAvailabilityZones",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAvailabilityZonesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAvailabilityZones synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAvailabilityZonesRequest
-- @return response
-- @return error_message
function M.DescribeAvailabilityZonesSync(DescribeAvailabilityZonesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAvailabilityZonesAsync(DescribeAvailabilityZonesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RequestSpotInstances asynchronously, invoking a callback when done
-- @param RequestSpotInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RequestSpotInstancesAsync(RequestSpotInstancesRequest, cb)
	assert(RequestSpotInstancesRequest, "You must provide a RequestSpotInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RequestSpotInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RequestSpotInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RequestSpotInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RequestSpotInstancesRequest
-- @return response
-- @return error_message
function M.RequestSpotInstancesSync(RequestSpotInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RequestSpotInstancesAsync(RequestSpotInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpnGateways asynchronously, invoking a callback when done
-- @param DescribeVpnGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpnGatewaysAsync(DescribeVpnGatewaysRequest, cb)
	assert(DescribeVpnGatewaysRequest, "You must provide a DescribeVpnGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpnGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpnGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpnGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpnGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeVpnGatewaysSync(DescribeVpnGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpnGatewaysAsync(DescribeVpnGatewaysRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AcceptVpcPeeringConnection asynchronously, invoking a callback when done
-- @param AcceptVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AcceptVpcPeeringConnectionAsync(AcceptVpcPeeringConnectionRequest, cb)
	assert(AcceptVpcPeeringConnectionRequest, "You must provide a AcceptVpcPeeringConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AcceptVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AcceptVpcPeeringConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AcceptVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AcceptVpcPeeringConnectionRequest
-- @return response
-- @return error_message
function M.AcceptVpcPeeringConnectionSync(AcceptVpcPeeringConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AcceptVpcPeeringConnectionAsync(AcceptVpcPeeringConnectionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstancesModifications asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesModificationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesModificationsAsync(DescribeReservedInstancesModificationsRequest, cb)
	assert(DescribeReservedInstancesModificationsRequest, "You must provide a DescribeReservedInstancesModificationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesModifications",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeReservedInstancesModificationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstancesModifications synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesModificationsRequest
-- @return response
-- @return error_message
function M.DescribeReservedInstancesModificationsSync(DescribeReservedInstancesModificationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesModificationsAsync(DescribeReservedInstancesModificationsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetPasswordData asynchronously, invoking a callback when done
-- @param GetPasswordDataRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetPasswordDataAsync(GetPasswordDataRequest, cb)
	assert(GetPasswordDataRequest, "You must provide a GetPasswordDataRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetPasswordData",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", GetPasswordDataRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetPasswordData synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetPasswordDataRequest
-- @return response
-- @return error_message
function M.GetPasswordDataSync(GetPasswordDataRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetPasswordDataAsync(GetPasswordDataRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImportSnapshotTasks asynchronously, invoking a callback when done
-- @param DescribeImportSnapshotTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImportSnapshotTasksAsync(DescribeImportSnapshotTasksRequest, cb)
	assert(DescribeImportSnapshotTasksRequest, "You must provide a DescribeImportSnapshotTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeImportSnapshotTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeImportSnapshotTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImportSnapshotTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImportSnapshotTasksRequest
-- @return response
-- @return error_message
function M.DescribeImportSnapshotTasksSync(DescribeImportSnapshotTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImportSnapshotTasksAsync(DescribeImportSnapshotTasksRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call UnassignIpv6Addresses asynchronously, invoking a callback when done
-- @param UnassignIpv6AddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.UnassignIpv6AddressesAsync(UnassignIpv6AddressesRequest, cb)
	assert(UnassignIpv6AddressesRequest, "You must provide a UnassignIpv6AddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UnassignIpv6Addresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", UnassignIpv6AddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UnassignIpv6Addresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UnassignIpv6AddressesRequest
-- @return response
-- @return error_message
function M.UnassignIpv6AddressesSync(UnassignIpv6AddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UnassignIpv6AddressesAsync(UnassignIpv6AddressesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpnConnection asynchronously, invoking a callback when done
-- @param DeleteVpnConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpnConnectionAsync(DeleteVpnConnectionRequest, cb)
	assert(DeleteVpnConnectionRequest, "You must provide a DeleteVpnConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpnConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpnConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpnConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpnConnectionRequest
-- @return response
-- @return error_message
function M.DeleteVpnConnectionSync(DeleteVpnConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpnConnectionAsync(DeleteVpnConnectionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachVpnGateway asynchronously, invoking a callback when done
-- @param AttachVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachVpnGatewayAsync(AttachVpnGatewayRequest, cb)
	assert(AttachVpnGatewayRequest, "You must provide a AttachVpnGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachVpnGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachVpnGatewayRequest
-- @return response
-- @return error_message
function M.AttachVpnGatewaySync(AttachVpnGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachVpnGatewayAsync(AttachVpnGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportImage asynchronously, invoking a callback when done
-- @param ImportImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportImageAsync(ImportImageRequest, cb)
	assert(ImportImageRequest, "You must provide a ImportImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportImageRequest
-- @return response
-- @return error_message
function M.ImportImageSync(ImportImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportImageAsync(ImportImageRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAddresses asynchronously, invoking a callback when done
-- @param DescribeAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeAddressesAsync(DescribeAddressesRequest, cb)
	assert(DescribeAddressesRequest, "You must provide a DescribeAddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAddressesRequest
-- @return response
-- @return error_message
function M.DescribeAddressesSync(DescribeAddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAddressesAsync(DescribeAddressesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateIamInstanceProfile asynchronously, invoking a callback when done
-- @param DisassociateIamInstanceProfileRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateIamInstanceProfileAsync(DisassociateIamInstanceProfileRequest, cb)
	assert(DisassociateIamInstanceProfileRequest, "You must provide a DisassociateIamInstanceProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateIamInstanceProfile",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateIamInstanceProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateIamInstanceProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateIamInstanceProfileRequest
-- @return response
-- @return error_message
function M.DisassociateIamInstanceProfileSync(DisassociateIamInstanceProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateIamInstanceProfileAsync(DisassociateIamInstanceProfileRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateIamInstanceProfile asynchronously, invoking a callback when done
-- @param AssociateIamInstanceProfileRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateIamInstanceProfileAsync(AssociateIamInstanceProfileRequest, cb)
	assert(AssociateIamInstanceProfileRequest, "You must provide a AssociateIamInstanceProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateIamInstanceProfile",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateIamInstanceProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateIamInstanceProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateIamInstanceProfileRequest
-- @return response
-- @return error_message
function M.AssociateIamInstanceProfileSync(AssociateIamInstanceProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateIamInstanceProfileAsync(AssociateIamInstanceProfileRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call PurchaseHostReservation asynchronously, invoking a callback when done
-- @param PurchaseHostReservationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.PurchaseHostReservationAsync(PurchaseHostReservationRequest, cb)
	assert(PurchaseHostReservationRequest, "You must provide a PurchaseHostReservationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".PurchaseHostReservation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", PurchaseHostReservationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call PurchaseHostReservation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PurchaseHostReservationRequest
-- @return response
-- @return error_message
function M.PurchaseHostReservationSync(PurchaseHostReservationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PurchaseHostReservationAsync(PurchaseHostReservationRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call BundleInstance asynchronously, invoking a callback when done
-- @param BundleInstanceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.BundleInstanceAsync(BundleInstanceRequest, cb)
	assert(BundleInstanceRequest, "You must provide a BundleInstanceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".BundleInstance",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", BundleInstanceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call BundleInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param BundleInstanceRequest
-- @return response
-- @return error_message
function M.BundleInstanceSync(BundleInstanceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.BundleInstanceAsync(BundleInstanceRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstances asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesAsync(DescribeReservedInstancesRequest, cb)
	assert(DescribeReservedInstancesRequest, "You must provide a DescribeReservedInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeReservedInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesRequest
-- @return response
-- @return error_message
function M.DescribeReservedInstancesSync(DescribeReservedInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesAsync(DescribeReservedInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkAcl asynchronously, invoking a callback when done
-- @param CreateNetworkAclRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNetworkAclAsync(CreateNetworkAclRequest, cb)
	assert(CreateNetworkAclRequest, "You must provide a CreateNetworkAclRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateNetworkAcl",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateNetworkAclRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkAcl synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkAclRequest
-- @return response
-- @return error_message
function M.CreateNetworkAclSync(CreateNetworkAclRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkAclAsync(CreateNetworkAclRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateImage asynchronously, invoking a callback when done
-- @param CreateImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateImageAsync(CreateImageRequest, cb)
	assert(CreateImageRequest, "You must provide a CreateImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateImageRequest
-- @return response
-- @return error_message
function M.CreateImageSync(CreateImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateImageAsync(CreateImageRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyHosts asynchronously, invoking a callback when done
-- @param ModifyHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyHostsAsync(ModifyHostsRequest, cb)
	assert(ModifyHostsRequest, "You must provide a ModifyHostsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyHostsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyHostsRequest
-- @return response
-- @return error_message
function M.ModifyHostsSync(ModifyHostsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyHostsAsync(ModifyHostsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RebootInstances asynchronously, invoking a callback when done
-- @param RebootInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RebootInstancesAsync(RebootInstancesRequest, cb)
	assert(RebootInstancesRequest, "You must provide a RebootInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RebootInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RebootInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RebootInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RebootInstancesRequest
-- @return response
-- @return error_message
function M.RebootInstancesSync(RebootInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RebootInstancesAsync(RebootInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpoints asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcEndpointsAsync(DescribeVpcEndpointsRequest, cb)
	assert(DescribeVpcEndpointsRequest, "You must provide a DescribeVpcEndpointsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpoints",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcEndpointsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpoints synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointsRequest
-- @return response
-- @return error_message
function M.DescribeVpcEndpointsSync(DescribeVpcEndpointsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointsAsync(DescribeVpcEndpointsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyIdentityIdFormat asynchronously, invoking a callback when done
-- @param ModifyIdentityIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyIdentityIdFormatAsync(ModifyIdentityIdFormatRequest, cb)
	assert(ModifyIdentityIdFormatRequest, "You must provide a ModifyIdentityIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyIdentityIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyIdentityIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyIdentityIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyIdentityIdFormatRequest
-- @return response
-- @return error_message
function M.ModifyIdentityIdFormatSync(ModifyIdentityIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyIdentityIdFormatAsync(ModifyIdentityIdFormatRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotFleetRequestHistory asynchronously, invoking a callback when done
-- @param DescribeSpotFleetRequestHistoryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotFleetRequestHistoryAsync(DescribeSpotFleetRequestHistoryRequest, cb)
	assert(DescribeSpotFleetRequestHistoryRequest, "You must provide a DescribeSpotFleetRequestHistoryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetRequestHistory",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotFleetRequestHistoryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotFleetRequestHistory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotFleetRequestHistoryRequest
-- @return response
-- @return error_message
function M.DescribeSpotFleetRequestHistorySync(DescribeSpotFleetRequestHistoryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotFleetRequestHistoryAsync(DescribeSpotFleetRequestHistoryRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call PurchaseScheduledInstances asynchronously, invoking a callback when done
-- @param PurchaseScheduledInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.PurchaseScheduledInstancesAsync(PurchaseScheduledInstancesRequest, cb)
	assert(PurchaseScheduledInstancesRequest, "You must provide a PurchaseScheduledInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".PurchaseScheduledInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", PurchaseScheduledInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call PurchaseScheduledInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PurchaseScheduledInstancesRequest
-- @return response
-- @return error_message
function M.PurchaseScheduledInstancesSync(PurchaseScheduledInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PurchaseScheduledInstancesAsync(PurchaseScheduledInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceIamInstanceProfileAssociation asynchronously, invoking a callback when done
-- @param ReplaceIamInstanceProfileAssociationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceIamInstanceProfileAssociationAsync(ReplaceIamInstanceProfileAssociationRequest, cb)
	assert(ReplaceIamInstanceProfileAssociationRequest, "You must provide a ReplaceIamInstanceProfileAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceIamInstanceProfileAssociation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceIamInstanceProfileAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceIamInstanceProfileAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceIamInstanceProfileAssociationRequest
-- @return response
-- @return error_message
function M.ReplaceIamInstanceProfileAssociationSync(ReplaceIamInstanceProfileAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceIamInstanceProfileAssociationAsync(ReplaceIamInstanceProfileAssociationRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachVolume asynchronously, invoking a callback when done
-- @param DetachVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachVolumeAsync(DetachVolumeRequest, cb)
	assert(DetachVolumeRequest, "You must provide a DetachVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachVolumeRequest
-- @return response
-- @return error_message
function M.DetachVolumeSync(DetachVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachVolumeAsync(DetachVolumeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIamInstanceProfileAssociations asynchronously, invoking a callback when done
-- @param DescribeIamInstanceProfileAssociationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeIamInstanceProfileAssociationsAsync(DescribeIamInstanceProfileAssociationsRequest, cb)
	assert(DescribeIamInstanceProfileAssociationsRequest, "You must provide a DescribeIamInstanceProfileAssociationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeIamInstanceProfileAssociations",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeIamInstanceProfileAssociationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIamInstanceProfileAssociations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIamInstanceProfileAssociationsRequest
-- @return response
-- @return error_message
function M.DescribeIamInstanceProfileAssociationsSync(DescribeIamInstanceProfileAssociationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIamInstanceProfileAssociationsAsync(DescribeIamInstanceProfileAssociationsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssignPrivateIpAddresses asynchronously, invoking a callback when done
-- @param AssignPrivateIpAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssignPrivateIpAddressesAsync(AssignPrivateIpAddressesRequest, cb)
	assert(AssignPrivateIpAddressesRequest, "You must provide a AssignPrivateIpAddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssignPrivateIpAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AssignPrivateIpAddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssignPrivateIpAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssignPrivateIpAddressesRequest
-- @return response
-- @return error_message
function M.AssignPrivateIpAddressesSync(AssignPrivateIpAddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssignPrivateIpAddressesAsync(AssignPrivateIpAddressesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelExportTask asynchronously, invoking a callback when done
-- @param CancelExportTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelExportTaskAsync(CancelExportTaskRequest, cb)
	assert(CancelExportTaskRequest, "You must provide a CancelExportTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelExportTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelExportTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelExportTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelExportTaskRequest
-- @return response
-- @return error_message
function M.CancelExportTaskSync(CancelExportTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelExportTaskAsync(CancelExportTaskRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachVpnGateway asynchronously, invoking a callback when done
-- @param DetachVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachVpnGatewayAsync(DetachVpnGatewayRequest, cb)
	assert(DetachVpnGatewayRequest, "You must provide a DetachVpnGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachVpnGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachVpnGatewayRequest
-- @return response
-- @return error_message
function M.DetachVpnGatewaySync(DetachVpnGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachVpnGatewayAsync(DetachVpnGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcAttribute asynchronously, invoking a callback when done
-- @param DescribeVpcAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcAttributeAsync(DescribeVpcAttributeRequest, cb)
	assert(DescribeVpcAttributeRequest, "You must provide a DescribeVpcAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcAttributeRequest
-- @return response
-- @return error_message
function M.DescribeVpcAttributeSync(DescribeVpcAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcAttributeAsync(DescribeVpcAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelBundleTask asynchronously, invoking a callback when done
-- @param CancelBundleTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelBundleTaskAsync(CancelBundleTaskRequest, cb)
	assert(CancelBundleTaskRequest, "You must provide a CancelBundleTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelBundleTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelBundleTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelBundleTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelBundleTaskRequest
-- @return response
-- @return error_message
function M.CancelBundleTaskSync(CancelBundleTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelBundleTaskAsync(CancelBundleTaskRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNatGateways asynchronously, invoking a callback when done
-- @param DescribeNatGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNatGatewaysAsync(DescribeNatGatewaysRequest, cb)
	assert(DescribeNatGatewaysRequest, "You must provide a DescribeNatGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeNatGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeNatGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNatGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNatGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeNatGatewaysSync(DescribeNatGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNatGatewaysAsync(DescribeNatGatewaysRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateSubnetCidrBlock asynchronously, invoking a callback when done
-- @param DisassociateSubnetCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateSubnetCidrBlockAsync(DisassociateSubnetCidrBlockRequest, cb)
	assert(DisassociateSubnetCidrBlockRequest, "You must provide a DisassociateSubnetCidrBlockRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateSubnetCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateSubnetCidrBlockRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateSubnetCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateSubnetCidrBlockRequest
-- @return response
-- @return error_message
function M.DisassociateSubnetCidrBlockSync(DisassociateSubnetCidrBlockRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateSubnetCidrBlockAsync(DisassociateSubnetCidrBlockRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpcPeeringConnection asynchronously, invoking a callback when done
-- @param CreateVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpcPeeringConnectionAsync(CreateVpcPeeringConnectionRequest, cb)
	assert(CreateVpcPeeringConnectionRequest, "You must provide a CreateVpcPeeringConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpcPeeringConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcPeeringConnectionRequest
-- @return response
-- @return error_message
function M.CreateVpcPeeringConnectionSync(CreateVpcPeeringConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcPeeringConnectionAsync(CreateVpcPeeringConnectionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyIdFormat asynchronously, invoking a callback when done
-- @param ModifyIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyIdFormatAsync(ModifyIdFormatRequest, cb)
	assert(ModifyIdFormatRequest, "You must provide a ModifyIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyIdFormatRequest
-- @return response
-- @return error_message
function M.ModifyIdFormatSync(ModifyIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyIdFormatAsync(ModifyIdFormatRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotFleetRequests asynchronously, invoking a callback when done
-- @param DescribeSpotFleetRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotFleetRequestsAsync(DescribeSpotFleetRequestsRequest, cb)
	assert(DescribeSpotFleetRequestsRequest, "You must provide a DescribeSpotFleetRequestsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotFleetRequestsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotFleetRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotFleetRequestsRequest
-- @return response
-- @return error_message
function M.DescribeSpotFleetRequestsSync(DescribeSpotFleetRequestsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotFleetRequestsAsync(DescribeSpotFleetRequestsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AllocateHosts asynchronously, invoking a callback when done
-- @param AllocateHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AllocateHostsAsync(AllocateHostsRequest, cb)
	assert(AllocateHostsRequest, "You must provide a AllocateHostsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AllocateHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AllocateHostsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AllocateHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AllocateHostsRequest
-- @return response
-- @return error_message
function M.AllocateHostsSync(AllocateHostsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AllocateHostsAsync(AllocateHostsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkAcl asynchronously, invoking a callback when done
-- @param DeleteNetworkAclRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNetworkAclAsync(DeleteNetworkAclRequest, cb)
	assert(DeleteNetworkAclRequest, "You must provide a DeleteNetworkAclRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteNetworkAcl",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteNetworkAclRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkAcl synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkAclRequest
-- @return response
-- @return error_message
function M.DeleteNetworkAclSync(DeleteNetworkAclRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkAclAsync(DeleteNetworkAclRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetHostReservationPurchasePreview asynchronously, invoking a callback when done
-- @param GetHostReservationPurchasePreviewRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetHostReservationPurchasePreviewAsync(GetHostReservationPurchasePreviewRequest, cb)
	assert(GetHostReservationPurchasePreviewRequest, "You must provide a GetHostReservationPurchasePreviewRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetHostReservationPurchasePreview",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", GetHostReservationPurchasePreviewRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetHostReservationPurchasePreview synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetHostReservationPurchasePreviewRequest
-- @return response
-- @return error_message
function M.GetHostReservationPurchasePreviewSync(GetHostReservationPurchasePreviewRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetHostReservationPurchasePreviewAsync(GetHostReservationPurchasePreviewRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CopyImage asynchronously, invoking a callback when done
-- @param CopyImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CopyImageAsync(CopyImageRequest, cb)
	assert(CopyImageRequest, "You must provide a CopyImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CopyImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CopyImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CopyImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CopyImageRequest
-- @return response
-- @return error_message
function M.CopyImageSync(CopyImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CopyImageAsync(CopyImageRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSnapshot asynchronously, invoking a callback when done
-- @param CreateSnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSnapshotAsync(CreateSnapshotRequest, cb)
	assert(CreateSnapshotRequest, "You must provide a CreateSnapshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateSnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateSnapshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSnapshotRequest
-- @return response
-- @return error_message
function M.CreateSnapshotSync(CreateSnapshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSnapshotAsync(CreateSnapshotRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSubnet asynchronously, invoking a callback when done
-- @param CreateSubnetRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSubnetAsync(CreateSubnetRequest, cb)
	assert(CreateSubnetRequest, "You must provide a CreateSubnetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateSubnet",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateSubnetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSubnet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSubnetRequest
-- @return response
-- @return error_message
function M.CreateSubnetSync(CreateSubnetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSubnetAsync(CreateSubnetRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RequestSpotFleet asynchronously, invoking a callback when done
-- @param RequestSpotFleetRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RequestSpotFleetAsync(RequestSpotFleetRequest, cb)
	assert(RequestSpotFleetRequest, "You must provide a RequestSpotFleetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RequestSpotFleet",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RequestSpotFleetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RequestSpotFleet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RequestSpotFleetRequest
-- @return response
-- @return error_message
function M.RequestSpotFleetSync(RequestSpotFleetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RequestSpotFleetAsync(RequestSpotFleetRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyImageAttribute asynchronously, invoking a callback when done
-- @param ModifyImageAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyImageAttributeAsync(ModifyImageAttributeRequest, cb)
	assert(ModifyImageAttributeRequest, "You must provide a ModifyImageAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyImageAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyImageAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyImageAttributeRequest
-- @return response
-- @return error_message
function M.ModifyImageAttributeSync(ModifyImageAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyImageAttributeAsync(ModifyImageAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateSubnetCidrBlock asynchronously, invoking a callback when done
-- @param AssociateSubnetCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateSubnetCidrBlockAsync(AssociateSubnetCidrBlockRequest, cb)
	assert(AssociateSubnetCidrBlockRequest, "You must provide a AssociateSubnetCidrBlockRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateSubnetCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateSubnetCidrBlockRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateSubnetCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateSubnetCidrBlockRequest
-- @return response
-- @return error_message
function M.AssociateSubnetCidrBlockSync(AssociateSubnetCidrBlockRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateSubnetCidrBlockAsync(AssociateSubnetCidrBlockRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call StartInstances asynchronously, invoking a callback when done
-- @param StartInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.StartInstancesAsync(StartInstancesRequest, cb)
	assert(StartInstancesRequest, "You must provide a StartInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".StartInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", StartInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StartInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StartInstancesRequest
-- @return response
-- @return error_message
function M.StartInstancesSync(StartInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StartInstancesAsync(StartInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotInstanceRequests asynchronously, invoking a callback when done
-- @param DescribeSpotInstanceRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotInstanceRequestsAsync(DescribeSpotInstanceRequestsRequest, cb)
	assert(DescribeSpotInstanceRequestsRequest, "You must provide a DescribeSpotInstanceRequestsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotInstanceRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotInstanceRequestsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotInstanceRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotInstanceRequestsRequest
-- @return response
-- @return error_message
function M.DescribeSpotInstanceRequestsSync(DescribeSpotInstanceRequestsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotInstanceRequestsAsync(DescribeSpotInstanceRequestsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableVgwRoutePropagation asynchronously, invoking a callback when done
-- @param DisableVgwRoutePropagationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisableVgwRoutePropagationAsync(DisableVgwRoutePropagationRequest, cb)
	assert(DisableVgwRoutePropagationRequest, "You must provide a DisableVgwRoutePropagationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisableVgwRoutePropagation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DisableVgwRoutePropagationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisableVgwRoutePropagation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableVgwRoutePropagationRequest
-- @return response
-- @return error_message
function M.DisableVgwRoutePropagationSync(DisableVgwRoutePropagationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableVgwRoutePropagationAsync(DisableVgwRoutePropagationRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcs asynchronously, invoking a callback when done
-- @param DescribeVpcsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcsAsync(DescribeVpcsRequest, cb)
	assert(DescribeVpcsRequest, "You must provide a DescribeVpcsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcsRequest
-- @return response
-- @return error_message
function M.DescribeVpcsSync(DescribeVpcsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcsAsync(DescribeVpcsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateAddress asynchronously, invoking a callback when done
-- @param DisassociateAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateAddressAsync(DisassociateAddressRequest, cb)
	assert(DisassociateAddressRequest, "You must provide a DisassociateAddressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateAddressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateAddressRequest
-- @return response
-- @return error_message
function M.DisassociateAddressSync(DisassociateAddressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateAddressAsync(DisassociateAddressRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifySnapshotAttribute asynchronously, invoking a callback when done
-- @param ModifySnapshotAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifySnapshotAttributeAsync(ModifySnapshotAttributeRequest, cb)
	assert(ModifySnapshotAttributeRequest, "You must provide a ModifySnapshotAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifySnapshotAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifySnapshotAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifySnapshotAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifySnapshotAttributeRequest
-- @return response
-- @return error_message
function M.ModifySnapshotAttributeSync(ModifySnapshotAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifySnapshotAttributeAsync(ModifySnapshotAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call MoveAddressToVpc asynchronously, invoking a callback when done
-- @param MoveAddressToVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.MoveAddressToVpcAsync(MoveAddressToVpcRequest, cb)
	assert(MoveAddressToVpcRequest, "You must provide a MoveAddressToVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".MoveAddressToVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", MoveAddressToVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call MoveAddressToVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param MoveAddressToVpcRequest
-- @return response
-- @return error_message
function M.MoveAddressToVpcSync(MoveAddressToVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.MoveAddressToVpcAsync(MoveAddressToVpcRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpc asynchronously, invoking a callback when done
-- @param CreateVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpcAsync(CreateVpcRequest, cb)
	assert(CreateVpcRequest, "You must provide a CreateVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcRequest
-- @return response
-- @return error_message
function M.CreateVpcSync(CreateVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcAsync(CreateVpcRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpointServices asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointServicesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcEndpointServicesAsync(DescribeVpcEndpointServicesRequest, cb)
	assert(DescribeVpcEndpointServicesRequest, "You must provide a DescribeVpcEndpointServicesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpointServices",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcEndpointServicesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpointServices synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointServicesRequest
-- @return response
-- @return error_message
function M.DescribeVpcEndpointServicesSync(DescribeVpcEndpointServicesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointServicesAsync(DescribeVpcEndpointServicesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelSpotFleetRequests asynchronously, invoking a callback when done
-- @param CancelSpotFleetRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelSpotFleetRequestsAsync(CancelSpotFleetRequestsRequest, cb)
	assert(CancelSpotFleetRequestsRequest, "You must provide a CancelSpotFleetRequestsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelSpotFleetRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelSpotFleetRequestsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelSpotFleetRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelSpotFleetRequestsRequest
-- @return response
-- @return error_message
function M.CancelSpotFleetRequestsSync(CancelSpotFleetRequestsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelSpotFleetRequestsAsync(CancelSpotFleetRequestsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call UnmonitorInstances asynchronously, invoking a callback when done
-- @param UnmonitorInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.UnmonitorInstancesAsync(UnmonitorInstancesRequest, cb)
	assert(UnmonitorInstancesRequest, "You must provide a UnmonitorInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UnmonitorInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", UnmonitorInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UnmonitorInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UnmonitorInstancesRequest
-- @return response
-- @return error_message
function M.UnmonitorInstancesSync(UnmonitorInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UnmonitorInstancesAsync(UnmonitorInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSubnet asynchronously, invoking a callback when done
-- @param DeleteSubnetRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSubnetAsync(DeleteSubnetRequest, cb)
	assert(DeleteSubnetRequest, "You must provide a DeleteSubnetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteSubnet",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteSubnetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSubnet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSubnetRequest
-- @return response
-- @return error_message
function M.DeleteSubnetSync(DeleteSubnetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSubnetAsync(DeleteSubnetRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreatePlacementGroup asynchronously, invoking a callback when done
-- @param CreatePlacementGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreatePlacementGroupAsync(CreatePlacementGroupRequest, cb)
	assert(CreatePlacementGroupRequest, "You must provide a CreatePlacementGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreatePlacementGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreatePlacementGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreatePlacementGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreatePlacementGroupRequest
-- @return response
-- @return error_message
function M.CreatePlacementGroupSync(CreatePlacementGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreatePlacementGroupAsync(CreatePlacementGroupRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CopySnapshot asynchronously, invoking a callback when done
-- @param CopySnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CopySnapshotAsync(CopySnapshotRequest, cb)
	assert(CopySnapshotRequest, "You must provide a CopySnapshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CopySnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CopySnapshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CopySnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CopySnapshotRequest
-- @return response
-- @return error_message
function M.CopySnapshotSync(CopySnapshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CopySnapshotAsync(CopySnapshotRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableVpcClassicLinkDnsSupport asynchronously, invoking a callback when done
-- @param DisableVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisableVpcClassicLinkDnsSupportAsync(DisableVpcClassicLinkDnsSupportRequest, cb)
	assert(DisableVpcClassicLinkDnsSupportRequest, "You must provide a DisableVpcClassicLinkDnsSupportRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisableVpcClassicLinkDnsSupport",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DisableVpcClassicLinkDnsSupportRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisableVpcClassicLinkDnsSupport synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableVpcClassicLinkDnsSupportRequest
-- @return response
-- @return error_message
function M.DisableVpcClassicLinkDnsSupportSync(DisableVpcClassicLinkDnsSupportRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableVpcClassicLinkDnsSupportAsync(DisableVpcClassicLinkDnsSupportRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeHostReservationOfferings asynchronously, invoking a callback when done
-- @param DescribeHostReservationOfferingsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeHostReservationOfferingsAsync(DescribeHostReservationOfferingsRequest, cb)
	assert(DescribeHostReservationOfferingsRequest, "You must provide a DescribeHostReservationOfferingsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeHostReservationOfferings",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeHostReservationOfferingsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeHostReservationOfferings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeHostReservationOfferingsRequest
-- @return response
-- @return error_message
function M.DescribeHostReservationOfferingsSync(DescribeHostReservationOfferingsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeHostReservationOfferingsAsync(DescribeHostReservationOfferingsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumesModifications asynchronously, invoking a callback when done
-- @param DescribeVolumesModificationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumesModificationsAsync(DescribeVolumesModificationsRequest, cb)
	assert(DescribeVolumesModificationsRequest, "You must provide a DescribeVolumesModificationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVolumesModifications",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVolumesModificationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumesModifications synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumesModificationsRequest
-- @return response
-- @return error_message
function M.DescribeVolumesModificationsSync(DescribeVolumesModificationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumesModificationsAsync(DescribeVolumesModificationsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateVpcCidrBlock asynchronously, invoking a callback when done
-- @param AssociateVpcCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateVpcCidrBlockAsync(AssociateVpcCidrBlockRequest, cb)
	assert(AssociateVpcCidrBlockRequest, "You must provide a AssociateVpcCidrBlockRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateVpcCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateVpcCidrBlockRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateVpcCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateVpcCidrBlockRequest
-- @return response
-- @return error_message
function M.AssociateVpcCidrBlockSync(AssociateVpcCidrBlockRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateVpcCidrBlockAsync(AssociateVpcCidrBlockRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateAddress asynchronously, invoking a callback when done
-- @param AssociateAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateAddressAsync(AssociateAddressRequest, cb)
	assert(AssociateAddressRequest, "You must provide a AssociateAddressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateAddressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateAddressRequest
-- @return response
-- @return error_message
function M.AssociateAddressSync(AssociateAddressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateAddressAsync(AssociateAddressRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteCustomerGateway asynchronously, invoking a callback when done
-- @param DeleteCustomerGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteCustomerGatewayAsync(DeleteCustomerGatewayRequest, cb)
	assert(DeleteCustomerGatewayRequest, "You must provide a DeleteCustomerGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteCustomerGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteCustomerGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteCustomerGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteCustomerGatewayRequest
-- @return response
-- @return error_message
function M.DeleteCustomerGatewaySync(DeleteCustomerGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteCustomerGatewayAsync(DeleteCustomerGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateInternetGateway asynchronously, invoking a callback when done
-- @param CreateInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateInternetGatewayAsync(CreateInternetGatewayRequest, cb)
	assert(CreateInternetGatewayRequest, "You must provide a CreateInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateInternetGatewayRequest
-- @return response
-- @return error_message
function M.CreateInternetGatewaySync(CreateInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateInternetGatewayAsync(CreateInternetGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachClassicLinkVpc asynchronously, invoking a callback when done
-- @param AttachClassicLinkVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachClassicLinkVpcAsync(AttachClassicLinkVpcRequest, cb)
	assert(AttachClassicLinkVpcRequest, "You must provide a AttachClassicLinkVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachClassicLinkVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachClassicLinkVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachClassicLinkVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachClassicLinkVpcRequest
-- @return response
-- @return error_message
function M.AttachClassicLinkVpcSync(AttachClassicLinkVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachClassicLinkVpcAsync(AttachClassicLinkVpcRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotPriceHistory asynchronously, invoking a callback when done
-- @param DescribeSpotPriceHistoryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotPriceHistoryAsync(DescribeSpotPriceHistoryRequest, cb)
	assert(DescribeSpotPriceHistoryRequest, "You must provide a DescribeSpotPriceHistoryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotPriceHistory",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotPriceHistoryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotPriceHistory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotPriceHistoryRequest
-- @return response
-- @return error_message
function M.DescribeSpotPriceHistorySync(DescribeSpotPriceHistoryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotPriceHistoryAsync(DescribeSpotPriceHistoryRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeDhcpOptions asynchronously, invoking a callback when done
-- @param DescribeDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeDhcpOptionsAsync(DescribeDhcpOptionsRequest, cb)
	assert(DescribeDhcpOptionsRequest, "You must provide a DescribeDhcpOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeDhcpOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeDhcpOptionsRequest
-- @return response
-- @return error_message
function M.DescribeDhcpOptionsSync(DescribeDhcpOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeDhcpOptionsAsync(DescribeDhcpOptionsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpcPeeringConnection asynchronously, invoking a callback when done
-- @param DeleteVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpcPeeringConnectionAsync(DeleteVpcPeeringConnectionRequest, cb)
	assert(DeleteVpcPeeringConnectionRequest, "You must provide a DeleteVpcPeeringConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpcPeeringConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcPeeringConnectionRequest
-- @return response
-- @return error_message
function M.DeleteVpcPeeringConnectionSync(DeleteVpcPeeringConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcPeeringConnectionAsync(DeleteVpcPeeringConnectionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFlowLogs asynchronously, invoking a callback when done
-- @param DescribeFlowLogsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeFlowLogsAsync(DescribeFlowLogsRequest, cb)
	assert(DescribeFlowLogsRequest, "You must provide a DescribeFlowLogsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeFlowLogs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeFlowLogsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFlowLogs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFlowLogsRequest
-- @return response
-- @return error_message
function M.DescribeFlowLogsSync(DescribeFlowLogsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFlowLogsAsync(DescribeFlowLogsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkAclEntry asynchronously, invoking a callback when done
-- @param CreateNetworkAclEntryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNetworkAclEntryAsync(CreateNetworkAclEntryRequest, cb)
	assert(CreateNetworkAclEntryRequest, "You must provide a CreateNetworkAclEntryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateNetworkAclEntry",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateNetworkAclEntryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkAclEntry synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkAclEntryRequest
-- @return response
-- @return error_message
function M.CreateNetworkAclEntrySync(CreateNetworkAclEntryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkAclEntryAsync(CreateNetworkAclEntryRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReleaseHosts asynchronously, invoking a callback when done
-- @param ReleaseHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReleaseHostsAsync(ReleaseHostsRequest, cb)
	assert(ReleaseHostsRequest, "You must provide a ReleaseHostsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReleaseHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ReleaseHostsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReleaseHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReleaseHostsRequest
-- @return response
-- @return error_message
function M.ReleaseHostsSync(ReleaseHostsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReleaseHostsAsync(ReleaseHostsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RestoreAddressToClassic asynchronously, invoking a callback when done
-- @param RestoreAddressToClassicRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RestoreAddressToClassicAsync(RestoreAddressToClassicRequest, cb)
	assert(RestoreAddressToClassicRequest, "You must provide a RestoreAddressToClassicRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RestoreAddressToClassic",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RestoreAddressToClassicRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RestoreAddressToClassic synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RestoreAddressToClassicRequest
-- @return response
-- @return error_message
function M.RestoreAddressToClassicSync(RestoreAddressToClassicRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RestoreAddressToClassicAsync(RestoreAddressToClassicRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkInterface asynchronously, invoking a callback when done
-- @param CreateNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNetworkInterfaceAsync(CreateNetworkInterfaceRequest, cb)
	assert(CreateNetworkInterfaceRequest, "You must provide a CreateNetworkInterfaceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateNetworkInterfaceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkInterfaceRequest
-- @return response
-- @return error_message
function M.CreateNetworkInterfaceSync(CreateNetworkInterfaceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkInterfaceAsync(CreateNetworkInterfaceRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeRegions asynchronously, invoking a callback when done
-- @param DescribeRegionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeRegionsAsync(DescribeRegionsRequest, cb)
	assert(DescribeRegionsRequest, "You must provide a DescribeRegionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeRegions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeRegionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeRegions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeRegionsRequest
-- @return response
-- @return error_message
function M.DescribeRegionsSync(DescribeRegionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeRegionsAsync(DescribeRegionsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RevokeSecurityGroupIngress asynchronously, invoking a callback when done
-- @param RevokeSecurityGroupIngressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RevokeSecurityGroupIngressAsync(RevokeSecurityGroupIngressRequest, cb)
	assert(RevokeSecurityGroupIngressRequest, "You must provide a RevokeSecurityGroupIngressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RevokeSecurityGroupIngress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RevokeSecurityGroupIngressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RevokeSecurityGroupIngress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RevokeSecurityGroupIngressRequest
-- @return response
-- @return error_message
function M.RevokeSecurityGroupIngressSync(RevokeSecurityGroupIngressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RevokeSecurityGroupIngressAsync(RevokeSecurityGroupIngressRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call UnassignPrivateIpAddresses asynchronously, invoking a callback when done
-- @param UnassignPrivateIpAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.UnassignPrivateIpAddressesAsync(UnassignPrivateIpAddressesRequest, cb)
	assert(UnassignPrivateIpAddressesRequest, "You must provide a UnassignPrivateIpAddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UnassignPrivateIpAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", UnassignPrivateIpAddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UnassignPrivateIpAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UnassignPrivateIpAddressesRequest
-- @return response
-- @return error_message
function M.UnassignPrivateIpAddressesSync(UnassignPrivateIpAddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UnassignPrivateIpAddressesAsync(UnassignPrivateIpAddressesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachInternetGateway asynchronously, invoking a callback when done
-- @param AttachInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachInternetGatewayAsync(AttachInternetGatewayRequest, cb)
	assert(AttachInternetGatewayRequest, "You must provide a AttachInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachInternetGatewayRequest
-- @return response
-- @return error_message
function M.AttachInternetGatewaySync(AttachInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachInternetGatewayAsync(AttachInternetGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateInstanceExportTask asynchronously, invoking a callback when done
-- @param CreateInstanceExportTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateInstanceExportTaskAsync(CreateInstanceExportTaskRequest, cb)
	assert(CreateInstanceExportTaskRequest, "You must provide a CreateInstanceExportTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateInstanceExportTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateInstanceExportTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateInstanceExportTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateInstanceExportTaskRequest
-- @return response
-- @return error_message
function M.CreateInstanceExportTaskSync(CreateInstanceExportTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateInstanceExportTaskAsync(CreateInstanceExportTaskRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteDhcpOptions asynchronously, invoking a callback when done
-- @param DeleteDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteDhcpOptionsAsync(DeleteDhcpOptionsRequest, cb)
	assert(DeleteDhcpOptionsRequest, "You must provide a DeleteDhcpOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteDhcpOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteDhcpOptionsRequest
-- @return response
-- @return error_message
function M.DeleteDhcpOptionsSync(DeleteDhcpOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteDhcpOptionsAsync(DeleteDhcpOptionsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetNetworkInterfaceAttribute asynchronously, invoking a callback when done
-- @param ResetNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetNetworkInterfaceAttributeAsync(ResetNetworkInterfaceAttributeRequest, cb)
	assert(ResetNetworkInterfaceAttributeRequest, "You must provide a ResetNetworkInterfaceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ResetNetworkInterfaceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ResetNetworkInterfaceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResetNetworkInterfaceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetNetworkInterfaceAttributeRequest
-- @return response
-- @return error_message
function M.ResetNetworkInterfaceAttributeSync(ResetNetworkInterfaceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetNetworkInterfaceAttributeAsync(ResetNetworkInterfaceAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyReservedInstances asynchronously, invoking a callback when done
-- @param ModifyReservedInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyReservedInstancesAsync(ModifyReservedInstancesRequest, cb)
	assert(ModifyReservedInstancesRequest, "You must provide a ModifyReservedInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyReservedInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyReservedInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyReservedInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyReservedInstancesRequest
-- @return response
-- @return error_message
function M.ModifyReservedInstancesSync(ModifyReservedInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyReservedInstancesAsync(ModifyReservedInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachNetworkInterface asynchronously, invoking a callback when done
-- @param DetachNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachNetworkInterfaceAsync(DetachNetworkInterfaceRequest, cb)
	assert(DetachNetworkInterfaceRequest, "You must provide a DetachNetworkInterfaceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachNetworkInterfaceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachNetworkInterfaceRequest
-- @return response
-- @return error_message
function M.DetachNetworkInterfaceSync(DetachNetworkInterfaceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachNetworkInterfaceAsync(DetachNetworkInterfaceRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImportImageTasks asynchronously, invoking a callback when done
-- @param DescribeImportImageTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImportImageTasksAsync(DescribeImportImageTasksRequest, cb)
	assert(DescribeImportImageTasksRequest, "You must provide a DescribeImportImageTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeImportImageTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeImportImageTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImportImageTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImportImageTasksRequest
-- @return response
-- @return error_message
function M.DescribeImportImageTasksSync(DescribeImportImageTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImportImageTasksAsync(DescribeImportImageTasksRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotFleetInstances asynchronously, invoking a callback when done
-- @param DescribeSpotFleetInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotFleetInstancesAsync(DescribeSpotFleetInstancesRequest, cb)
	assert(DescribeSpotFleetInstancesRequest, "You must provide a DescribeSpotFleetInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotFleetInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotFleetInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotFleetInstancesRequest
-- @return response
-- @return error_message
function M.DescribeSpotFleetInstancesSync(DescribeSpotFleetInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotFleetInstancesAsync(DescribeSpotFleetInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVpcClassicLink asynchronously, invoking a callback when done
-- @param EnableVpcClassicLinkRequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVpcClassicLinkAsync(EnableVpcClassicLinkRequest, cb)
	assert(EnableVpcClassicLinkRequest, "You must provide a EnableVpcClassicLinkRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".EnableVpcClassicLink",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", EnableVpcClassicLinkRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVpcClassicLink synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVpcClassicLinkRequest
-- @return response
-- @return error_message
function M.EnableVpcClassicLinkSync(EnableVpcClassicLinkRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVpcClassicLinkAsync(EnableVpcClassicLinkRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateFlowLogs asynchronously, invoking a callback when done
-- @param CreateFlowLogsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateFlowLogsAsync(CreateFlowLogsRequest, cb)
	assert(CreateFlowLogsRequest, "You must provide a CreateFlowLogsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateFlowLogs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateFlowLogsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateFlowLogs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateFlowLogsRequest
-- @return response
-- @return error_message
function M.CreateFlowLogsSync(CreateFlowLogsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateFlowLogsAsync(CreateFlowLogsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateVpcCidrBlock asynchronously, invoking a callback when done
-- @param DisassociateVpcCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateVpcCidrBlockAsync(DisassociateVpcCidrBlockRequest, cb)
	assert(DisassociateVpcCidrBlockRequest, "You must provide a DisassociateVpcCidrBlockRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateVpcCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateVpcCidrBlockRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateVpcCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateVpcCidrBlockRequest
-- @return response
-- @return error_message
function M.DisassociateVpcCidrBlockSync(DisassociateVpcCidrBlockRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateVpcCidrBlockAsync(DisassociateVpcCidrBlockRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumeStatus asynchronously, invoking a callback when done
-- @param DescribeVolumeStatusRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumeStatusAsync(DescribeVolumeStatusRequest, cb)
	assert(DescribeVolumeStatusRequest, "You must provide a DescribeVolumeStatusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVolumeStatus",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVolumeStatusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumeStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumeStatusRequest
-- @return response
-- @return error_message
function M.DescribeVolumeStatusSync(DescribeVolumeStatusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumeStatusAsync(DescribeVolumeStatusRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeHosts asynchronously, invoking a callback when done
-- @param DescribeHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeHostsAsync(DescribeHostsRequest, cb)
	assert(DescribeHostsRequest, "You must provide a DescribeHostsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeHostsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeHostsRequest
-- @return response
-- @return error_message
function M.DescribeHostsSync(DescribeHostsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeHostsAsync(DescribeHostsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcPeeringConnections asynchronously, invoking a callback when done
-- @param DescribeVpcPeeringConnectionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcPeeringConnectionsAsync(DescribeVpcPeeringConnectionsRequest, cb)
	assert(DescribeVpcPeeringConnectionsRequest, "You must provide a DescribeVpcPeeringConnectionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcPeeringConnections",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcPeeringConnectionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcPeeringConnections synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcPeeringConnectionsRequest
-- @return response
-- @return error_message
function M.DescribeVpcPeeringConnectionsSync(DescribeVpcPeeringConnectionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcPeeringConnectionsAsync(DescribeVpcPeeringConnectionsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumes asynchronously, invoking a callback when done
-- @param DescribeVolumesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumesAsync(DescribeVolumesRequest, cb)
	assert(DescribeVolumesRequest, "You must provide a DescribeVolumesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVolumes",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVolumesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumes synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumesRequest
-- @return response
-- @return error_message
function M.DescribeVolumesSync(DescribeVolumesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumesAsync(DescribeVolumesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkInterface asynchronously, invoking a callback when done
-- @param DeleteNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNetworkInterfaceAsync(DeleteNetworkInterfaceRequest, cb)
	assert(DeleteNetworkInterfaceRequest, "You must provide a DeleteNetworkInterfaceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteNetworkInterfaceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkInterfaceRequest
-- @return response
-- @return error_message
function M.DeleteNetworkInterfaceSync(DeleteNetworkInterfaceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkInterfaceAsync(DeleteNetworkInterfaceRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpnConnections asynchronously, invoking a callback when done
-- @param DescribeVpnConnectionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpnConnectionsAsync(DescribeVpnConnectionsRequest, cb)
	assert(DescribeVpnConnectionsRequest, "You must provide a DescribeVpnConnectionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpnConnections",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpnConnectionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpnConnections synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpnConnectionsRequest
-- @return response
-- @return error_message
function M.DescribeVpnConnectionsSync(DescribeVpnConnectionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpnConnectionsAsync(DescribeVpnConnectionsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpcEndpoints asynchronously, invoking a callback when done
-- @param DeleteVpcEndpointsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpcEndpointsAsync(DeleteVpcEndpointsRequest, cb)
	assert(DeleteVpcEndpointsRequest, "You must provide a DeleteVpcEndpointsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpcEndpoints",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpcEndpointsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpcEndpoints synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcEndpointsRequest
-- @return response
-- @return error_message
function M.DeleteVpcEndpointsSync(DeleteVpcEndpointsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcEndpointsAsync(DeleteVpcEndpointsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumeAttribute asynchronously, invoking a callback when done
-- @param DescribeVolumeAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumeAttributeAsync(DescribeVolumeAttributeRequest, cb)
	assert(DescribeVolumeAttributeRequest, "You must provide a DescribeVolumeAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVolumeAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVolumeAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumeAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumeAttributeRequest
-- @return response
-- @return error_message
function M.DescribeVolumeAttributeSync(DescribeVolumeAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumeAttributeAsync(DescribeVolumeAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteKeyPair asynchronously, invoking a callback when done
-- @param DeleteKeyPairRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteKeyPairAsync(DeleteKeyPairRequest, cb)
	assert(DeleteKeyPairRequest, "You must provide a DeleteKeyPairRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteKeyPair",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteKeyPairRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteKeyPair synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteKeyPairRequest
-- @return response
-- @return error_message
function M.DeleteKeyPairSync(DeleteKeyPairRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteKeyPairAsync(DeleteKeyPairRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNatGateway asynchronously, invoking a callback when done
-- @param DeleteNatGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNatGatewayAsync(DeleteNatGatewayRequest, cb)
	assert(DeleteNatGatewayRequest, "You must provide a DeleteNatGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteNatGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteNatGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNatGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNatGatewayRequest
-- @return response
-- @return error_message
function M.DeleteNatGatewaySync(DeleteNatGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNatGatewayAsync(DeleteNatGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyInstancePlacement asynchronously, invoking a callback when done
-- @param ModifyInstancePlacementRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyInstancePlacementAsync(ModifyInstancePlacementRequest, cb)
	assert(ModifyInstancePlacementRequest, "You must provide a ModifyInstancePlacementRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyInstancePlacement",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyInstancePlacementRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyInstancePlacement synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyInstancePlacementRequest
-- @return response
-- @return error_message
function M.ModifyInstancePlacementSync(ModifyInstancePlacementRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyInstancePlacementAsync(ModifyInstancePlacementRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceNetworkAclEntry asynchronously, invoking a callback when done
-- @param ReplaceNetworkAclEntryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceNetworkAclEntryAsync(ReplaceNetworkAclEntryRequest, cb)
	assert(ReplaceNetworkAclEntryRequest, "You must provide a ReplaceNetworkAclEntryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceNetworkAclEntry",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceNetworkAclEntryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceNetworkAclEntry synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceNetworkAclEntryRequest
-- @return response
-- @return error_message
function M.ReplaceNetworkAclEntrySync(ReplaceNetworkAclEntryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceNetworkAclEntryAsync(ReplaceNetworkAclEntryRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateEgressOnlyInternetGateway asynchronously, invoking a callback when done
-- @param CreateEgressOnlyInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateEgressOnlyInternetGatewayAsync(CreateEgressOnlyInternetGatewayRequest, cb)
	assert(CreateEgressOnlyInternetGatewayRequest, "You must provide a CreateEgressOnlyInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateEgressOnlyInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateEgressOnlyInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateEgressOnlyInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateEgressOnlyInternetGatewayRequest
-- @return response
-- @return error_message
function M.CreateEgressOnlyInternetGatewaySync(CreateEgressOnlyInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateEgressOnlyInternetGatewayAsync(CreateEgressOnlyInternetGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteInternetGateway asynchronously, invoking a callback when done
-- @param DeleteInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteInternetGatewayAsync(DeleteInternetGatewayRequest, cb)
	assert(DeleteInternetGatewayRequest, "You must provide a DeleteInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteInternetGatewayRequest
-- @return response
-- @return error_message
function M.DeleteInternetGatewaySync(DeleteInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteInternetGatewayAsync(DeleteInternetGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVolume asynchronously, invoking a callback when done
-- @param CreateVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVolumeAsync(CreateVolumeRequest, cb)
	assert(CreateVolumeRequest, "You must provide a CreateVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVolumeRequest
-- @return response
-- @return error_message
function M.CreateVolumeSync(CreateVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVolumeAsync(CreateVolumeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RunInstances asynchronously, invoking a callback when done
-- @param RunInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RunInstancesAsync(RunInstancesRequest, cb)
	assert(RunInstancesRequest, "You must provide a RunInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RunInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RunInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RunInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RunInstancesRequest
-- @return response
-- @return error_message
function M.RunInstancesSync(RunInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RunInstancesAsync(RunInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeScheduledInstances asynchronously, invoking a callback when done
-- @param DescribeScheduledInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeScheduledInstancesAsync(DescribeScheduledInstancesRequest, cb)
	assert(DescribeScheduledInstancesRequest, "You must provide a DescribeScheduledInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeScheduledInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeScheduledInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeScheduledInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeScheduledInstancesRequest
-- @return response
-- @return error_message
function M.DescribeScheduledInstancesSync(DescribeScheduledInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeScheduledInstancesAsync(DescribeScheduledInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteRoute asynchronously, invoking a callback when done
-- @param DeleteRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteRouteAsync(DeleteRouteRequest, cb)
	assert(DeleteRouteRequest, "You must provide a DeleteRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteRouteRequest
-- @return response
-- @return error_message
function M.DeleteRouteSync(DeleteRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteRouteAsync(DeleteRouteRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableVpcClassicLink asynchronously, invoking a callback when done
-- @param DisableVpcClassicLinkRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisableVpcClassicLinkAsync(DisableVpcClassicLinkRequest, cb)
	assert(DisableVpcClassicLinkRequest, "You must provide a DisableVpcClassicLinkRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisableVpcClassicLink",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DisableVpcClassicLinkRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisableVpcClassicLink synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableVpcClassicLinkRequest
-- @return response
-- @return error_message
function M.DisableVpcClassicLinkSync(DisableVpcClassicLinkRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableVpcClassicLinkAsync(DisableVpcClassicLinkRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachNetworkInterface asynchronously, invoking a callback when done
-- @param AttachNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachNetworkInterfaceAsync(AttachNetworkInterfaceRequest, cb)
	assert(AttachNetworkInterfaceRequest, "You must provide a AttachNetworkInterfaceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachNetworkInterfaceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachNetworkInterfaceRequest
-- @return response
-- @return error_message
function M.AttachNetworkInterfaceSync(AttachNetworkInterfaceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachNetworkInterfaceAsync(AttachNetworkInterfaceRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNatGateway asynchronously, invoking a callback when done
-- @param CreateNatGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNatGatewayAsync(CreateNatGatewayRequest, cb)
	assert(CreateNatGatewayRequest, "You must provide a CreateNatGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateNatGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateNatGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNatGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNatGatewayRequest
-- @return response
-- @return error_message
function M.CreateNatGatewaySync(CreateNatGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNatGatewayAsync(CreateNatGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpnConnectionRoute asynchronously, invoking a callback when done
-- @param DeleteVpnConnectionRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpnConnectionRouteAsync(DeleteVpnConnectionRouteRequest, cb)
	assert(DeleteVpnConnectionRouteRequest, "You must provide a DeleteVpnConnectionRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpnConnectionRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpnConnectionRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpnConnectionRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpnConnectionRouteRequest
-- @return response
-- @return error_message
function M.DeleteVpnConnectionRouteSync(DeleteVpnConnectionRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpnConnectionRouteAsync(DeleteVpnConnectionRouteRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelSpotInstanceRequests asynchronously, invoking a callback when done
-- @param CancelSpotInstanceRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelSpotInstanceRequestsAsync(CancelSpotInstanceRequestsRequest, cb)
	assert(CancelSpotInstanceRequestsRequest, "You must provide a CancelSpotInstanceRequestsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelSpotInstanceRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelSpotInstanceRequestsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelSpotInstanceRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelSpotInstanceRequestsRequest
-- @return response
-- @return error_message
function M.CancelSpotInstanceRequestsSync(CancelSpotInstanceRequestsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelSpotInstanceRequestsAsync(CancelSpotInstanceRequestsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateKeyPair asynchronously, invoking a callback when done
-- @param CreateKeyPairRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateKeyPairAsync(CreateKeyPairRequest, cb)
	assert(CreateKeyPairRequest, "You must provide a CreateKeyPairRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateKeyPair",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateKeyPairRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateKeyPair synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateKeyPairRequest
-- @return response
-- @return error_message
function M.CreateKeyPairSync(CreateKeyPairRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateKeyPairAsync(CreateKeyPairRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkInterfaceAttribute asynchronously, invoking a callback when done
-- @param DescribeNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNetworkInterfaceAttributeAsync(DescribeNetworkInterfaceAttributeRequest, cb)
	assert(DescribeNetworkInterfaceAttributeRequest, "You must provide a DescribeNetworkInterfaceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeNetworkInterfaceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeNetworkInterfaceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkInterfaceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkInterfaceAttributeRequest
-- @return response
-- @return error_message
function M.DescribeNetworkInterfaceAttributeSync(DescribeNetworkInterfaceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkInterfaceAttributeAsync(DescribeNetworkInterfaceAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIdFormat asynchronously, invoking a callback when done
-- @param DescribeIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeIdFormatAsync(DescribeIdFormatRequest, cb)
	assert(DescribeIdFormatRequest, "You must provide a DescribeIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIdFormatRequest
-- @return response
-- @return error_message
function M.DescribeIdFormatSync(DescribeIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIdFormatAsync(DescribeIdFormatRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSnapshot asynchronously, invoking a callback when done
-- @param DeleteSnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSnapshotAsync(DeleteSnapshotRequest, cb)
	assert(DeleteSnapshotRequest, "You must provide a DeleteSnapshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteSnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteSnapshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSnapshotRequest
-- @return response
-- @return error_message
function M.DeleteSnapshotSync(DeleteSnapshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSnapshotAsync(DeleteSnapshotRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMovingAddresses asynchronously, invoking a callback when done
-- @param DescribeMovingAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeMovingAddressesAsync(DescribeMovingAddressesRequest, cb)
	assert(DescribeMovingAddressesRequest, "You must provide a DescribeMovingAddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeMovingAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMovingAddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMovingAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMovingAddressesRequest
-- @return response
-- @return error_message
function M.DescribeMovingAddressesSync(DescribeMovingAddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMovingAddressesAsync(DescribeMovingAddressesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstanceAttribute asynchronously, invoking a callback when done
-- @param DescribeInstanceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInstanceAttributeAsync(DescribeInstanceAttributeRequest, cb)
	assert(DescribeInstanceAttributeRequest, "You must provide a DescribeInstanceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeInstanceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstanceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstanceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstanceAttributeRequest
-- @return response
-- @return error_message
function M.DescribeInstanceAttributeSync(DescribeInstanceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstanceAttributeAsync(DescribeInstanceAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeregisterImage asynchronously, invoking a callback when done
-- @param DeregisterImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeregisterImageAsync(DeregisterImageRequest, cb)
	assert(DeregisterImageRequest, "You must provide a DeregisterImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeregisterImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeregisterImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeregisterImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeregisterImageRequest
-- @return response
-- @return error_message
function M.DeregisterImageSync(DeregisterImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeregisterImageAsync(DeregisterImageRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpnGateway asynchronously, invoking a callback when done
-- @param DeleteVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpnGatewayAsync(DeleteVpnGatewayRequest, cb)
	assert(DeleteVpnGatewayRequest, "You must provide a DeleteVpnGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpnGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpnGatewayRequest
-- @return response
-- @return error_message
function M.DeleteVpnGatewaySync(DeleteVpnGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpnGatewayAsync(DeleteVpnGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReportInstanceStatus asynchronously, invoking a callback when done
-- @param ReportInstanceStatusRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReportInstanceStatusAsync(ReportInstanceStatusRequest, cb)
	assert(ReportInstanceStatusRequest, "You must provide a ReportInstanceStatusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReportInstanceStatus",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ReportInstanceStatusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReportInstanceStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReportInstanceStatusRequest
-- @return response
-- @return error_message
function M.ReportInstanceStatusSync(ReportInstanceStatusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReportInstanceStatusAsync(ReportInstanceStatusRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelReservedInstancesListing asynchronously, invoking a callback when done
-- @param CancelReservedInstancesListingRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelReservedInstancesListingAsync(CancelReservedInstancesListingRequest, cb)
	assert(CancelReservedInstancesListingRequest, "You must provide a CancelReservedInstancesListingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelReservedInstancesListing",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelReservedInstancesListingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelReservedInstancesListing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelReservedInstancesListingRequest
-- @return response
-- @return error_message
function M.CancelReservedInstancesListingSync(CancelReservedInstancesListingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelReservedInstancesListingAsync(CancelReservedInstancesListingRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePrefixLists asynchronously, invoking a callback when done
-- @param DescribePrefixListsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribePrefixListsAsync(DescribePrefixListsRequest, cb)
	assert(DescribePrefixListsRequest, "You must provide a DescribePrefixListsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribePrefixLists",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribePrefixListsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePrefixLists synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePrefixListsRequest
-- @return response
-- @return error_message
function M.DescribePrefixListsSync(DescribePrefixListsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePrefixListsAsync(DescribePrefixListsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSnapshotAttribute asynchronously, invoking a callback when done
-- @param DescribeSnapshotAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSnapshotAttributeAsync(DescribeSnapshotAttributeRequest, cb)
	assert(DescribeSnapshotAttributeRequest, "You must provide a DescribeSnapshotAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSnapshotAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSnapshotAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSnapshotAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSnapshotAttributeRequest
-- @return response
-- @return error_message
function M.DescribeSnapshotAttributeSync(DescribeSnapshotAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSnapshotAttributeAsync(DescribeSnapshotAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call PurchaseReservedInstancesOffering asynchronously, invoking a callback when done
-- @param PurchaseReservedInstancesOfferingRequest
-- @param cb Callback function accepting two args: response, error_message
function M.PurchaseReservedInstancesOfferingAsync(PurchaseReservedInstancesOfferingRequest, cb)
	assert(PurchaseReservedInstancesOfferingRequest, "You must provide a PurchaseReservedInstancesOfferingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".PurchaseReservedInstancesOffering",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", PurchaseReservedInstancesOfferingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call PurchaseReservedInstancesOffering synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PurchaseReservedInstancesOfferingRequest
-- @return response
-- @return error_message
function M.PurchaseReservedInstancesOfferingSync(PurchaseReservedInstancesOfferingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PurchaseReservedInstancesOfferingAsync(PurchaseReservedInstancesOfferingRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifySubnetAttribute asynchronously, invoking a callback when done
-- @param ModifySubnetAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifySubnetAttributeAsync(ModifySubnetAttributeRequest, cb)
	assert(ModifySubnetAttributeRequest, "You must provide a ModifySubnetAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifySubnetAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifySubnetAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifySubnetAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifySubnetAttributeRequest
-- @return response
-- @return error_message
function M.ModifySubnetAttributeSync(ModifySubnetAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifySubnetAttributeAsync(ModifySubnetAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkInterfaces asynchronously, invoking a callback when done
-- @param DescribeNetworkInterfacesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNetworkInterfacesAsync(DescribeNetworkInterfacesRequest, cb)
	assert(DescribeNetworkInterfacesRequest, "You must provide a DescribeNetworkInterfacesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeNetworkInterfaces",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeNetworkInterfacesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkInterfaces synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkInterfacesRequest
-- @return response
-- @return error_message
function M.DescribeNetworkInterfacesSync(DescribeNetworkInterfacesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkInterfacesAsync(DescribeNetworkInterfacesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ConfirmProductInstance asynchronously, invoking a callback when done
-- @param ConfirmProductInstanceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ConfirmProductInstanceAsync(ConfirmProductInstanceRequest, cb)
	assert(ConfirmProductInstanceRequest, "You must provide a ConfirmProductInstanceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ConfirmProductInstance",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ConfirmProductInstanceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ConfirmProductInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ConfirmProductInstanceRequest
-- @return response
-- @return error_message
function M.ConfirmProductInstanceSync(ConfirmProductInstanceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ConfirmProductInstanceAsync(ConfirmProductInstanceRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeExportTasks asynchronously, invoking a callback when done
-- @param DescribeExportTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeExportTasksAsync(DescribeExportTasksRequest, cb)
	assert(DescribeExportTasksRequest, "You must provide a DescribeExportTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeExportTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeExportTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeExportTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeExportTasksRequest
-- @return response
-- @return error_message
function M.DescribeExportTasksSync(DescribeExportTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeExportTasksAsync(DescribeExportTasksRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachInternetGateway asynchronously, invoking a callback when done
-- @param DetachInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachInternetGatewayAsync(DetachInternetGatewayRequest, cb)
	assert(DetachInternetGatewayRequest, "You must provide a DetachInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachInternetGatewayRequest
-- @return response
-- @return error_message
function M.DetachInternetGatewaySync(DetachInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachInternetGatewayAsync(DetachInternetGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkAclEntry asynchronously, invoking a callback when done
-- @param DeleteNetworkAclEntryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNetworkAclEntryAsync(DeleteNetworkAclEntryRequest, cb)
	assert(DeleteNetworkAclEntryRequest, "You must provide a DeleteNetworkAclEntryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteNetworkAclEntry",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteNetworkAclEntryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkAclEntry synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkAclEntryRequest
-- @return response
-- @return error_message
function M.DeleteNetworkAclEntrySync(DeleteNetworkAclEntryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkAclEntryAsync(DeleteNetworkAclEntryRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateFpgaImage asynchronously, invoking a callback when done
-- @param CreateFpgaImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateFpgaImageAsync(CreateFpgaImageRequest, cb)
	assert(CreateFpgaImageRequest, "You must provide a CreateFpgaImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateFpgaImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateFpgaImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateFpgaImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateFpgaImageRequest
-- @return response
-- @return error_message
function M.CreateFpgaImageSync(CreateFpgaImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateFpgaImageAsync(CreateFpgaImageRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateCustomerGateway asynchronously, invoking a callback when done
-- @param CreateCustomerGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateCustomerGatewayAsync(CreateCustomerGatewayRequest, cb)
	assert(CreateCustomerGatewayRequest, "You must provide a CreateCustomerGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateCustomerGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateCustomerGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateCustomerGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateCustomerGatewayRequest
-- @return response
-- @return error_message
function M.CreateCustomerGatewaySync(CreateCustomerGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateCustomerGatewayAsync(CreateCustomerGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetInstanceAttribute asynchronously, invoking a callback when done
-- @param ResetInstanceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetInstanceAttributeAsync(ResetInstanceAttributeRequest, cb)
	assert(ResetInstanceAttributeRequest, "You must provide a ResetInstanceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ResetInstanceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ResetInstanceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResetInstanceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetInstanceAttributeRequest
-- @return response
-- @return error_message
function M.ResetInstanceAttributeSync(ResetInstanceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetInstanceAttributeAsync(ResetInstanceAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSecurityGroup asynchronously, invoking a callback when done
-- @param CreateSecurityGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSecurityGroupAsync(CreateSecurityGroupRequest, cb)
	assert(CreateSecurityGroupRequest, "You must provide a CreateSecurityGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateSecurityGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateSecurityGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSecurityGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSecurityGroupRequest
-- @return response
-- @return error_message
function M.CreateSecurityGroupSync(CreateSecurityGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSecurityGroupAsync(CreateSecurityGroupRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInternetGateways asynchronously, invoking a callback when done
-- @param DescribeInternetGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInternetGatewaysAsync(DescribeInternetGatewaysRequest, cb)
	assert(DescribeInternetGatewaysRequest, "You must provide a DescribeInternetGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeInternetGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInternetGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInternetGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInternetGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeInternetGatewaysSync(DescribeInternetGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInternetGatewaysAsync(DescribeInternetGatewaysRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyNetworkInterfaceAttribute asynchronously, invoking a callback when done
-- @param ModifyNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyNetworkInterfaceAttributeAsync(ModifyNetworkInterfaceAttributeRequest, cb)
	assert(ModifyNetworkInterfaceAttributeRequest, "You must provide a ModifyNetworkInterfaceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyNetworkInterfaceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyNetworkInterfaceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyNetworkInterfaceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyNetworkInterfaceAttributeRequest
-- @return response
-- @return error_message
function M.ModifyNetworkInterfaceAttributeSync(ModifyNetworkInterfaceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyNetworkInterfaceAttributeAsync(ModifyNetworkInterfaceAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachVolume asynchronously, invoking a callback when done
-- @param AttachVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachVolumeAsync(AttachVolumeRequest, cb)
	assert(AttachVolumeRequest, "You must provide a AttachVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachVolumeRequest
-- @return response
-- @return error_message
function M.AttachVolumeSync(AttachVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachVolumeAsync(AttachVolumeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSnapshots asynchronously, invoking a callback when done
-- @param DescribeSnapshotsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSnapshotsAsync(DescribeSnapshotsRequest, cb)
	assert(DescribeSnapshotsRequest, "You must provide a DescribeSnapshotsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSnapshots",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSnapshotsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSnapshots synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSnapshotsRequest
-- @return response
-- @return error_message
function M.DescribeSnapshotsSync(DescribeSnapshotsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSnapshotsAsync(DescribeSnapshotsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call TerminateInstances asynchronously, invoking a callback when done
-- @param TerminateInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.TerminateInstancesAsync(TerminateInstancesRequest, cb)
	assert(TerminateInstancesRequest, "You must provide a TerminateInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".TerminateInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", TerminateInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call TerminateInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param TerminateInstancesRequest
-- @return response
-- @return error_message
function M.TerminateInstancesSync(TerminateInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.TerminateInstancesAsync(TerminateInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AcceptReservedInstancesExchangeQuote asynchronously, invoking a callback when done
-- @param AcceptReservedInstancesExchangeQuoteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AcceptReservedInstancesExchangeQuoteAsync(AcceptReservedInstancesExchangeQuoteRequest, cb)
	assert(AcceptReservedInstancesExchangeQuoteRequest, "You must provide a AcceptReservedInstancesExchangeQuoteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AcceptReservedInstancesExchangeQuote",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AcceptReservedInstancesExchangeQuoteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AcceptReservedInstancesExchangeQuote synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AcceptReservedInstancesExchangeQuoteRequest
-- @return response
-- @return error_message
function M.AcceptReservedInstancesExchangeQuoteSync(AcceptReservedInstancesExchangeQuoteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AcceptReservedInstancesExchangeQuoteAsync(AcceptReservedInstancesExchangeQuoteRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSpotDatafeedSubscription asynchronously, invoking a callback when done
-- @param DeleteSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSpotDatafeedSubscriptionAsync(DeleteSpotDatafeedSubscriptionRequest, cb)
	assert(DeleteSpotDatafeedSubscriptionRequest, "You must provide a DeleteSpotDatafeedSubscriptionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteSpotDatafeedSubscription",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteSpotDatafeedSubscriptionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSpotDatafeedSubscription synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSpotDatafeedSubscriptionRequest
-- @return response
-- @return error_message
function M.DeleteSpotDatafeedSubscriptionSync(DeleteSpotDatafeedSubscriptionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSpotDatafeedSubscriptionAsync(DeleteSpotDatafeedSubscriptionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeletePlacementGroup asynchronously, invoking a callback when done
-- @param DeletePlacementGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeletePlacementGroupAsync(DeletePlacementGroupRequest, cb)
	assert(DeletePlacementGroupRequest, "You must provide a DeletePlacementGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeletePlacementGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeletePlacementGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeletePlacementGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeletePlacementGroupRequest
-- @return response
-- @return error_message
function M.DeletePlacementGroupSync(DeletePlacementGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeletePlacementGroupAsync(DeletePlacementGroupRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteRouteTable asynchronously, invoking a callback when done
-- @param DeleteRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteRouteTableAsync(DeleteRouteTableRequest, cb)
	assert(DeleteRouteTableRequest, "You must provide a DeleteRouteTableRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteRouteTableRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteRouteTableRequest
-- @return response
-- @return error_message
function M.DeleteRouteTableSync(DeleteRouteTableRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteRouteTableAsync(DeleteRouteTableRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeKeyPairs asynchronously, invoking a callback when done
-- @param DescribeKeyPairsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeKeyPairsAsync(DescribeKeyPairsRequest, cb)
	assert(DescribeKeyPairsRequest, "You must provide a DescribeKeyPairsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeKeyPairs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeKeyPairsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeKeyPairs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeKeyPairsRequest
-- @return response
-- @return error_message
function M.DescribeKeyPairsSync(DescribeKeyPairsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeKeyPairsAsync(DescribeKeyPairsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeStaleSecurityGroups asynchronously, invoking a callback when done
-- @param DescribeStaleSecurityGroupsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeStaleSecurityGroupsAsync(DescribeStaleSecurityGroupsRequest, cb)
	assert(DescribeStaleSecurityGroupsRequest, "You must provide a DescribeStaleSecurityGroupsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeStaleSecurityGroups",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeStaleSecurityGroupsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeStaleSecurityGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeStaleSecurityGroupsRequest
-- @return response
-- @return error_message
function M.DescribeStaleSecurityGroupsSync(DescribeStaleSecurityGroupsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeStaleSecurityGroupsAsync(DescribeStaleSecurityGroupsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstancesOfferings asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesOfferingsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesOfferingsAsync(DescribeReservedInstancesOfferingsRequest, cb)
	assert(DescribeReservedInstancesOfferingsRequest, "You must provide a DescribeReservedInstancesOfferingsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesOfferings",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeReservedInstancesOfferingsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstancesOfferings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesOfferingsRequest
-- @return response
-- @return error_message
function M.DescribeReservedInstancesOfferingsSync(DescribeReservedInstancesOfferingsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesOfferingsAsync(DescribeReservedInstancesOfferingsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetConsoleScreenshot asynchronously, invoking a callback when done
-- @param GetConsoleScreenshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetConsoleScreenshotAsync(GetConsoleScreenshotRequest, cb)
	assert(GetConsoleScreenshotRequest, "You must provide a GetConsoleScreenshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetConsoleScreenshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", GetConsoleScreenshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetConsoleScreenshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetConsoleScreenshotRequest
-- @return response
-- @return error_message
function M.GetConsoleScreenshotSync(GetConsoleScreenshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetConsoleScreenshotAsync(GetConsoleScreenshotRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAccountAttributes asynchronously, invoking a callback when done
-- @param DescribeAccountAttributesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeAccountAttributesAsync(DescribeAccountAttributesRequest, cb)
	assert(DescribeAccountAttributesRequest, "You must provide a DescribeAccountAttributesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAccountAttributes",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAccountAttributesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAccountAttributes synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAccountAttributesRequest
-- @return response
-- @return error_message
function M.DescribeAccountAttributesSync(DescribeAccountAttributesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAccountAttributesAsync(DescribeAccountAttributesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssignIpv6Addresses asynchronously, invoking a callback when done
-- @param AssignIpv6AddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssignIpv6AddressesAsync(AssignIpv6AddressesRequest, cb)
	assert(AssignIpv6AddressesRequest, "You must provide a AssignIpv6AddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssignIpv6Addresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AssignIpv6AddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssignIpv6Addresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssignIpv6AddressesRequest
-- @return response
-- @return error_message
function M.AssignIpv6AddressesSync(AssignIpv6AddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssignIpv6AddressesAsync(AssignIpv6AddressesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AuthorizeSecurityGroupEgress asynchronously, invoking a callback when done
-- @param AuthorizeSecurityGroupEgressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AuthorizeSecurityGroupEgressAsync(AuthorizeSecurityGroupEgressRequest, cb)
	assert(AuthorizeSecurityGroupEgressRequest, "You must provide a AuthorizeSecurityGroupEgressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AuthorizeSecurityGroupEgress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AuthorizeSecurityGroupEgressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AuthorizeSecurityGroupEgress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AuthorizeSecurityGroupEgressRequest
-- @return response
-- @return error_message
function M.AuthorizeSecurityGroupEgressSync(AuthorizeSecurityGroupEgressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AuthorizeSecurityGroupEgressAsync(AuthorizeSecurityGroupEgressRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AllocateAddress asynchronously, invoking a callback when done
-- @param AllocateAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AllocateAddressAsync(AllocateAddressRequest, cb)
	assert(AllocateAddressRequest, "You must provide a AllocateAddressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AllocateAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AllocateAddressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AllocateAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AllocateAddressRequest
-- @return response
-- @return error_message
function M.AllocateAddressSync(AllocateAddressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AllocateAddressAsync(AllocateAddressRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AuthorizeSecurityGroupIngress asynchronously, invoking a callback when done
-- @param AuthorizeSecurityGroupIngressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AuthorizeSecurityGroupIngressAsync(AuthorizeSecurityGroupIngressRequest, cb)
	assert(AuthorizeSecurityGroupIngressRequest, "You must provide a AuthorizeSecurityGroupIngressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AuthorizeSecurityGroupIngress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AuthorizeSecurityGroupIngressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AuthorizeSecurityGroupIngress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AuthorizeSecurityGroupIngressRequest
-- @return response
-- @return error_message
function M.AuthorizeSecurityGroupIngressSync(AuthorizeSecurityGroupIngressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AuthorizeSecurityGroupIngressAsync(AuthorizeSecurityGroupIngressRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSpotDatafeedSubscription asynchronously, invoking a callback when done
-- @param CreateSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSpotDatafeedSubscriptionAsync(CreateSpotDatafeedSubscriptionRequest, cb)
	assert(CreateSpotDatafeedSubscriptionRequest, "You must provide a CreateSpotDatafeedSubscriptionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateSpotDatafeedSubscription",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateSpotDatafeedSubscriptionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSpotDatafeedSubscription synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSpotDatafeedSubscriptionRequest
-- @return response
-- @return error_message
function M.CreateSpotDatafeedSubscriptionSync(CreateSpotDatafeedSubscriptionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSpotDatafeedSubscriptionAsync(CreateSpotDatafeedSubscriptionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportInstance asynchronously, invoking a callback when done
-- @param ImportInstanceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportInstanceAsync(ImportInstanceRequest, cb)
	assert(ImportInstanceRequest, "You must provide a ImportInstanceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportInstance",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportInstanceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportInstanceRequest
-- @return response
-- @return error_message
function M.ImportInstanceSync(ImportInstanceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportInstanceAsync(ImportInstanceRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call StopInstances asynchronously, invoking a callback when done
-- @param StopInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.StopInstancesAsync(StopInstancesRequest, cb)
	assert(StopInstancesRequest, "You must provide a StopInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".StopInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", StopInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StopInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StopInstancesRequest
-- @return response
-- @return error_message
function M.StopInstancesSync(StopInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StopInstancesAsync(StopInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReleaseAddress asynchronously, invoking a callback when done
-- @param ReleaseAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReleaseAddressAsync(ReleaseAddressRequest, cb)
	assert(ReleaseAddressRequest, "You must provide a ReleaseAddressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReleaseAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ReleaseAddressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReleaseAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReleaseAddressRequest
-- @return response
-- @return error_message
function M.ReleaseAddressSync(ReleaseAddressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReleaseAddressAsync(ReleaseAddressRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFpgaImages asynchronously, invoking a callback when done
-- @param DescribeFpgaImagesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeFpgaImagesAsync(DescribeFpgaImagesRequest, cb)
	assert(DescribeFpgaImagesRequest, "You must provide a DescribeFpgaImagesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeFpgaImages",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeFpgaImagesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFpgaImages synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFpgaImagesRequest
-- @return response
-- @return error_message
function M.DescribeFpgaImagesSync(DescribeFpgaImagesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFpgaImagesAsync(DescribeFpgaImagesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RejectVpcPeeringConnection asynchronously, invoking a callback when done
-- @param RejectVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RejectVpcPeeringConnectionAsync(RejectVpcPeeringConnectionRequest, cb)
	assert(RejectVpcPeeringConnectionRequest, "You must provide a RejectVpcPeeringConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RejectVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RejectVpcPeeringConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RejectVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RejectVpcPeeringConnectionRequest
-- @return response
-- @return error_message
function M.RejectVpcPeeringConnectionSync(RejectVpcPeeringConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RejectVpcPeeringConnectionAsync(RejectVpcPeeringConnectionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call MonitorInstances asynchronously, invoking a callback when done
-- @param MonitorInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.MonitorInstancesAsync(MonitorInstancesRequest, cb)
	assert(MonitorInstancesRequest, "You must provide a MonitorInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".MonitorInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", MonitorInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call MonitorInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param MonitorInstancesRequest
-- @return response
-- @return error_message
function M.MonitorInstancesSync(MonitorInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.MonitorInstancesAsync(MonitorInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImages asynchronously, invoking a callback when done
-- @param DescribeImagesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImagesAsync(DescribeImagesRequest, cb)
	assert(DescribeImagesRequest, "You must provide a DescribeImagesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeImages",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeImagesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImages synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImagesRequest
-- @return response
-- @return error_message
function M.DescribeImagesSync(DescribeImagesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImagesAsync(DescribeImagesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateRouteTable asynchronously, invoking a callback when done
-- @param DisassociateRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateRouteTableAsync(DisassociateRouteTableRequest, cb)
	assert(DisassociateRouteTableRequest, "You must provide a DisassociateRouteTableRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateRouteTableRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateRouteTableRequest
-- @return response
-- @return error_message
function M.DisassociateRouteTableSync(DisassociateRouteTableRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateRouteTableAsync(DisassociateRouteTableRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceRoute asynchronously, invoking a callback when done
-- @param ReplaceRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceRouteAsync(ReplaceRouteRequest, cb)
	assert(ReplaceRouteRequest, "You must provide a ReplaceRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceRouteRequest
-- @return response
-- @return error_message
function M.ReplaceRouteSync(ReplaceRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceRouteAsync(ReplaceRouteRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateRouteTable asynchronously, invoking a callback when done
-- @param AssociateRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateRouteTableAsync(AssociateRouteTableRequest, cb)
	assert(AssociateRouteTableRequest, "You must provide a AssociateRouteTableRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateRouteTableRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateRouteTableRequest
-- @return response
-- @return error_message
function M.AssociateRouteTableSync(AssociateRouteTableRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateRouteTableAsync(AssociateRouteTableRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpc asynchronously, invoking a callback when done
-- @param DeleteVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpcAsync(DeleteVpcRequest, cb)
	assert(DeleteVpcRequest, "You must provide a DeleteVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcRequest
-- @return response
-- @return error_message
function M.DeleteVpcSync(DeleteVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcAsync(DeleteVpcRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotDatafeedSubscription asynchronously, invoking a callback when done
-- @param DescribeSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotDatafeedSubscriptionAsync(DescribeSpotDatafeedSubscriptionRequest, cb)
	assert(DescribeSpotDatafeedSubscriptionRequest, "You must provide a DescribeSpotDatafeedSubscriptionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotDatafeedSubscription",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotDatafeedSubscriptionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotDatafeedSubscription synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotDatafeedSubscriptionRequest
-- @return response
-- @return error_message
function M.DescribeSpotDatafeedSubscriptionSync(DescribeSpotDatafeedSubscriptionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotDatafeedSubscriptionAsync(DescribeSpotDatafeedSubscriptionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePlacementGroups asynchronously, invoking a callback when done
-- @param DescribePlacementGroupsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribePlacementGroupsAsync(DescribePlacementGroupsRequest, cb)
	assert(DescribePlacementGroupsRequest, "You must provide a DescribePlacementGroupsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribePlacementGroups",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribePlacementGroupsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePlacementGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePlacementGroupsRequest
-- @return response
-- @return error_message
function M.DescribePlacementGroupsSync(DescribePlacementGroupsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePlacementGroupsAsync(DescribePlacementGroupsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstances asynchronously, invoking a callback when done
-- @param DescribeInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInstancesAsync(DescribeInstancesRequest, cb)
	assert(DescribeInstancesRequest, "You must provide a DescribeInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstancesRequest
-- @return response
-- @return error_message
function M.DescribeInstancesSync(DescribeInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstancesAsync(DescribeInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateRoute asynchronously, invoking a callback when done
-- @param CreateRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateRouteAsync(CreateRouteRequest, cb)
	assert(CreateRouteRequest, "You must provide a CreateRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateRouteRequest
-- @return response
-- @return error_message
function M.CreateRouteSync(CreateRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateRouteAsync(CreateRouteRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteEgressOnlyInternetGateway asynchronously, invoking a callback when done
-- @param DeleteEgressOnlyInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteEgressOnlyInternetGatewayAsync(DeleteEgressOnlyInternetGatewayRequest, cb)
	assert(DeleteEgressOnlyInternetGatewayRequest, "You must provide a DeleteEgressOnlyInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteEgressOnlyInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteEgressOnlyInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteEgressOnlyInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteEgressOnlyInternetGatewayRequest
-- @return response
-- @return error_message
function M.DeleteEgressOnlyInternetGatewaySync(DeleteEgressOnlyInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteEgressOnlyInternetGatewayAsync(DeleteEgressOnlyInternetGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSecurityGroups asynchronously, invoking a callback when done
-- @param DescribeSecurityGroupsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSecurityGroupsAsync(DescribeSecurityGroupsRequest, cb)
	assert(DescribeSecurityGroupsRequest, "You must provide a DescribeSecurityGroupsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSecurityGroups",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSecurityGroupsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSecurityGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSecurityGroupsRequest
-- @return response
-- @return error_message
function M.DescribeSecurityGroupsSync(DescribeSecurityGroupsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSecurityGroupsAsync(DescribeSecurityGroupsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateDhcpOptions asynchronously, invoking a callback when done
-- @param CreateDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateDhcpOptionsAsync(CreateDhcpOptionsRequest, cb)
	assert(CreateDhcpOptionsRequest, "You must provide a CreateDhcpOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateDhcpOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateDhcpOptionsRequest
-- @return response
-- @return error_message
function M.CreateDhcpOptionsSync(CreateDhcpOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateDhcpOptionsAsync(CreateDhcpOptionsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RevokeSecurityGroupEgress asynchronously, invoking a callback when done
-- @param RevokeSecurityGroupEgressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RevokeSecurityGroupEgressAsync(RevokeSecurityGroupEgressRequest, cb)
	assert(RevokeSecurityGroupEgressRequest, "You must provide a RevokeSecurityGroupEgressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RevokeSecurityGroupEgress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RevokeSecurityGroupEgressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RevokeSecurityGroupEgress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RevokeSecurityGroupEgressRequest
-- @return response
-- @return error_message
function M.RevokeSecurityGroupEgressSync(RevokeSecurityGroupEgressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RevokeSecurityGroupEgressAsync(RevokeSecurityGroupEgressRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpnGateway asynchronously, invoking a callback when done
-- @param CreateVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpnGatewayAsync(CreateVpnGatewayRequest, cb)
	assert(CreateVpnGatewayRequest, "You must provide a CreateVpnGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpnGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpnGatewayRequest
-- @return response
-- @return error_message
function M.CreateVpnGatewaySync(CreateVpnGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpnGatewayAsync(CreateVpnGatewayRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeBundleTasks asynchronously, invoking a callback when done
-- @param DescribeBundleTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeBundleTasksAsync(DescribeBundleTasksRequest, cb)
	assert(DescribeBundleTasksRequest, "You must provide a DescribeBundleTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeBundleTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeBundleTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeBundleTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeBundleTasksRequest
-- @return response
-- @return error_message
function M.DescribeBundleTasksSync(DescribeBundleTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeBundleTasksAsync(DescribeBundleTasksRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstancesListings asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesListingsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesListingsAsync(DescribeReservedInstancesListingsRequest, cb)
	assert(DescribeReservedInstancesListingsRequest, "You must provide a DescribeReservedInstancesListingsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesListings",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeReservedInstancesListingsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstancesListings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesListingsRequest
-- @return response
-- @return error_message
function M.DescribeReservedInstancesListingsSync(DescribeReservedInstancesListingsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesListingsAsync(DescribeReservedInstancesListingsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetReservedInstancesExchangeQuote asynchronously, invoking a callback when done
-- @param GetReservedInstancesExchangeQuoteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetReservedInstancesExchangeQuoteAsync(GetReservedInstancesExchangeQuoteRequest, cb)
	assert(GetReservedInstancesExchangeQuoteRequest, "You must provide a GetReservedInstancesExchangeQuoteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetReservedInstancesExchangeQuote",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", GetReservedInstancesExchangeQuoteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetReservedInstancesExchangeQuote synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetReservedInstancesExchangeQuoteRequest
-- @return response
-- @return error_message
function M.GetReservedInstancesExchangeQuoteSync(GetReservedInstancesExchangeQuoteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetReservedInstancesExchangeQuoteAsync(GetReservedInstancesExchangeQuoteRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeClassicLinkInstances asynchronously, invoking a callback when done
-- @param DescribeClassicLinkInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeClassicLinkInstancesAsync(DescribeClassicLinkInstancesRequest, cb)
	assert(DescribeClassicLinkInstancesRequest, "You must provide a DescribeClassicLinkInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeClassicLinkInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeClassicLinkInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeClassicLinkInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeClassicLinkInstancesRequest
-- @return response
-- @return error_message
function M.DescribeClassicLinkInstancesSync(DescribeClassicLinkInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeClassicLinkInstancesAsync(DescribeClassicLinkInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifySpotFleetRequest asynchronously, invoking a callback when done
-- @param ModifySpotFleetRequestRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifySpotFleetRequestAsync(ModifySpotFleetRequestRequest, cb)
	assert(ModifySpotFleetRequestRequest, "You must provide a ModifySpotFleetRequestRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifySpotFleetRequest",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifySpotFleetRequestRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifySpotFleetRequest synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifySpotFleetRequestRequest
-- @return response
-- @return error_message
function M.ModifySpotFleetRequestSync(ModifySpotFleetRequestRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifySpotFleetRequestAsync(ModifySpotFleetRequestRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVolume asynchronously, invoking a callback when done
-- @param DeleteVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVolumeAsync(DeleteVolumeRequest, cb)
	assert(DeleteVolumeRequest, "You must provide a DeleteVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVolumeRequest
-- @return response
-- @return error_message
function M.DeleteVolumeSync(DeleteVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVolumeAsync(DeleteVolumeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeConversionTasks asynchronously, invoking a callback when done
-- @param DescribeConversionTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeConversionTasksAsync(DescribeConversionTasksRequest, cb)
	assert(DescribeConversionTasksRequest, "You must provide a DescribeConversionTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeConversionTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeConversionTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeConversionTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeConversionTasksRequest
-- @return response
-- @return error_message
function M.DescribeConversionTasksSync(DescribeConversionTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeConversionTasksAsync(DescribeConversionTasksRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcClassicLinkDnsSupport asynchronously, invoking a callback when done
-- @param DescribeVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcClassicLinkDnsSupportAsync(DescribeVpcClassicLinkDnsSupportRequest, cb)
	assert(DescribeVpcClassicLinkDnsSupportRequest, "You must provide a DescribeVpcClassicLinkDnsSupportRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcClassicLinkDnsSupport",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcClassicLinkDnsSupportRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcClassicLinkDnsSupport synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcClassicLinkDnsSupportRequest
-- @return response
-- @return error_message
function M.DescribeVpcClassicLinkDnsSupportSync(DescribeVpcClassicLinkDnsSupportRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcClassicLinkDnsSupportAsync(DescribeVpcClassicLinkDnsSupportRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSecurityGroup asynchronously, invoking a callback when done
-- @param DeleteSecurityGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSecurityGroupAsync(DeleteSecurityGroupRequest, cb)
	assert(DeleteSecurityGroupRequest, "You must provide a DeleteSecurityGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteSecurityGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteSecurityGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSecurityGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSecurityGroupRequest
-- @return response
-- @return error_message
function M.DeleteSecurityGroupSync(DeleteSecurityGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSecurityGroupAsync(DeleteSecurityGroupRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSubnets asynchronously, invoking a callback when done
-- @param DescribeSubnetsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSubnetsAsync(DescribeSubnetsRequest, cb)
	assert(DescribeSubnetsRequest, "You must provide a DescribeSubnetsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSubnets",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSubnetsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSubnets synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSubnetsRequest
-- @return response
-- @return error_message
function M.DescribeSubnetsSync(DescribeSubnetsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSubnetsAsync(DescribeSubnetsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcClassicLink asynchronously, invoking a callback when done
-- @param DescribeVpcClassicLinkRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcClassicLinkAsync(DescribeVpcClassicLinkRequest, cb)
	assert(DescribeVpcClassicLinkRequest, "You must provide a DescribeVpcClassicLinkRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcClassicLink",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcClassicLinkRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcClassicLink synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcClassicLinkRequest
-- @return response
-- @return error_message
function M.DescribeVpcClassicLinkSync(DescribeVpcClassicLinkRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcClassicLinkAsync(DescribeVpcClassicLinkRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIdentityIdFormat asynchronously, invoking a callback when done
-- @param DescribeIdentityIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeIdentityIdFormatAsync(DescribeIdentityIdFormatRequest, cb)
	assert(DescribeIdentityIdFormatRequest, "You must provide a DescribeIdentityIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeIdentityIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeIdentityIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIdentityIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIdentityIdFormatRequest
-- @return response
-- @return error_message
function M.DescribeIdentityIdFormatSync(DescribeIdentityIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIdentityIdFormatAsync(DescribeIdentityIdFormatRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcPeeringConnectionOptions asynchronously, invoking a callback when done
-- @param ModifyVpcPeeringConnectionOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVpcPeeringConnectionOptionsAsync(ModifyVpcPeeringConnectionOptionsRequest, cb)
	assert(ModifyVpcPeeringConnectionOptionsRequest, "You must provide a ModifyVpcPeeringConnectionOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcPeeringConnectionOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcPeeringConnectionOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcPeeringConnectionOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcPeeringConnectionOptionsRequest
-- @return response
-- @return error_message
function M.ModifyVpcPeeringConnectionOptionsSync(ModifyVpcPeeringConnectionOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcPeeringConnectionOptionsAsync(ModifyVpcPeeringConnectionOptionsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVolumeAttribute asynchronously, invoking a callback when done
-- @param ModifyVolumeAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVolumeAttributeAsync(ModifyVolumeAttributeRequest, cb)
	assert(ModifyVolumeAttributeRequest, "You must provide a ModifyVolumeAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVolumeAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVolumeAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVolumeAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVolumeAttributeRequest
-- @return response
-- @return error_message
function M.ModifyVolumeAttributeSync(ModifyVolumeAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVolumeAttributeAsync(ModifyVolumeAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportVolume asynchronously, invoking a callback when done
-- @param ImportVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportVolumeAsync(ImportVolumeRequest, cb)
	assert(ImportVolumeRequest, "You must provide a ImportVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportVolumeRequest
-- @return response
-- @return error_message
function M.ImportVolumeSync(ImportVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportVolumeAsync(ImportVolumeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportSnapshot asynchronously, invoking a callback when done
-- @param ImportSnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportSnapshotAsync(ImportSnapshotRequest, cb)
	assert(ImportSnapshotRequest, "You must provide a ImportSnapshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportSnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportSnapshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportSnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportSnapshotRequest
-- @return response
-- @return error_message
function M.ImportSnapshotSync(ImportSnapshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportSnapshotAsync(ImportSnapshotRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetConsoleOutput asynchronously, invoking a callback when done
-- @param GetConsoleOutputRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetConsoleOutputAsync(GetConsoleOutputRequest, cb)
	assert(GetConsoleOutputRequest, "You must provide a GetConsoleOutputRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetConsoleOutput",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", GetConsoleOutputRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetConsoleOutput synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetConsoleOutputRequest
-- @return response
-- @return error_message
function M.GetConsoleOutputSync(GetConsoleOutputRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetConsoleOutputAsync(GetConsoleOutputRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeTags asynchronously, invoking a callback when done
-- @param DescribeTagsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeTagsAsync(DescribeTagsRequest, cb)
	assert(DescribeTagsRequest, "You must provide a DescribeTagsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeTags",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeTagsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeTags synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeTagsRequest
-- @return response
-- @return error_message
function M.DescribeTagsSync(DescribeTagsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeTagsAsync(DescribeTagsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVgwRoutePropagation asynchronously, invoking a callback when done
-- @param EnableVgwRoutePropagationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVgwRoutePropagationAsync(EnableVgwRoutePropagationRequest, cb)
	assert(EnableVgwRoutePropagationRequest, "You must provide a EnableVgwRoutePropagationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".EnableVgwRoutePropagation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", EnableVgwRoutePropagationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVgwRoutePropagation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVgwRoutePropagationRequest
-- @return response
-- @return error_message
function M.EnableVgwRoutePropagationSync(EnableVgwRoutePropagationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVgwRoutePropagationAsync(EnableVgwRoutePropagationRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcEndpoint asynchronously, invoking a callback when done
-- @param ModifyVpcEndpointRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVpcEndpointAsync(ModifyVpcEndpointRequest, cb)
	assert(ModifyVpcEndpointRequest, "You must provide a ModifyVpcEndpointRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcEndpoint",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcEndpointRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcEndpoint synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcEndpointRequest
-- @return response
-- @return error_message
function M.ModifyVpcEndpointSync(ModifyVpcEndpointRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcEndpointAsync(ModifyVpcEndpointRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstanceStatus asynchronously, invoking a callback when done
-- @param DescribeInstanceStatusRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInstanceStatusAsync(DescribeInstanceStatusRequest, cb)
	assert(DescribeInstanceStatusRequest, "You must provide a DescribeInstanceStatusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeInstanceStatus",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstanceStatusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstanceStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstanceStatusRequest
-- @return response
-- @return error_message
function M.DescribeInstanceStatusSync(DescribeInstanceStatusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstanceStatusAsync(DescribeInstanceStatusRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcAttribute asynchronously, invoking a callback when done
-- @param ModifyVpcAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVpcAttributeAsync(ModifyVpcAttributeRequest, cb)
	assert(ModifyVpcAttributeRequest, "You must provide a ModifyVpcAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcAttributeRequest
-- @return response
-- @return error_message
function M.ModifyVpcAttributeSync(ModifyVpcAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcAttributeAsync(ModifyVpcAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVolumeIO asynchronously, invoking a callback when done
-- @param EnableVolumeIORequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVolumeIOAsync(EnableVolumeIORequest, cb)
	assert(EnableVolumeIORequest, "You must provide a EnableVolumeIORequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".EnableVolumeIO",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", EnableVolumeIORequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVolumeIO synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVolumeIORequest
-- @return response
-- @return error_message
function M.EnableVolumeIOSync(EnableVolumeIORequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVolumeIOAsync(EnableVolumeIORequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateTags asynchronously, invoking a callback when done
-- @param CreateTagsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateTagsAsync(CreateTagsRequest, cb)
	assert(CreateTagsRequest, "You must provide a CreateTagsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateTags",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateTagsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateTags synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateTagsRequest
-- @return response
-- @return error_message
function M.CreateTagsSync(CreateTagsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateTagsAsync(CreateTagsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSecurityGroupReferences asynchronously, invoking a callback when done
-- @param DescribeSecurityGroupReferencesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSecurityGroupReferencesAsync(DescribeSecurityGroupReferencesRequest, cb)
	assert(DescribeSecurityGroupReferencesRequest, "You must provide a DescribeSecurityGroupReferencesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSecurityGroupReferences",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSecurityGroupReferencesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSecurityGroupReferences synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSecurityGroupReferencesRequest
-- @return response
-- @return error_message
function M.DescribeSecurityGroupReferencesSync(DescribeSecurityGroupReferencesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSecurityGroupReferencesAsync(DescribeSecurityGroupReferencesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteFlowLogs asynchronously, invoking a callback when done
-- @param DeleteFlowLogsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteFlowLogsAsync(DeleteFlowLogsRequest, cb)
	assert(DeleteFlowLogsRequest, "You must provide a DeleteFlowLogsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteFlowLogs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteFlowLogsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteFlowLogs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteFlowLogsRequest
-- @return response
-- @return error_message
function M.DeleteFlowLogsSync(DeleteFlowLogsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteFlowLogsAsync(DeleteFlowLogsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceNetworkAclAssociation asynchronously, invoking a callback when done
-- @param ReplaceNetworkAclAssociationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceNetworkAclAssociationAsync(ReplaceNetworkAclAssociationRequest, cb)
	assert(ReplaceNetworkAclAssociationRequest, "You must provide a ReplaceNetworkAclAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceNetworkAclAssociation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceNetworkAclAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceNetworkAclAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceNetworkAclAssociationRequest
-- @return response
-- @return error_message
function M.ReplaceNetworkAclAssociationSync(ReplaceNetworkAclAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceNetworkAclAssociationAsync(ReplaceNetworkAclAssociationRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpnConnection asynchronously, invoking a callback when done
-- @param CreateVpnConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpnConnectionAsync(CreateVpnConnectionRequest, cb)
	assert(CreateVpnConnectionRequest, "You must provide a CreateVpnConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpnConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpnConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpnConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpnConnectionRequest
-- @return response
-- @return error_message
function M.CreateVpnConnectionSync(CreateVpnConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpnConnectionAsync(CreateVpnConnectionRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachClassicLinkVpc asynchronously, invoking a callback when done
-- @param DetachClassicLinkVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachClassicLinkVpcAsync(DetachClassicLinkVpcRequest, cb)
	assert(DetachClassicLinkVpcRequest, "You must provide a DetachClassicLinkVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachClassicLinkVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachClassicLinkVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachClassicLinkVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachClassicLinkVpcRequest
-- @return response
-- @return error_message
function M.DetachClassicLinkVpcSync(DetachClassicLinkVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachClassicLinkVpcAsync(DetachClassicLinkVpcRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateReservedInstancesListing asynchronously, invoking a callback when done
-- @param CreateReservedInstancesListingRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateReservedInstancesListingAsync(CreateReservedInstancesListingRequest, cb)
	assert(CreateReservedInstancesListingRequest, "You must provide a CreateReservedInstancesListingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateReservedInstancesListing",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateReservedInstancesListingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateReservedInstancesListing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateReservedInstancesListingRequest
-- @return response
-- @return error_message
function M.CreateReservedInstancesListingSync(CreateReservedInstancesListingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateReservedInstancesListingAsync(CreateReservedInstancesListingRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeHostReservations asynchronously, invoking a callback when done
-- @param DescribeHostReservationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeHostReservationsAsync(DescribeHostReservationsRequest, cb)
	assert(DescribeHostReservationsRequest, "You must provide a DescribeHostReservationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeHostReservations",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeHostReservationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeHostReservations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeHostReservationsRequest
-- @return response
-- @return error_message
function M.DescribeHostReservationsSync(DescribeHostReservationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeHostReservationsAsync(DescribeHostReservationsRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeEgressOnlyInternetGateways asynchronously, invoking a callback when done
-- @param DescribeEgressOnlyInternetGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeEgressOnlyInternetGatewaysAsync(DescribeEgressOnlyInternetGatewaysRequest, cb)
	assert(DescribeEgressOnlyInternetGatewaysRequest, "You must provide a DescribeEgressOnlyInternetGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeEgressOnlyInternetGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeEgressOnlyInternetGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeEgressOnlyInternetGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeEgressOnlyInternetGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeEgressOnlyInternetGatewaysSync(DescribeEgressOnlyInternetGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeEgressOnlyInternetGatewaysAsync(DescribeEgressOnlyInternetGatewaysRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyInstanceAttribute asynchronously, invoking a callback when done
-- @param ModifyInstanceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyInstanceAttributeAsync(ModifyInstanceAttributeRequest, cb)
	assert(ModifyInstanceAttributeRequest, "You must provide a ModifyInstanceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyInstanceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyInstanceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyInstanceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyInstanceAttributeRequest
-- @return response
-- @return error_message
function M.ModifyInstanceAttributeSync(ModifyInstanceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyInstanceAttributeAsync(ModifyInstanceAttributeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVolume asynchronously, invoking a callback when done
-- @param ModifyVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVolumeAsync(ModifyVolumeRequest, cb)
	assert(ModifyVolumeRequest, "You must provide a ModifyVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVolumeRequest
-- @return response
-- @return error_message
function M.ModifyVolumeSync(ModifyVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVolumeAsync(ModifyVolumeRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RunScheduledInstances asynchronously, invoking a callback when done
-- @param RunScheduledInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RunScheduledInstancesAsync(RunScheduledInstancesRequest, cb)
	assert(RunScheduledInstancesRequest, "You must provide a RunScheduledInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RunScheduledInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", RunScheduledInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RunScheduledInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RunScheduledInstancesRequest
-- @return response
-- @return error_message
function M.RunScheduledInstancesSync(RunScheduledInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RunScheduledInstancesAsync(RunScheduledInstancesRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeScheduledInstanceAvailability asynchronously, invoking a callback when done
-- @param DescribeScheduledInstanceAvailabilityRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeScheduledInstanceAvailabilityAsync(DescribeScheduledInstanceAvailabilityRequest, cb)
	assert(DescribeScheduledInstanceAvailabilityRequest, "You must provide a DescribeScheduledInstanceAvailabilityRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeScheduledInstanceAvailability",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeScheduledInstanceAvailabilityRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeScheduledInstanceAvailability synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeScheduledInstanceAvailabilityRequest
-- @return response
-- @return error_message
function M.DescribeScheduledInstanceAvailabilitySync(DescribeScheduledInstanceAvailabilityRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeScheduledInstanceAvailabilityAsync(DescribeScheduledInstanceAvailabilityRequest, function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end


return M

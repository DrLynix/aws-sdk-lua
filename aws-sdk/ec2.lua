--- GENERATED CODE - DO NOT MODIFY
-- Amazon Elastic Compute Cloud (ec2-2016-11-15)

local M = {}

M.metadata = {
	api_version = "2016-11-15",
	json_version = "",
	protocol = "ec2",
	checksum_format = "",
	endpoint_prefix = "ec2",
	service_abbreviation = "Amazon EC2",
	service_full_name = "Amazon Elastic Compute Cloud",
	signature_version = "v4",
	target_prefix = "",
	timestamp_format = "",
	global_endpoint = "",
	uid = "ec2-2016-11-15",
}

local NetworkAcl_keys = { "Associations" = true, "NetworkAclId" = true, "VpcId" = true, "Tags" = true, "Entries" = true, "IsDefault" = true, nil }

function M.AssertNetworkAcl(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAcl to be of type 'table'")
	if struct["Associations"] then M.AssertNetworkAclAssociationList(struct["Associations"]) end
	if struct["NetworkAclId"] then M.AssertString(struct["NetworkAclId"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["Entries"] then M.AssertNetworkAclEntryList(struct["Entries"]) end
	if struct["IsDefault"] then M.AssertBoolean(struct["IsDefault"]) end
	for k,_ in pairs(struct) do
		assert(NetworkAcl_keys[k], "NetworkAcl contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAcl
-- <p>Describes a network ACL.</p>
-- @param Associations [NetworkAclAssociationList] <p>Any associations between the network ACL and one or more subnets</p>
-- @param NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param VpcId [String] <p>The ID of the VPC for the network ACL.</p>
-- @param Tags [TagList] <p>Any tags assigned to the network ACL.</p>
-- @param Entries [NetworkAclEntryList] <p>One or more entries (rules) in the network ACL.</p>
-- @param IsDefault [Boolean] <p>Indicates whether this is the default network ACL for the VPC.</p>
function M.NetworkAcl(Associations, NetworkAclId, VpcId, Tags, Entries, IsDefault, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkAcl")
	local t = { 
		["Associations"] = Associations,
		["NetworkAclId"] = NetworkAclId,
		["VpcId"] = VpcId,
		["Tags"] = Tags,
		["Entries"] = Entries,
		["IsDefault"] = IsDefault,
	}
	M.AssertNetworkAcl(t)
	return t
end

local CreateSecurityGroupResult_keys = { "GroupId" = true, nil }

function M.AssertCreateSecurityGroupResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityGroupResult to be of type 'table'")
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(CreateSecurityGroupResult_keys[k], "CreateSecurityGroupResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityGroupResult
-- <p>Contains the output of CreateSecurityGroup.</p>
-- @param GroupId [String] <p>The ID of the security group.</p>
function M.CreateSecurityGroupResult(GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSecurityGroupResult")
	local t = { 
		["GroupId"] = GroupId,
	}
	M.AssertCreateSecurityGroupResult(t)
	return t
end

local CreateFpgaImageResult_keys = { "FpgaImageId" = true, "FpgaImageGlobalId" = true, nil }

function M.AssertCreateFpgaImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFpgaImageResult to be of type 'table'")
	if struct["FpgaImageId"] then M.AssertString(struct["FpgaImageId"]) end
	if struct["FpgaImageGlobalId"] then M.AssertString(struct["FpgaImageGlobalId"]) end
	for k,_ in pairs(struct) do
		assert(CreateFpgaImageResult_keys[k], "CreateFpgaImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFpgaImageResult
--  
-- @param FpgaImageId [String] <p>The FPGA image identifier (AFI ID).</p>
-- @param FpgaImageGlobalId [String] <p>The global FPGA image identifier (AGFI ID).</p>
function M.CreateFpgaImageResult(FpgaImageId, FpgaImageGlobalId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateFpgaImageResult")
	local t = { 
		["FpgaImageId"] = FpgaImageId,
		["FpgaImageGlobalId"] = FpgaImageGlobalId,
	}
	M.AssertCreateFpgaImageResult(t)
	return t
end

local VpcCidrBlockState_keys = { "State" = true, "StatusMessage" = true, nil }

function M.AssertVpcCidrBlockState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcCidrBlockState to be of type 'table'")
	if struct["State"] then M.AssertVpcCidrBlockStateCode(struct["State"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(VpcCidrBlockState_keys[k], "VpcCidrBlockState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcCidrBlockState
-- <p>Describes the state of a CIDR block.</p>
-- @param State [VpcCidrBlockStateCode] <p>The state of the CIDR block.</p>
-- @param StatusMessage [String] <p>A message about the status of the CIDR block, if applicable.</p>
function M.VpcCidrBlockState(State, StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcCidrBlockState")
	local t = { 
		["State"] = State,
		["StatusMessage"] = StatusMessage,
	}
	M.AssertVpcCidrBlockState(t)
	return t
end

local InstanceBlockDeviceMapping_keys = { "DeviceName" = true, "Ebs" = true, nil }

function M.AssertInstanceBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceBlockDeviceMapping to be of type 'table'")
	if struct["DeviceName"] then M.AssertString(struct["DeviceName"]) end
	if struct["Ebs"] then M.AssertEbsInstanceBlockDevice(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(InstanceBlockDeviceMapping_keys[k], "InstanceBlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceBlockDeviceMapping
-- <p>Describes a block device mapping.</p>
-- @param DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param Ebs [EbsInstanceBlockDevice] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
function M.InstanceBlockDeviceMapping(DeviceName, Ebs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceBlockDeviceMapping")
	local t = { 
		["DeviceName"] = DeviceName,
		["Ebs"] = Ebs,
	}
	M.AssertInstanceBlockDeviceMapping(t)
	return t
end

local ImportInstanceTaskDetails_keys = { "InstanceId" = true, "Platform" = true, "Description" = true, "Volumes" = true, nil }

function M.AssertImportInstanceTaskDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceTaskDetails to be of type 'table'")
	assert(struct["Volumes"], "Expected key Volumes to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Platform"] then M.AssertPlatformValues(struct["Platform"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Volumes"] then M.AssertImportInstanceVolumeDetailSet(struct["Volumes"]) end
	for k,_ in pairs(struct) do
		assert(ImportInstanceTaskDetails_keys[k], "ImportInstanceTaskDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceTaskDetails
-- <p>Describes an import instance task.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param Platform [PlatformValues] <p>The instance operating system.</p>
-- @param Description [String] <p>A description of the task.</p>
-- @param Volumes [ImportInstanceVolumeDetailSet] <p>One or more volumes.</p>
-- Required parameter: Volumes
function M.ImportInstanceTaskDetails(InstanceId, Platform, Description, Volumes, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceTaskDetails")
	local t = { 
		["InstanceId"] = InstanceId,
		["Platform"] = Platform,
		["Description"] = Description,
		["Volumes"] = Volumes,
	}
	M.AssertImportInstanceTaskDetails(t)
	return t
end

local DescribeVpnConnectionsResult_keys = { "VpnConnections" = true, nil }

function M.AssertDescribeVpnConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnConnectionsResult to be of type 'table'")
	if struct["VpnConnections"] then M.AssertVpnConnectionList(struct["VpnConnections"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpnConnectionsResult_keys[k], "DescribeVpnConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnConnectionsResult
-- <p>Contains the output of DescribeVpnConnections.</p>
-- @param VpnConnections [VpnConnectionList] <p>Information about one or more VPN connections.</p>
function M.DescribeVpnConnectionsResult(VpnConnections, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpnConnectionsResult")
	local t = { 
		["VpnConnections"] = VpnConnections,
	}
	M.AssertDescribeVpnConnectionsResult(t)
	return t
end

local ReservedInstancesConfiguration_keys = { "Platform" = true, "AvailabilityZone" = true, "Scope" = true, "InstanceType" = true, "InstanceCount" = true, nil }

function M.AssertReservedInstancesConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesConfiguration to be of type 'table'")
	if struct["Platform"] then M.AssertString(struct["Platform"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["Scope"] then M.Assertscope(struct["Scope"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(ReservedInstancesConfiguration_keys[k], "ReservedInstancesConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesConfiguration
-- <p>Describes the configuration settings for the modified Reserved Instances.</p>
-- @param Platform [String] <p>The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone for the modified Reserved Instances.</p>
-- @param Scope [scope] <p>Whether the Reserved Instance is applied to instances in a region or instances in a specific Availability Zone.</p>
-- @param InstanceType [InstanceType] <p>The instance type for the modified Reserved Instances.</p>
-- @param InstanceCount [Integer] <p>The number of modified Reserved Instances.</p>
function M.ReservedInstancesConfiguration(Platform, AvailabilityZone, Scope, InstanceType, InstanceCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesConfiguration")
	local t = { 
		["Platform"] = Platform,
		["AvailabilityZone"] = AvailabilityZone,
		["Scope"] = Scope,
		["InstanceType"] = InstanceType,
		["InstanceCount"] = InstanceCount,
	}
	M.AssertReservedInstancesConfiguration(t)
	return t
end

local CreateVpcPeeringConnectionRequest_keys = { "VpcId" = true, "PeerOwnerId" = true, "PeerVpcId" = true, "DryRun" = true, nil }

function M.AssertCreateVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcPeeringConnectionRequest to be of type 'table'")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["PeerOwnerId"] then M.AssertString(struct["PeerOwnerId"]) end
	if struct["PeerVpcId"] then M.AssertString(struct["PeerVpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpcPeeringConnectionRequest_keys[k], "CreateVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcPeeringConnectionRequest
-- <p>Contains the parameters for CreateVpcPeeringConnection.</p>
-- @param VpcId [String] <p>The ID of the requester VPC.</p>
-- @param PeerOwnerId [String] <p>The AWS account ID of the owner of the peer VPC.</p> <p>Default: Your AWS account ID</p>
-- @param PeerVpcId [String] <p>The ID of the VPC with which you are creating the VPC peering connection.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.CreateVpcPeeringConnectionRequest(VpcId, PeerOwnerId, PeerVpcId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcPeeringConnectionRequest")
	local t = { 
		["VpcId"] = VpcId,
		["PeerOwnerId"] = PeerOwnerId,
		["PeerVpcId"] = PeerVpcId,
		["DryRun"] = DryRun,
	}
	M.AssertCreateVpcPeeringConnectionRequest(t)
	return t
end

local DeleteVpnConnectionRouteRequest_keys = { "VpnConnectionId" = true, "DestinationCidrBlock" = true, nil }

function M.AssertDeleteVpnConnectionRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnConnectionRouteRequest to be of type 'table'")
	assert(struct["DestinationCidrBlock"], "Expected key DestinationCidrBlock to exist in table")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then M.AssertString(struct["VpnConnectionId"]) end
	if struct["DestinationCidrBlock"] then M.AssertString(struct["DestinationCidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(DeleteVpnConnectionRouteRequest_keys[k], "DeleteVpnConnectionRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnConnectionRouteRequest
-- <p>Contains the parameters for DeleteVpnConnectionRoute.</p>
-- @param VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- @param DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer network.</p>
-- Required parameter: DestinationCidrBlock
-- Required parameter: VpnConnectionId
function M.DeleteVpnConnectionRouteRequest(VpnConnectionId, DestinationCidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpnConnectionRouteRequest")
	local t = { 
		["VpnConnectionId"] = VpnConnectionId,
		["DestinationCidrBlock"] = DestinationCidrBlock,
	}
	M.AssertDeleteVpnConnectionRouteRequest(t)
	return t
end

local ScheduledInstancesNetworkInterface_keys = { "PrivateIpAddressConfigs" = true, "DeviceIndex" = true, "Description" = true, "Ipv6AddressCount" = true, "SubnetId" = true, "DeleteOnTermination" = true, "PrivateIpAddress" = true, "Groups" = true, "Ipv6Addresses" = true, "NetworkInterfaceId" = true, "AssociatePublicIpAddress" = true, "SecondaryPrivateIpAddressCount" = true, nil }

function M.AssertScheduledInstancesNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesNetworkInterface to be of type 'table'")
	if struct["PrivateIpAddressConfigs"] then M.AssertPrivateIpAddressConfigSet(struct["PrivateIpAddressConfigs"]) end
	if struct["DeviceIndex"] then M.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then M.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then M.AssertScheduledInstancesSecurityGroupIdSet(struct["Groups"]) end
	if struct["Ipv6Addresses"] then M.AssertScheduledInstancesIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then M.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then M.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstancesNetworkInterface_keys[k], "ScheduledInstancesNetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesNetworkInterface
-- <p>Describes a network interface for a Scheduled Instance.</p>
-- @param PrivateIpAddressConfigs [PrivateIpAddressConfigSet] <p>The private IPv4 addresses.</p>
-- @param DeviceIndex [Integer] <p>The index of the device for the network interface attachment.</p>
-- @param Description [String] <p>The description.</p>
-- @param Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.</p>
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param DeleteOnTermination [Boolean] <p>Indicates whether to delete the interface when the instance is terminated.</p>
-- @param PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- @param Groups [ScheduledInstancesSecurityGroupIdSet] <p>The IDs of one or more security groups.</p>
-- @param Ipv6Addresses [ScheduledInstancesIpv6AddressList] <p>One or more specific IPv6 addresses from the subnet range.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param AssociatePublicIpAddress [Boolean] <p>Indicates whether to assign a public IPv4 address to instances launched in a VPC. The public IPv4 address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>
-- @param SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses.</p>
function M.ScheduledInstancesNetworkInterface(PrivateIpAddressConfigs, DeviceIndex, Description, Ipv6AddressCount, SubnetId, DeleteOnTermination, PrivateIpAddress, Groups, Ipv6Addresses, NetworkInterfaceId, AssociatePublicIpAddress, SecondaryPrivateIpAddressCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesNetworkInterface")
	local t = { 
		["PrivateIpAddressConfigs"] = PrivateIpAddressConfigs,
		["DeviceIndex"] = DeviceIndex,
		["Description"] = Description,
		["Ipv6AddressCount"] = Ipv6AddressCount,
		["SubnetId"] = SubnetId,
		["DeleteOnTermination"] = DeleteOnTermination,
		["PrivateIpAddress"] = PrivateIpAddress,
		["Groups"] = Groups,
		["Ipv6Addresses"] = Ipv6Addresses,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["AssociatePublicIpAddress"] = AssociatePublicIpAddress,
		["SecondaryPrivateIpAddressCount"] = SecondaryPrivateIpAddressCount,
	}
	M.AssertScheduledInstancesNetworkInterface(t)
	return t
end

local GetPasswordDataRequest_keys = { "InstanceId" = true, "DryRun" = true, nil }

function M.AssertGetPasswordDataRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPasswordDataRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(GetPasswordDataRequest_keys[k], "GetPasswordDataRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPasswordDataRequest
-- <p>Contains the parameters for GetPasswordData.</p>
-- @param InstanceId [String] <p>The ID of the Windows instance.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
function M.GetPasswordDataRequest(InstanceId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetPasswordDataRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["DryRun"] = DryRun,
	}
	M.AssertGetPasswordDataRequest(t)
	return t
end

local DescribeImagesResult_keys = { "Images" = true, nil }

function M.AssertDescribeImagesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImagesResult to be of type 'table'")
	if struct["Images"] then M.AssertImageList(struct["Images"]) end
	for k,_ in pairs(struct) do
		assert(DescribeImagesResult_keys[k], "DescribeImagesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImagesResult
-- <p>Contains the output of DescribeImages.</p>
-- @param Images [ImageList] <p>Information about one or more images.</p>
function M.DescribeImagesResult(Images, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImagesResult")
	local t = { 
		["Images"] = Images,
	}
	M.AssertDescribeImagesResult(t)
	return t
end

local PurchaseScheduledInstancesResult_keys = { "ScheduledInstanceSet" = true, nil }

function M.AssertPurchaseScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseScheduledInstancesResult to be of type 'table'")
	if struct["ScheduledInstanceSet"] then M.AssertPurchasedScheduledInstanceSet(struct["ScheduledInstanceSet"]) end
	for k,_ in pairs(struct) do
		assert(PurchaseScheduledInstancesResult_keys[k], "PurchaseScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseScheduledInstancesResult
-- <p>Contains the output of PurchaseScheduledInstances.</p>
-- @param ScheduledInstanceSet [PurchasedScheduledInstanceSet] <p>Information about the Scheduled Instances.</p>
function M.PurchaseScheduledInstancesResult(ScheduledInstanceSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseScheduledInstancesResult")
	local t = { 
		["ScheduledInstanceSet"] = ScheduledInstanceSet,
	}
	M.AssertPurchaseScheduledInstancesResult(t)
	return t
end

local Host_keys = { "HostId" = true, "HostProperties" = true, "State" = true, "Instances" = true, "HostReservationId" = true, "AvailabilityZone" = true, "AvailableCapacity" = true, "ClientToken" = true, "AutoPlacement" = true, nil }

function M.AssertHost(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Host to be of type 'table'")
	if struct["HostId"] then M.AssertString(struct["HostId"]) end
	if struct["HostProperties"] then M.AssertHostProperties(struct["HostProperties"]) end
	if struct["State"] then M.AssertAllocationState(struct["State"]) end
	if struct["Instances"] then M.AssertHostInstanceList(struct["Instances"]) end
	if struct["HostReservationId"] then M.AssertString(struct["HostReservationId"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["AvailableCapacity"] then M.AssertAvailableCapacity(struct["AvailableCapacity"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["AutoPlacement"] then M.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(Host_keys[k], "Host contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Host
-- <p>Describes the properties of the Dedicated Host.</p>
-- @param HostId [String] <p>The ID of the Dedicated Host.</p>
-- @param HostProperties [HostProperties] <p>The hardware specifications of the Dedicated Host.</p>
-- @param State [AllocationState] <p>The Dedicated Host's state.</p>
-- @param Instances [HostInstanceList] <p>The IDs and instance type that are currently running on the Dedicated Host.</p>
-- @param HostReservationId [String] <p>The reservation ID of the Dedicated Host. This returns a <code>null</code> response if the Dedicated Host doesn't have an associated reservation.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone of the Dedicated Host.</p>
-- @param AvailableCapacity [AvailableCapacity] <p>The number of new instances that can be launched onto the Dedicated Host.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. </p>
-- @param AutoPlacement [AutoPlacement] <p>Whether auto-placement is on or off.</p>
function M.Host(HostId, HostProperties, State, Instances, HostReservationId, AvailabilityZone, AvailableCapacity, ClientToken, AutoPlacement, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Host")
	local t = { 
		["HostId"] = HostId,
		["HostProperties"] = HostProperties,
		["State"] = State,
		["Instances"] = Instances,
		["HostReservationId"] = HostReservationId,
		["AvailabilityZone"] = AvailabilityZone,
		["AvailableCapacity"] = AvailableCapacity,
		["ClientToken"] = ClientToken,
		["AutoPlacement"] = AutoPlacement,
	}
	M.AssertHost(t)
	return t
end

local CancelReservedInstancesListingRequest_keys = { "ReservedInstancesListingId" = true, nil }

function M.AssertCancelReservedInstancesListingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelReservedInstancesListingRequest to be of type 'table'")
	assert(struct["ReservedInstancesListingId"], "Expected key ReservedInstancesListingId to exist in table")
	if struct["ReservedInstancesListingId"] then M.AssertString(struct["ReservedInstancesListingId"]) end
	for k,_ in pairs(struct) do
		assert(CancelReservedInstancesListingRequest_keys[k], "CancelReservedInstancesListingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelReservedInstancesListingRequest
-- <p>Contains the parameters for CancelReservedInstancesListing.</p>
-- @param ReservedInstancesListingId [String] <p>The ID of the Reserved Instance listing.</p>
-- Required parameter: ReservedInstancesListingId
function M.CancelReservedInstancesListingRequest(ReservedInstancesListingId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelReservedInstancesListingRequest")
	local t = { 
		["ReservedInstancesListingId"] = ReservedInstancesListingId,
	}
	M.AssertCancelReservedInstancesListingRequest(t)
	return t
end

local CreateSubnetResult_keys = { "Subnet" = true, nil }

function M.AssertCreateSubnetResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSubnetResult to be of type 'table'")
	if struct["Subnet"] then M.AssertSubnet(struct["Subnet"]) end
	for k,_ in pairs(struct) do
		assert(CreateSubnetResult_keys[k], "CreateSubnetResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSubnetResult
-- <p>Contains the output of CreateSubnet.</p>
-- @param Subnet [Subnet] <p>Information about the subnet.</p>
function M.CreateSubnetResult(Subnet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSubnetResult")
	local t = { 
		["Subnet"] = Subnet,
	}
	M.AssertCreateSubnetResult(t)
	return t
end

local DescribeTagsRequest_keys = { "NextToken" = true, "DryRun" = true, "MaxResults" = true, "Filters" = true, nil }

function M.AssertDescribeTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeTagsRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeTagsRequest_keys[k], "DescribeTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeTagsRequest
-- <p>Contains the parameters for DescribeTags.</p>
-- @param NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>key</code> - The tag key.</p> </li> <li> <p> <code>resource-id</code> - The resource ID.</p> </li> <li> <p> <code>resource-type</code> - The resource type (<code>customer-gateway</code> | <code>dhcp-options</code> | <code>image</code> | <code>instance</code> | <code>internet-gateway</code> | <code>network-acl</code> | <code>network-interface</code> | <code>reserved-instances</code> | <code>route-table</code> | <code>security-group</code> | <code>snapshot</code> | <code>spot-instances-request</code> | <code>subnet</code> | <code>volume</code> | <code>vpc</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>).</p> </li> <li> <p> <code>value</code> - The tag value.</p> </li> </ul>
function M.DescribeTagsRequest(NextToken, DryRun, MaxResults, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeTagsRequest")
	local t = { 
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
	}
	M.AssertDescribeTagsRequest(t)
	return t
end

local InstancePrivateIpAddress_keys = { "PrivateDnsName" = true, "PrivateIpAddress" = true, "Primary" = true, "Association" = true, nil }

function M.AssertInstancePrivateIpAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstancePrivateIpAddress to be of type 'table'")
	if struct["PrivateDnsName"] then M.AssertString(struct["PrivateDnsName"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	if struct["Primary"] then M.AssertBoolean(struct["Primary"]) end
	if struct["Association"] then M.AssertInstanceNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(InstancePrivateIpAddress_keys[k], "InstancePrivateIpAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstancePrivateIpAddress
-- <p>Describes a private IPv4 address.</p>
-- @param PrivateDnsName [String] <p>The private IPv4 DNS name.</p>
-- @param PrivateIpAddress [String] <p>The private IPv4 address of the network interface.</p>
-- @param Primary [Boolean] <p>Indicates whether this IPv4 address is the primary private IP address of the network interface.</p>
-- @param Association [InstanceNetworkInterfaceAssociation] <p>The association information for an Elastic IP address for the network interface.</p>
function M.InstancePrivateIpAddress(PrivateDnsName, PrivateIpAddress, Primary, Association, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstancePrivateIpAddress")
	local t = { 
		["PrivateDnsName"] = PrivateDnsName,
		["PrivateIpAddress"] = PrivateIpAddress,
		["Primary"] = Primary,
		["Association"] = Association,
	}
	M.AssertInstancePrivateIpAddress(t)
	return t
end

local CreateInstanceExportTaskRequest_keys = { "InstanceId" = true, "TargetEnvironment" = true, "Description" = true, "ExportToS3Task" = true, nil }

function M.AssertCreateInstanceExportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInstanceExportTaskRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["TargetEnvironment"] then M.AssertExportEnvironment(struct["TargetEnvironment"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["ExportToS3Task"] then M.AssertExportToS3TaskSpecification(struct["ExportToS3Task"]) end
	for k,_ in pairs(struct) do
		assert(CreateInstanceExportTaskRequest_keys[k], "CreateInstanceExportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInstanceExportTaskRequest
-- <p>Contains the parameters for CreateInstanceExportTask.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param TargetEnvironment [ExportEnvironment] <p>The target virtualization environment.</p>
-- @param Description [String] <p>A description for the conversion task or the resource being exported. The maximum length is 255 bytes.</p>
-- @param ExportToS3Task [ExportToS3TaskSpecification] <p>The format and location for an instance export task.</p>
-- Required parameter: InstanceId
function M.CreateInstanceExportTaskRequest(InstanceId, TargetEnvironment, Description, ExportToS3Task, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateInstanceExportTaskRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["TargetEnvironment"] = TargetEnvironment,
		["Description"] = Description,
		["ExportToS3Task"] = ExportToS3Task,
	}
	M.AssertCreateInstanceExportTaskRequest(t)
	return t
end

local CreateInstanceExportTaskResult_keys = { "ExportTask" = true, nil }

function M.AssertCreateInstanceExportTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInstanceExportTaskResult to be of type 'table'")
	if struct["ExportTask"] then M.AssertExportTask(struct["ExportTask"]) end
	for k,_ in pairs(struct) do
		assert(CreateInstanceExportTaskResult_keys[k], "CreateInstanceExportTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInstanceExportTaskResult
-- <p>Contains the output for CreateInstanceExportTask.</p>
-- @param ExportTask [ExportTask] <p>Information about the instance export task.</p>
function M.CreateInstanceExportTaskResult(ExportTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateInstanceExportTaskResult")
	local t = { 
		["ExportTask"] = ExportTask,
	}
	M.AssertCreateInstanceExportTaskResult(t)
	return t
end

local RejectVpcPeeringConnectionRequest_keys = { "DryRun" = true, "VpcPeeringConnectionId" = true, nil }

function M.AssertRejectVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcPeeringConnectionRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(RejectVpcPeeringConnectionRequest_keys[k], "RejectVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcPeeringConnectionRequest
-- <p>Contains the parameters for RejectVpcPeeringConnection.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required parameter: VpcPeeringConnectionId
function M.RejectVpcPeeringConnectionRequest(DryRun, VpcPeeringConnectionId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RejectVpcPeeringConnectionRequest")
	local t = { 
		["DryRun"] = DryRun,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
	}
	M.AssertRejectVpcPeeringConnectionRequest(t)
	return t
end

local CopyImageResult_keys = { "ImageId" = true, nil }

function M.AssertCopyImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyImageResult to be of type 'table'")
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(CopyImageResult_keys[k], "CopyImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyImageResult
-- <p>Contains the output of CopyImage.</p>
-- @param ImageId [String] <p>The ID of the new AMI.</p>
function M.CopyImageResult(ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CopyImageResult")
	local t = { 
		["ImageId"] = ImageId,
	}
	M.AssertCopyImageResult(t)
	return t
end

local Region_keys = { "Endpoint" = true, "RegionName" = true, nil }

function M.AssertRegion(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Region to be of type 'table'")
	if struct["Endpoint"] then M.AssertString(struct["Endpoint"]) end
	if struct["RegionName"] then M.AssertString(struct["RegionName"]) end
	for k,_ in pairs(struct) do
		assert(Region_keys[k], "Region contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Region
-- <p>Describes a region.</p>
-- @param Endpoint [String] <p>The region service endpoint.</p>
-- @param RegionName [String] <p>The name of the region.</p>
function M.Region(Endpoint, RegionName, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Region")
	local t = { 
		["Endpoint"] = Endpoint,
		["RegionName"] = RegionName,
	}
	M.AssertRegion(t)
	return t
end

local AllocateHostsRequest_keys = { "ClientToken" = true, "Quantity" = true, "AvailabilityZone" = true, "InstanceType" = true, "AutoPlacement" = true, nil }

function M.AssertAllocateHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateHostsRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["InstanceType"], "Expected key InstanceType to exist in table")
	assert(struct["Quantity"], "Expected key Quantity to exist in table")
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["Quantity"] then M.AssertInteger(struct["Quantity"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceType"] then M.AssertString(struct["InstanceType"]) end
	if struct["AutoPlacement"] then M.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(AllocateHostsRequest_keys[k], "AllocateHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateHostsRequest
-- <p>Contains the parameters for AllocateHosts.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. </p>
-- @param Quantity [Integer] <p>The number of Dedicated Hosts you want to allocate to your account with these parameters.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone for the Dedicated Hosts.</p>
-- @param InstanceType [String] <p>Specify the instance type that you want your Dedicated Hosts to be configured for. When you specify the instance type, that is the only instance type that you can launch onto that host.</p>
-- @param AutoPlacement [AutoPlacement] <p>This is enabled by default. This property allows instances to be automatically placed onto available Dedicated Hosts, when you are launching instances without specifying a host ID.</p> <p>Default: Enabled</p>
-- Required parameter: AvailabilityZone
-- Required parameter: InstanceType
-- Required parameter: Quantity
function M.AllocateHostsRequest(ClientToken, Quantity, AvailabilityZone, InstanceType, AutoPlacement, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AllocateHostsRequest")
	local t = { 
		["ClientToken"] = ClientToken,
		["Quantity"] = Quantity,
		["AvailabilityZone"] = AvailabilityZone,
		["InstanceType"] = InstanceType,
		["AutoPlacement"] = AutoPlacement,
	}
	M.AssertAllocateHostsRequest(t)
	return t
end

local DescribeSpotFleetRequestHistoryResponse_keys = { "HistoryRecords" = true, "SpotFleetRequestId" = true, "NextToken" = true, "LastEvaluatedTime" = true, "StartTime" = true, nil }

function M.AssertDescribeSpotFleetRequestHistoryResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestHistoryResponse to be of type 'table'")
	assert(struct["HistoryRecords"], "Expected key HistoryRecords to exist in table")
	assert(struct["LastEvaluatedTime"], "Expected key LastEvaluatedTime to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["StartTime"], "Expected key StartTime to exist in table")
	if struct["HistoryRecords"] then M.AssertHistoryRecords(struct["HistoryRecords"]) end
	if struct["SpotFleetRequestId"] then M.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["LastEvaluatedTime"] then M.AssertDateTime(struct["LastEvaluatedTime"]) end
	if struct["StartTime"] then M.AssertDateTime(struct["StartTime"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotFleetRequestHistoryResponse_keys[k], "DescribeSpotFleetRequestHistoryResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestHistoryResponse
-- <p>Contains the output of DescribeSpotFleetRequestHistory.</p>
-- @param HistoryRecords [HistoryRecords] <p>Information about the events in the history of the Spot fleet request.</p>
-- @param SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param LastEvaluatedTime [DateTime] <p>The last date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). All records up to this time were retrieved.</p> <p>If <code>nextToken</code> indicates that there are more results, this value is not present.</p>
-- @param StartTime [DateTime] <p>The starting date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- Required parameter: HistoryRecords
-- Required parameter: LastEvaluatedTime
-- Required parameter: SpotFleetRequestId
-- Required parameter: StartTime
function M.DescribeSpotFleetRequestHistoryResponse(HistoryRecords, SpotFleetRequestId, NextToken, LastEvaluatedTime, StartTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetRequestHistoryResponse")
	local t = { 
		["HistoryRecords"] = HistoryRecords,
		["SpotFleetRequestId"] = SpotFleetRequestId,
		["NextToken"] = NextToken,
		["LastEvaluatedTime"] = LastEvaluatedTime,
		["StartTime"] = StartTime,
	}
	M.AssertDescribeSpotFleetRequestHistoryResponse(t)
	return t
end

local PurchaseReservedInstancesOfferingRequest_keys = { "ReservedInstancesOfferingId" = true, "InstanceCount" = true, "DryRun" = true, "LimitPrice" = true, nil }

function M.AssertPurchaseReservedInstancesOfferingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseReservedInstancesOfferingRequest to be of type 'table'")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["ReservedInstancesOfferingId"], "Expected key ReservedInstancesOfferingId to exist in table")
	if struct["ReservedInstancesOfferingId"] then M.AssertString(struct["ReservedInstancesOfferingId"]) end
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["LimitPrice"] then M.AssertReservedInstanceLimitPrice(struct["LimitPrice"]) end
	for k,_ in pairs(struct) do
		assert(PurchaseReservedInstancesOfferingRequest_keys[k], "PurchaseReservedInstancesOfferingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseReservedInstancesOfferingRequest
-- <p>Contains the parameters for PurchaseReservedInstancesOffering.</p>
-- @param ReservedInstancesOfferingId [String] <p>The ID of the Reserved Instance offering to purchase.</p>
-- @param InstanceCount [Integer] <p>The number of Reserved Instances to purchase.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param LimitPrice [ReservedInstanceLimitPrice] <p>Specified for Reserved Instance Marketplace offerings to limit the total order and ensure that the Reserved Instances are not purchased at unexpected prices.</p>
-- Required parameter: InstanceCount
-- Required parameter: ReservedInstancesOfferingId
function M.PurchaseReservedInstancesOfferingRequest(ReservedInstancesOfferingId, InstanceCount, DryRun, LimitPrice, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseReservedInstancesOfferingRequest")
	local t = { 
		["ReservedInstancesOfferingId"] = ReservedInstancesOfferingId,
		["InstanceCount"] = InstanceCount,
		["DryRun"] = DryRun,
		["LimitPrice"] = LimitPrice,
	}
	M.AssertPurchaseReservedInstancesOfferingRequest(t)
	return t
end

local FlowLog_keys = { "ResourceId" = true, "CreationTime" = true, "LogGroupName" = true, "TrafficType" = true, "FlowLogStatus" = true, "FlowLogId" = true, "DeliverLogsPermissionArn" = true, "DeliverLogsStatus" = true, "DeliverLogsErrorMessage" = true, nil }

function M.AssertFlowLog(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FlowLog to be of type 'table'")
	if struct["ResourceId"] then M.AssertString(struct["ResourceId"]) end
	if struct["CreationTime"] then M.AssertDateTime(struct["CreationTime"]) end
	if struct["LogGroupName"] then M.AssertString(struct["LogGroupName"]) end
	if struct["TrafficType"] then M.AssertTrafficType(struct["TrafficType"]) end
	if struct["FlowLogStatus"] then M.AssertString(struct["FlowLogStatus"]) end
	if struct["FlowLogId"] then M.AssertString(struct["FlowLogId"]) end
	if struct["DeliverLogsPermissionArn"] then M.AssertString(struct["DeliverLogsPermissionArn"]) end
	if struct["DeliverLogsStatus"] then M.AssertString(struct["DeliverLogsStatus"]) end
	if struct["DeliverLogsErrorMessage"] then M.AssertString(struct["DeliverLogsErrorMessage"]) end
	for k,_ in pairs(struct) do
		assert(FlowLog_keys[k], "FlowLog contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FlowLog
-- <p>Describes a flow log.</p>
-- @param ResourceId [String] <p>The ID of the resource on which the flow log was created.</p>
-- @param CreationTime [DateTime] <p>The date and time the flow log was created.</p>
-- @param LogGroupName [String] <p>The name of the flow log group.</p>
-- @param TrafficType [TrafficType] <p>The type of traffic captured for the flow log.</p>
-- @param FlowLogStatus [String] <p>The status of the flow log (<code>ACTIVE</code>).</p>
-- @param FlowLogId [String] <p>The flow log ID.</p>
-- @param DeliverLogsPermissionArn [String] <p>The ARN of the IAM role that posts logs to CloudWatch Logs.</p>
-- @param DeliverLogsStatus [String] <p>The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p>
-- @param DeliverLogsErrorMessage [String] <p>Information about the error that occurred. <code>Rate limited</code> indicates that CloudWatch logs throttling has been applied for one or more network interfaces, or that you've reached the limit on the number of CloudWatch Logs log groups that you can create. <code>Access error</code> indicates that the IAM role associated with the flow log does not have sufficient permissions to publish to CloudWatch Logs. <code>Unknown error</code> indicates an internal error.</p>
function M.FlowLog(ResourceId, CreationTime, LogGroupName, TrafficType, FlowLogStatus, FlowLogId, DeliverLogsPermissionArn, DeliverLogsStatus, DeliverLogsErrorMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating FlowLog")
	local t = { 
		["ResourceId"] = ResourceId,
		["CreationTime"] = CreationTime,
		["LogGroupName"] = LogGroupName,
		["TrafficType"] = TrafficType,
		["FlowLogStatus"] = FlowLogStatus,
		["FlowLogId"] = FlowLogId,
		["DeliverLogsPermissionArn"] = DeliverLogsPermissionArn,
		["DeliverLogsStatus"] = DeliverLogsStatus,
		["DeliverLogsErrorMessage"] = DeliverLogsErrorMessage,
	}
	M.AssertFlowLog(t)
	return t
end

local RequestSpotInstancesRequest_keys = { "InstanceCount" = true, "DryRun" = true, "LaunchGroup" = true, "BlockDurationMinutes" = true, "LaunchSpecification" = true, "AvailabilityZoneGroup" = true, "ClientToken" = true, "ValidUntil" = true, "ValidFrom" = true, "Type" = true, "SpotPrice" = true, nil }

function M.AssertRequestSpotInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotInstancesRequest to be of type 'table'")
	assert(struct["SpotPrice"], "Expected key SpotPrice to exist in table")
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["LaunchGroup"] then M.AssertString(struct["LaunchGroup"]) end
	if struct["BlockDurationMinutes"] then M.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["LaunchSpecification"] then M.AssertRequestSpotLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["AvailabilityZoneGroup"] then M.AssertString(struct["AvailabilityZoneGroup"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["ValidUntil"] then M.AssertDateTime(struct["ValidUntil"]) end
	if struct["ValidFrom"] then M.AssertDateTime(struct["ValidFrom"]) end
	if struct["Type"] then M.AssertSpotInstanceType(struct["Type"]) end
	if struct["SpotPrice"] then M.AssertString(struct["SpotPrice"]) end
	for k,_ in pairs(struct) do
		assert(RequestSpotInstancesRequest_keys[k], "RequestSpotInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotInstancesRequest
-- <p>Contains the parameters for RequestSpotInstances.</p>
-- @param InstanceCount [Integer] <p>The maximum number of Spot instances to launch.</p> <p>Default: 1</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param LaunchGroup [String] <p>The instance launch group. Launch groups are Spot instances that launch together and terminate together.</p> <p>Default: Instances are launched and terminated individually</p>
-- @param BlockDurationMinutes [Integer] <p>The required duration for the Spot instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p> <p>The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.</p> <p>Note that you can't specify an Availability Zone group or a launch group if you specify a duration.</p>
-- @param LaunchSpecification [RequestSpotLaunchSpecification] <p>The launch specification.</p>
-- @param AvailabilityZoneGroup [String] <p>The user-specified name for a logical grouping of bids.</p> <p>When you specify an Availability Zone group in a Spot Instance request, all Spot instances in the request are launched in the same Availability Zone. Instance proximity is maintained with this parameter, but the choice of Availability Zone is not. The group applies only to bids for Spot Instances of the same instance type. Any additional Spot instance requests that are specified with the same Availability Zone group name are launched in that same Availability Zone, as long as at least one instance from the group is still active.</p> <p>If there is no active instance running in the Availability Zone group that you specify for a new Spot instance request (all instances are terminated, the bid is expired, or the bid falls below current market), then Amazon EC2 launches the instance in any Availability Zone where the constraint can be met. Consequently, the subsequent set of Spot instances could be placed in a different zone from the original request, even if you specified the same Availability Zone group.</p> <p>Default: Instances are launched in any available Availability Zone.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param ValidUntil [DateTime] <p>The end date of the request. If this is a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached.</p> <p>Default: The request is effective indefinitely.</p>
-- @param ValidFrom [DateTime] <p>The start date of the request. If this is a one-time request, the request becomes active at this date and time and remains active until all instances launch, the request expires, or the request is canceled. If the request is persistent, the request becomes active at this date and time and remains active until it expires or is canceled.</p> <p>Default: The request is effective indefinitely.</p>
-- @param Type [SpotInstanceType] <p>The Spot instance request type.</p> <p>Default: <code>one-time</code> </p>
-- @param SpotPrice [String] <p>The maximum hourly price (bid) for any Spot instance launched to fulfill the request.</p>
-- Required parameter: SpotPrice
function M.RequestSpotInstancesRequest(InstanceCount, DryRun, LaunchGroup, BlockDurationMinutes, LaunchSpecification, AvailabilityZoneGroup, ClientToken, ValidUntil, ValidFrom, Type, SpotPrice, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotInstancesRequest")
	local t = { 
		["InstanceCount"] = InstanceCount,
		["DryRun"] = DryRun,
		["LaunchGroup"] = LaunchGroup,
		["BlockDurationMinutes"] = BlockDurationMinutes,
		["LaunchSpecification"] = LaunchSpecification,
		["AvailabilityZoneGroup"] = AvailabilityZoneGroup,
		["ClientToken"] = ClientToken,
		["ValidUntil"] = ValidUntil,
		["ValidFrom"] = ValidFrom,
		["Type"] = Type,
		["SpotPrice"] = SpotPrice,
	}
	M.AssertRequestSpotInstancesRequest(t)
	return t
end

local DisableVpcClassicLinkDnsSupportRequest_keys = { "VpcId" = true, nil }

function M.AssertDisableVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(DisableVpcClassicLinkDnsSupportRequest_keys[k], "DisableVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkDnsSupportRequest
-- <p>Contains the parameters for DisableVpcClassicLinkDnsSupport.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
function M.DisableVpcClassicLinkDnsSupportRequest(VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVpcClassicLinkDnsSupportRequest")
	local t = { 
		["VpcId"] = VpcId,
	}
	M.AssertDisableVpcClassicLinkDnsSupportRequest(t)
	return t
end

local BlobAttributeValue_keys = { "Value" = true, nil }

function M.AssertBlobAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BlobAttributeValue to be of type 'table'")
	if struct["Value"] then M.AssertBlob(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(BlobAttributeValue_keys[k], "BlobAttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BlobAttributeValue
--  
-- @param Value [Blob]  
function M.BlobAttributeValue(Value, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BlobAttributeValue")
	local t = { 
		["Value"] = Value,
	}
	M.AssertBlobAttributeValue(t)
	return t
end

local CancelSpotInstanceRequestsRequest_keys = { "SpotInstanceRequestIds" = true, "DryRun" = true, nil }

function M.AssertCancelSpotInstanceRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotInstanceRequestsRequest to be of type 'table'")
	assert(struct["SpotInstanceRequestIds"], "Expected key SpotInstanceRequestIds to exist in table")
	if struct["SpotInstanceRequestIds"] then M.AssertSpotInstanceRequestIdList(struct["SpotInstanceRequestIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(CancelSpotInstanceRequestsRequest_keys[k], "CancelSpotInstanceRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotInstanceRequestsRequest
-- <p>Contains the parameters for CancelSpotInstanceRequests.</p>
-- @param SpotInstanceRequestIds [SpotInstanceRequestIdList] <p>One or more Spot instance request IDs.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: SpotInstanceRequestIds
function M.CancelSpotInstanceRequestsRequest(SpotInstanceRequestIds, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotInstanceRequestsRequest")
	local t = { 
		["SpotInstanceRequestIds"] = SpotInstanceRequestIds,
		["DryRun"] = DryRun,
	}
	M.AssertCancelSpotInstanceRequestsRequest(t)
	return t
end

local DeleteSnapshotRequest_keys = { "SnapshotId" = true, "DryRun" = true, nil }

function M.AssertDeleteSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSnapshotRequest to be of type 'table'")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteSnapshotRequest_keys[k], "DeleteSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSnapshotRequest
-- <p>Contains the parameters for DeleteSnapshot.</p>
-- @param SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: SnapshotId
function M.DeleteSnapshotRequest(SnapshotId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteSnapshotRequest")
	local t = { 
		["SnapshotId"] = SnapshotId,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteSnapshotRequest(t)
	return t
end

local DetachClassicLinkVpcRequest_keys = { "InstanceId" = true, "VpcId" = true, "DryRun" = true, nil }

function M.AssertDetachClassicLinkVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachClassicLinkVpcRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DetachClassicLinkVpcRequest_keys[k], "DetachClassicLinkVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachClassicLinkVpcRequest
-- <p>Contains the parameters for DetachClassicLinkVpc.</p>
-- @param InstanceId [String] <p>The ID of the instance to unlink from the VPC.</p>
-- @param VpcId [String] <p>The ID of the VPC to which the instance is linked.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
-- Required parameter: VpcId
function M.DetachClassicLinkVpcRequest(InstanceId, VpcId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachClassicLinkVpcRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
	}
	M.AssertDetachClassicLinkVpcRequest(t)
	return t
end

local SnapshotTaskDetail_keys = { "Status" = true, "Description" = true, "Format" = true, "Url" = true, "DiskImageSize" = true, "SnapshotId" = true, "Progress" = true, "StatusMessage" = true, "UserBucket" = true, nil }

function M.AssertSnapshotTaskDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotTaskDetail to be of type 'table'")
	if struct["Status"] then M.AssertString(struct["Status"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Format"] then M.AssertString(struct["Format"]) end
	if struct["Url"] then M.AssertString(struct["Url"]) end
	if struct["DiskImageSize"] then M.AssertDouble(struct["DiskImageSize"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	if struct["Progress"] then M.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	if struct["UserBucket"] then M.AssertUserBucketDetails(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(SnapshotTaskDetail_keys[k], "SnapshotTaskDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotTaskDetail
-- <p>Details about the import snapshot task.</p>
-- @param Status [String] <p>A brief status for the import snapshot task.</p>
-- @param Description [String] <p>The description of the snapshot.</p>
-- @param Format [String] <p>The format of the disk image from which the snapshot is created.</p>
-- @param Url [String] <p>The URL of the disk image from which the snapshot is created.</p>
-- @param DiskImageSize [Double] <p>The size of the disk in the snapshot, in GiB.</p>
-- @param SnapshotId [String] <p>The snapshot ID of the disk being imported.</p>
-- @param Progress [String] <p>The percentage of completion for the import snapshot task.</p>
-- @param StatusMessage [String] <p>A detailed status message for the import snapshot task.</p>
-- @param UserBucket [UserBucketDetails] <p>The S3 bucket for the disk image.</p>
function M.SnapshotTaskDetail(Status, Description, Format, Url, DiskImageSize, SnapshotId, Progress, StatusMessage, UserBucket, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SnapshotTaskDetail")
	local t = { 
		["Status"] = Status,
		["Description"] = Description,
		["Format"] = Format,
		["Url"] = Url,
		["DiskImageSize"] = DiskImageSize,
		["SnapshotId"] = SnapshotId,
		["Progress"] = Progress,
		["StatusMessage"] = StatusMessage,
		["UserBucket"] = UserBucket,
	}
	M.AssertSnapshotTaskDetail(t)
	return t
end

local Tag_keys = { "Value" = true, "Key" = true, nil }

function M.AssertTag(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Tag to be of type 'table'")
	if struct["Value"] then M.AssertString(struct["Value"]) end
	if struct["Key"] then M.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(Tag_keys[k], "Tag contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Tag
-- <p>Describes a tag.</p>
-- @param Value [String] <p>The value of the tag.</p> <p>Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.</p>
-- @param Key [String] <p>The key of the tag.</p> <p>Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with <code>aws:</code> </p>
function M.Tag(Value, Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Tag")
	local t = { 
		["Value"] = Value,
		["Key"] = Key,
	}
	M.AssertTag(t)
	return t
end

local ScheduledInstancesPlacement_keys = { "GroupName" = true, "AvailabilityZone" = true, nil }

function M.AssertScheduledInstancesPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesPlacement to be of type 'table'")
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstancesPlacement_keys[k], "ScheduledInstancesPlacement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesPlacement
-- <p>Describes the placement for a Scheduled Instance.</p>
-- @param GroupName [String] <p>The name of the placement group.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone.</p>
function M.ScheduledInstancesPlacement(GroupName, AvailabilityZone, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesPlacement")
	local t = { 
		["GroupName"] = GroupName,
		["AvailabilityZone"] = AvailabilityZone,
	}
	M.AssertScheduledInstancesPlacement(t)
	return t
end

local DescribeFpgaImagesResult_keys = { "FpgaImages" = true, "NextToken" = true, nil }

function M.AssertDescribeFpgaImagesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImagesResult to be of type 'table'")
	if struct["FpgaImages"] then M.AssertFpgaImageList(struct["FpgaImages"]) end
	if struct["NextToken"] then M.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeFpgaImagesResult_keys[k], "DescribeFpgaImagesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImagesResult
--  
-- @param FpgaImages [FpgaImageList] <p>Information about one or more FPGA images.</p>
-- @param NextToken [NextToken] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeFpgaImagesResult(FpgaImages, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeFpgaImagesResult")
	local t = { 
		["FpgaImages"] = FpgaImages,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeFpgaImagesResult(t)
	return t
end

local ModifyInstancePlacementResult_keys = { "Return" = true, nil }

function M.AssertModifyInstancePlacementResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstancePlacementResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(ModifyInstancePlacementResult_keys[k], "ModifyInstancePlacementResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstancePlacementResult
-- <p>Contains the output of ModifyInstancePlacement.</p>
-- @param Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
function M.ModifyInstancePlacementResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyInstancePlacementResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertModifyInstancePlacementResult(t)
	return t
end

local DescribeSecurityGroupReferencesResult_keys = { "SecurityGroupReferenceSet" = true, nil }

function M.AssertDescribeSecurityGroupReferencesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupReferencesResult to be of type 'table'")
	if struct["SecurityGroupReferenceSet"] then M.AssertSecurityGroupReferences(struct["SecurityGroupReferenceSet"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSecurityGroupReferencesResult_keys[k], "DescribeSecurityGroupReferencesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupReferencesResult
--  
-- @param SecurityGroupReferenceSet [SecurityGroupReferences] <p>Information about the VPCs with the referencing security groups.</p>
function M.DescribeSecurityGroupReferencesResult(SecurityGroupReferenceSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSecurityGroupReferencesResult")
	local t = { 
		["SecurityGroupReferenceSet"] = SecurityGroupReferenceSet,
	}
	M.AssertDescribeSecurityGroupReferencesResult(t)
	return t
end

local DescribeDhcpOptionsRequest_keys = { "DhcpOptionsIds" = true, "DryRun" = true, "Filters" = true, nil }

function M.AssertDescribeDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDhcpOptionsRequest to be of type 'table'")
	if struct["DhcpOptionsIds"] then M.AssertDhcpOptionsIdStringList(struct["DhcpOptionsIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeDhcpOptionsRequest_keys[k], "DescribeDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDhcpOptionsRequest
-- <p>Contains the parameters for DescribeDhcpOptions.</p>
-- @param DhcpOptionsIds [DhcpOptionsIdStringList] <p>The IDs of one or more DHCP options sets.</p> <p>Default: Describes all your DHCP options sets.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>dhcp-options-id</code> - The ID of a set of DHCP options.</p> </li> <li> <p> <code>key</code> - The key for one of the options (for example, <code>domain-name</code>).</p> </li> <li> <p> <code>value</code> - The value for one of the options.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
function M.DescribeDhcpOptionsRequest(DhcpOptionsIds, DryRun, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeDhcpOptionsRequest")
	local t = { 
		["DhcpOptionsIds"] = DhcpOptionsIds,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
	}
	M.AssertDescribeDhcpOptionsRequest(t)
	return t
end

local ScheduledInstanceRecurrence_keys = { "OccurrenceDaySet" = true, "Interval" = true, "Frequency" = true, "OccurrenceRelativeToEnd" = true, "OccurrenceUnit" = true, nil }

function M.AssertScheduledInstanceRecurrence(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceRecurrence to be of type 'table'")
	if struct["OccurrenceDaySet"] then M.AssertOccurrenceDaySet(struct["OccurrenceDaySet"]) end
	if struct["Interval"] then M.AssertInteger(struct["Interval"]) end
	if struct["Frequency"] then M.AssertString(struct["Frequency"]) end
	if struct["OccurrenceRelativeToEnd"] then M.AssertBoolean(struct["OccurrenceRelativeToEnd"]) end
	if struct["OccurrenceUnit"] then M.AssertString(struct["OccurrenceUnit"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstanceRecurrence_keys[k], "ScheduledInstanceRecurrence contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceRecurrence
-- <p>Describes the recurring schedule for a Scheduled Instance.</p>
-- @param OccurrenceDaySet [OccurrenceDaySet] <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday).</p>
-- @param Interval [Integer] <p>The interval quantity. The interval unit depends on the value of <code>frequency</code>. For example, every 2 weeks or every 2 months.</p>
-- @param Frequency [String] <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
-- @param OccurrenceRelativeToEnd [Boolean] <p>Indicates whether the occurrence is relative to the end of the specified week or month.</p>
-- @param OccurrenceUnit [String] <p>The unit for <code>occurrenceDaySet</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>).</p>
function M.ScheduledInstanceRecurrence(OccurrenceDaySet, Interval, Frequency, OccurrenceRelativeToEnd, OccurrenceUnit, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstanceRecurrence")
	local t = { 
		["OccurrenceDaySet"] = OccurrenceDaySet,
		["Interval"] = Interval,
		["Frequency"] = Frequency,
		["OccurrenceRelativeToEnd"] = OccurrenceRelativeToEnd,
		["OccurrenceUnit"] = OccurrenceUnit,
	}
	M.AssertScheduledInstanceRecurrence(t)
	return t
end

local DescribeSecurityGroupsResult_keys = { "SecurityGroups" = true, nil }

function M.AssertDescribeSecurityGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupsResult to be of type 'table'")
	if struct["SecurityGroups"] then M.AssertSecurityGroupList(struct["SecurityGroups"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSecurityGroupsResult_keys[k], "DescribeSecurityGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupsResult
-- <p>Contains the output of DescribeSecurityGroups.</p>
-- @param SecurityGroups [SecurityGroupList] <p>Information about one or more security groups.</p>
function M.DescribeSecurityGroupsResult(SecurityGroups, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSecurityGroupsResult")
	local t = { 
		["SecurityGroups"] = SecurityGroups,
	}
	M.AssertDescribeSecurityGroupsResult(t)
	return t
end

local CancelExportTaskRequest_keys = { "ExportTaskId" = true, nil }

function M.AssertCancelExportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelExportTaskRequest to be of type 'table'")
	assert(struct["ExportTaskId"], "Expected key ExportTaskId to exist in table")
	if struct["ExportTaskId"] then M.AssertString(struct["ExportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(CancelExportTaskRequest_keys[k], "CancelExportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelExportTaskRequest
-- <p>Contains the parameters for CancelExportTask.</p>
-- @param ExportTaskId [String] <p>The ID of the export task. This is the ID returned by <code>CreateInstanceExportTask</code>.</p>
-- Required parameter: ExportTaskId
function M.CancelExportTaskRequest(ExportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelExportTaskRequest")
	local t = { 
		["ExportTaskId"] = ExportTaskId,
	}
	M.AssertCancelExportTaskRequest(t)
	return t
end

local ModifyReservedInstancesResult_keys = { "ReservedInstancesModificationId" = true, nil }

function M.AssertModifyReservedInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyReservedInstancesResult to be of type 'table'")
	if struct["ReservedInstancesModificationId"] then M.AssertString(struct["ReservedInstancesModificationId"]) end
	for k,_ in pairs(struct) do
		assert(ModifyReservedInstancesResult_keys[k], "ModifyReservedInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyReservedInstancesResult
-- <p>Contains the output of ModifyReservedInstances.</p>
-- @param ReservedInstancesModificationId [String] <p>The ID for the modification.</p>
function M.ModifyReservedInstancesResult(ReservedInstancesModificationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyReservedInstancesResult")
	local t = { 
		["ReservedInstancesModificationId"] = ReservedInstancesModificationId,
	}
	M.AssertModifyReservedInstancesResult(t)
	return t
end

local DeleteDhcpOptionsRequest_keys = { "DryRun" = true, "DhcpOptionsId" = true, nil }

function M.AssertDeleteDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpOptionsId"], "Expected key DhcpOptionsId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpOptionsId"] then M.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(DeleteDhcpOptionsRequest_keys[k], "DeleteDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteDhcpOptionsRequest
-- <p>Contains the parameters for DeleteDhcpOptions.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param DhcpOptionsId [String] <p>The ID of the DHCP options set.</p>
-- Required parameter: DhcpOptionsId
function M.DeleteDhcpOptionsRequest(DryRun, DhcpOptionsId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteDhcpOptionsRequest")
	local t = { 
		["DryRun"] = DryRun,
		["DhcpOptionsId"] = DhcpOptionsId,
	}
	M.AssertDeleteDhcpOptionsRequest(t)
	return t
end

local CreateEgressOnlyInternetGatewayRequest_keys = { "VpcId" = true, "DryRun" = true, "ClientToken" = true, nil }

function M.AssertCreateEgressOnlyInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateEgressOnlyInternetGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(CreateEgressOnlyInternetGatewayRequest_keys[k], "CreateEgressOnlyInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateEgressOnlyInternetGatewayRequest
--  
-- @param VpcId [String] <p>The ID of the VPC for which to create the egress-only Internet gateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required parameter: VpcId
function M.CreateEgressOnlyInternetGatewayRequest(VpcId, DryRun, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateEgressOnlyInternetGatewayRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
		["ClientToken"] = ClientToken,
	}
	M.AssertCreateEgressOnlyInternetGatewayRequest(t)
	return t
end

local DescribeInstancesResult_keys = { "Reservations" = true, "NextToken" = true, nil }

function M.AssertDescribeInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancesResult to be of type 'table'")
	if struct["Reservations"] then M.AssertReservationList(struct["Reservations"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeInstancesResult_keys[k], "DescribeInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancesResult
-- <p>Contains the output of DescribeInstances.</p>
-- @param Reservations [ReservationList] <p>Zero or more reservations.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeInstancesResult(Reservations, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstancesResult")
	local t = { 
		["Reservations"] = Reservations,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeInstancesResult(t)
	return t
end

local SnapshotDetail_keys = { "Status" = true, "DeviceName" = true, "Description" = true, "Format" = true, "Url" = true, "DiskImageSize" = true, "Progress" = true, "SnapshotId" = true, "StatusMessage" = true, "UserBucket" = true, nil }

function M.AssertSnapshotDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotDetail to be of type 'table'")
	if struct["Status"] then M.AssertString(struct["Status"]) end
	if struct["DeviceName"] then M.AssertString(struct["DeviceName"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Format"] then M.AssertString(struct["Format"]) end
	if struct["Url"] then M.AssertString(struct["Url"]) end
	if struct["DiskImageSize"] then M.AssertDouble(struct["DiskImageSize"]) end
	if struct["Progress"] then M.AssertString(struct["Progress"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	if struct["UserBucket"] then M.AssertUserBucketDetails(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(SnapshotDetail_keys[k], "SnapshotDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotDetail
-- <p>Describes the snapshot created from the imported disk.</p>
-- @param Status [String] <p>A brief status of the snapshot creation.</p>
-- @param DeviceName [String] <p>The block device mapping for the snapshot.</p>
-- @param Description [String] <p>A description for the snapshot.</p>
-- @param Format [String] <p>The format of the disk image from which the snapshot is created.</p>
-- @param Url [String] <p>The URL used to access the disk image.</p>
-- @param DiskImageSize [Double] <p>The size of the disk in the snapshot, in GiB.</p>
-- @param Progress [String] <p>The percentage of progress for the task.</p>
-- @param SnapshotId [String] <p>The snapshot ID of the disk being imported.</p>
-- @param StatusMessage [String] <p>A detailed status message for the snapshot creation.</p>
-- @param UserBucket [UserBucketDetails] <p>The S3 bucket for the disk image.</p>
function M.SnapshotDetail(Status, DeviceName, Description, Format, Url, DiskImageSize, Progress, SnapshotId, StatusMessage, UserBucket, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SnapshotDetail")
	local t = { 
		["Status"] = Status,
		["DeviceName"] = DeviceName,
		["Description"] = Description,
		["Format"] = Format,
		["Url"] = Url,
		["DiskImageSize"] = DiskImageSize,
		["Progress"] = Progress,
		["SnapshotId"] = SnapshotId,
		["StatusMessage"] = StatusMessage,
		["UserBucket"] = UserBucket,
	}
	M.AssertSnapshotDetail(t)
	return t
end

local RequestSpotFleetResponse_keys = { "SpotFleetRequestId" = true, nil }

function M.AssertRequestSpotFleetResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotFleetResponse to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then M.AssertString(struct["SpotFleetRequestId"]) end
	for k,_ in pairs(struct) do
		assert(RequestSpotFleetResponse_keys[k], "RequestSpotFleetResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotFleetResponse
-- <p>Contains the output of RequestSpotFleet.</p>
-- @param SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- Required parameter: SpotFleetRequestId
function M.RequestSpotFleetResponse(SpotFleetRequestId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotFleetResponse")
	local t = { 
		["SpotFleetRequestId"] = SpotFleetRequestId,
	}
	M.AssertRequestSpotFleetResponse(t)
	return t
end

local AssociateRouteTableRequest_keys = { "SubnetId" = true, "RouteTableId" = true, "DryRun" = true, nil }

function M.AssertAssociateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateRouteTableRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(AssociateRouteTableRequest_keys[k], "AssociateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateRouteTableRequest
-- <p>Contains the parameters for AssociateRouteTable.</p>
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param RouteTableId [String] <p>The ID of the route table.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: RouteTableId
-- Required parameter: SubnetId
function M.AssociateRouteTableRequest(SubnetId, RouteTableId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateRouteTableRequest")
	local t = { 
		["SubnetId"] = SubnetId,
		["RouteTableId"] = RouteTableId,
		["DryRun"] = DryRun,
	}
	M.AssertAssociateRouteTableRequest(t)
	return t
end

local HostReservation_keys = { "Count" = true, "End" = true, "HourlyPrice" = true, "InstanceFamily" = true, "CurrencyCode" = true, "OfferingId" = true, "PaymentOption" = true, "State" = true, "HostIdSet" = true, "Start" = true, "HostReservationId" = true, "UpfrontPrice" = true, "Duration" = true, nil }

function M.AssertHostReservation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostReservation to be of type 'table'")
	if struct["Count"] then M.AssertInteger(struct["Count"]) end
	if struct["End"] then M.AssertDateTime(struct["End"]) end
	if struct["HourlyPrice"] then M.AssertString(struct["HourlyPrice"]) end
	if struct["InstanceFamily"] then M.AssertString(struct["InstanceFamily"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["OfferingId"] then M.AssertString(struct["OfferingId"]) end
	if struct["PaymentOption"] then M.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["State"] then M.AssertReservationState(struct["State"]) end
	if struct["HostIdSet"] then M.AssertResponseHostIdSet(struct["HostIdSet"]) end
	if struct["Start"] then M.AssertDateTime(struct["Start"]) end
	if struct["HostReservationId"] then M.AssertString(struct["HostReservationId"]) end
	if struct["UpfrontPrice"] then M.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then M.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(HostReservation_keys[k], "HostReservation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostReservation
-- <p>Details about the Dedicated Host Reservation and associated Dedicated Hosts.</p>
-- @param Count [Integer] <p>The number of Dedicated Hosts the reservation is associated with.</p>
-- @param End [DateTime] <p>The date and time that the reservation ends.</p>
-- @param HourlyPrice [String] <p>The hourly price of the reservation.</p>
-- @param InstanceFamily [String] <p>The instance family of the Dedicated Host Reservation. The instance family on the Dedicated Host must be the same in order for it to benefit from the reservation.</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>upfrontPrice</code> and <code>hourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param OfferingId [String] <p>The ID of the reservation. This remains the same regardless of which Dedicated Hosts are associated with it.</p>
-- @param PaymentOption [PaymentOption] <p>The payment option selected for this reservation.</p>
-- @param State [ReservationState] <p>The state of the reservation.</p>
-- @param HostIdSet [ResponseHostIdSet] <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
-- @param Start [DateTime] <p>The date and time that the reservation started.</p>
-- @param HostReservationId [String] <p>The ID of the reservation that specifies the associated Dedicated Hosts.</p>
-- @param UpfrontPrice [String] <p>The upfront price of the reservation.</p>
-- @param Duration [Integer] <p>The length of the reservation's term, specified in seconds. Can be <code>31536000 (1 year)</code> | <code>94608000 (3 years)</code>.</p>
function M.HostReservation(Count, End, HourlyPrice, InstanceFamily, CurrencyCode, OfferingId, PaymentOption, State, HostIdSet, Start, HostReservationId, UpfrontPrice, Duration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HostReservation")
	local t = { 
		["Count"] = Count,
		["End"] = End,
		["HourlyPrice"] = HourlyPrice,
		["InstanceFamily"] = InstanceFamily,
		["CurrencyCode"] = CurrencyCode,
		["OfferingId"] = OfferingId,
		["PaymentOption"] = PaymentOption,
		["State"] = State,
		["HostIdSet"] = HostIdSet,
		["Start"] = Start,
		["HostReservationId"] = HostReservationId,
		["UpfrontPrice"] = UpfrontPrice,
		["Duration"] = Duration,
	}
	M.AssertHostReservation(t)
	return t
end

local ResetNetworkInterfaceAttributeRequest_keys = { "NetworkInterfaceId" = true, "DryRun" = true, "SourceDestCheck" = true, nil }

function M.AssertResetNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["SourceDestCheck"] then M.AssertString(struct["SourceDestCheck"]) end
	for k,_ in pairs(struct) do
		assert(ResetNetworkInterfaceAttributeRequest_keys[k], "ResetNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for ResetNetworkInterfaceAttribute.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param SourceDestCheck [String] <p>The source/destination checking attribute. Resets the value to <code>true</code>.</p>
-- Required parameter: NetworkInterfaceId
function M.ResetNetworkInterfaceAttributeRequest(NetworkInterfaceId, DryRun, SourceDestCheck, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ResetNetworkInterfaceAttributeRequest")
	local t = { 
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["DryRun"] = DryRun,
		["SourceDestCheck"] = SourceDestCheck,
	}
	M.AssertResetNetworkInterfaceAttributeRequest(t)
	return t
end

local NetworkInterfacePrivateIpAddress_keys = { "PrivateDnsName" = true, "PrivateIpAddress" = true, "Primary" = true, "Association" = true, nil }

function M.AssertNetworkInterfacePrivateIpAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfacePrivateIpAddress to be of type 'table'")
	if struct["PrivateDnsName"] then M.AssertString(struct["PrivateDnsName"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	if struct["Primary"] then M.AssertBoolean(struct["Primary"]) end
	if struct["Association"] then M.AssertNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(NetworkInterfacePrivateIpAddress_keys[k], "NetworkInterfacePrivateIpAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfacePrivateIpAddress
-- <p>Describes the private IPv4 address of a network interface.</p>
-- @param PrivateDnsName [String] <p>The private DNS name.</p>
-- @param PrivateIpAddress [String] <p>The private IPv4 address.</p>
-- @param Primary [Boolean] <p>Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.</p>
-- @param Association [NetworkInterfaceAssociation] <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
function M.NetworkInterfacePrivateIpAddress(PrivateDnsName, PrivateIpAddress, Primary, Association, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfacePrivateIpAddress")
	local t = { 
		["PrivateDnsName"] = PrivateDnsName,
		["PrivateIpAddress"] = PrivateIpAddress,
		["Primary"] = Primary,
		["Association"] = Association,
	}
	M.AssertNetworkInterfacePrivateIpAddress(t)
	return t
end

local DescribeFlowLogsRequest_keys = { "Filter" = true, "NextToken" = true, "MaxResults" = true, "FlowLogIds" = true, nil }

function M.AssertDescribeFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFlowLogsRequest to be of type 'table'")
	if struct["Filter"] then M.AssertFilterList(struct["Filter"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["FlowLogIds"] then M.AssertValueStringList(struct["FlowLogIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeFlowLogsRequest_keys[k], "DescribeFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFlowLogsRequest
-- <p>Contains the parameters for DescribeFlowLogs.</p>
-- @param Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>deliver-log-status</code> - The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p> </li> <li> <p> <code>flow-log-id</code> - The ID of the flow log.</p> </li> <li> <p> <code>log-group-name</code> - The name of the log group.</p> </li> <li> <p> <code>resource-id</code> - The ID of the VPC, subnet, or network interface.</p> </li> <li> <p> <code>traffic-type</code> - The type of traffic (<code>ACCEPT</code> | <code>REJECT</code> | <code>ALL</code>)</p> </li> </ul>
-- @param NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the flow log IDs parameter in the same request.</p>
-- @param FlowLogIds [ValueStringList] <p>One or more flow log IDs.</p>
function M.DescribeFlowLogsRequest(Filter, NextToken, MaxResults, FlowLogIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeFlowLogsRequest")
	local t = { 
		["Filter"] = Filter,
		["NextToken"] = NextToken,
		["MaxResults"] = MaxResults,
		["FlowLogIds"] = FlowLogIds,
	}
	M.AssertDescribeFlowLogsRequest(t)
	return t
end

local SpotInstanceStatus_keys = { "Message" = true, "Code" = true, "UpdateTime" = true, nil }

function M.AssertSpotInstanceStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceStatus to be of type 'table'")
	if struct["Message"] then M.AssertString(struct["Message"]) end
	if struct["Code"] then M.AssertString(struct["Code"]) end
	if struct["UpdateTime"] then M.AssertDateTime(struct["UpdateTime"]) end
	for k,_ in pairs(struct) do
		assert(SpotInstanceStatus_keys[k], "SpotInstanceStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceStatus
-- <p>Describes the status of a Spot instance request.</p>
-- @param Message [String] <p>The description for the status code.</p>
-- @param Code [String] <p>The status code. For a list of status codes, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html#spot-instance-bid-status-understand">Spot Bid Status Codes</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param UpdateTime [DateTime] <p>The date and time of the most recent status update, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
function M.SpotInstanceStatus(Message, Code, UpdateTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotInstanceStatus")
	local t = { 
		["Message"] = Message,
		["Code"] = Code,
		["UpdateTime"] = UpdateTime,
	}
	M.AssertSpotInstanceStatus(t)
	return t
end

local CreateFpgaImageRequest_keys = { "DryRun" = true, "Name" = true, "LogsStorageLocation" = true, "InputStorageLocation" = true, "ClientToken" = true, "Description" = true, nil }

function M.AssertCreateFpgaImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFpgaImageRequest to be of type 'table'")
	assert(struct["InputStorageLocation"], "Expected key InputStorageLocation to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Name"] then M.AssertString(struct["Name"]) end
	if struct["LogsStorageLocation"] then M.AssertStorageLocation(struct["LogsStorageLocation"]) end
	if struct["InputStorageLocation"] then M.AssertStorageLocation(struct["InputStorageLocation"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(CreateFpgaImageRequest_keys[k], "CreateFpgaImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFpgaImageRequest
--  
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Name [String] <p>A name for the AFI.</p>
-- @param LogsStorageLocation [StorageLocation] <p>The location in Amazon S3 for the output logs.</p>
-- @param InputStorageLocation [StorageLocation] <p>The location of the encrypted design checkpoint in Amazon S3. The input must be a tarball.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- @param Description [String] <p>A description for the AFI.</p>
-- Required parameter: InputStorageLocation
function M.CreateFpgaImageRequest(DryRun, Name, LogsStorageLocation, InputStorageLocation, ClientToken, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateFpgaImageRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Name"] = Name,
		["LogsStorageLocation"] = LogsStorageLocation,
		["InputStorageLocation"] = InputStorageLocation,
		["ClientToken"] = ClientToken,
		["Description"] = Description,
	}
	M.AssertCreateFpgaImageRequest(t)
	return t
end

local LaunchPermission_keys = { "UserId" = true, "Group" = true, nil }

function M.AssertLaunchPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchPermission to be of type 'table'")
	if struct["UserId"] then M.AssertString(struct["UserId"]) end
	if struct["Group"] then M.AssertPermissionGroup(struct["Group"]) end
	for k,_ in pairs(struct) do
		assert(LaunchPermission_keys[k], "LaunchPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchPermission
-- <p>Describes a launch permission.</p>
-- @param UserId [String] <p>The AWS account ID.</p>
-- @param Group [PermissionGroup] <p>The name of the group.</p>
function M.LaunchPermission(UserId, Group, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating LaunchPermission")
	local t = { 
		["UserId"] = UserId,
		["Group"] = Group,
	}
	M.AssertLaunchPermission(t)
	return t
end

local DescribeInstanceStatusRequest_keys = { "DryRun" = true, "IncludeAllInstances" = true, "MaxResults" = true, "Filters" = true, "NextToken" = true, "InstanceIds" = true, nil }

function M.AssertDescribeInstanceStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceStatusRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["IncludeAllInstances"] then M.AssertBoolean(struct["IncludeAllInstances"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["InstanceIds"] then M.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeInstanceStatusRequest_keys[k], "DescribeInstanceStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceStatusRequest
-- <p>Contains the parameters for DescribeInstanceStatus.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param IncludeAllInstances [Boolean] <p>When <code>true</code>, includes the health status for all instances. When <code>false</code>, includes the health status for running instances only.</p> <p>Default: <code>false</code> </p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter in the same call.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>event.code</code> - The code for the scheduled event (<code>instance-reboot</code> | <code>system-reboot</code> | <code>system-maintenance</code> | <code>instance-retirement</code> | <code>instance-stop</code>).</p> </li> <li> <p> <code>event.description</code> - A description of the event.</p> </li> <li> <p> <code>event.not-after</code> - The latest end time for the scheduled event (for example, <code>2014-09-15T17:15:20.000Z</code>).</p> </li> <li> <p> <code>event.not-before</code> - The earliest start time for the scheduled event (for example, <code>2014-09-15T17:15:20.000Z</code>).</p> </li> <li> <p> <code>instance-state-code</code> - The code for the instance state, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).</p> </li> <li> <p> <code>instance-state-name</code> - The state of the instance (<code>pending</code> | <code>running</code> | <code>shutting-down</code> | <code>terminated</code> | <code>stopping</code> | <code>stopped</code>).</p> </li> <li> <p> <code>instance-status.reachability</code> - Filters on instance status where the name is <code>reachability</code> (<code>passed</code> | <code>failed</code> | <code>initializing</code> | <code>insufficient-data</code>).</p> </li> <li> <p> <code>instance-status.status</code> - The status of the instance (<code>ok</code> | <code>impaired</code> | <code>initializing</code> | <code>insufficient-data</code> | <code>not-applicable</code>).</p> </li> <li> <p> <code>system-status.reachability</code> - Filters on system status where the name is <code>reachability</code> (<code>passed</code> | <code>failed</code> | <code>initializing</code> | <code>insufficient-data</code>).</p> </li> <li> <p> <code>system-status.status</code> - The system status of the instance (<code>ok</code> | <code>impaired</code> | <code>initializing</code> | <code>insufficient-data</code> | <code>not-applicable</code>).</p> </li> </ul>
-- @param NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Default: Describes all your instances.</p> <p>Constraints: Maximum 100 explicitly specified instance IDs.</p>
function M.DescribeInstanceStatusRequest(DryRun, IncludeAllInstances, MaxResults, Filters, NextToken, InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstanceStatusRequest")
	local t = { 
		["DryRun"] = DryRun,
		["IncludeAllInstances"] = IncludeAllInstances,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
		["NextToken"] = NextToken,
		["InstanceIds"] = InstanceIds,
	}
	M.AssertDescribeInstanceStatusRequest(t)
	return t
end

local ImportSnapshotTask_keys = { "SnapshotTaskDetail" = true, "Description" = true, "ImportTaskId" = true, nil }

function M.AssertImportSnapshotTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotTask to be of type 'table'")
	if struct["SnapshotTaskDetail"] then M.AssertSnapshotTaskDetail(struct["SnapshotTaskDetail"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["ImportTaskId"] then M.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(ImportSnapshotTask_keys[k], "ImportSnapshotTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotTask
-- <p>Describes an import snapshot task.</p>
-- @param SnapshotTaskDetail [SnapshotTaskDetail] <p>Describes an import snapshot task.</p>
-- @param Description [String] <p>A description of the import snapshot task.</p>
-- @param ImportTaskId [String] <p>The ID of the import snapshot task.</p>
function M.ImportSnapshotTask(SnapshotTaskDetail, Description, ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportSnapshotTask")
	local t = { 
		["SnapshotTaskDetail"] = SnapshotTaskDetail,
		["Description"] = Description,
		["ImportTaskId"] = ImportTaskId,
	}
	M.AssertImportSnapshotTask(t)
	return t
end

local GetHostReservationPurchasePreviewResult_keys = { "TotalHourlyPrice" = true, "Purchase" = true, "CurrencyCode" = true, "TotalUpfrontPrice" = true, nil }

function M.AssertGetHostReservationPurchasePreviewResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetHostReservationPurchasePreviewResult to be of type 'table'")
	if struct["TotalHourlyPrice"] then M.AssertString(struct["TotalHourlyPrice"]) end
	if struct["Purchase"] then M.AssertPurchaseSet(struct["Purchase"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["TotalUpfrontPrice"] then M.AssertString(struct["TotalUpfrontPrice"]) end
	for k,_ in pairs(struct) do
		assert(GetHostReservationPurchasePreviewResult_keys[k], "GetHostReservationPurchasePreviewResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetHostReservationPurchasePreviewResult
--  
-- @param TotalHourlyPrice [String] <p>The potential total hourly price of the reservation per hour.</p>
-- @param Purchase [PurchaseSet] <p>The purchase information of the Dedicated Host Reservation and the Dedicated Hosts associated with it.</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param TotalUpfrontPrice [String] <p>The potential total upfront price. This is billed immediately.</p>
function M.GetHostReservationPurchasePreviewResult(TotalHourlyPrice, Purchase, CurrencyCode, TotalUpfrontPrice, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetHostReservationPurchasePreviewResult")
	local t = { 
		["TotalHourlyPrice"] = TotalHourlyPrice,
		["Purchase"] = Purchase,
		["CurrencyCode"] = CurrencyCode,
		["TotalUpfrontPrice"] = TotalUpfrontPrice,
	}
	M.AssertGetHostReservationPurchasePreviewResult(t)
	return t
end

local UnsuccessfulItem_keys = { "ResourceId" = true, "Error" = true, nil }

function M.AssertUnsuccessfulItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulItem to be of type 'table'")
	assert(struct["Error"], "Expected key Error to exist in table")
	if struct["ResourceId"] then M.AssertString(struct["ResourceId"]) end
	if struct["Error"] then M.AssertUnsuccessfulItemError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(UnsuccessfulItem_keys[k], "UnsuccessfulItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulItem
-- <p>Information about items that were not successfully processed in a batch call.</p>
-- @param ResourceId [String] <p>The ID of the resource.</p>
-- @param Error [UnsuccessfulItemError] <p>Information about the error.</p>
-- Required parameter: Error
function M.UnsuccessfulItem(ResourceId, Error, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnsuccessfulItem")
	local t = { 
		["ResourceId"] = ResourceId,
		["Error"] = Error,
	}
	M.AssertUnsuccessfulItem(t)
	return t
end

local PeeringConnectionOptionsRequest_keys = { "AllowEgressFromLocalVpcToRemoteClassicLink" = true, "AllowDnsResolutionFromRemoteVpc" = true, "AllowEgressFromLocalClassicLinkToRemoteVpc" = true, nil }

function M.AssertPeeringConnectionOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PeeringConnectionOptionsRequest to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then M.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then M.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then M.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(PeeringConnectionOptionsRequest_keys[k], "PeeringConnectionOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PeeringConnectionOptionsRequest
-- <p>The VPC peering connection options.</p>
-- @param AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.</p>
-- @param AllowDnsResolutionFromRemoteVpc [Boolean] <p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>
-- @param AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.</p>
function M.PeeringConnectionOptionsRequest(AllowEgressFromLocalVpcToRemoteClassicLink, AllowDnsResolutionFromRemoteVpc, AllowEgressFromLocalClassicLinkToRemoteVpc, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PeeringConnectionOptionsRequest")
	local t = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = AllowEgressFromLocalVpcToRemoteClassicLink,
		["AllowDnsResolutionFromRemoteVpc"] = AllowDnsResolutionFromRemoteVpc,
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = AllowEgressFromLocalClassicLinkToRemoteVpc,
	}
	M.AssertPeeringConnectionOptionsRequest(t)
	return t
end

local DescribeInstanceAttributeRequest_keys = { "InstanceId" = true, "Attribute" = true, "DryRun" = true, nil }

function M.AssertDescribeInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then M.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DescribeInstanceAttributeRequest_keys[k], "DescribeInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceAttributeRequest
-- <p>Contains the parameters for DescribeInstanceAttribute.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param Attribute [InstanceAttributeName] <p>The instance attribute.</p> <p>Note: The <code>enaSupport</code> attribute is not supported at this time.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: Attribute
-- Required parameter: InstanceId
function M.DescribeInstanceAttributeRequest(InstanceId, Attribute, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstanceAttributeRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["Attribute"] = Attribute,
		["DryRun"] = DryRun,
	}
	M.AssertDescribeInstanceAttributeRequest(t)
	return t
end

local DiskImageDetail_keys = { "Bytes" = true, "ImportManifestUrl" = true, "Format" = true, nil }

function M.AssertDiskImageDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageDetail to be of type 'table'")
	assert(struct["Bytes"], "Expected key Bytes to exist in table")
	assert(struct["Format"], "Expected key Format to exist in table")
	assert(struct["ImportManifestUrl"], "Expected key ImportManifestUrl to exist in table")
	if struct["Bytes"] then M.AssertLong(struct["Bytes"]) end
	if struct["ImportManifestUrl"] then M.AssertString(struct["ImportManifestUrl"]) end
	if struct["Format"] then M.AssertDiskImageFormat(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(DiskImageDetail_keys[k], "DiskImageDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageDetail
-- <p>Describes a disk image.</p>
-- @param Bytes [Long] <p>The size of the disk image, in GiB.</p>
-- @param ImportManifestUrl [String] <p>A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
-- @param Format [DiskImageFormat] <p>The disk image format.</p>
-- Required parameter: Bytes
-- Required parameter: Format
-- Required parameter: ImportManifestUrl
function M.DiskImageDetail(Bytes, ImportManifestUrl, Format, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DiskImageDetail")
	local t = { 
		["Bytes"] = Bytes,
		["ImportManifestUrl"] = ImportManifestUrl,
		["Format"] = Format,
	}
	M.AssertDiskImageDetail(t)
	return t
end

local AvailabilityZone_keys = { "State" = true, "ZoneName" = true, "Messages" = true, "RegionName" = true, nil }

function M.AssertAvailabilityZone(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailabilityZone to be of type 'table'")
	if struct["State"] then M.AssertAvailabilityZoneState(struct["State"]) end
	if struct["ZoneName"] then M.AssertString(struct["ZoneName"]) end
	if struct["Messages"] then M.AssertAvailabilityZoneMessageList(struct["Messages"]) end
	if struct["RegionName"] then M.AssertString(struct["RegionName"]) end
	for k,_ in pairs(struct) do
		assert(AvailabilityZone_keys[k], "AvailabilityZone contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailabilityZone
-- <p>Describes an Availability Zone.</p>
-- @param State [AvailabilityZoneState] <p>The state of the Availability Zone.</p>
-- @param ZoneName [String] <p>The name of the Availability Zone.</p>
-- @param Messages [AvailabilityZoneMessageList] <p>Any messages about the Availability Zone.</p>
-- @param RegionName [String] <p>The name of the region.</p>
function M.AvailabilityZone(State, ZoneName, Messages, RegionName, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AvailabilityZone")
	local t = { 
		["State"] = State,
		["ZoneName"] = ZoneName,
		["Messages"] = Messages,
		["RegionName"] = RegionName,
	}
	M.AssertAvailabilityZone(t)
	return t
end

local DescribeNetworkInterfacesRequest_keys = { "NetworkInterfaceIds" = true, "DryRun" = true, "Filters" = true, nil }

function M.AssertDescribeNetworkInterfacesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacesRequest to be of type 'table'")
	if struct["NetworkInterfaceIds"] then M.AssertNetworkInterfaceIdList(struct["NetworkInterfaceIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeNetworkInterfacesRequest_keys[k], "DescribeNetworkInterfacesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacesRequest
-- <p>Contains the parameters for DescribeNetworkInterfaces.</p>
-- @param NetworkInterfaceIds [NetworkInterfaceIdList] <p>One or more network interface IDs.</p> <p>Default: Describes all your network interfaces.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>addresses.private-ip-address</code> - The private IPv4 addresses associated with the network interface.</p> </li> <li> <p> <code>addresses.primary</code> - Whether the private IPv4 address is the primary IP address associated with the network interface. </p> </li> <li> <p> <code>addresses.association.public-ip</code> - The association ID returned when the network interface was associated with the Elastic IP address (IPv4).</p> </li> <li> <p> <code>addresses.association.owner-id</code> - The owner ID of the addresses associated with the network interface.</p> </li> <li> <p> <code>association.association-id</code> - The association ID returned when the network interface was associated with an IPv4 address.</p> </li> <li> <p> <code>association.allocation-id</code> - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.</p> </li> <li> <p> <code>association.ip-owner-id</code> - The owner of the Elastic IP address (IPv4) associated with the network interface.</p> </li> <li> <p> <code>association.public-ip</code> - The address of the Elastic IP address (IPv4) bound to the network interface.</p> </li> <li> <p> <code>association.public-dns-name</code> - The public DNS name for the network interface (IPv4).</p> </li> <li> <p> <code>attachment.attachment-id</code> - The ID of the interface attachment.</p> </li> <li> <p> <code>attachment.attach.time</code> - The time that the network interface was attached to an instance.</p> </li> <li> <p> <code>attachment.delete-on-termination</code> - Indicates whether the attachment is deleted when an instance is terminated.</p> </li> <li> <p> <code>attachment.device-index</code> - The device index to which the network interface is attached.</p> </li> <li> <p> <code>attachment.instance-id</code> - The ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>attachment.instance-owner-id</code> - The owner ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>attachment.nat-gateway-id</code> - The ID of the NAT gateway to which the network interface is attached.</p> </li> <li> <p> <code>attachment.status</code> - The status of the attachment (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the network interface.</p> </li> <li> <p> <code>description</code> - The description of the network interface.</p> </li> <li> <p> <code>group-id</code> - The ID of a security group associated with the network interface.</p> </li> <li> <p> <code>group-name</code> - The name of a security group associated with the network interface.</p> </li> <li> <p> <code>ipv6-addresses.ipv6-address</code> - An IPv6 address associated with the network interface.</p> </li> <li> <p> <code>mac-address</code> - The MAC address of the network interface.</p> </li> <li> <p> <code>network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the network interface owner.</p> </li> <li> <p> <code>private-ip-address</code> - The private IPv4 address or addresses of the network interface.</p> </li> <li> <p> <code>private-dns-name</code> - The private DNS name of the network interface (IPv4).</p> </li> <li> <p> <code>requester-id</code> - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>requester-managed</code> - Indicates whether the network interface is being managed by an AWS service (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>source-desk-check</code> - Indicates whether the network interface performs source/destination checking. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the network interface to perform network address translation (NAT) in your VPC. </p> </li> <li> <p> <code>status</code> - The status of the network interface. If the network interface is not attached to an instance, the status is <code>available</code>; if a network interface is attached to an instance the status is <code>in-use</code>.</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet for the network interface.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the network interface.</p> </li> </ul>
function M.DescribeNetworkInterfacesRequest(NetworkInterfaceIds, DryRun, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkInterfacesRequest")
	local t = { 
		["NetworkInterfaceIds"] = NetworkInterfaceIds,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
	}
	M.AssertDescribeNetworkInterfacesRequest(t)
	return t
end

local GroupIdentifier_keys = { "GroupName" = true, "GroupId" = true, nil }

function M.AssertGroupIdentifier(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GroupIdentifier to be of type 'table'")
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(GroupIdentifier_keys[k], "GroupIdentifier contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GroupIdentifier
-- <p>Describes a security group.</p>
-- @param GroupName [String] <p>The name of the security group.</p>
-- @param GroupId [String] <p>The ID of the security group.</p>
function M.GroupIdentifier(GroupName, GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GroupIdentifier")
	local t = { 
		["GroupName"] = GroupName,
		["GroupId"] = GroupId,
	}
	M.AssertGroupIdentifier(t)
	return t
end

local RunScheduledInstancesRequest_keys = { "ScheduledInstanceId" = true, "LaunchSpecification" = true, "InstanceCount" = true, "DryRun" = true, "ClientToken" = true, nil }

function M.AssertRunScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunScheduledInstancesRequest to be of type 'table'")
	assert(struct["LaunchSpecification"], "Expected key LaunchSpecification to exist in table")
	assert(struct["ScheduledInstanceId"], "Expected key ScheduledInstanceId to exist in table")
	if struct["ScheduledInstanceId"] then M.AssertString(struct["ScheduledInstanceId"]) end
	if struct["LaunchSpecification"] then M.AssertScheduledInstancesLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(RunScheduledInstancesRequest_keys[k], "RunScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunScheduledInstancesRequest
-- <p>Contains the parameters for RunScheduledInstances.</p>
-- @param ScheduledInstanceId [String] <p>The Scheduled Instance ID.</p>
-- @param LaunchSpecification [ScheduledInstancesLaunchSpecification] <p>The launch specification. You must match the instance type, Availability Zone, network, and platform of the schedule that you purchased.</p>
-- @param InstanceCount [Integer] <p>The number of instances.</p> <p>Default: 1</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required parameter: LaunchSpecification
-- Required parameter: ScheduledInstanceId
function M.RunScheduledInstancesRequest(ScheduledInstanceId, LaunchSpecification, InstanceCount, DryRun, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RunScheduledInstancesRequest")
	local t = { 
		["ScheduledInstanceId"] = ScheduledInstanceId,
		["LaunchSpecification"] = LaunchSpecification,
		["InstanceCount"] = InstanceCount,
		["DryRun"] = DryRun,
		["ClientToken"] = ClientToken,
	}
	M.AssertRunScheduledInstancesRequest(t)
	return t
end

local DiskImageDescription_keys = { "Checksum" = true, "Size" = true, "ImportManifestUrl" = true, "Format" = true, nil }

function M.AssertDiskImageDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageDescription to be of type 'table'")
	assert(struct["Format"], "Expected key Format to exist in table")
	assert(struct["ImportManifestUrl"], "Expected key ImportManifestUrl to exist in table")
	assert(struct["Size"], "Expected key Size to exist in table")
	if struct["Checksum"] then M.AssertString(struct["Checksum"]) end
	if struct["Size"] then M.AssertLong(struct["Size"]) end
	if struct["ImportManifestUrl"] then M.AssertString(struct["ImportManifestUrl"]) end
	if struct["Format"] then M.AssertDiskImageFormat(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(DiskImageDescription_keys[k], "DiskImageDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageDescription
-- <p>Describes a disk image.</p>
-- @param Checksum [String] <p>The checksum computed for the disk image.</p>
-- @param Size [Long] <p>The size of the disk image, in GiB.</p>
-- @param ImportManifestUrl [String] <p>A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
-- @param Format [DiskImageFormat] <p>The disk image format.</p>
-- Required parameter: Format
-- Required parameter: ImportManifestUrl
-- Required parameter: Size
function M.DiskImageDescription(Checksum, Size, ImportManifestUrl, Format, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DiskImageDescription")
	local t = { 
		["Checksum"] = Checksum,
		["Size"] = Size,
		["ImportManifestUrl"] = ImportManifestUrl,
		["Format"] = Format,
	}
	M.AssertDiskImageDescription(t)
	return t
end

local RouteTableAssociation_keys = { "SubnetId" = true, "RouteTableAssociationId" = true, "Main" = true, "RouteTableId" = true, nil }

function M.AssertRouteTableAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RouteTableAssociation to be of type 'table'")
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["RouteTableAssociationId"] then M.AssertString(struct["RouteTableAssociationId"]) end
	if struct["Main"] then M.AssertBoolean(struct["Main"]) end
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(RouteTableAssociation_keys[k], "RouteTableAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RouteTableAssociation
-- <p>Describes an association between a route table and a subnet.</p>
-- @param SubnetId [String] <p>The ID of the subnet. A subnet ID is not returned for an implicit association.</p>
-- @param RouteTableAssociationId [String] <p>The ID of the association between a route table and a subnet.</p>
-- @param Main [Boolean] <p>Indicates whether this is the main route table.</p>
-- @param RouteTableId [String] <p>The ID of the route table.</p>
function M.RouteTableAssociation(SubnetId, RouteTableAssociationId, Main, RouteTableId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RouteTableAssociation")
	local t = { 
		["SubnetId"] = SubnetId,
		["RouteTableAssociationId"] = RouteTableAssociationId,
		["Main"] = Main,
		["RouteTableId"] = RouteTableId,
	}
	M.AssertRouteTableAssociation(t)
	return t
end

local CancelImportTaskRequest_keys = { "DryRun" = true, "CancelReason" = true, "ImportTaskId" = true, nil }

function M.AssertCancelImportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelImportTaskRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["CancelReason"] then M.AssertString(struct["CancelReason"]) end
	if struct["ImportTaskId"] then M.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(CancelImportTaskRequest_keys[k], "CancelImportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelImportTaskRequest
-- <p>Contains the parameters for CancelImportTask.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param CancelReason [String] <p>The reason for canceling the task.</p>
-- @param ImportTaskId [String] <p>The ID of the import image or import snapshot task to be canceled.</p>
function M.CancelImportTaskRequest(DryRun, CancelReason, ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelImportTaskRequest")
	local t = { 
		["DryRun"] = DryRun,
		["CancelReason"] = CancelReason,
		["ImportTaskId"] = ImportTaskId,
	}
	M.AssertCancelImportTaskRequest(t)
	return t
end

local ImportInstanceRequest_keys = { "Platform" = true, "DiskImages" = true, "DryRun" = true, "Description" = true, "LaunchSpecification" = true, nil }

function M.AssertImportInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceRequest to be of type 'table'")
	assert(struct["Platform"], "Expected key Platform to exist in table")
	if struct["Platform"] then M.AssertPlatformValues(struct["Platform"]) end
	if struct["DiskImages"] then M.AssertDiskImageList(struct["DiskImages"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["LaunchSpecification"] then M.AssertImportInstanceLaunchSpecification(struct["LaunchSpecification"]) end
	for k,_ in pairs(struct) do
		assert(ImportInstanceRequest_keys[k], "ImportInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceRequest
-- <p>Contains the parameters for ImportInstance.</p>
-- @param Platform [PlatformValues] <p>The instance operating system.</p>
-- @param DiskImages [DiskImageList] <p>The disk image.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>A description for the instance being imported.</p>
-- @param LaunchSpecification [ImportInstanceLaunchSpecification] <p>The launch specification.</p>
-- Required parameter: Platform
function M.ImportInstanceRequest(Platform, DiskImages, DryRun, Description, LaunchSpecification, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceRequest")
	local t = { 
		["Platform"] = Platform,
		["DiskImages"] = DiskImages,
		["DryRun"] = DryRun,
		["Description"] = Description,
		["LaunchSpecification"] = LaunchSpecification,
	}
	M.AssertImportInstanceRequest(t)
	return t
end

local SubnetCidrBlockState_keys = { "State" = true, "StatusMessage" = true, nil }

function M.AssertSubnetCidrBlockState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SubnetCidrBlockState to be of type 'table'")
	if struct["State"] then M.AssertSubnetCidrBlockStateCode(struct["State"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(SubnetCidrBlockState_keys[k], "SubnetCidrBlockState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SubnetCidrBlockState
-- <p>Describes the state of a CIDR block.</p>
-- @param State [SubnetCidrBlockStateCode] <p>The state of a CIDR block.</p>
-- @param StatusMessage [String] <p>A message about the status of the CIDR block, if applicable.</p>
function M.SubnetCidrBlockState(State, StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SubnetCidrBlockState")
	local t = { 
		["State"] = State,
		["StatusMessage"] = StatusMessage,
	}
	M.AssertSubnetCidrBlockState(t)
	return t
end

local CreateVolumeRequest_keys = { "AvailabilityZone" = true, "DryRun" = true, "TagSpecifications" = true, "Encrypted" = true, "VolumeType" = true, "KmsKeyId" = true, "SnapshotId" = true, "Iops" = true, "Size" = true, nil }

function M.AssertCreateVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumeRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["TagSpecifications"] then M.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["Encrypted"] then M.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then M.AssertVolumeType(struct["VolumeType"]) end
	if struct["KmsKeyId"] then M.AssertString(struct["KmsKeyId"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then M.AssertInteger(struct["Iops"]) end
	if struct["Size"] then M.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(CreateVolumeRequest_keys[k], "CreateVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumeRequest
-- <p>Contains the parameters for CreateVolume.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone in which to create the volume. Use <a>DescribeAvailabilityZones</a> to list the Availability Zones that are currently available to you.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param TagSpecifications [TagSpecificationList] <p>The tags to apply to the volume during creation.</p>
-- @param Encrypted [Boolean] <p>Specifies whether the volume should be encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption. Volumes that are created from encrypted snapshots are automatically encrypted. There is no way to create an encrypted volume from an unencrypted snapshot or vice versa. If your AMI uses encrypted volumes, you can only launch it on supported instance types. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param VolumeType [VolumeType] <p>The volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p> <p>Default: <code>standard</code> </p>
-- @param KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set.</p>
-- @param SnapshotId [String] <p>The snapshot from which to create the volume.</p>
-- @param Iops [Integer] <p>Only valid for Provisioned IOPS SSD volumes. The number of I/O operations per second (IOPS) to provision for the volume, with a maximum ratio of 50 IOPS/GiB.</p> <p>Constraint: Range is 100 to 20000 for Provisioned IOPS SSD volumes </p>
-- @param Size [Integer] <p>The size of the volume, in GiBs.</p> <p>Constraints: 1-16384 for <code>gp2</code>, 4-16384 for <code>io1</code>, 500-16384 for <code>st1</code>, 500-16384 for <code>sc1</code>, and 1-1024 for <code>standard</code>. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- Required parameter: AvailabilityZone
function M.CreateVolumeRequest(AvailabilityZone, DryRun, TagSpecifications, Encrypted, VolumeType, KmsKeyId, SnapshotId, Iops, Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVolumeRequest")
	local t = { 
		["AvailabilityZone"] = AvailabilityZone,
		["DryRun"] = DryRun,
		["TagSpecifications"] = TagSpecifications,
		["Encrypted"] = Encrypted,
		["VolumeType"] = VolumeType,
		["KmsKeyId"] = KmsKeyId,
		["SnapshotId"] = SnapshotId,
		["Iops"] = Iops,
		["Size"] = Size,
	}
	M.AssertCreateVolumeRequest(t)
	return t
end

local DescribeHostsResult_keys = { "NextToken" = true, "Hosts" = true, nil }

function M.AssertDescribeHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostsResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["Hosts"] then M.AssertHostList(struct["Hosts"]) end
	for k,_ in pairs(struct) do
		assert(DescribeHostsResult_keys[k], "DescribeHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostsResult
-- <p>Contains the output of DescribeHosts.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param Hosts [HostList] <p>Information about the Dedicated Hosts.</p>
function M.DescribeHostsResult(NextToken, Hosts, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostsResult")
	local t = { 
		["NextToken"] = NextToken,
		["Hosts"] = Hosts,
	}
	M.AssertDescribeHostsResult(t)
	return t
end

local DescribeVolumesResult_keys = { "NextToken" = true, "Volumes" = true, nil }

function M.AssertDescribeVolumesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["Volumes"] then M.AssertVolumeList(struct["Volumes"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVolumesResult_keys[k], "DescribeVolumesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesResult
-- <p>Contains the output of DescribeVolumes.</p>
-- @param NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeVolumes</code> request. When the results of a <code>DescribeVolumes</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param Volumes [VolumeList] <p>Information about the volumes.</p>
function M.DescribeVolumesResult(NextToken, Volumes, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumesResult")
	local t = { 
		["NextToken"] = NextToken,
		["Volumes"] = Volumes,
	}
	M.AssertDescribeVolumesResult(t)
	return t
end

local DescribeNatGatewaysRequest_keys = { "Filter" = true, "NextToken" = true, "NatGatewayIds" = true, "MaxResults" = true, nil }

function M.AssertDescribeNatGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNatGatewaysRequest to be of type 'table'")
	if struct["Filter"] then M.AssertFilterList(struct["Filter"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["NatGatewayIds"] then M.AssertValueStringList(struct["NatGatewayIds"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(DescribeNatGatewaysRequest_keys[k], "DescribeNatGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNatGatewaysRequest
-- <p>Contains the parameters for DescribeNatGateways.</p>
-- @param Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>nat-gateway-id</code> - The ID of the NAT gateway.</p> </li> <li> <p> <code>state</code> - The state of the NAT gateway (<code>pending</code> | <code>failed</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet in which the NAT gateway resides.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC in which the NAT gateway resides.</p> </li> </ul>
-- @param NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param NatGatewayIds [ValueStringList] <p>One or more NAT gateway IDs.</p>
-- @param MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value specified is greater than 1000, we return only 1000 items.</p>
function M.DescribeNatGatewaysRequest(Filter, NextToken, NatGatewayIds, MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNatGatewaysRequest")
	local t = { 
		["Filter"] = Filter,
		["NextToken"] = NextToken,
		["NatGatewayIds"] = NatGatewayIds,
		["MaxResults"] = MaxResults,
	}
	M.AssertDescribeNatGatewaysRequest(t)
	return t
end

local DetachInternetGatewayRequest_keys = { "VpcId" = true, "DryRun" = true, "InternetGatewayId" = true, nil }

function M.AssertDetachInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then M.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(DetachInternetGatewayRequest_keys[k], "DetachInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachInternetGatewayRequest
-- <p>Contains the parameters for DetachInternetGateway.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- Required parameter: InternetGatewayId
-- Required parameter: VpcId
function M.DetachInternetGatewayRequest(VpcId, DryRun, InternetGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachInternetGatewayRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
		["InternetGatewayId"] = InternetGatewayId,
	}
	M.AssertDetachInternetGatewayRequest(t)
	return t
end

local ScheduledInstancesEbs_keys = { "VolumeSize" = true, "Encrypted" = true, "VolumeType" = true, "DeleteOnTermination" = true, "SnapshotId" = true, "Iops" = true, nil }

function M.AssertScheduledInstancesEbs(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesEbs to be of type 'table'")
	if struct["VolumeSize"] then M.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then M.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then M.AssertString(struct["VolumeType"]) end
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then M.AssertInteger(struct["Iops"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstancesEbs_keys[k], "ScheduledInstancesEbs contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesEbs
-- <p>Describes an EBS volume for a Scheduled Instance.</p>
-- @param VolumeSize [Integer] <p>The size of the volume, in GiB.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- @param Encrypted [Boolean] <p>Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.</p>
-- @param VolumeType [String] <p>The volume type. <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, Throughput Optimized HDD for <code>st1</code>, Cold HDD for <code>sc1</code>, or <code>standard</code> for Magnetic.</p> <p>Default: <code>standard</code> </p>
-- @param DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- @param SnapshotId [String] <p>The ID of the snapshot.</p>
-- @param Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about <code>gp2</code> baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for <code>io1</code> volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code>volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
function M.ScheduledInstancesEbs(VolumeSize, Encrypted, VolumeType, DeleteOnTermination, SnapshotId, Iops, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesEbs")
	local t = { 
		["VolumeSize"] = VolumeSize,
		["Encrypted"] = Encrypted,
		["VolumeType"] = VolumeType,
		["DeleteOnTermination"] = DeleteOnTermination,
		["SnapshotId"] = SnapshotId,
		["Iops"] = Iops,
	}
	M.AssertScheduledInstancesEbs(t)
	return t
end

local CreateImageRequest_keys = { "DryRun" = true, "Description" = true, "InstanceId" = true, "BlockDeviceMappings" = true, "NoReboot" = true, "Name" = true, nil }

function M.AssertCreateImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateImageRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["BlockDeviceMappings"] then M.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["NoReboot"] then M.AssertBoolean(struct["NoReboot"]) end
	if struct["Name"] then M.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(CreateImageRequest_keys[k], "CreateImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateImageRequest
-- <p>Contains the parameters for CreateImage.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>A description for the new image.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param BlockDeviceMappings [BlockDeviceMappingRequestList] <p>Information about one or more block device mappings.</p>
-- @param NoReboot [Boolean] <p>By default, Amazon EC2 attempts to shut down and reboot the instance before creating the image. If the 'No Reboot' option is set, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed.</p>
-- @param Name [String] <p>A name for the new image.</p> <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
-- Required parameter: InstanceId
-- Required parameter: Name
function M.CreateImageRequest(DryRun, Description, InstanceId, BlockDeviceMappings, NoReboot, Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateImageRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Description"] = Description,
		["InstanceId"] = InstanceId,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["NoReboot"] = NoReboot,
		["Name"] = Name,
	}
	M.AssertCreateImageRequest(t)
	return t
end

local DisableVpcClassicLinkDnsSupportResult_keys = { "Return" = true, nil }

function M.AssertDisableVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(DisableVpcClassicLinkDnsSupportResult_keys[k], "DisableVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkDnsSupportResult
-- <p>Contains the output of DisableVpcClassicLinkDnsSupport.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DisableVpcClassicLinkDnsSupportResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVpcClassicLinkDnsSupportResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertDisableVpcClassicLinkDnsSupportResult(t)
	return t
end

local DescribePrefixListsResult_keys = { "NextToken" = true, "PrefixLists" = true, nil }

function M.AssertDescribePrefixListsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrefixListsResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["PrefixLists"] then M.AssertPrefixListSet(struct["PrefixLists"]) end
	for k,_ in pairs(struct) do
		assert(DescribePrefixListsResult_keys[k], "DescribePrefixListsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrefixListsResult
-- <p>Contains the output of DescribePrefixLists.</p>
-- @param NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @param PrefixLists [PrefixListSet] <p>All available prefix lists.</p>
function M.DescribePrefixListsResult(NextToken, PrefixLists, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribePrefixListsResult")
	local t = { 
		["NextToken"] = NextToken,
		["PrefixLists"] = PrefixLists,
	}
	M.AssertDescribePrefixListsResult(t)
	return t
end

local DescribeMovingAddressesResult_keys = { "MovingAddressStatuses" = true, "NextToken" = true, nil }

function M.AssertDescribeMovingAddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMovingAddressesResult to be of type 'table'")
	if struct["MovingAddressStatuses"] then M.AssertMovingAddressStatusSet(struct["MovingAddressStatuses"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeMovingAddressesResult_keys[k], "DescribeMovingAddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMovingAddressesResult
-- <p>Contains the output of DescribeMovingAddresses.</p>
-- @param MovingAddressStatuses [MovingAddressStatusSet] <p>The status for each Elastic IP address.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeMovingAddressesResult(MovingAddressStatuses, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeMovingAddressesResult")
	local t = { 
		["MovingAddressStatuses"] = MovingAddressStatuses,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeMovingAddressesResult(t)
	return t
end

local VolumeModification_keys = { "TargetSize" = true, "TargetVolumeType" = true, "ModificationState" = true, "VolumeId" = true, "TargetIops" = true, "OriginalSize" = true, "StartTime" = true, "Progress" = true, "OriginalVolumeType" = true, "OriginalIops" = true, "EndTime" = true, "StatusMessage" = true, nil }

function M.AssertVolumeModification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeModification to be of type 'table'")
	if struct["TargetSize"] then M.AssertInteger(struct["TargetSize"]) end
	if struct["TargetVolumeType"] then M.AssertVolumeType(struct["TargetVolumeType"]) end
	if struct["ModificationState"] then M.AssertVolumeModificationState(struct["ModificationState"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	if struct["TargetIops"] then M.AssertInteger(struct["TargetIops"]) end
	if struct["OriginalSize"] then M.AssertInteger(struct["OriginalSize"]) end
	if struct["StartTime"] then M.AssertDateTime(struct["StartTime"]) end
	if struct["Progress"] then M.AssertLong(struct["Progress"]) end
	if struct["OriginalVolumeType"] then M.AssertVolumeType(struct["OriginalVolumeType"]) end
	if struct["OriginalIops"] then M.AssertInteger(struct["OriginalIops"]) end
	if struct["EndTime"] then M.AssertDateTime(struct["EndTime"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(VolumeModification_keys[k], "VolumeModification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeModification
-- <p>Describes the modification status of an EBS volume.</p> <p>If the volume has never been modified, some element values will be null.</p>
-- @param TargetSize [Integer] <p>Target size of the volume being modified.</p>
-- @param TargetVolumeType [VolumeType] <p>Target EBS volume type of the volume being modified.</p>
-- @param ModificationState [VolumeModificationState] <p>Current state of modification. Modification state is null for unmodified volumes. </p>
-- @param VolumeId [String] <p>ID of the volume being modified.</p>
-- @param TargetIops [Integer] <p>Target IOPS rate of the volume being modified.</p>
-- @param OriginalSize [Integer] <p>Original size of the volume being modified.</p>
-- @param StartTime [DateTime] <p>Modification start time </p>
-- @param Progress [Long] <p>Modification progress from 0 to 100%.</p>
-- @param OriginalVolumeType [VolumeType] <p>Original EBS volume type of the volume being modified.</p>
-- @param OriginalIops [Integer] <p>Original IOPS rate of the volume being modified.</p>
-- @param EndTime [DateTime] <p>Modification completion or failure time.</p>
-- @param StatusMessage [String] <p>Generic status message on modification progress or failure.</p>
function M.VolumeModification(TargetSize, TargetVolumeType, ModificationState, VolumeId, TargetIops, OriginalSize, StartTime, Progress, OriginalVolumeType, OriginalIops, EndTime, StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeModification")
	local t = { 
		["TargetSize"] = TargetSize,
		["TargetVolumeType"] = TargetVolumeType,
		["ModificationState"] = ModificationState,
		["VolumeId"] = VolumeId,
		["TargetIops"] = TargetIops,
		["OriginalSize"] = OriginalSize,
		["StartTime"] = StartTime,
		["Progress"] = Progress,
		["OriginalVolumeType"] = OriginalVolumeType,
		["OriginalIops"] = OriginalIops,
		["EndTime"] = EndTime,
		["StatusMessage"] = StatusMessage,
	}
	M.AssertVolumeModification(t)
	return t
end

local ModifySnapshotAttributeRequest_keys = { "DryRun" = true, "Attribute" = true, "UserIds" = true, "GroupNames" = true, "CreateVolumePermission" = true, "OperationType" = true, "SnapshotId" = true, nil }

function M.AssertModifySnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySnapshotAttributeRequest to be of type 'table'")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Attribute"] then M.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["UserIds"] then M.AssertUserIdStringList(struct["UserIds"]) end
	if struct["GroupNames"] then M.AssertGroupNameStringList(struct["GroupNames"]) end
	if struct["CreateVolumePermission"] then M.AssertCreateVolumePermissionModifications(struct["CreateVolumePermission"]) end
	if struct["OperationType"] then M.AssertOperationType(struct["OperationType"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(ModifySnapshotAttributeRequest_keys[k], "ModifySnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySnapshotAttributeRequest
-- <p>Contains the parameters for ModifySnapshotAttribute.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Attribute [SnapshotAttributeName] <p>The snapshot attribute to modify.</p> <note> <p>Only volume creation permissions may be modified at the customer level.</p> </note>
-- @param UserIds [UserIdStringList] <p>The account ID to modify for the snapshot.</p>
-- @param GroupNames [GroupNameStringList] <p>The group to modify for the snapshot.</p>
-- @param CreateVolumePermission [CreateVolumePermissionModifications] <p>A JSON representation of the snapshot attribute modification.</p>
-- @param OperationType [OperationType] <p>The type of operation to perform to the attribute.</p>
-- @param SnapshotId [String] <p>The ID of the snapshot.</p>
-- Required parameter: SnapshotId
function M.ModifySnapshotAttributeRequest(DryRun, Attribute, UserIds, GroupNames, CreateVolumePermission, OperationType, SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifySnapshotAttributeRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Attribute"] = Attribute,
		["UserIds"] = UserIds,
		["GroupNames"] = GroupNames,
		["CreateVolumePermission"] = CreateVolumePermission,
		["OperationType"] = OperationType,
		["SnapshotId"] = SnapshotId,
	}
	M.AssertModifySnapshotAttributeRequest(t)
	return t
end

local DescribeAddressesResult_keys = { "Addresses" = true, nil }

function M.AssertDescribeAddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAddressesResult to be of type 'table'")
	if struct["Addresses"] then M.AssertAddressList(struct["Addresses"]) end
	for k,_ in pairs(struct) do
		assert(DescribeAddressesResult_keys[k], "DescribeAddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAddressesResult
-- <p>Contains the output of DescribeAddresses.</p>
-- @param Addresses [AddressList] <p>Information about one or more Elastic IP addresses.</p>
function M.DescribeAddressesResult(Addresses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAddressesResult")
	local t = { 
		["Addresses"] = Addresses,
	}
	M.AssertDescribeAddressesResult(t)
	return t
end

local RunInstancesMonitoringEnabled_keys = { "Enabled" = true, nil }

function M.AssertRunInstancesMonitoringEnabled(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunInstancesMonitoringEnabled to be of type 'table'")
	assert(struct["Enabled"], "Expected key Enabled to exist in table")
	if struct["Enabled"] then M.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(RunInstancesMonitoringEnabled_keys[k], "RunInstancesMonitoringEnabled contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunInstancesMonitoringEnabled
-- <p>Describes the monitoring of an instance.</p>
-- @param Enabled [Boolean] <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
-- Required parameter: Enabled
function M.RunInstancesMonitoringEnabled(Enabled, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RunInstancesMonitoringEnabled")
	local t = { 
		["Enabled"] = Enabled,
	}
	M.AssertRunInstancesMonitoringEnabled(t)
	return t
end

local HostProperties_keys = { "Cores" = true, "TotalVCpus" = true, "InstanceType" = true, "Sockets" = true, nil }

function M.AssertHostProperties(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostProperties to be of type 'table'")
	if struct["Cores"] then M.AssertInteger(struct["Cores"]) end
	if struct["TotalVCpus"] then M.AssertInteger(struct["TotalVCpus"]) end
	if struct["InstanceType"] then M.AssertString(struct["InstanceType"]) end
	if struct["Sockets"] then M.AssertInteger(struct["Sockets"]) end
	for k,_ in pairs(struct) do
		assert(HostProperties_keys[k], "HostProperties contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostProperties
-- <p>Describes properties of a Dedicated Host.</p>
-- @param Cores [Integer] <p>The number of cores on the Dedicated Host.</p>
-- @param TotalVCpus [Integer] <p>The number of vCPUs on the Dedicated Host.</p>
-- @param InstanceType [String] <p>The instance type size that the Dedicated Host supports (for example, <code>m3.medium</code>).</p>
-- @param Sockets [Integer] <p>The number of sockets on the Dedicated Host.</p>
function M.HostProperties(Cores, TotalVCpus, InstanceType, Sockets, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HostProperties")
	local t = { 
		["Cores"] = Cores,
		["TotalVCpus"] = TotalVCpus,
		["InstanceType"] = InstanceType,
		["Sockets"] = Sockets,
	}
	M.AssertHostProperties(t)
	return t
end

local InstanceStatusSummary_keys = { "Status" = true, "Details" = true, nil }

function M.AssertInstanceStatusSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusSummary to be of type 'table'")
	if struct["Status"] then M.AssertSummaryStatus(struct["Status"]) end
	if struct["Details"] then M.AssertInstanceStatusDetailsList(struct["Details"]) end
	for k,_ in pairs(struct) do
		assert(InstanceStatusSummary_keys[k], "InstanceStatusSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusSummary
-- <p>Describes the status of an instance.</p>
-- @param Status [SummaryStatus] <p>The status.</p>
-- @param Details [InstanceStatusDetailsList] <p>The system instance health or application instance health.</p>
function M.InstanceStatusSummary(Status, Details, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStatusSummary")
	local t = { 
		["Status"] = Status,
		["Details"] = Details,
	}
	M.AssertInstanceStatusSummary(t)
	return t
end

local DescribeVpcsRequest_keys = { "DryRun" = true, "Filters" = true, "VpcIds" = true, nil }

function M.AssertDescribeVpcsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcsRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["VpcIds"] then M.AssertVpcIdStringList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcsRequest_keys[k], "DescribeVpcsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcsRequest
-- <p>Contains the parameters for DescribeVpcs.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>cidr</code> - The IPv4 CIDR block of the VPC. The CIDR block you specify must exactly match the VPC's CIDR block for information to be returned for the VPC. Must contain the slash followed by one or two digits (for example, <code>/28</code>).</p> </li> <li> <p> <code>dhcp-options-id</code> - The ID of a set of DHCP options.</p> </li> <li> <p> <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>ipv6-cidr-block-association.association-id</code> - The association ID for an IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>isDefault</code> - Indicates whether the VPC is the default VPC.</p> </li> <li> <p> <code>state</code> - The state of the VPC (<code>pending</code> | <code>available</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC.</p> </li> </ul>
-- @param VpcIds [VpcIdStringList] <p>One or more VPC IDs.</p> <p>Default: Describes all your VPCs.</p>
function M.DescribeVpcsRequest(DryRun, Filters, VpcIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcsRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Filters"] = Filters,
		["VpcIds"] = VpcIds,
	}
	M.AssertDescribeVpcsRequest(t)
	return t
end

local SubnetIpv6CidrBlockAssociation_keys = { "Ipv6CidrBlock" = true, "AssociationId" = true, "Ipv6CidrBlockState" = true, nil }

function M.AssertSubnetIpv6CidrBlockAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SubnetIpv6CidrBlockAssociation to be of type 'table'")
	if struct["Ipv6CidrBlock"] then M.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["Ipv6CidrBlockState"] then M.AssertSubnetCidrBlockState(struct["Ipv6CidrBlockState"]) end
	for k,_ in pairs(struct) do
		assert(SubnetIpv6CidrBlockAssociation_keys[k], "SubnetIpv6CidrBlockAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SubnetIpv6CidrBlockAssociation
-- <p>Describes an IPv6 CIDR block associated with a subnet.</p>
-- @param Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- @param AssociationId [String] <p>The association ID for the CIDR block.</p>
-- @param Ipv6CidrBlockState [SubnetCidrBlockState] <p>Information about the state of the CIDR block.</p>
function M.SubnetIpv6CidrBlockAssociation(Ipv6CidrBlock, AssociationId, Ipv6CidrBlockState, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SubnetIpv6CidrBlockAssociation")
	local t = { 
		["Ipv6CidrBlock"] = Ipv6CidrBlock,
		["AssociationId"] = AssociationId,
		["Ipv6CidrBlockState"] = Ipv6CidrBlockState,
	}
	M.AssertSubnetIpv6CidrBlockAssociation(t)
	return t
end

local CreateRouteTableResult_keys = { "RouteTable" = true, nil }

function M.AssertCreateRouteTableResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteTableResult to be of type 'table'")
	if struct["RouteTable"] then M.AssertRouteTable(struct["RouteTable"]) end
	for k,_ in pairs(struct) do
		assert(CreateRouteTableResult_keys[k], "CreateRouteTableResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteTableResult
-- <p>Contains the output of CreateRouteTable.</p>
-- @param RouteTable [RouteTable] <p>Information about the route table.</p>
function M.CreateRouteTableResult(RouteTable, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateRouteTableResult")
	local t = { 
		["RouteTable"] = RouteTable,
	}
	M.AssertCreateRouteTableResult(t)
	return t
end

local ModifyVpcEndpointResult_keys = { "Return" = true, nil }

function M.AssertModifyVpcEndpointResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(ModifyVpcEndpointResult_keys[k], "ModifyVpcEndpointResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointResult
-- <p>Contains the output of ModifyVpcEndpoint.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.ModifyVpcEndpointResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcEndpointResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertModifyVpcEndpointResult(t)
	return t
end

local DescribeTagsResult_keys = { "NextToken" = true, "Tags" = true, nil }

function M.AssertDescribeTagsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeTagsResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["Tags"] then M.AssertTagDescriptionList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(DescribeTagsResult_keys[k], "DescribeTagsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeTagsResult
-- <p>Contains the output of DescribeTags.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return..</p>
-- @param Tags [TagDescriptionList] <p>A list of tags.</p>
function M.DescribeTagsResult(NextToken, Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeTagsResult")
	local t = { 
		["NextToken"] = NextToken,
		["Tags"] = Tags,
	}
	M.AssertDescribeTagsResult(t)
	return t
end

local DeleteVpcPeeringConnectionResult_keys = { "Return" = true, nil }

function M.AssertDeleteVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcPeeringConnectionResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(DeleteVpcPeeringConnectionResult_keys[k], "DeleteVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcPeeringConnectionResult
-- <p>Contains the output of DeleteVpcPeeringConnection.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DeleteVpcPeeringConnectionResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcPeeringConnectionResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertDeleteVpcPeeringConnectionResult(t)
	return t
end

local BlockDeviceMapping_keys = { "DeviceName" = true, "VirtualName" = true, "NoDevice" = true, "Ebs" = true, nil }

function M.AssertBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BlockDeviceMapping to be of type 'table'")
	if struct["DeviceName"] then M.AssertString(struct["DeviceName"]) end
	if struct["VirtualName"] then M.AssertString(struct["VirtualName"]) end
	if struct["NoDevice"] then M.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then M.AssertEbsBlockDevice(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(BlockDeviceMapping_keys[k], "BlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BlockDeviceMapping
-- <p>Describes a block device mapping.</p>
-- @param DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param VirtualName [String] <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
-- @param NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- @param Ebs [EbsBlockDevice] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
function M.BlockDeviceMapping(DeviceName, VirtualName, NoDevice, Ebs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BlockDeviceMapping")
	local t = { 
		["DeviceName"] = DeviceName,
		["VirtualName"] = VirtualName,
		["NoDevice"] = NoDevice,
		["Ebs"] = Ebs,
	}
	M.AssertBlockDeviceMapping(t)
	return t
end

local ImportInstanceResult_keys = { "ConversionTask" = true, nil }

function M.AssertImportInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceResult to be of type 'table'")
	if struct["ConversionTask"] then M.AssertConversionTask(struct["ConversionTask"]) end
	for k,_ in pairs(struct) do
		assert(ImportInstanceResult_keys[k], "ImportInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceResult
-- <p>Contains the output for ImportInstance.</p>
-- @param ConversionTask [ConversionTask] <p>Information about the conversion task.</p>
function M.ImportInstanceResult(ConversionTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceResult")
	local t = { 
		["ConversionTask"] = ConversionTask,
	}
	M.AssertImportInstanceResult(t)
	return t
end

local AssociateRouteTableResult_keys = { "AssociationId" = true, nil }

function M.AssertAssociateRouteTableResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateRouteTableResult to be of type 'table'")
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(AssociateRouteTableResult_keys[k], "AssociateRouteTableResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateRouteTableResult
-- <p>Contains the output of AssociateRouteTable.</p>
-- @param AssociationId [String] <p>The route table association ID (needed to disassociate the route table).</p>
function M.AssociateRouteTableResult(AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateRouteTableResult")
	local t = { 
		["AssociationId"] = AssociationId,
	}
	M.AssertAssociateRouteTableResult(t)
	return t
end

local DiskImageVolumeDescription_keys = { "Id" = true, "Size" = true, nil }

function M.AssertDiskImageVolumeDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageVolumeDescription to be of type 'table'")
	assert(struct["Id"], "Expected key Id to exist in table")
	if struct["Id"] then M.AssertString(struct["Id"]) end
	if struct["Size"] then M.AssertLong(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(DiskImageVolumeDescription_keys[k], "DiskImageVolumeDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageVolumeDescription
-- <p>Describes a disk image volume.</p>
-- @param Id [String] <p>The volume identifier.</p>
-- @param Size [Long] <p>The size of the volume, in GiB.</p>
-- Required parameter: Id
function M.DiskImageVolumeDescription(Id, Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DiskImageVolumeDescription")
	local t = { 
		["Id"] = Id,
		["Size"] = Size,
	}
	M.AssertDiskImageVolumeDescription(t)
	return t
end

local VpcAttachment_keys = { "State" = true, "VpcId" = true, nil }

function M.AssertVpcAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcAttachment to be of type 'table'")
	if struct["State"] then M.AssertAttachmentStatus(struct["State"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(VpcAttachment_keys[k], "VpcAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcAttachment
-- <p>Describes an attachment between a virtual private gateway and a VPC.</p>
-- @param State [AttachmentStatus] <p>The current state of the attachment.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
function M.VpcAttachment(State, VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcAttachment")
	local t = { 
		["State"] = State,
		["VpcId"] = VpcId,
	}
	M.AssertVpcAttachment(t)
	return t
end

local Snapshot_keys = { "OwnerAlias" = true, "DataEncryptionKeyId" = true, "Description" = true, "VolumeSize" = true, "Tags" = true, "Encrypted" = true, "SnapshotId" = true, "VolumeId" = true, "StateMessage" = true, "State" = true, "KmsKeyId" = true, "StartTime" = true, "OwnerId" = true, "Progress" = true, nil }

function M.AssertSnapshot(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Snapshot to be of type 'table'")
	if struct["OwnerAlias"] then M.AssertString(struct["OwnerAlias"]) end
	if struct["DataEncryptionKeyId"] then M.AssertString(struct["DataEncryptionKeyId"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["VolumeSize"] then M.AssertInteger(struct["VolumeSize"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["Encrypted"] then M.AssertBoolean(struct["Encrypted"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	if struct["StateMessage"] then M.AssertString(struct["StateMessage"]) end
	if struct["State"] then M.AssertSnapshotState(struct["State"]) end
	if struct["KmsKeyId"] then M.AssertString(struct["KmsKeyId"]) end
	if struct["StartTime"] then M.AssertDateTime(struct["StartTime"]) end
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	if struct["Progress"] then M.AssertString(struct["Progress"]) end
	for k,_ in pairs(struct) do
		assert(Snapshot_keys[k], "Snapshot contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Snapshot
-- <p>Describes a snapshot.</p>
-- @param OwnerAlias [String] <p> Value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console. </p>
-- @param DataEncryptionKeyId [String] <p>The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by the <a>DescribeSnapshots</a> API operation.</p>
-- @param Description [String] <p>The description for the snapshot.</p>
-- @param VolumeSize [Integer] <p>The size of the volume, in GiB.</p>
-- @param Tags [TagList] <p>Any tags assigned to the snapshot.</p>
-- @param Encrypted [Boolean] <p>Indicates whether the snapshot is encrypted.</p>
-- @param SnapshotId [String] <p>The ID of the snapshot. Each snapshot receives a unique identifier when it is created.</p>
-- @param VolumeId [String] <p>The ID of the volume that was used to create the snapshot. Snapshots created by the <a>CopySnapshot</a> action have an arbitrary volume ID that should not be used for any purpose.</p>
-- @param StateMessage [String] <p>Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper AWS Key Management Service (AWS KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by the <a>DescribeSnapshots</a> API operation.</p>
-- @param State [SnapshotState] <p>The snapshot state.</p>
-- @param KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the parent volume.</p>
-- @param StartTime [DateTime] <p>The time stamp when the snapshot was initiated.</p>
-- @param OwnerId [String] <p>The AWS account ID of the EBS snapshot owner.</p>
-- @param Progress [String] <p>The progress of the snapshot, as a percentage.</p>
function M.Snapshot(OwnerAlias, DataEncryptionKeyId, Description, VolumeSize, Tags, Encrypted, SnapshotId, VolumeId, StateMessage, State, KmsKeyId, StartTime, OwnerId, Progress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Snapshot")
	local t = { 
		["OwnerAlias"] = OwnerAlias,
		["DataEncryptionKeyId"] = DataEncryptionKeyId,
		["Description"] = Description,
		["VolumeSize"] = VolumeSize,
		["Tags"] = Tags,
		["Encrypted"] = Encrypted,
		["SnapshotId"] = SnapshotId,
		["VolumeId"] = VolumeId,
		["StateMessage"] = StateMessage,
		["State"] = State,
		["KmsKeyId"] = KmsKeyId,
		["StartTime"] = StartTime,
		["OwnerId"] = OwnerId,
		["Progress"] = Progress,
	}
	M.AssertSnapshot(t)
	return t
end

local DescribeVpcsResult_keys = { "Vpcs" = true, nil }

function M.AssertDescribeVpcsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcsResult to be of type 'table'")
	if struct["Vpcs"] then M.AssertVpcList(struct["Vpcs"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcsResult_keys[k], "DescribeVpcsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcsResult
-- <p>Contains the output of DescribeVpcs.</p>
-- @param Vpcs [VpcList] <p>Information about one or more VPCs.</p>
function M.DescribeVpcsResult(Vpcs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcsResult")
	local t = { 
		["Vpcs"] = Vpcs,
	}
	M.AssertDescribeVpcsResult(t)
	return t
end

local CancelSpotFleetRequestsErrorItem_keys = { "SpotFleetRequestId" = true, "Error" = true, nil }

function M.AssertCancelSpotFleetRequestsErrorItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsErrorItem to be of type 'table'")
	assert(struct["Error"], "Expected key Error to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then M.AssertString(struct["SpotFleetRequestId"]) end
	if struct["Error"] then M.AssertCancelSpotFleetRequestsError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(CancelSpotFleetRequestsErrorItem_keys[k], "CancelSpotFleetRequestsErrorItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsErrorItem
-- <p>Describes a Spot fleet request that was not successfully canceled.</p>
-- @param SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param Error [CancelSpotFleetRequestsError] <p>The error.</p>
-- Required parameter: Error
-- Required parameter: SpotFleetRequestId
function M.CancelSpotFleetRequestsErrorItem(SpotFleetRequestId, Error, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsErrorItem")
	local t = { 
		["SpotFleetRequestId"] = SpotFleetRequestId,
		["Error"] = Error,
	}
	M.AssertCancelSpotFleetRequestsErrorItem(t)
	return t
end

local DeleteRouteRequest_keys = { "DestinationCidrBlock" = true, "DryRun" = true, "DestinationIpv6CidrBlock" = true, "RouteTableId" = true, nil }

function M.AssertDeleteRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then M.AssertString(struct["DestinationCidrBlock"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["DestinationIpv6CidrBlock"] then M.AssertString(struct["DestinationIpv6CidrBlock"]) end
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(DeleteRouteRequest_keys[k], "DeleteRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRouteRequest
-- <p>Contains the parameters for DeleteRoute.</p>
-- @param DestinationCidrBlock [String] <p>The IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
-- @param RouteTableId [String] <p>The ID of the route table.</p>
-- Required parameter: RouteTableId
function M.DeleteRouteRequest(DestinationCidrBlock, DryRun, DestinationIpv6CidrBlock, RouteTableId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteRouteRequest")
	local t = { 
		["DestinationCidrBlock"] = DestinationCidrBlock,
		["DryRun"] = DryRun,
		["DestinationIpv6CidrBlock"] = DestinationIpv6CidrBlock,
		["RouteTableId"] = RouteTableId,
	}
	M.AssertDeleteRouteRequest(t)
	return t
end

local ReplaceRouteRequest_keys = { "DestinationCidrBlock" = true, "EgressOnlyInternetGatewayId" = true, "DryRun" = true, "InstanceId" = true, "NetworkInterfaceId" = true, "RouteTableId" = true, "NatGatewayId" = true, "VpcPeeringConnectionId" = true, "GatewayId" = true, "DestinationIpv6CidrBlock" = true, nil }

function M.AssertReplaceRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then M.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then M.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	if struct["NatGatewayId"] then M.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then M.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then M.AssertString(struct["DestinationIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(ReplaceRouteRequest_keys[k], "ReplaceRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteRequest
-- <p>Contains the parameters for ReplaceRoute.</p>
-- @param DestinationCidrBlock [String] <p>The IPv4 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.</p>
-- @param EgressOnlyInternetGatewayId [String] <p>[IPv6 traffic only] The ID of an egress-only Internet gateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceId [String] <p>The ID of a NAT instance in your VPC.</p>
-- @param NetworkInterfaceId [String] <p>The ID of a network interface.</p>
-- @param RouteTableId [String] <p>The ID of the route table.</p>
-- @param NatGatewayId [String] <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of a VPC peering connection.</p>
-- @param GatewayId [String] <p>The ID of an Internet gateway or virtual private gateway.</p>
-- @param DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.</p>
-- Required parameter: RouteTableId
function M.ReplaceRouteRequest(DestinationCidrBlock, EgressOnlyInternetGatewayId, DryRun, InstanceId, NetworkInterfaceId, RouteTableId, NatGatewayId, VpcPeeringConnectionId, GatewayId, DestinationIpv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceRouteRequest")
	local t = { 
		["DestinationCidrBlock"] = DestinationCidrBlock,
		["EgressOnlyInternetGatewayId"] = EgressOnlyInternetGatewayId,
		["DryRun"] = DryRun,
		["InstanceId"] = InstanceId,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["RouteTableId"] = RouteTableId,
		["NatGatewayId"] = NatGatewayId,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
		["GatewayId"] = GatewayId,
		["DestinationIpv6CidrBlock"] = DestinationIpv6CidrBlock,
	}
	M.AssertReplaceRouteRequest(t)
	return t
end

local SecurityGroupReference_keys = { "ReferencingVpcId" = true, "GroupId" = true, "VpcPeeringConnectionId" = true, nil }

function M.AssertSecurityGroupReference(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityGroupReference to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	assert(struct["ReferencingVpcId"], "Expected key ReferencingVpcId to exist in table")
	if struct["ReferencingVpcId"] then M.AssertString(struct["ReferencingVpcId"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(SecurityGroupReference_keys[k], "SecurityGroupReference contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityGroupReference
-- <p>Describes a VPC with a security group that references your security group.</p>
-- @param ReferencingVpcId [String] <p>The ID of the VPC with the referencing security group.</p>
-- @param GroupId [String] <p>The ID of your security group.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required parameter: GroupId
-- Required parameter: ReferencingVpcId
function M.SecurityGroupReference(ReferencingVpcId, GroupId, VpcPeeringConnectionId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SecurityGroupReference")
	local t = { 
		["ReferencingVpcId"] = ReferencingVpcId,
		["GroupId"] = GroupId,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
	}
	M.AssertSecurityGroupReference(t)
	return t
end

local DescribeConversionTasksResult_keys = { "ConversionTasks" = true, nil }

function M.AssertDescribeConversionTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeConversionTasksResult to be of type 'table'")
	if struct["ConversionTasks"] then M.AssertDescribeConversionTaskList(struct["ConversionTasks"]) end
	for k,_ in pairs(struct) do
		assert(DescribeConversionTasksResult_keys[k], "DescribeConversionTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeConversionTasksResult
-- <p>Contains the output for DescribeConversionTasks.</p>
-- @param ConversionTasks [DescribeConversionTaskList] <p>Information about the conversion tasks.</p>
function M.DescribeConversionTasksResult(ConversionTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeConversionTasksResult")
	local t = { 
		["ConversionTasks"] = ConversionTasks,
	}
	M.AssertDescribeConversionTasksResult(t)
	return t
end

local CreateSnapshotRequest_keys = { "DryRun" = true, "Description" = true, "VolumeId" = true, nil }

function M.AssertCreateSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSnapshotRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(CreateSnapshotRequest_keys[k], "CreateSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSnapshotRequest
-- <p>Contains the parameters for CreateSnapshot.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>A description for the snapshot.</p>
-- @param VolumeId [String] <p>The ID of the EBS volume.</p>
-- Required parameter: VolumeId
function M.CreateSnapshotRequest(DryRun, Description, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSnapshotRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Description"] = Description,
		["VolumeId"] = VolumeId,
	}
	M.AssertCreateSnapshotRequest(t)
	return t
end

local AssociateSubnetCidrBlockRequest_keys = { "SubnetId" = true, "Ipv6CidrBlock" = true, nil }

function M.AssertAssociateSubnetCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateSubnetCidrBlockRequest to be of type 'table'")
	assert(struct["Ipv6CidrBlock"], "Expected key Ipv6CidrBlock to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlock"] then M.AssertString(struct["Ipv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(AssociateSubnetCidrBlockRequest_keys[k], "AssociateSubnetCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateSubnetCidrBlockRequest
--  
-- @param SubnetId [String] <p>The ID of your subnet.</p>
-- @param Ipv6CidrBlock [String] <p>The IPv6 CIDR block for your subnet. The subnet must have a /64 prefix length.</p>
-- Required parameter: Ipv6CidrBlock
-- Required parameter: SubnetId
function M.AssociateSubnetCidrBlockRequest(SubnetId, Ipv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateSubnetCidrBlockRequest")
	local t = { 
		["SubnetId"] = SubnetId,
		["Ipv6CidrBlock"] = Ipv6CidrBlock,
	}
	M.AssertAssociateSubnetCidrBlockRequest(t)
	return t
end

local ImageAttribute_keys = { "ProductCodes" = true, "Description" = true, "LaunchPermissions" = true, "SriovNetSupport" = true, "ImageId" = true, "BlockDeviceMappings" = true, "KernelId" = true, "RamdiskId" = true, nil }

function M.AssertImageAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImageAttribute to be of type 'table'")
	if struct["ProductCodes"] then M.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["Description"] then M.AssertAttributeValue(struct["Description"]) end
	if struct["LaunchPermissions"] then M.AssertLaunchPermissionList(struct["LaunchPermissions"]) end
	if struct["SriovNetSupport"] then M.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["BlockDeviceMappings"] then M.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then M.AssertAttributeValue(struct["KernelId"]) end
	if struct["RamdiskId"] then M.AssertAttributeValue(struct["RamdiskId"]) end
	for k,_ in pairs(struct) do
		assert(ImageAttribute_keys[k], "ImageAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImageAttribute
-- <p>Describes an image attribute.</p>
-- @param ProductCodes [ProductCodeList] <p>One or more product codes.</p>
-- @param Description [AttributeValue] <p>A description for the AMI.</p>
-- @param LaunchPermissions [LaunchPermissionList] <p>One or more launch permissions.</p>
-- @param SriovNetSupport [AttributeValue] <p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- @param ImageId [String] <p>The ID of the AMI.</p>
-- @param BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p>
-- @param KernelId [AttributeValue] <p>The kernel ID.</p>
-- @param RamdiskId [AttributeValue] <p>The RAM disk ID.</p>
function M.ImageAttribute(ProductCodes, Description, LaunchPermissions, SriovNetSupport, ImageId, BlockDeviceMappings, KernelId, RamdiskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImageAttribute")
	local t = { 
		["ProductCodes"] = ProductCodes,
		["Description"] = Description,
		["LaunchPermissions"] = LaunchPermissions,
		["SriovNetSupport"] = SriovNetSupport,
		["ImageId"] = ImageId,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["KernelId"] = KernelId,
		["RamdiskId"] = RamdiskId,
	}
	M.AssertImageAttribute(t)
	return t
end

local DeleteEgressOnlyInternetGatewayRequest_keys = { "EgressOnlyInternetGatewayId" = true, "DryRun" = true, nil }

function M.AssertDeleteEgressOnlyInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteEgressOnlyInternetGatewayRequest to be of type 'table'")
	assert(struct["EgressOnlyInternetGatewayId"], "Expected key EgressOnlyInternetGatewayId to exist in table")
	if struct["EgressOnlyInternetGatewayId"] then M.AssertEgressOnlyInternetGatewayId(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteEgressOnlyInternetGatewayRequest_keys[k], "DeleteEgressOnlyInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteEgressOnlyInternetGatewayRequest
--  
-- @param EgressOnlyInternetGatewayId [EgressOnlyInternetGatewayId] <p>The ID of the egress-only Internet gateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: EgressOnlyInternetGatewayId
function M.DeleteEgressOnlyInternetGatewayRequest(EgressOnlyInternetGatewayId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteEgressOnlyInternetGatewayRequest")
	local t = { 
		["EgressOnlyInternetGatewayId"] = EgressOnlyInternetGatewayId,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteEgressOnlyInternetGatewayRequest(t)
	return t
end

local DescribeVolumesRequest_keys = { "MaxResults" = true, "NextToken" = true, "DryRun" = true, "VolumeIds" = true, "Filters" = true, nil }

function M.AssertDescribeVolumesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesRequest to be of type 'table'")
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeIds"] then M.AssertVolumeIdStringList(struct["VolumeIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVolumesRequest_keys[k], "DescribeVolumesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesRequest
-- <p>Contains the parameters for DescribeVolumes.</p>
-- @param MaxResults [Integer] <p>The maximum number of volume results returned by <code>DescribeVolumes</code> in paginated output. When this parameter is used, <code>DescribeVolumes</code> only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>DescribeVolumes</code> request with the returned <code>NextToken</code> value. This value can be between 5 and 500; if <code>MaxResults</code> is given a value larger than 500, only 500 results are returned. If this parameter is not used, then <code>DescribeVolumes</code> returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.</p>
-- @param NextToken [String] <p>The <code>NextToken</code> value returned from a previous paginated <code>DescribeVolumes</code> request where <code>MaxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>NextToken</code> value. This value is <code>null</code> when there are no more results to return.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VolumeIds [VolumeIdStringList] <p>One or more volume IDs.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.attach-time</code> - The time stamp when the attachment initiated.</p> </li> <li> <p> <code>attachment.delete-on-termination</code> - Whether the volume is deleted on instance termination.</p> </li> <li> <p> <code>attachment.device</code> - The device name that is exposed to the instance (for example, <code>/dev/sda1</code>).</p> </li> <li> <p> <code>attachment.instance-id</code> - The ID of the instance the volume is attached to.</p> </li> <li> <p> <code>attachment.status</code> - The attachment state (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone in which the volume was created.</p> </li> <li> <p> <code>create-time</code> - The time stamp when the volume was created.</p> </li> <li> <p> <code>encrypted</code> - The encryption status of the volume.</p> </li> <li> <p> <code>size</code> - The size of the volume, in GiB.</p> </li> <li> <p> <code>snapshot-id</code> - The snapshot from which the volume was created.</p> </li> <li> <p> <code>status</code> - The status of the volume (<code>creating</code> | <code>available</code> | <code>in-use</code> | <code>deleting</code> | <code>deleted</code> | <code>error</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>volume-id</code> - The volume ID.</p> </li> <li> <p> <code>volume-type</code> - The Amazon EBS volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p> </li> </ul>
function M.DescribeVolumesRequest(MaxResults, NextToken, DryRun, VolumeIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumesRequest")
	local t = { 
		["MaxResults"] = MaxResults,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["VolumeIds"] = VolumeIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeVolumesRequest(t)
	return t
end

local DescribeHostsRequest_keys = { "Filter" = true, "HostIds" = true, "NextToken" = true, "MaxResults" = true, nil }

function M.AssertDescribeHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostsRequest to be of type 'table'")
	if struct["Filter"] then M.AssertFilterList(struct["Filter"]) end
	if struct["HostIds"] then M.AssertRequestHostIdList(struct["HostIds"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(DescribeHostsRequest_keys[k], "DescribeHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostsRequest
-- <p>Contains the parameters for DescribeHosts.</p>
-- @param Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-type</code> - The instance type size that the Dedicated Host is configured to support.</p> </li> <li> <p> <code>auto-placement</code> - Whether auto-placement is enabled or disabled (<code>on</code> | <code>off</code>).</p> </li> <li> <p> <code>host-reservation-id</code> - The ID of the reservation assigned to this host.</p> </li> <li> <p> <code>client-token</code> - The idempotency token you provided when you launched the instance</p> </li> <li> <p> <code>state</code>- The allocation state of the Dedicated Host (<code>available</code> | <code>under-assessment</code> | <code>permanent-failure</code> | <code>released</code> | <code>released-permanent-failure</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the host.</p> </li> </ul>
-- @param HostIds [RequestHostIdList] <p>The IDs of the Dedicated Hosts. The IDs are used for targeted instance launches.</p>
-- @param NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500; if <code>maxResults</code> is given a larger value than 500, you will receive an error. You cannot specify this parameter and the host IDs parameter in the same request.</p>
function M.DescribeHostsRequest(Filter, HostIds, NextToken, MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostsRequest")
	local t = { 
		["Filter"] = Filter,
		["HostIds"] = HostIds,
		["NextToken"] = NextToken,
		["MaxResults"] = MaxResults,
	}
	M.AssertDescribeHostsRequest(t)
	return t
end

local DescribeImportImageTasksResult_keys = { "NextToken" = true, "ImportImageTasks" = true, nil }

function M.AssertDescribeImportImageTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportImageTasksResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["ImportImageTasks"] then M.AssertImportImageTaskList(struct["ImportImageTasks"]) end
	for k,_ in pairs(struct) do
		assert(DescribeImportImageTasksResult_keys[k], "DescribeImportImageTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportImageTasksResult
-- <p>Contains the output for DescribeImportImageTasks.</p>
-- @param NextToken [String] <p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param ImportImageTasks [ImportImageTaskList] <p>A list of zero or more import image tasks that are currently active or were completed or canceled in the previous 7 days.</p>
function M.DescribeImportImageTasksResult(NextToken, ImportImageTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImportImageTasksResult")
	local t = { 
		["NextToken"] = NextToken,
		["ImportImageTasks"] = ImportImageTasks,
	}
	M.AssertDescribeImportImageTasksResult(t)
	return t
end

local CreatePlacementGroupRequest_keys = { "GroupName" = true, "DryRun" = true, "Strategy" = true, nil }

function M.AssertCreatePlacementGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePlacementGroupRequest to be of type 'table'")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	assert(struct["Strategy"], "Expected key Strategy to exist in table")
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Strategy"] then M.AssertPlacementStrategy(struct["Strategy"]) end
	for k,_ in pairs(struct) do
		assert(CreatePlacementGroupRequest_keys[k], "CreatePlacementGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePlacementGroupRequest
-- <p>Contains the parameters for CreatePlacementGroup.</p>
-- @param GroupName [String] <p>A name for the placement group.</p> <p>Constraints: Up to 255 ASCII characters</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Strategy [PlacementStrategy] <p>The placement strategy.</p>
-- Required parameter: GroupName
-- Required parameter: Strategy
function M.CreatePlacementGroupRequest(GroupName, DryRun, Strategy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreatePlacementGroupRequest")
	local t = { 
		["GroupName"] = GroupName,
		["DryRun"] = DryRun,
		["Strategy"] = Strategy,
	}
	M.AssertCreatePlacementGroupRequest(t)
	return t
end

local DisassociateIamInstanceProfileResult_keys = { "IamInstanceProfileAssociation" = true, nil }

function M.AssertDisassociateIamInstanceProfileResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateIamInstanceProfileResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then M.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(DisassociateIamInstanceProfileResult_keys[k], "DisassociateIamInstanceProfileResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateIamInstanceProfileResult
--  
-- @param IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
function M.DisassociateIamInstanceProfileResult(IamInstanceProfileAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateIamInstanceProfileResult")
	local t = { 
		["IamInstanceProfileAssociation"] = IamInstanceProfileAssociation,
	}
	M.AssertDisassociateIamInstanceProfileResult(t)
	return t
end

local AssignIpv6AddressesResult_keys = { "AssignedIpv6Addresses" = true, "NetworkInterfaceId" = true, nil }

function M.AssertAssignIpv6AddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignIpv6AddressesResult to be of type 'table'")
	if struct["AssignedIpv6Addresses"] then M.AssertIpv6AddressList(struct["AssignedIpv6Addresses"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(AssignIpv6AddressesResult_keys[k], "AssignIpv6AddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignIpv6AddressesResult
--  
-- @param AssignedIpv6Addresses [Ipv6AddressList] <p>The IPv6 addresses assigned to the network interface.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
function M.AssignIpv6AddressesResult(AssignedIpv6Addresses, NetworkInterfaceId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssignIpv6AddressesResult")
	local t = { 
		["AssignedIpv6Addresses"] = AssignedIpv6Addresses,
		["NetworkInterfaceId"] = NetworkInterfaceId,
	}
	M.AssertAssignIpv6AddressesResult(t)
	return t
end

local StaleSecurityGroup_keys = { "VpcId" = true, "StaleIpPermissionsEgress" = true, "GroupName" = true, "StaleIpPermissions" = true, "GroupId" = true, "Description" = true, nil }

function M.AssertStaleSecurityGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StaleSecurityGroup to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["StaleIpPermissionsEgress"] then M.AssertStaleIpPermissionSet(struct["StaleIpPermissionsEgress"]) end
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["StaleIpPermissions"] then M.AssertStaleIpPermissionSet(struct["StaleIpPermissions"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(StaleSecurityGroup_keys[k], "StaleSecurityGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StaleSecurityGroup
-- <p>Describes a stale security group (a security group that contains stale rules).</p>
-- @param VpcId [String] <p>The ID of the VPC for the security group.</p>
-- @param StaleIpPermissionsEgress [StaleIpPermissionSet] <p>Information about the stale outbound rules in the security group.</p>
-- @param GroupName [String] <p>The name of the security group.</p>
-- @param StaleIpPermissions [StaleIpPermissionSet] <p>Information about the stale inbound rules in the security group.</p>
-- @param GroupId [String] <p>The ID of the security group.</p>
-- @param Description [String] <p>The description of the security group.</p>
-- Required parameter: GroupId
function M.StaleSecurityGroup(VpcId, StaleIpPermissionsEgress, GroupName, StaleIpPermissions, GroupId, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StaleSecurityGroup")
	local t = { 
		["VpcId"] = VpcId,
		["StaleIpPermissionsEgress"] = StaleIpPermissionsEgress,
		["GroupName"] = GroupName,
		["StaleIpPermissions"] = StaleIpPermissions,
		["GroupId"] = GroupId,
		["Description"] = Description,
	}
	M.AssertStaleSecurityGroup(t)
	return t
end

local IamInstanceProfileSpecification_keys = { "Name" = true, "Arn" = true, nil }

function M.AssertIamInstanceProfileSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfileSpecification to be of type 'table'")
	if struct["Name"] then M.AssertString(struct["Name"]) end
	if struct["Arn"] then M.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(IamInstanceProfileSpecification_keys[k], "IamInstanceProfileSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfileSpecification
-- <p>Describes an IAM instance profile.</p>
-- @param Name [String] <p>The name of the instance profile.</p>
-- @param Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
function M.IamInstanceProfileSpecification(Name, Arn, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IamInstanceProfileSpecification")
	local t = { 
		["Name"] = Name,
		["Arn"] = Arn,
	}
	M.AssertIamInstanceProfileSpecification(t)
	return t
end

local DescribeVolumeAttributeRequest_keys = { "Attribute" = true, "DryRun" = true, "VolumeId" = true, nil }

function M.AssertDescribeVolumeAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeAttributeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Attribute"] then M.AssertVolumeAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVolumeAttributeRequest_keys[k], "DescribeVolumeAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeAttributeRequest
-- <p>Contains the parameters for DescribeVolumeAttribute.</p>
-- @param Attribute [VolumeAttributeName] <p>The attribute of the volume. This parameter is required.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.DescribeVolumeAttributeRequest(Attribute, DryRun, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumeAttributeRequest")
	local t = { 
		["Attribute"] = Attribute,
		["DryRun"] = DryRun,
		["VolumeId"] = VolumeId,
	}
	M.AssertDescribeVolumeAttributeRequest(t)
	return t
end

local DescribeSecurityGroupsRequest_keys = { "GroupNames" = true, "DryRun" = true, "GroupIds" = true, "Filters" = true, nil }

function M.AssertDescribeSecurityGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupsRequest to be of type 'table'")
	if struct["GroupNames"] then M.AssertGroupNameStringList(struct["GroupNames"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["GroupIds"] then M.AssertGroupIdStringList(struct["GroupIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSecurityGroupsRequest_keys[k], "DescribeSecurityGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupsRequest
-- <p>Contains the parameters for DescribeSecurityGroups.</p>
-- @param GroupNames [GroupNameStringList] <p>[EC2-Classic and default VPC only] One or more security group names. You can specify either the security group name or the security group ID. For security groups in a nondefault VPC, use the <code>group-name</code> filter to describe security groups by name.</p> <p>Default: Describes all your security groups.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param GroupIds [GroupIdStringList] <p>One or more security group IDs. Required for security groups in a nondefault VPC.</p> <p>Default: Describes all your security groups.</p>
-- @param Filters [FilterList] <p>One or more filters. If using multiple filters for rules, the results include security groups for which any combination of rules - not necessarily a single rule - match all filters.</p> <ul> <li> <p> <code>description</code> - The description of the security group.</p> </li> <li> <p> <code>egress.ip-permission.prefix-list-id</code> - The ID (prefix) of the AWS service to which the security group allows access.</p> </li> <li> <p> <code>group-id</code> - The ID of the security group. </p> </li> <li> <p> <code>group-name</code> - The name of the security group.</p> </li> <li> <p> <code>ip-permission.cidr</code> - An IPv4 CIDR range that has been granted permission in a security group rule.</p> </li> <li> <p> <code>ip-permission.from-port</code> - The start of port range for the TCP and UDP protocols, or an ICMP type number.</p> </li> <li> <p> <code>ip-permission.group-id</code> - The ID of a security group that has been granted permission.</p> </li> <li> <p> <code>ip-permission.group-name</code> - The name of a security group that has been granted permission.</p> </li> <li> <p> <code>ip-permission.ipv6-cidr</code> - An IPv6 CIDR range that has been granted permission in a security group rule.</p> </li> <li> <p> <code>ip-permission.protocol</code> - The IP protocol for the permission (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p> </li> <li> <p> <code>ip-permission.to-port</code> - The end of port range for the TCP and UDP protocols, or an ICMP code.</p> </li> <li> <p> <code>ip-permission.user-id</code> - The ID of an AWS account that has been granted permission.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the owner of the security group.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the security group.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the security group.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC specified when the security group was created.</p> </li> </ul>
function M.DescribeSecurityGroupsRequest(GroupNames, DryRun, GroupIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSecurityGroupsRequest")
	local t = { 
		["GroupNames"] = GroupNames,
		["DryRun"] = DryRun,
		["GroupIds"] = GroupIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeSecurityGroupsRequest(t)
	return t
end

local NetworkAclEntry_keys = { "IcmpTypeCode" = true, "RuleNumber" = true, "Protocol" = true, "Ipv6CidrBlock" = true, "Egress" = true, "RuleAction" = true, "PortRange" = true, "CidrBlock" = true, nil }

function M.AssertNetworkAclEntry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAclEntry to be of type 'table'")
	if struct["IcmpTypeCode"] then M.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["RuleNumber"] then M.AssertInteger(struct["RuleNumber"]) end
	if struct["Protocol"] then M.AssertString(struct["Protocol"]) end
	if struct["Ipv6CidrBlock"] then M.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then M.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then M.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then M.AssertPortRange(struct["PortRange"]) end
	if struct["CidrBlock"] then M.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(NetworkAclEntry_keys[k], "NetworkAclEntry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAclEntry
-- <p>Describes an entry in a network ACL.</p>
-- @param IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP type and code.</p>
-- @param RuleNumber [Integer] <p>The rule number for the entry. ACL entries are processed in ascending order by rule number.</p>
-- @param Protocol [String] <p>The protocol. A value of <code>-1</code> means all protocols.</p>
-- @param Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
-- @param Egress [Boolean] <p>Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).</p>
-- @param RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- @param PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
-- @param CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
function M.NetworkAclEntry(IcmpTypeCode, RuleNumber, Protocol, Ipv6CidrBlock, Egress, RuleAction, PortRange, CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkAclEntry")
	local t = { 
		["IcmpTypeCode"] = IcmpTypeCode,
		["RuleNumber"] = RuleNumber,
		["Protocol"] = Protocol,
		["Ipv6CidrBlock"] = Ipv6CidrBlock,
		["Egress"] = Egress,
		["RuleAction"] = RuleAction,
		["PortRange"] = PortRange,
		["CidrBlock"] = CidrBlock,
	}
	M.AssertNetworkAclEntry(t)
	return t
end

local UserBucketDetails_keys = { "S3Bucket" = true, "S3Key" = true, nil }

function M.AssertUserBucketDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserBucketDetails to be of type 'table'")
	if struct["S3Bucket"] then M.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then M.AssertString(struct["S3Key"]) end
	for k,_ in pairs(struct) do
		assert(UserBucketDetails_keys[k], "UserBucketDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserBucketDetails
-- <p>Describes the S3 bucket for the disk image.</p>
-- @param S3Bucket [String] <p>The S3 bucket from which the disk image was created.</p>
-- @param S3Key [String] <p>The file name of the disk image.</p>
function M.UserBucketDetails(S3Bucket, S3Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UserBucketDetails")
	local t = { 
		["S3Bucket"] = S3Bucket,
		["S3Key"] = S3Key,
	}
	M.AssertUserBucketDetails(t)
	return t
end

local CancelImportTaskResult_keys = { "State" = true, "PreviousState" = true, "ImportTaskId" = true, nil }

function M.AssertCancelImportTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelImportTaskResult to be of type 'table'")
	if struct["State"] then M.AssertString(struct["State"]) end
	if struct["PreviousState"] then M.AssertString(struct["PreviousState"]) end
	if struct["ImportTaskId"] then M.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(CancelImportTaskResult_keys[k], "CancelImportTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelImportTaskResult
-- <p>Contains the output for CancelImportTask.</p>
-- @param State [String] <p>The current state of the task being canceled.</p>
-- @param PreviousState [String] <p>The current state of the task being canceled.</p>
-- @param ImportTaskId [String] <p>The ID of the task being canceled.</p>
function M.CancelImportTaskResult(State, PreviousState, ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelImportTaskResult")
	local t = { 
		["State"] = State,
		["PreviousState"] = PreviousState,
		["ImportTaskId"] = ImportTaskId,
	}
	M.AssertCancelImportTaskResult(t)
	return t
end

local RegisterImageResult_keys = { "ImageId" = true, nil }

function M.AssertRegisterImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterImageResult to be of type 'table'")
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(RegisterImageResult_keys[k], "RegisterImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterImageResult
-- <p>Contains the output of RegisterImage.</p>
-- @param ImageId [String] <p>The ID of the newly registered AMI.</p>
function M.RegisterImageResult(ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RegisterImageResult")
	local t = { 
		["ImageId"] = ImageId,
	}
	M.AssertRegisterImageResult(t)
	return t
end

local CreateNetworkAclResult_keys = { "NetworkAcl" = true, nil }

function M.AssertCreateNetworkAclResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclResult to be of type 'table'")
	if struct["NetworkAcl"] then M.AssertNetworkAcl(struct["NetworkAcl"]) end
	for k,_ in pairs(struct) do
		assert(CreateNetworkAclResult_keys[k], "CreateNetworkAclResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclResult
-- <p>Contains the output of CreateNetworkAcl.</p>
-- @param NetworkAcl [NetworkAcl] <p>Information about the network ACL.</p>
function M.CreateNetworkAclResult(NetworkAcl, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkAclResult")
	local t = { 
		["NetworkAcl"] = NetworkAcl,
	}
	M.AssertCreateNetworkAclResult(t)
	return t
end

local DescribeVolumeStatusResult_keys = { "NextToken" = true, "VolumeStatuses" = true, nil }

function M.AssertDescribeVolumeStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeStatusResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["VolumeStatuses"] then M.AssertVolumeStatusList(struct["VolumeStatuses"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVolumeStatusResult_keys[k], "DescribeVolumeStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeStatusResult
-- <p>Contains the output of DescribeVolumeStatus.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param VolumeStatuses [VolumeStatusList] <p>A list of volumes.</p>
function M.DescribeVolumeStatusResult(NextToken, VolumeStatuses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumeStatusResult")
	local t = { 
		["NextToken"] = NextToken,
		["VolumeStatuses"] = VolumeStatuses,
	}
	M.AssertDescribeVolumeStatusResult(t)
	return t
end

local ModifyVolumeResult_keys = { "VolumeModification" = true, nil }

function M.AssertModifyVolumeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeResult to be of type 'table'")
	if struct["VolumeModification"] then M.AssertVolumeModification(struct["VolumeModification"]) end
	for k,_ in pairs(struct) do
		assert(ModifyVolumeResult_keys[k], "ModifyVolumeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeResult
--  
-- @param VolumeModification [VolumeModification] <p>A <a>VolumeModification</a> object.</p>
function M.ModifyVolumeResult(VolumeModification, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVolumeResult")
	local t = { 
		["VolumeModification"] = VolumeModification,
	}
	M.AssertModifyVolumeResult(t)
	return t
end

local CancelConversionRequest_keys = { "ConversionTaskId" = true, "ReasonMessage" = true, "DryRun" = true, nil }

function M.AssertCancelConversionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelConversionRequest to be of type 'table'")
	assert(struct["ConversionTaskId"], "Expected key ConversionTaskId to exist in table")
	if struct["ConversionTaskId"] then M.AssertString(struct["ConversionTaskId"]) end
	if struct["ReasonMessage"] then M.AssertString(struct["ReasonMessage"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(CancelConversionRequest_keys[k], "CancelConversionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelConversionRequest
-- <p>Contains the parameters for CancelConversionTask.</p>
-- @param ConversionTaskId [String] <p>The ID of the conversion task.</p>
-- @param ReasonMessage [String] <p>The reason for canceling the conversion task.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: ConversionTaskId
function M.CancelConversionRequest(ConversionTaskId, ReasonMessage, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelConversionRequest")
	local t = { 
		["ConversionTaskId"] = ConversionTaskId,
		["ReasonMessage"] = ReasonMessage,
		["DryRun"] = DryRun,
	}
	M.AssertCancelConversionRequest(t)
	return t
end

local ConfirmProductInstanceResult_keys = { "OwnerId" = true, "Return" = true, nil }

function M.AssertConfirmProductInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConfirmProductInstanceResult to be of type 'table'")
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(ConfirmProductInstanceResult_keys[k], "ConfirmProductInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConfirmProductInstanceResult
-- <p>Contains the output of ConfirmProductInstance.</p>
-- @param OwnerId [String] <p>The AWS account ID of the instance owner. This is only present if the product code is attached to the instance.</p>
-- @param Return [Boolean] <p>The return value of the request. Returns <code>true</code> if the specified product code is owned by the requester and associated with the specified instance.</p>
function M.ConfirmProductInstanceResult(OwnerId, Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ConfirmProductInstanceResult")
	local t = { 
		["OwnerId"] = OwnerId,
		["Return"] = Return,
	}
	M.AssertConfirmProductInstanceResult(t)
	return t
end

local CreateReservedInstancesListingResult_keys = { "ReservedInstancesListings" = true, nil }

function M.AssertCreateReservedInstancesListingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateReservedInstancesListingResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then M.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(CreateReservedInstancesListingResult_keys[k], "CreateReservedInstancesListingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateReservedInstancesListingResult
-- <p>Contains the output of CreateReservedInstancesListing.</p>
-- @param ReservedInstancesListings [ReservedInstancesListingList] <p>Information about the Standard Reserved Instance listing.</p>
function M.CreateReservedInstancesListingResult(ReservedInstancesListings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateReservedInstancesListingResult")
	local t = { 
		["ReservedInstancesListings"] = ReservedInstancesListings,
	}
	M.AssertCreateReservedInstancesListingResult(t)
	return t
end

local ReplaceNetworkAclEntryRequest_keys = { "IcmpTypeCode" = true, "NetworkAclId" = true, "RuleNumber" = true, "DryRun" = true, "Ipv6CidrBlock" = true, "Egress" = true, "RuleAction" = true, "PortRange" = true, "Protocol" = true, "CidrBlock" = true, nil }

function M.AssertReplaceNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["Protocol"], "Expected key Protocol to exist in table")
	assert(struct["RuleAction"], "Expected key RuleAction to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["IcmpTypeCode"] then M.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["NetworkAclId"] then M.AssertString(struct["NetworkAclId"]) end
	if struct["RuleNumber"] then M.AssertInteger(struct["RuleNumber"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Ipv6CidrBlock"] then M.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then M.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then M.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then M.AssertPortRange(struct["PortRange"]) end
	if struct["Protocol"] then M.AssertString(struct["Protocol"]) end
	if struct["CidrBlock"] then M.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(ReplaceNetworkAclEntryRequest_keys[k], "ReplaceNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclEntryRequest
-- <p>Contains the parameters for ReplaceNetworkAclEntry.</p>
-- @param IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP (1) protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
-- @param NetworkAclId [String] <p>The ID of the ACL.</p>
-- @param RuleNumber [Integer] <p>The rule number of the entry to replace.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation (for example <code>2001:bd8:1234:1a00::/64</code>).</p>
-- @param Egress [Boolean] <p>Indicates whether to replace the egress rule.</p> <p>Default: If no value is specified, we replace the ingress rule.</p>
-- @param RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- @param PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to. Required if specifying TCP (6) or UDP (17) for the protocol.</p>
-- @param Protocol [String] <p>The IP protocol. You can specify <code>all</code> or <code>-1</code> to mean all protocols. If you specify <code>all</code>, <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, or <code>icmp</code>, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
-- @param CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation (for example <code>172.16.0.0/24</code>).</p>
-- Required parameter: Egress
-- Required parameter: NetworkAclId
-- Required parameter: Protocol
-- Required parameter: RuleAction
-- Required parameter: RuleNumber
function M.ReplaceNetworkAclEntryRequest(IcmpTypeCode, NetworkAclId, RuleNumber, DryRun, Ipv6CidrBlock, Egress, RuleAction, PortRange, Protocol, CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceNetworkAclEntryRequest")
	local t = { 
		["IcmpTypeCode"] = IcmpTypeCode,
		["NetworkAclId"] = NetworkAclId,
		["RuleNumber"] = RuleNumber,
		["DryRun"] = DryRun,
		["Ipv6CidrBlock"] = Ipv6CidrBlock,
		["Egress"] = Egress,
		["RuleAction"] = RuleAction,
		["PortRange"] = PortRange,
		["Protocol"] = Protocol,
		["CidrBlock"] = CidrBlock,
	}
	M.AssertReplaceNetworkAclEntryRequest(t)
	return t
end

local ImportSnapshotRequest_keys = { "DryRun" = true, "Description" = true, "ClientData" = true, "ClientToken" = true, "RoleName" = true, "DiskContainer" = true, nil }

function M.AssertImportSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["ClientData"] then M.AssertClientData(struct["ClientData"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["RoleName"] then M.AssertString(struct["RoleName"]) end
	if struct["DiskContainer"] then M.AssertSnapshotDiskContainer(struct["DiskContainer"]) end
	for k,_ in pairs(struct) do
		assert(ImportSnapshotRequest_keys[k], "ImportSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotRequest
-- <p>Contains the parameters for ImportSnapshot.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>The description string for the import snapshot task.</p>
-- @param ClientData [ClientData] <p>The client-specific data.</p>
-- @param ClientToken [String] <p>Token to enable idempotency for VM import requests.</p>
-- @param RoleName [String] <p>The name of the role to use when not using the default role, 'vmimport'.</p>
-- @param DiskContainer [SnapshotDiskContainer] <p>Information about the disk container.</p>
function M.ImportSnapshotRequest(DryRun, Description, ClientData, ClientToken, RoleName, DiskContainer, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportSnapshotRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Description"] = Description,
		["ClientData"] = ClientData,
		["ClientToken"] = ClientToken,
		["RoleName"] = RoleName,
		["DiskContainer"] = DiskContainer,
	}
	M.AssertImportSnapshotRequest(t)
	return t
end

local PortRange_keys = { "To" = true, "From" = true, nil }

function M.AssertPortRange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PortRange to be of type 'table'")
	if struct["To"] then M.AssertInteger(struct["To"]) end
	if struct["From"] then M.AssertInteger(struct["From"]) end
	for k,_ in pairs(struct) do
		assert(PortRange_keys[k], "PortRange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PortRange
-- <p>Describes a range of ports.</p>
-- @param To [Integer] <p>The last port in the range.</p>
-- @param From [Integer] <p>The first port in the range.</p>
function M.PortRange(To, From, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PortRange")
	local t = { 
		["To"] = To,
		["From"] = From,
	}
	M.AssertPortRange(t)
	return t
end

local Reservation_keys = { "Instances" = true, "ReservationId" = true, "RequesterId" = true, "Groups" = true, "OwnerId" = true, nil }

function M.AssertReservation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Reservation to be of type 'table'")
	if struct["Instances"] then M.AssertInstanceList(struct["Instances"]) end
	if struct["ReservationId"] then M.AssertString(struct["ReservationId"]) end
	if struct["RequesterId"] then M.AssertString(struct["RequesterId"]) end
	if struct["Groups"] then M.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(Reservation_keys[k], "Reservation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Reservation
-- <p>Describes a reservation.</p>
-- @param Instances [InstanceList] <p>One or more instances.</p>
-- @param ReservationId [String] <p>The ID of the reservation.</p>
-- @param RequesterId [String] <p>The ID of the requester that launched the instances on your behalf (for example, AWS Management Console or Auto Scaling).</p>
-- @param Groups [GroupIdentifierList] <p>[EC2-Classic only] One or more security groups.</p>
-- @param OwnerId [String] <p>The ID of the AWS account that owns the reservation.</p>
function M.Reservation(Instances, ReservationId, RequesterId, Groups, OwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Reservation")
	local t = { 
		["Instances"] = Instances,
		["ReservationId"] = ReservationId,
		["RequesterId"] = RequesterId,
		["Groups"] = Groups,
		["OwnerId"] = OwnerId,
	}
	M.AssertReservation(t)
	return t
end

local DescribeConversionTasksRequest_keys = { "ConversionTaskIds" = true, "DryRun" = true, nil }

function M.AssertDescribeConversionTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeConversionTasksRequest to be of type 'table'")
	if struct["ConversionTaskIds"] then M.AssertConversionIdStringList(struct["ConversionTaskIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DescribeConversionTasksRequest_keys[k], "DescribeConversionTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeConversionTasksRequest
-- <p>Contains the parameters for DescribeConversionTasks.</p>
-- @param ConversionTaskIds [ConversionIdStringList] <p>One or more conversion task IDs.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.DescribeConversionTasksRequest(ConversionTaskIds, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeConversionTasksRequest")
	local t = { 
		["ConversionTaskIds"] = ConversionTaskIds,
		["DryRun"] = DryRun,
	}
	M.AssertDescribeConversionTasksRequest(t)
	return t
end

local DescribeImagesRequest_keys = { "Owners" = true, "ImageIds" = true, "DryRun" = true, "Filters" = true, "ExecutableUsers" = true, nil }

function M.AssertDescribeImagesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImagesRequest to be of type 'table'")
	if struct["Owners"] then M.AssertOwnerStringList(struct["Owners"]) end
	if struct["ImageIds"] then M.AssertImageIdStringList(struct["ImageIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["ExecutableUsers"] then M.AssertExecutableByStringList(struct["ExecutableUsers"]) end
	for k,_ in pairs(struct) do
		assert(DescribeImagesRequest_keys[k], "DescribeImagesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImagesRequest
-- <p>Contains the parameters for DescribeImages.</p>
-- @param Owners [OwnerStringList] <p>Filters the images by the owner. Specify an AWS account ID, <code>self</code> (owner is the sender of the request), or an AWS owner alias (valid values are <code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>). Omitting this option returns all images for which you have launch permissions, regardless of ownership.</p>
-- @param ImageIds [ImageIdStringList] <p>One or more image IDs.</p> <p>Default: Describes all images available to you.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>architecture</code> - The image architecture (<code>i386</code> | <code>x86_64</code>).</p> </li> <li> <p> <code>block-device-mapping.delete-on-termination</code> - A Boolean value that indicates whether the Amazon EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>block-device-mapping.device-name</code> - The device name for the EBS volume (for example, <code>/dev/sdh</code>).</p> </li> <li> <p> <code>block-device-mapping.snapshot-id</code> - The ID of the snapshot used for the EBS volume.</p> </li> <li> <p> <code>block-device-mapping.volume-size</code> - The volume size of the EBS volume, in GiB.</p> </li> <li> <p> <code>block-device-mapping.volume-type</code> - The volume type of the EBS volume (<code>gp2</code> | <code>io1</code> | <code>st1 </code>| <code>sc1</code> | <code>standard</code>).</p> </li> <li> <p> <code>description</code> - The description of the image (provided during image creation).</p> </li> <li> <p> <code>ena-support</code> - A Boolean that indicates whether enhanced networking with ENA is enabled.</p> </li> <li> <p> <code>hypervisor</code> - The hypervisor type (<code>ovm</code> | <code>xen</code>).</p> </li> <li> <p> <code>image-id</code> - The ID of the image.</p> </li> <li> <p> <code>image-type</code> - The image type (<code>machine</code> | <code>kernel</code> | <code>ramdisk</code>).</p> </li> <li> <p> <code>is-public</code> - A Boolean that indicates whether the image is public.</p> </li> <li> <p> <code>kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>manifest-location</code> - The location of the image manifest.</p> </li> <li> <p> <code>name</code> - The name of the AMI (provided during image creation).</p> </li> <li> <p> <code>owner-alias</code> - String value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the image owner.</p> </li> <li> <p> <code>platform</code> - The platform. To only list Windows-based AMIs, use <code>windows</code>.</p> </li> <li> <p> <code>product-code</code> - The product code.</p> </li> <li> <p> <code>product-code.type</code> - The type of the product code (<code>devpay</code> | <code>marketplace</code>).</p> </li> <li> <p> <code>ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>root-device-name</code> - The name of the root device volume (for example, <code>/dev/sda1</code>).</p> </li> <li> <p> <code>root-device-type</code> - The type of the root device volume (<code>ebs</code> | <code>instance-store</code>).</p> </li> <li> <p> <code>state</code> - The state of the image (<code>available</code> | <code>pending</code> | <code>failed</code>).</p> </li> <li> <p> <code>state-reason-code</code> - The reason code for the state change.</p> </li> <li> <p> <code>state-reason-message</code> - The message for the state change.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>virtualization-type</code> - The virtualization type (<code>paravirtual</code> | <code>hvm</code>).</p> </li> </ul>
-- @param ExecutableUsers [ExecutableByStringList] <p>Scopes the images by users with explicit launch permissions. Specify an AWS account ID, <code>self</code> (the sender of the request), or <code>all</code> (public AMIs).</p>
function M.DescribeImagesRequest(Owners, ImageIds, DryRun, Filters, ExecutableUsers, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImagesRequest")
	local t = { 
		["Owners"] = Owners,
		["ImageIds"] = ImageIds,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
		["ExecutableUsers"] = ExecutableUsers,
	}
	M.AssertDescribeImagesRequest(t)
	return t
end

local TagSpecification_keys = { "ResourceType" = true, "Tags" = true, nil }

function M.AssertTagSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TagSpecification to be of type 'table'")
	if struct["ResourceType"] then M.AssertResourceType(struct["ResourceType"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(TagSpecification_keys[k], "TagSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TagSpecification
-- <p>The tags to apply to a resource when the resource is being created.</p>
-- @param ResourceType [ResourceType] <p>The type of resource to tag. Currently, the resource types that support tagging on creation are <code>instance</code> and <code>volume</code>. </p>
-- @param Tags [TagList] <p>The tags to apply to the resource.</p>
function M.TagSpecification(ResourceType, Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TagSpecification")
	local t = { 
		["ResourceType"] = ResourceType,
		["Tags"] = Tags,
	}
	M.AssertTagSpecification(t)
	return t
end

local DescribeIdentityIdFormatRequest_keys = { "PrincipalArn" = true, "Resource" = true, nil }

function M.AssertDescribeIdentityIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdentityIdFormatRequest to be of type 'table'")
	assert(struct["PrincipalArn"], "Expected key PrincipalArn to exist in table")
	if struct["PrincipalArn"] then M.AssertString(struct["PrincipalArn"]) end
	if struct["Resource"] then M.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(DescribeIdentityIdFormatRequest_keys[k], "DescribeIdentityIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdentityIdFormatRequest
-- <p>Contains the parameters for DescribeIdentityIdFormat.</p>
-- @param PrincipalArn [String] <p>The ARN of the principal, which can be an IAM role, IAM user, or the root user.</p>
-- @param Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- Required parameter: PrincipalArn
function M.DescribeIdentityIdFormatRequest(PrincipalArn, Resource, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIdentityIdFormatRequest")
	local t = { 
		["PrincipalArn"] = PrincipalArn,
		["Resource"] = Resource,
	}
	M.AssertDescribeIdentityIdFormatRequest(t)
	return t
end

local DescribeFpgaImagesRequest_keys = { "Owners" = true, "DryRun" = true, "FpgaImageIds" = true, "MaxResults" = true, "Filters" = true, "NextToken" = true, nil }

function M.AssertDescribeFpgaImagesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImagesRequest to be of type 'table'")
	if struct["Owners"] then M.AssertOwnerStringList(struct["Owners"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["FpgaImageIds"] then M.AssertFpgaImageIdList(struct["FpgaImageIds"]) end
	if struct["MaxResults"] then M.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then M.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeFpgaImagesRequest_keys[k], "DescribeFpgaImagesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImagesRequest
--  
-- @param Owners [OwnerStringList] <p>Filters the AFI by owner. Specify an AWS account ID, <code>self</code> (owner is the sender of the request), or an AWS owner alias (valid values are <code>amazon</code> | <code>aws-marketplace</code>).</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param FpgaImageIds [FpgaImageIdList] <p>One or more AFI IDs.</p>
-- @param MaxResults [MaxResults] <p>The maximum number of results to return in a single call.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>create-time</code> - The creation time of the AFI.</p> </li> <li> <p> <code>fpga-image-id</code> - The FPGA image identifier (AFI ID).</p> </li> <li> <p> <code>fpga-image-global-id</code> - The global FPGA image identifier (AGFI ID).</p> </li> <li> <p> <code>name</code> - The name of the AFI.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the AFI owner.</p> </li> <li> <p> <code>product-code</code> - The product code.</p> </li> <li> <p> <code>shell-version</code> - The version of the AWS Shell that was used to create the bitstream.</p> </li> <li> <p> <code>state</code> - The state of the AFI (<code>pending</code> | <code>failed</code> | <code>available</code> | <code>unavailable</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>update-time</code> - The time of the most recent update.</p> </li> </ul>
-- @param NextToken [NextToken] <p>The token to retrieve the next page of results.</p>
function M.DescribeFpgaImagesRequest(Owners, DryRun, FpgaImageIds, MaxResults, Filters, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeFpgaImagesRequest")
	local t = { 
		["Owners"] = Owners,
		["DryRun"] = DryRun,
		["FpgaImageIds"] = FpgaImageIds,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeFpgaImagesRequest(t)
	return t
end

local NetworkInterface_keys = { "Status" = true, "MacAddress" = true, "SourceDestCheck" = true, "AvailabilityZone" = true, "Description" = true, "NetworkInterfaceId" = true, "VpcId" = true, "PrivateIpAddresses" = true, "RequesterManaged" = true, "PrivateDnsName" = true, "RequesterId" = true, "InterfaceType" = true, "Attachment" = true, "Groups" = true, "Ipv6Addresses" = true, "OwnerId" = true, "PrivateIpAddress" = true, "SubnetId" = true, "TagSet" = true, "Association" = true, nil }

function M.AssertNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterface to be of type 'table'")
	if struct["Status"] then M.AssertNetworkInterfaceStatus(struct["Status"]) end
	if struct["MacAddress"] then M.AssertString(struct["MacAddress"]) end
	if struct["SourceDestCheck"] then M.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["PrivateIpAddresses"] then M.AssertNetworkInterfacePrivateIpAddressList(struct["PrivateIpAddresses"]) end
	if struct["RequesterManaged"] then M.AssertBoolean(struct["RequesterManaged"]) end
	if struct["PrivateDnsName"] then M.AssertString(struct["PrivateDnsName"]) end
	if struct["RequesterId"] then M.AssertString(struct["RequesterId"]) end
	if struct["InterfaceType"] then M.AssertNetworkInterfaceType(struct["InterfaceType"]) end
	if struct["Attachment"] then M.AssertNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then M.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then M.AssertNetworkInterfaceIpv6AddressesList(struct["Ipv6Addresses"]) end
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["TagSet"] then M.AssertTagList(struct["TagSet"]) end
	if struct["Association"] then M.AssertNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(NetworkInterface_keys[k], "NetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterface
-- <p>Describes a network interface.</p>
-- @param Status [NetworkInterfaceStatus] <p>The status of the network interface.</p>
-- @param MacAddress [String] <p>The MAC address.</p>
-- @param SourceDestCheck [Boolean] <p>Indicates whether traffic to or from the instance is validated.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone.</p>
-- @param Description [String] <p>A description.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param PrivateIpAddresses [NetworkInterfacePrivateIpAddressList] <p>The private IPv4 addresses associated with the network interface.</p>
-- @param RequesterManaged [Boolean] <p>Indicates whether the network interface is being managed by AWS.</p>
-- @param PrivateDnsName [String] <p>The private DNS name.</p>
-- @param RequesterId [String] <p>The ID of the entity that launched the instance on your behalf (for example, AWS Management Console or Auto Scaling).</p>
-- @param InterfaceType [NetworkInterfaceType] <p>The type of interface.</p>
-- @param Attachment [NetworkInterfaceAttachment] <p>The network interface attachment.</p>
-- @param Groups [GroupIdentifierList] <p>Any security groups for the network interface.</p>
-- @param Ipv6Addresses [NetworkInterfaceIpv6AddressesList] <p>The IPv6 addresses associated with the network interface.</p>
-- @param OwnerId [String] <p>The AWS account ID of the owner of the network interface.</p>
-- @param PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param TagSet [TagList] <p>Any tags assigned to the network interface.</p>
-- @param Association [NetworkInterfaceAssociation] <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
function M.NetworkInterface(Status, MacAddress, SourceDestCheck, AvailabilityZone, Description, NetworkInterfaceId, VpcId, PrivateIpAddresses, RequesterManaged, PrivateDnsName, RequesterId, InterfaceType, Attachment, Groups, Ipv6Addresses, OwnerId, PrivateIpAddress, SubnetId, TagSet, Association, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterface")
	local t = { 
		["Status"] = Status,
		["MacAddress"] = MacAddress,
		["SourceDestCheck"] = SourceDestCheck,
		["AvailabilityZone"] = AvailabilityZone,
		["Description"] = Description,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["VpcId"] = VpcId,
		["PrivateIpAddresses"] = PrivateIpAddresses,
		["RequesterManaged"] = RequesterManaged,
		["PrivateDnsName"] = PrivateDnsName,
		["RequesterId"] = RequesterId,
		["InterfaceType"] = InterfaceType,
		["Attachment"] = Attachment,
		["Groups"] = Groups,
		["Ipv6Addresses"] = Ipv6Addresses,
		["OwnerId"] = OwnerId,
		["PrivateIpAddress"] = PrivateIpAddress,
		["SubnetId"] = SubnetId,
		["TagSet"] = TagSet,
		["Association"] = Association,
	}
	M.AssertNetworkInterface(t)
	return t
end

local KeyPair_keys = { "KeyMaterial" = true, "KeyName" = true, "KeyFingerprint" = true, nil }

function M.AssertKeyPair(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KeyPair to be of type 'table'")
	if struct["KeyMaterial"] then M.AssertString(struct["KeyMaterial"]) end
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then M.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(KeyPair_keys[k], "KeyPair contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KeyPair
-- <p>Describes a key pair.</p>
-- @param KeyMaterial [String] <p>An unencrypted PEM encoded RSA private key.</p>
-- @param KeyName [String] <p>The name of the key pair.</p>
-- @param KeyFingerprint [String] <p>The SHA-1 digest of the DER encoded private key.</p>
function M.KeyPair(KeyMaterial, KeyName, KeyFingerprint, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating KeyPair")
	local t = { 
		["KeyMaterial"] = KeyMaterial,
		["KeyName"] = KeyName,
		["KeyFingerprint"] = KeyFingerprint,
	}
	M.AssertKeyPair(t)
	return t
end

local PropagatingVgw_keys = { "GatewayId" = true, nil }

function M.AssertPropagatingVgw(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PropagatingVgw to be of type 'table'")
	if struct["GatewayId"] then M.AssertString(struct["GatewayId"]) end
	for k,_ in pairs(struct) do
		assert(PropagatingVgw_keys[k], "PropagatingVgw contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PropagatingVgw
-- <p>Describes a virtual private gateway propagating route.</p>
-- @param GatewayId [String] <p>The ID of the virtual private gateway (VGW).</p>
function M.PropagatingVgw(GatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PropagatingVgw")
	local t = { 
		["GatewayId"] = GatewayId,
	}
	M.AssertPropagatingVgw(t)
	return t
end

local DescribePrefixListsRequest_keys = { "NextToken" = true, "DryRun" = true, "MaxResults" = true, "Filters" = true, "PrefixListIds" = true, nil }

function M.AssertDescribePrefixListsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrefixListsRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["PrefixListIds"] then M.AssertValueStringList(struct["PrefixListIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribePrefixListsRequest_keys[k], "DescribePrefixListsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrefixListsRequest
-- <p>Contains the parameters for DescribePrefixLists.</p>
-- @param NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value specified is greater than 1000, we return only 1000 items.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>prefix-list-id</code>: The ID of a prefix list.</p> </li> <li> <p> <code>prefix-list-name</code>: The name of a prefix list.</p> </li> </ul>
-- @param PrefixListIds [ValueStringList] <p>One or more prefix list IDs.</p>
function M.DescribePrefixListsRequest(NextToken, DryRun, MaxResults, Filters, PrefixListIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribePrefixListsRequest")
	local t = { 
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
		["PrefixListIds"] = PrefixListIds,
	}
	M.AssertDescribePrefixListsRequest(t)
	return t
end

local PriceSchedule_keys = { "Active" = true, "CurrencyCode" = true, "Term" = true, "Price" = true, nil }

function M.AssertPriceSchedule(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PriceSchedule to be of type 'table'")
	if struct["Active"] then M.AssertBoolean(struct["Active"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Term"] then M.AssertLong(struct["Term"]) end
	if struct["Price"] then M.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(PriceSchedule_keys[k], "PriceSchedule contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PriceSchedule
-- <p>Describes the price for a Reserved Instance.</p>
-- @param Active [Boolean] <p>The current price schedule, as determined by the term remaining for the Reserved Instance in the listing.</p> <p>A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>
-- @param Term [Long] <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
-- @param Price [Double] <p>The fixed price for the term.</p>
function M.PriceSchedule(Active, CurrencyCode, Term, Price, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PriceSchedule")
	local t = { 
		["Active"] = Active,
		["CurrencyCode"] = CurrencyCode,
		["Term"] = Term,
		["Price"] = Price,
	}
	M.AssertPriceSchedule(t)
	return t
end

local InstanceNetworkInterfaceSpecification_keys = { "DeviceIndex" = true, "Description" = true, "Ipv6AddressCount" = true, "PrivateIpAddresses" = true, "SubnetId" = true, "DeleteOnTermination" = true, "PrivateIpAddress" = true, "Groups" = true, "Ipv6Addresses" = true, "NetworkInterfaceId" = true, "AssociatePublicIpAddress" = true, "SecondaryPrivateIpAddressCount" = true, nil }

function M.AssertInstanceNetworkInterfaceSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceSpecification to be of type 'table'")
	if struct["DeviceIndex"] then M.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then M.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then M.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then M.AssertSecurityGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then M.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then M.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then M.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(InstanceNetworkInterfaceSpecification_keys[k], "InstanceNetworkInterfaceSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceSpecification
-- <p>Describes a network interface.</p>
-- @param DeviceIndex [Integer] <p>The index of the device on the instance for the network interface attachment. If you are specifying a network interface in a <a>RunInstances</a> request, you must provide the device index.</p>
-- @param Description [String] <p>The description of the network interface. Applies only if creating a network interface when launching an instance.</p>
-- @param Ipv6AddressCount [Integer] <p>A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.</p>
-- @param PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- @param SubnetId [String] <p>The ID of the subnet associated with the network string. Applies only if creating a network interface when launching an instance.</p>
-- @param DeleteOnTermination [Boolean] <p>If set to <code>true</code>, the interface is deleted when the instance is terminated. You can specify <code>true</code> only if creating a new network interface when launching an instance.</p>
-- @param PrivateIpAddress [String] <p>The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- @param Groups [SecurityGroupIdStringList] <p>The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.</p>
-- @param Ipv6Addresses [InstanceIpv6AddressList] <p>One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param AssociatePublicIpAddress [Boolean] <p>Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>
-- @param SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
function M.InstanceNetworkInterfaceSpecification(DeviceIndex, Description, Ipv6AddressCount, PrivateIpAddresses, SubnetId, DeleteOnTermination, PrivateIpAddress, Groups, Ipv6Addresses, NetworkInterfaceId, AssociatePublicIpAddress, SecondaryPrivateIpAddressCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceNetworkInterfaceSpecification")
	local t = { 
		["DeviceIndex"] = DeviceIndex,
		["Description"] = Description,
		["Ipv6AddressCount"] = Ipv6AddressCount,
		["PrivateIpAddresses"] = PrivateIpAddresses,
		["SubnetId"] = SubnetId,
		["DeleteOnTermination"] = DeleteOnTermination,
		["PrivateIpAddress"] = PrivateIpAddress,
		["Groups"] = Groups,
		["Ipv6Addresses"] = Ipv6Addresses,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["AssociatePublicIpAddress"] = AssociatePublicIpAddress,
		["SecondaryPrivateIpAddressCount"] = SecondaryPrivateIpAddressCount,
	}
	M.AssertInstanceNetworkInterfaceSpecification(t)
	return t
end

local ReplaceNetworkAclAssociationResult_keys = { "NewAssociationId" = true, nil }

function M.AssertReplaceNetworkAclAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclAssociationResult to be of type 'table'")
	if struct["NewAssociationId"] then M.AssertString(struct["NewAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(ReplaceNetworkAclAssociationResult_keys[k], "ReplaceNetworkAclAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclAssociationResult
-- <p>Contains the output of ReplaceNetworkAclAssociation.</p>
-- @param NewAssociationId [String] <p>The ID of the new association.</p>
function M.ReplaceNetworkAclAssociationResult(NewAssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceNetworkAclAssociationResult")
	local t = { 
		["NewAssociationId"] = NewAssociationId,
	}
	M.AssertReplaceNetworkAclAssociationResult(t)
	return t
end

local UnsuccessfulItemError_keys = { "Message" = true, "Code" = true, nil }

function M.AssertUnsuccessfulItemError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulItemError to be of type 'table'")
	assert(struct["Code"], "Expected key Code to exist in table")
	assert(struct["Message"], "Expected key Message to exist in table")
	if struct["Message"] then M.AssertString(struct["Message"]) end
	if struct["Code"] then M.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(UnsuccessfulItemError_keys[k], "UnsuccessfulItemError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulItemError
-- <p>Information about the error that occurred. For more information about errors, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html">Error Codes</a>.</p>
-- @param Message [String] <p>The error message accompanying the error code.</p>
-- @param Code [String] <p>The error code.</p>
-- Required parameter: Code
-- Required parameter: Message
function M.UnsuccessfulItemError(Message, Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnsuccessfulItemError")
	local t = { 
		["Message"] = Message,
		["Code"] = Code,
	}
	M.AssertUnsuccessfulItemError(t)
	return t
end

local ReplaceRouteTableAssociationResult_keys = { "NewAssociationId" = true, nil }

function M.AssertReplaceRouteTableAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteTableAssociationResult to be of type 'table'")
	if struct["NewAssociationId"] then M.AssertString(struct["NewAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(ReplaceRouteTableAssociationResult_keys[k], "ReplaceRouteTableAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteTableAssociationResult
-- <p>Contains the output of ReplaceRouteTableAssociation.</p>
-- @param NewAssociationId [String] <p>The ID of the new association.</p>
function M.ReplaceRouteTableAssociationResult(NewAssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceRouteTableAssociationResult")
	local t = { 
		["NewAssociationId"] = NewAssociationId,
	}
	M.AssertReplaceRouteTableAssociationResult(t)
	return t
end

local AllocateHostsResult_keys = { "HostIds" = true, nil }

function M.AssertAllocateHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateHostsResult to be of type 'table'")
	if struct["HostIds"] then M.AssertResponseHostIdList(struct["HostIds"]) end
	for k,_ in pairs(struct) do
		assert(AllocateHostsResult_keys[k], "AllocateHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateHostsResult
-- <p>Contains the output of AllocateHosts.</p>
-- @param HostIds [ResponseHostIdList] <p>The ID of the allocated Dedicated Host. This is used when you want to launch an instance onto a specific host.</p>
function M.AllocateHostsResult(HostIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AllocateHostsResult")
	local t = { 
		["HostIds"] = HostIds,
	}
	M.AssertAllocateHostsResult(t)
	return t
end

local CreateCustomerGatewayResult_keys = { "CustomerGateway" = true, nil }

function M.AssertCreateCustomerGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCustomerGatewayResult to be of type 'table'")
	if struct["CustomerGateway"] then M.AssertCustomerGateway(struct["CustomerGateway"]) end
	for k,_ in pairs(struct) do
		assert(CreateCustomerGatewayResult_keys[k], "CreateCustomerGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCustomerGatewayResult
-- <p>Contains the output of CreateCustomerGateway.</p>
-- @param CustomerGateway [CustomerGateway] <p>Information about the customer gateway.</p>
function M.CreateCustomerGatewayResult(CustomerGateway, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateCustomerGatewayResult")
	local t = { 
		["CustomerGateway"] = CustomerGateway,
	}
	M.AssertCreateCustomerGatewayResult(t)
	return t
end

local DescribeVpcClassicLinkRequest_keys = { "DryRun" = true, "Filters" = true, "VpcIds" = true, nil }

function M.AssertDescribeVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["VpcIds"] then M.AssertVpcClassicLinkIdList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcClassicLinkRequest_keys[k], "DescribeVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkRequest
-- <p>Contains the parameters for DescribeVpcClassicLink.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>is-classic-link-enabled</code> - Whether the VPC is enabled for ClassicLink (<code>true</code> | <code>false</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
-- @param VpcIds [VpcClassicLinkIdList] <p>One or more VPCs for which you want to describe the ClassicLink status.</p>
function M.DescribeVpcClassicLinkRequest(DryRun, Filters, VpcIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcClassicLinkRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Filters"] = Filters,
		["VpcIds"] = VpcIds,
	}
	M.AssertDescribeVpcClassicLinkRequest(t)
	return t
end

local ModifySpotFleetRequestResponse_keys = { "Return" = true, nil }

function M.AssertModifySpotFleetRequestResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySpotFleetRequestResponse to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(ModifySpotFleetRequestResponse_keys[k], "ModifySpotFleetRequestResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySpotFleetRequestResponse
-- <p>Contains the output of ModifySpotFleetRequest.</p>
-- @param Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
function M.ModifySpotFleetRequestResponse(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifySpotFleetRequestResponse")
	local t = { 
		["Return"] = Return,
	}
	M.AssertModifySpotFleetRequestResponse(t)
	return t
end

local ModifySpotFleetRequestRequest_keys = { "TargetCapacity" = true, "SpotFleetRequestId" = true, "ExcessCapacityTerminationPolicy" = true, nil }

function M.AssertModifySpotFleetRequestRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySpotFleetRequestRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["TargetCapacity"] then M.AssertInteger(struct["TargetCapacity"]) end
	if struct["SpotFleetRequestId"] then M.AssertString(struct["SpotFleetRequestId"]) end
	if struct["ExcessCapacityTerminationPolicy"] then M.AssertExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	for k,_ in pairs(struct) do
		assert(ModifySpotFleetRequestRequest_keys[k], "ModifySpotFleetRequestRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySpotFleetRequestRequest
-- <p>Contains the parameters for ModifySpotFleetRequest.</p>
-- @param TargetCapacity [Integer] <p>The size of the fleet.</p>
-- @param SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param ExcessCapacityTerminationPolicy [ExcessCapacityTerminationPolicy] <p>Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.</p>
-- Required parameter: SpotFleetRequestId
function M.ModifySpotFleetRequestRequest(TargetCapacity, SpotFleetRequestId, ExcessCapacityTerminationPolicy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifySpotFleetRequestRequest")
	local t = { 
		["TargetCapacity"] = TargetCapacity,
		["SpotFleetRequestId"] = SpotFleetRequestId,
		["ExcessCapacityTerminationPolicy"] = ExcessCapacityTerminationPolicy,
	}
	M.AssertModifySpotFleetRequestRequest(t)
	return t
end

local Subnet_keys = { "AvailabilityZone" = true, "Tags" = true, "AvailableIpAddressCount" = true, "DefaultForAz" = true, "Ipv6CidrBlockAssociationSet" = true, "VpcId" = true, "State" = true, "MapPublicIpOnLaunch" = true, "SubnetId" = true, "CidrBlock" = true, "AssignIpv6AddressOnCreation" = true, nil }

function M.AssertSubnet(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Subnet to be of type 'table'")
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["AvailableIpAddressCount"] then M.AssertInteger(struct["AvailableIpAddressCount"]) end
	if struct["DefaultForAz"] then M.AssertBoolean(struct["DefaultForAz"]) end
	if struct["Ipv6CidrBlockAssociationSet"] then M.AssertSubnetIpv6CidrBlockAssociationSet(struct["Ipv6CidrBlockAssociationSet"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["State"] then M.AssertSubnetState(struct["State"]) end
	if struct["MapPublicIpOnLaunch"] then M.AssertBoolean(struct["MapPublicIpOnLaunch"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["CidrBlock"] then M.AssertString(struct["CidrBlock"]) end
	if struct["AssignIpv6AddressOnCreation"] then M.AssertBoolean(struct["AssignIpv6AddressOnCreation"]) end
	for k,_ in pairs(struct) do
		assert(Subnet_keys[k], "Subnet contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Subnet
-- <p>Describes a subnet.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone of the subnet.</p>
-- @param Tags [TagList] <p>Any tags assigned to the subnet.</p>
-- @param AvailableIpAddressCount [Integer] <p>The number of unused private IPv4 addresses in the subnet. Note that the IPv4 addresses for any stopped instances are considered unavailable.</p>
-- @param DefaultForAz [Boolean] <p>Indicates whether this is the default subnet for the Availability Zone.</p>
-- @param Ipv6CidrBlockAssociationSet [SubnetIpv6CidrBlockAssociationSet] <p>Information about the IPv6 CIDR blocks associated with the subnet.</p>
-- @param VpcId [String] <p>The ID of the VPC the subnet is in.</p>
-- @param State [SubnetState] <p>The current state of the subnet.</p>
-- @param MapPublicIpOnLaunch [Boolean] <p>Indicates whether instances launched in this subnet receive a public IPv4 address.</p>
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param CidrBlock [String] <p>The IPv4 CIDR block assigned to the subnet.</p>
-- @param AssignIpv6AddressOnCreation [Boolean] <p>Indicates whether a network interface created in this subnet (including a network interface created by <a>RunInstances</a>) receives an IPv6 address.</p>
function M.Subnet(AvailabilityZone, Tags, AvailableIpAddressCount, DefaultForAz, Ipv6CidrBlockAssociationSet, VpcId, State, MapPublicIpOnLaunch, SubnetId, CidrBlock, AssignIpv6AddressOnCreation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Subnet")
	local t = { 
		["AvailabilityZone"] = AvailabilityZone,
		["Tags"] = Tags,
		["AvailableIpAddressCount"] = AvailableIpAddressCount,
		["DefaultForAz"] = DefaultForAz,
		["Ipv6CidrBlockAssociationSet"] = Ipv6CidrBlockAssociationSet,
		["VpcId"] = VpcId,
		["State"] = State,
		["MapPublicIpOnLaunch"] = MapPublicIpOnLaunch,
		["SubnetId"] = SubnetId,
		["CidrBlock"] = CidrBlock,
		["AssignIpv6AddressOnCreation"] = AssignIpv6AddressOnCreation,
	}
	M.AssertSubnet(t)
	return t
end

local DisableVgwRoutePropagationRequest_keys = { "GatewayId" = true, "RouteTableId" = true, nil }

function M.AssertDisableVgwRoutePropagationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVgwRoutePropagationRequest to be of type 'table'")
	assert(struct["GatewayId"], "Expected key GatewayId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["GatewayId"] then M.AssertString(struct["GatewayId"]) end
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(DisableVgwRoutePropagationRequest_keys[k], "DisableVgwRoutePropagationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVgwRoutePropagationRequest
-- <p>Contains the parameters for DisableVgwRoutePropagation.</p>
-- @param GatewayId [String] <p>The ID of the virtual private gateway.</p>
-- @param RouteTableId [String] <p>The ID of the route table.</p>
-- Required parameter: GatewayId
-- Required parameter: RouteTableId
function M.DisableVgwRoutePropagationRequest(GatewayId, RouteTableId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVgwRoutePropagationRequest")
	local t = { 
		["GatewayId"] = GatewayId,
		["RouteTableId"] = RouteTableId,
	}
	M.AssertDisableVgwRoutePropagationRequest(t)
	return t
end

local DescribeHostReservationsResult_keys = { "NextToken" = true, "HostReservationSet" = true, nil }

function M.AssertDescribeHostReservationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationsResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["HostReservationSet"] then M.AssertHostReservationSet(struct["HostReservationSet"]) end
	for k,_ in pairs(struct) do
		assert(DescribeHostReservationsResult_keys[k], "DescribeHostReservationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationsResult
--  
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param HostReservationSet [HostReservationSet] <p>Details about the reservation's configuration.</p>
function M.DescribeHostReservationsResult(NextToken, HostReservationSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostReservationsResult")
	local t = { 
		["NextToken"] = NextToken,
		["HostReservationSet"] = HostReservationSet,
	}
	M.AssertDescribeHostReservationsResult(t)
	return t
end

local CancelSpotInstanceRequestsResult_keys = { "CancelledSpotInstanceRequests" = true, nil }

function M.AssertCancelSpotInstanceRequestsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotInstanceRequestsResult to be of type 'table'")
	if struct["CancelledSpotInstanceRequests"] then M.AssertCancelledSpotInstanceRequestList(struct["CancelledSpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(CancelSpotInstanceRequestsResult_keys[k], "CancelSpotInstanceRequestsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotInstanceRequestsResult
-- <p>Contains the output of CancelSpotInstanceRequests.</p>
-- @param CancelledSpotInstanceRequests [CancelledSpotInstanceRequestList] <p>One or more Spot instance requests.</p>
function M.CancelSpotInstanceRequestsResult(CancelledSpotInstanceRequests, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotInstanceRequestsResult")
	local t = { 
		["CancelledSpotInstanceRequests"] = CancelledSpotInstanceRequests,
	}
	M.AssertCancelSpotInstanceRequestsResult(t)
	return t
end

local RunInstancesRequest_keys = { "DryRun" = true, "TagSpecifications" = true, "MinCount" = true, "EbsOptimized" = true, "RamdiskId" = true, "Monitoring" = true, "PrivateIpAddress" = true, "ImageId" = true, "KeyName" = true, "SecurityGroups" = true, "ClientToken" = true, "SubnetId" = true, "InstanceType" = true, "NetworkInterfaces" = true, "AdditionalInfo" = true, "Placement" = true, "InstanceInitiatedShutdownBehavior" = true, "SecurityGroupIds" = true, "BlockDeviceMappings" = true, "KernelId" = true, "IamInstanceProfile" = true, "UserData" = true, "Ipv6AddressCount" = true, "MaxCount" = true, "Ipv6Addresses" = true, "DisableApiTermination" = true, nil }

function M.AssertRunInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunInstancesRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	assert(struct["MaxCount"], "Expected key MaxCount to exist in table")
	assert(struct["MinCount"], "Expected key MinCount to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["TagSpecifications"] then M.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["MinCount"] then M.AssertInteger(struct["MinCount"]) end
	if struct["EbsOptimized"] then M.AssertBoolean(struct["EbsOptimized"]) end
	if struct["RamdiskId"] then M.AssertString(struct["RamdiskId"]) end
	if struct["Monitoring"] then M.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then M.AssertSecurityGroupStringList(struct["SecurityGroups"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then M.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	if struct["AdditionalInfo"] then M.AssertString(struct["AdditionalInfo"]) end
	if struct["Placement"] then M.AssertPlacement(struct["Placement"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then M.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["SecurityGroupIds"] then M.AssertSecurityGroupIdStringList(struct["SecurityGroupIds"]) end
	if struct["BlockDeviceMappings"] then M.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then M.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then M.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["UserData"] then M.AssertString(struct["UserData"]) end
	if struct["Ipv6AddressCount"] then M.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["MaxCount"] then M.AssertInteger(struct["MaxCount"]) end
	if struct["Ipv6Addresses"] then M.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["DisableApiTermination"] then M.AssertBoolean(struct["DisableApiTermination"]) end
	for k,_ in pairs(struct) do
		assert(RunInstancesRequest_keys[k], "RunInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunInstancesRequest
-- <p>Contains the parameters for RunInstances.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param TagSpecifications [TagSpecificationList] <p>The tags to apply to the resources during launch. You can tag instances and volumes. The specified tags are applied to all instances or volumes that are created during launch.</p>
-- @param MinCount [Integer] <p>The minimum number of instances to launch. If you specify a minimum that is more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches no instances.</p> <p>Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I run in Amazon EC2</a> in the Amazon EC2 General FAQ.</p>
-- @param EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param RamdiskId [String] <p>The ID of the RAM disk.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- @param Monitoring [RunInstancesMonitoringEnabled] <p>The monitoring for the instance.</p>
-- @param PrivateIpAddress [String] <p>[EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.</p> <p>Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.</p>
-- @param ImageId [String] <p>The ID of the AMI, which you can get by calling <a>DescribeImages</a>.</p>
-- @param KeyName [String] <p>The name of the key pair. You can create a key pair using <a>CreateKeyPair</a> or <a>ImportKeyPair</a>.</p> <important> <p>If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.</p> </important>
-- @param SecurityGroups [SecurityGroupStringList] <p>[EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead.</p> <p>Default: Amazon EC2 uses the default security group.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p> <p>Constraints: Maximum 64 ASCII characters</p>
-- @param SubnetId [String] <p>[EC2-VPC] The ID of the subnet to launch the instance into.</p>
-- @param InstanceType [InstanceType] <p>The instance type. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Default: <code>m1.small</code> </p>
-- @param NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces.</p>
-- @param AdditionalInfo [String] <p>Reserved.</p>
-- @param Placement [Placement] <p>The placement for the instance.</p>
-- @param InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p> <p>Default: <code>stop</code> </p>
-- @param SecurityGroupIds [SecurityGroupIdStringList] <p>One or more security group IDs. You can create a security group using <a>CreateSecurityGroup</a>.</p> <p>Default: Amazon EC2 uses the default security group.</p>
-- @param BlockDeviceMappings [BlockDeviceMappingRequestList] <p>The block device mapping.</p> <important> <p>Supplying both a snapshot ID and an encryption value as arguments for block-device mapping results in an error. This is because only blank volumes can be encrypted on start, and these are not created from a snapshot. If a snapshot is the basis for the volume, it contains data by definition and its encryption status cannot be changed using this action.</p> </important>
-- @param KernelId [String] <p>The ID of the kernel.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- @param IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- @param UserData [String] <p>The user data to make available to the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html">Running Commands on Your Linux Instance at Launch</a> (Linux) and <a href="http://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data">Adding User Data</a> (Windows). If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param Ipv6AddressCount [Integer] <p>[EC2-VPC] A number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.</p>
-- @param MaxCount [Integer] <p>The maximum number of instances to launch. If you specify more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches the largest possible number of instances above <code>MinCount</code>.</p> <p>Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I run in Amazon EC2</a> in the Amazon EC2 FAQ.</p>
-- @param Ipv6Addresses [InstanceIpv6AddressList] <p>[EC2-VPC] Specify one or more IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.</p>
-- @param DisableApiTermination [Boolean] <p>If you set this parameter to <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute to <code>false</code> after launch, use <a>ModifyInstanceAttribute</a>. Alternatively, if you set <code>InstanceInitiatedShutdownBehavior</code> to <code>terminate</code>, you can terminate the instance by running the shutdown command from the instance.</p> <p>Default: <code>false</code> </p>
-- Required parameter: ImageId
-- Required parameter: MaxCount
-- Required parameter: MinCount
function M.RunInstancesRequest(DryRun, TagSpecifications, MinCount, EbsOptimized, RamdiskId, Monitoring, PrivateIpAddress, ImageId, KeyName, SecurityGroups, ClientToken, SubnetId, InstanceType, NetworkInterfaces, AdditionalInfo, Placement, InstanceInitiatedShutdownBehavior, SecurityGroupIds, BlockDeviceMappings, KernelId, IamInstanceProfile, UserData, Ipv6AddressCount, MaxCount, Ipv6Addresses, DisableApiTermination, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RunInstancesRequest")
	local t = { 
		["DryRun"] = DryRun,
		["TagSpecifications"] = TagSpecifications,
		["MinCount"] = MinCount,
		["EbsOptimized"] = EbsOptimized,
		["RamdiskId"] = RamdiskId,
		["Monitoring"] = Monitoring,
		["PrivateIpAddress"] = PrivateIpAddress,
		["ImageId"] = ImageId,
		["KeyName"] = KeyName,
		["SecurityGroups"] = SecurityGroups,
		["ClientToken"] = ClientToken,
		["SubnetId"] = SubnetId,
		["InstanceType"] = InstanceType,
		["NetworkInterfaces"] = NetworkInterfaces,
		["AdditionalInfo"] = AdditionalInfo,
		["Placement"] = Placement,
		["InstanceInitiatedShutdownBehavior"] = InstanceInitiatedShutdownBehavior,
		["SecurityGroupIds"] = SecurityGroupIds,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["KernelId"] = KernelId,
		["IamInstanceProfile"] = IamInstanceProfile,
		["UserData"] = UserData,
		["Ipv6AddressCount"] = Ipv6AddressCount,
		["MaxCount"] = MaxCount,
		["Ipv6Addresses"] = Ipv6Addresses,
		["DisableApiTermination"] = DisableApiTermination,
	}
	M.AssertRunInstancesRequest(t)
	return t
end

local CreateVpnConnectionRequest_keys = { "CustomerGatewayId" = true, "DryRun" = true, "Type" = true, "VpnGatewayId" = true, "Options" = true, nil }

function M.AssertCreateVpnConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionRequest to be of type 'table'")
	assert(struct["CustomerGatewayId"], "Expected key CustomerGatewayId to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["CustomerGatewayId"] then M.AssertString(struct["CustomerGatewayId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Type"] then M.AssertString(struct["Type"]) end
	if struct["VpnGatewayId"] then M.AssertString(struct["VpnGatewayId"]) end
	if struct["Options"] then M.AssertVpnConnectionOptionsSpecification(struct["Options"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpnConnectionRequest_keys[k], "CreateVpnConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionRequest
-- <p>Contains the parameters for CreateVpnConnection.</p>
-- @param CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Type [String] <p>The type of VPN connection (<code>ipsec.1</code>).</p>
-- @param VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- @param Options [VpnConnectionOptionsSpecification] <p>Indicates whether the VPN connection requires static routes. If you are creating a VPN connection for a device that does not support BGP, you must specify <code>true</code>.</p> <p>Default: <code>false</code> </p>
-- Required parameter: CustomerGatewayId
-- Required parameter: Type
-- Required parameter: VpnGatewayId
function M.CreateVpnConnectionRequest(CustomerGatewayId, DryRun, Type, VpnGatewayId, Options, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnConnectionRequest")
	local t = { 
		["CustomerGatewayId"] = CustomerGatewayId,
		["DryRun"] = DryRun,
		["Type"] = Type,
		["VpnGatewayId"] = VpnGatewayId,
		["Options"] = Options,
	}
	M.AssertCreateVpnConnectionRequest(t)
	return t
end

local VpcIpv6CidrBlockAssociation_keys = { "Ipv6CidrBlock" = true, "AssociationId" = true, "Ipv6CidrBlockState" = true, nil }

function M.AssertVpcIpv6CidrBlockAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcIpv6CidrBlockAssociation to be of type 'table'")
	if struct["Ipv6CidrBlock"] then M.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["Ipv6CidrBlockState"] then M.AssertVpcCidrBlockState(struct["Ipv6CidrBlockState"]) end
	for k,_ in pairs(struct) do
		assert(VpcIpv6CidrBlockAssociation_keys[k], "VpcIpv6CidrBlockAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcIpv6CidrBlockAssociation
-- <p>Describes an IPv6 CIDR block associated with a VPC.</p>
-- @param Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- @param AssociationId [String] <p>The association ID for the IPv6 CIDR block.</p>
-- @param Ipv6CidrBlockState [VpcCidrBlockState] <p>Information about the state of the CIDR block.</p>
function M.VpcIpv6CidrBlockAssociation(Ipv6CidrBlock, AssociationId, Ipv6CidrBlockState, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcIpv6CidrBlockAssociation")
	local t = { 
		["Ipv6CidrBlock"] = Ipv6CidrBlock,
		["AssociationId"] = AssociationId,
		["Ipv6CidrBlockState"] = Ipv6CidrBlockState,
	}
	M.AssertVpcIpv6CidrBlockAssociation(t)
	return t
end

local DescribeSpotFleetInstancesResponse_keys = { "ActiveInstances" = true, "SpotFleetRequestId" = true, "NextToken" = true, nil }

function M.AssertDescribeSpotFleetInstancesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetInstancesResponse to be of type 'table'")
	assert(struct["ActiveInstances"], "Expected key ActiveInstances to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["ActiveInstances"] then M.AssertActiveInstanceSet(struct["ActiveInstances"]) end
	if struct["SpotFleetRequestId"] then M.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotFleetInstancesResponse_keys[k], "DescribeSpotFleetInstancesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetInstancesResponse
-- <p>Contains the output of DescribeSpotFleetInstances.</p>
-- @param ActiveInstances [ActiveInstanceSet] <p>The running instances. Note that this list is refreshed periodically and might be out of date.</p>
-- @param SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- Required parameter: ActiveInstances
-- Required parameter: SpotFleetRequestId
function M.DescribeSpotFleetInstancesResponse(ActiveInstances, SpotFleetRequestId, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetInstancesResponse")
	local t = { 
		["ActiveInstances"] = ActiveInstances,
		["SpotFleetRequestId"] = SpotFleetRequestId,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeSpotFleetInstancesResponse(t)
	return t
end

local VpnConnection_keys = { "VpnConnectionId" = true, "Tags" = true, "CustomerGatewayConfiguration" = true, "Routes" = true, "State" = true, "VpnGatewayId" = true, "CustomerGatewayId" = true, "Type" = true, "Options" = true, "VgwTelemetry" = true, nil }

function M.AssertVpnConnection(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnection to be of type 'table'")
	if struct["VpnConnectionId"] then M.AssertString(struct["VpnConnectionId"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["CustomerGatewayConfiguration"] then M.AssertString(struct["CustomerGatewayConfiguration"]) end
	if struct["Routes"] then M.AssertVpnStaticRouteList(struct["Routes"]) end
	if struct["State"] then M.AssertVpnState(struct["State"]) end
	if struct["VpnGatewayId"] then M.AssertString(struct["VpnGatewayId"]) end
	if struct["CustomerGatewayId"] then M.AssertString(struct["CustomerGatewayId"]) end
	if struct["Type"] then M.AssertGatewayType(struct["Type"]) end
	if struct["Options"] then M.AssertVpnConnectionOptions(struct["Options"]) end
	if struct["VgwTelemetry"] then M.AssertVgwTelemetryList(struct["VgwTelemetry"]) end
	for k,_ in pairs(struct) do
		assert(VpnConnection_keys[k], "VpnConnection contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnection
-- <p>Describes a VPN connection.</p>
-- @param VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- @param Tags [TagList] <p>Any tags assigned to the VPN connection.</p>
-- @param CustomerGatewayConfiguration [String] <p>The configuration information for the VPN connection's customer gateway (in the native XML format). This element is always present in the <a>CreateVpnConnection</a> response; however, it's present in the <a>DescribeVpnConnections</a> response only if the VPN connection is in the <code>pending</code> or <code>available</code> state.</p>
-- @param Routes [VpnStaticRouteList] <p>The static routes associated with the VPN connection.</p>
-- @param State [VpnState] <p>The current state of the VPN connection.</p>
-- @param VpnGatewayId [String] <p>The ID of the virtual private gateway at the AWS side of the VPN connection.</p>
-- @param CustomerGatewayId [String] <p>The ID of the customer gateway at your end of the VPN connection.</p>
-- @param Type [GatewayType] <p>The type of VPN connection.</p>
-- @param Options [VpnConnectionOptions] <p>The VPN connection options.</p>
-- @param VgwTelemetry [VgwTelemetryList] <p>Information about the VPN tunnel.</p>
function M.VpnConnection(VpnConnectionId, Tags, CustomerGatewayConfiguration, Routes, State, VpnGatewayId, CustomerGatewayId, Type, Options, VgwTelemetry, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnConnection")
	local t = { 
		["VpnConnectionId"] = VpnConnectionId,
		["Tags"] = Tags,
		["CustomerGatewayConfiguration"] = CustomerGatewayConfiguration,
		["Routes"] = Routes,
		["State"] = State,
		["VpnGatewayId"] = VpnGatewayId,
		["CustomerGatewayId"] = CustomerGatewayId,
		["Type"] = Type,
		["Options"] = Options,
		["VgwTelemetry"] = VgwTelemetry,
	}
	M.AssertVpnConnection(t)
	return t
end

local ScheduledInstancesPrivateIpAddressConfig_keys = { "Primary" = true, "PrivateIpAddress" = true, nil }

function M.AssertScheduledInstancesPrivateIpAddressConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesPrivateIpAddressConfig to be of type 'table'")
	if struct["Primary"] then M.AssertBoolean(struct["Primary"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstancesPrivateIpAddressConfig_keys[k], "ScheduledInstancesPrivateIpAddressConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesPrivateIpAddressConfig
-- <p>Describes a private IPv4 address for a Scheduled Instance.</p>
-- @param Primary [Boolean] <p>Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.</p>
-- @param PrivateIpAddress [String] <p>The IPv4 address.</p>
function M.ScheduledInstancesPrivateIpAddressConfig(Primary, PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesPrivateIpAddressConfig")
	local t = { 
		["Primary"] = Primary,
		["PrivateIpAddress"] = PrivateIpAddress,
	}
	M.AssertScheduledInstancesPrivateIpAddressConfig(t)
	return t
end

local DescribeSubnetsResult_keys = { "Subnets" = true, nil }

function M.AssertDescribeSubnetsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSubnetsResult to be of type 'table'")
	if struct["Subnets"] then M.AssertSubnetList(struct["Subnets"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSubnetsResult_keys[k], "DescribeSubnetsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSubnetsResult
-- <p>Contains the output of DescribeSubnets.</p>
-- @param Subnets [SubnetList] <p>Information about one or more subnets.</p>
function M.DescribeSubnetsResult(Subnets, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSubnetsResult")
	local t = { 
		["Subnets"] = Subnets,
	}
	M.AssertDescribeSubnetsResult(t)
	return t
end

local DisableVpcClassicLinkResult_keys = { "Return" = true, nil }

function M.AssertDisableVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(DisableVpcClassicLinkResult_keys[k], "DisableVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkResult
-- <p>Contains the output of DisableVpcClassicLink.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DisableVpcClassicLinkResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVpcClassicLinkResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertDisableVpcClassicLinkResult(t)
	return t
end

local AcceptVpcPeeringConnectionResult_keys = { "VpcPeeringConnection" = true, nil }

function M.AssertAcceptVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcPeeringConnectionResult to be of type 'table'")
	if struct["VpcPeeringConnection"] then M.AssertVpcPeeringConnection(struct["VpcPeeringConnection"]) end
	for k,_ in pairs(struct) do
		assert(AcceptVpcPeeringConnectionResult_keys[k], "AcceptVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcPeeringConnectionResult
-- <p>Contains the output of AcceptVpcPeeringConnection.</p>
-- @param VpcPeeringConnection [VpcPeeringConnection] <p>Information about the VPC peering connection.</p>
function M.AcceptVpcPeeringConnectionResult(VpcPeeringConnection, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AcceptVpcPeeringConnectionResult")
	local t = { 
		["VpcPeeringConnection"] = VpcPeeringConnection,
	}
	M.AssertAcceptVpcPeeringConnectionResult(t)
	return t
end

local ModifyReservedInstancesRequest_keys = { "TargetConfigurations" = true, "ReservedInstancesIds" = true, "ClientToken" = true, nil }

function M.AssertModifyReservedInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyReservedInstancesRequest to be of type 'table'")
	assert(struct["ReservedInstancesIds"], "Expected key ReservedInstancesIds to exist in table")
	assert(struct["TargetConfigurations"], "Expected key TargetConfigurations to exist in table")
	if struct["TargetConfigurations"] then M.AssertReservedInstancesConfigurationList(struct["TargetConfigurations"]) end
	if struct["ReservedInstancesIds"] then M.AssertReservedInstancesIdStringList(struct["ReservedInstancesIds"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(ModifyReservedInstancesRequest_keys[k], "ModifyReservedInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyReservedInstancesRequest
-- <p>Contains the parameters for ModifyReservedInstances.</p>
-- @param TargetConfigurations [ReservedInstancesConfigurationList] <p>The configuration settings for the Reserved Instances to modify.</p>
-- @param ReservedInstancesIds [ReservedInstancesIdStringList] <p>The IDs of the Reserved Instances to modify.</p>
-- @param ClientToken [String] <p>A unique, case-sensitive token you provide to ensure idempotency of your modification request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required parameter: ReservedInstancesIds
-- Required parameter: TargetConfigurations
function M.ModifyReservedInstancesRequest(TargetConfigurations, ReservedInstancesIds, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyReservedInstancesRequest")
	local t = { 
		["TargetConfigurations"] = TargetConfigurations,
		["ReservedInstancesIds"] = ReservedInstancesIds,
		["ClientToken"] = ClientToken,
	}
	M.AssertModifyReservedInstancesRequest(t)
	return t
end

local ReservedInstanceReservationValue_keys = { "ReservedInstanceId" = true, "ReservationValue" = true, nil }

function M.AssertReservedInstanceReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstanceReservationValue to be of type 'table'")
	if struct["ReservedInstanceId"] then M.AssertString(struct["ReservedInstanceId"]) end
	if struct["ReservationValue"] then M.AssertReservationValue(struct["ReservationValue"]) end
	for k,_ in pairs(struct) do
		assert(ReservedInstanceReservationValue_keys[k], "ReservedInstanceReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstanceReservationValue
-- <p>The total value of the Convertible Reserved Instance.</p>
-- @param ReservedInstanceId [String] <p>The ID of the Convertible Reserved Instance that you are exchanging.</p>
-- @param ReservationValue [ReservationValue] <p>The total value of the Convertible Reserved Instance that you are exchanging.</p>
function M.ReservedInstanceReservationValue(ReservedInstanceId, ReservationValue, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstanceReservationValue")
	local t = { 
		["ReservedInstanceId"] = ReservedInstanceId,
		["ReservationValue"] = ReservationValue,
	}
	M.AssertReservedInstanceReservationValue(t)
	return t
end

local CreateVolumePermission_keys = { "UserId" = true, "Group" = true, nil }

function M.AssertCreateVolumePermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumePermission to be of type 'table'")
	if struct["UserId"] then M.AssertString(struct["UserId"]) end
	if struct["Group"] then M.AssertPermissionGroup(struct["Group"]) end
	for k,_ in pairs(struct) do
		assert(CreateVolumePermission_keys[k], "CreateVolumePermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumePermission
-- <p>Describes the user or group to be added or removed from the permissions for a volume.</p>
-- @param UserId [String] <p>The specific AWS account ID that is to be added or removed from a volume's list of create volume permissions.</p>
-- @param Group [PermissionGroup] <p>The specific group that is to be added or removed from a volume's list of create volume permissions.</p>
function M.CreateVolumePermission(UserId, Group, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVolumePermission")
	local t = { 
		["UserId"] = UserId,
		["Group"] = Group,
	}
	M.AssertCreateVolumePermission(t)
	return t
end

local DescribeSpotFleetRequestsRequest_keys = { "SpotFleetRequestIds" = true, "NextToken" = true, "DryRun" = true, "MaxResults" = true, nil }

function M.AssertDescribeSpotFleetRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestsRequest to be of type 'table'")
	if struct["SpotFleetRequestIds"] then M.AssertValueStringList(struct["SpotFleetRequestIds"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotFleetRequestsRequest_keys[k], "DescribeSpotFleetRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestsRequest
-- <p>Contains the parameters for DescribeSpotFleetRequests.</p>
-- @param SpotFleetRequestIds [ValueStringList] <p>The IDs of the Spot fleet requests.</p>
-- @param NextToken [String] <p>The token for the next set of results.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
function M.DescribeSpotFleetRequestsRequest(SpotFleetRequestIds, NextToken, DryRun, MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetRequestsRequest")
	local t = { 
		["SpotFleetRequestIds"] = SpotFleetRequestIds,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
	}
	M.AssertDescribeSpotFleetRequestsRequest(t)
	return t
end

local GetConsoleOutputRequest_keys = { "InstanceId" = true, "DryRun" = true, nil }

function M.AssertGetConsoleOutputRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleOutputRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(GetConsoleOutputRequest_keys[k], "GetConsoleOutputRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleOutputRequest
-- <p>Contains the parameters for GetConsoleOutput.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
function M.GetConsoleOutputRequest(InstanceId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetConsoleOutputRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["DryRun"] = DryRun,
	}
	M.AssertGetConsoleOutputRequest(t)
	return t
end

local DescribeFlowLogsResult_keys = { "FlowLogs" = true, "NextToken" = true, nil }

function M.AssertDescribeFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFlowLogsResult to be of type 'table'")
	if struct["FlowLogs"] then M.AssertFlowLogSet(struct["FlowLogs"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeFlowLogsResult_keys[k], "DescribeFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFlowLogsResult
-- <p>Contains the output of DescribeFlowLogs.</p>
-- @param FlowLogs [FlowLogSet] <p>Information about the flow logs.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeFlowLogsResult(FlowLogs, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeFlowLogsResult")
	local t = { 
		["FlowLogs"] = FlowLogs,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeFlowLogsResult(t)
	return t
end

local VolumeStatusInfo_keys = { "Status" = true, "Details" = true, nil }

function M.AssertVolumeStatusInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusInfo to be of type 'table'")
	if struct["Status"] then M.AssertVolumeStatusInfoStatus(struct["Status"]) end
	if struct["Details"] then M.AssertVolumeStatusDetailsList(struct["Details"]) end
	for k,_ in pairs(struct) do
		assert(VolumeStatusInfo_keys[k], "VolumeStatusInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusInfo
-- <p>Describes the status of a volume.</p>
-- @param Status [VolumeStatusInfoStatus] <p>The status of the volume.</p>
-- @param Details [VolumeStatusDetailsList] <p>The details of the volume status.</p>
function M.VolumeStatusInfo(Status, Details, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusInfo")
	local t = { 
		["Status"] = Status,
		["Details"] = Details,
	}
	M.AssertVolumeStatusInfo(t)
	return t
end

local Purchase_keys = { "HourlyPrice" = true, "InstanceFamily" = true, "CurrencyCode" = true, "PaymentOption" = true, "HostIdSet" = true, "HostReservationId" = true, "UpfrontPrice" = true, "Duration" = true, nil }

function M.AssertPurchase(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Purchase to be of type 'table'")
	if struct["HourlyPrice"] then M.AssertString(struct["HourlyPrice"]) end
	if struct["InstanceFamily"] then M.AssertString(struct["InstanceFamily"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["PaymentOption"] then M.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["HostIdSet"] then M.AssertResponseHostIdSet(struct["HostIdSet"]) end
	if struct["HostReservationId"] then M.AssertString(struct["HostReservationId"]) end
	if struct["UpfrontPrice"] then M.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then M.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(Purchase_keys[k], "Purchase contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Purchase
-- <p>Describes the result of the purchase.</p>
-- @param HourlyPrice [String] <p>The hourly price of the reservation per hour.</p>
-- @param InstanceFamily [String] <p>The instance family on the Dedicated Host that the reservation can be associated with.</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>UpfrontPrice</code> and <code>HourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param PaymentOption [PaymentOption] <p>The payment option for the reservation.</p>
-- @param HostIdSet [ResponseHostIdSet] <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
-- @param HostReservationId [String] <p>The ID of the reservation.</p>
-- @param UpfrontPrice [String] <p>The upfront price of the reservation.</p>
-- @param Duration [Integer] <p>The duration of the reservation's term in seconds.</p>
function M.Purchase(HourlyPrice, InstanceFamily, CurrencyCode, PaymentOption, HostIdSet, HostReservationId, UpfrontPrice, Duration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Purchase")
	local t = { 
		["HourlyPrice"] = HourlyPrice,
		["InstanceFamily"] = InstanceFamily,
		["CurrencyCode"] = CurrencyCode,
		["PaymentOption"] = PaymentOption,
		["HostIdSet"] = HostIdSet,
		["HostReservationId"] = HostReservationId,
		["UpfrontPrice"] = UpfrontPrice,
		["Duration"] = Duration,
	}
	M.AssertPurchase(t)
	return t
end

local PeeringConnectionOptions_keys = { "AllowEgressFromLocalVpcToRemoteClassicLink" = true, "AllowDnsResolutionFromRemoteVpc" = true, "AllowEgressFromLocalClassicLinkToRemoteVpc" = true, nil }

function M.AssertPeeringConnectionOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PeeringConnectionOptions to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then M.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then M.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then M.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(PeeringConnectionOptions_keys[k], "PeeringConnectionOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PeeringConnectionOptions
-- <p>Describes the VPC peering connection options.</p>
-- @param AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.</p>
-- @param AllowDnsResolutionFromRemoteVpc [Boolean] <p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>
-- @param AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.</p>
function M.PeeringConnectionOptions(AllowEgressFromLocalVpcToRemoteClassicLink, AllowDnsResolutionFromRemoteVpc, AllowEgressFromLocalClassicLinkToRemoteVpc, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PeeringConnectionOptions")
	local t = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = AllowEgressFromLocalVpcToRemoteClassicLink,
		["AllowDnsResolutionFromRemoteVpc"] = AllowDnsResolutionFromRemoteVpc,
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = AllowEgressFromLocalClassicLinkToRemoteVpc,
	}
	M.AssertPeeringConnectionOptions(t)
	return t
end

local Vpc_keys = { "VpcId" = true, "InstanceTenancy" = true, "Tags" = true, "Ipv6CidrBlockAssociationSet" = true, "State" = true, "DhcpOptionsId" = true, "CidrBlock" = true, "IsDefault" = true, nil }

function M.AssertVpc(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Vpc to be of type 'table'")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["InstanceTenancy"] then M.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["Ipv6CidrBlockAssociationSet"] then M.AssertVpcIpv6CidrBlockAssociationSet(struct["Ipv6CidrBlockAssociationSet"]) end
	if struct["State"] then M.AssertVpcState(struct["State"]) end
	if struct["DhcpOptionsId"] then M.AssertString(struct["DhcpOptionsId"]) end
	if struct["CidrBlock"] then M.AssertString(struct["CidrBlock"]) end
	if struct["IsDefault"] then M.AssertBoolean(struct["IsDefault"]) end
	for k,_ in pairs(struct) do
		assert(Vpc_keys[k], "Vpc contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Vpc
-- <p>Describes a VPC.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param InstanceTenancy [Tenancy] <p>The allowed tenancy of instances launched into the VPC.</p>
-- @param Tags [TagList] <p>Any tags assigned to the VPC.</p>
-- @param Ipv6CidrBlockAssociationSet [VpcIpv6CidrBlockAssociationSet] <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
-- @param State [VpcState] <p>The current state of the VPC.</p>
-- @param DhcpOptionsId [String] <p>The ID of the set of DHCP options you've associated with the VPC (or <code>default</code> if the default options are associated with the VPC).</p>
-- @param CidrBlock [String] <p>The IPv4 CIDR block for the VPC.</p>
-- @param IsDefault [Boolean] <p>Indicates whether the VPC is the default VPC.</p>
function M.Vpc(VpcId, InstanceTenancy, Tags, Ipv6CidrBlockAssociationSet, State, DhcpOptionsId, CidrBlock, IsDefault, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Vpc")
	local t = { 
		["VpcId"] = VpcId,
		["InstanceTenancy"] = InstanceTenancy,
		["Tags"] = Tags,
		["Ipv6CidrBlockAssociationSet"] = Ipv6CidrBlockAssociationSet,
		["State"] = State,
		["DhcpOptionsId"] = DhcpOptionsId,
		["CidrBlock"] = CidrBlock,
		["IsDefault"] = IsDefault,
	}
	M.AssertVpc(t)
	return t
end

local DescribeVpcEndpointServicesResult_keys = { "NextToken" = true, "ServiceNames" = true, nil }

function M.AssertDescribeVpcEndpointServicesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicesResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["ServiceNames"] then M.AssertValueStringList(struct["ServiceNames"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcEndpointServicesResult_keys[k], "DescribeVpcEndpointServicesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicesResult
-- <p>Contains the output of DescribeVpcEndpointServices.</p>
-- @param NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @param ServiceNames [ValueStringList] <p>A list of supported AWS services.</p>
function M.DescribeVpcEndpointServicesResult(NextToken, ServiceNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcEndpointServicesResult")
	local t = { 
		["NextToken"] = NextToken,
		["ServiceNames"] = ServiceNames,
	}
	M.AssertDescribeVpcEndpointServicesResult(t)
	return t
end

local ReplaceRouteTableAssociationRequest_keys = { "RouteTableId" = true, "AssociationId" = true, "DryRun" = true, nil }

function M.AssertReplaceRouteTableAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteTableAssociationRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(ReplaceRouteTableAssociationRequest_keys[k], "ReplaceRouteTableAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteTableAssociationRequest
-- <p>Contains the parameters for ReplaceRouteTableAssociation.</p>
-- @param RouteTableId [String] <p>The ID of the new route table to associate with the subnet.</p>
-- @param AssociationId [String] <p>The association ID.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: AssociationId
-- Required parameter: RouteTableId
function M.ReplaceRouteTableAssociationRequest(RouteTableId, AssociationId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceRouteTableAssociationRequest")
	local t = { 
		["RouteTableId"] = RouteTableId,
		["AssociationId"] = AssociationId,
		["DryRun"] = DryRun,
	}
	M.AssertReplaceRouteTableAssociationRequest(t)
	return t
end

local CancelBundleTaskResult_keys = { "BundleTask" = true, nil }

function M.AssertCancelBundleTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelBundleTaskResult to be of type 'table'")
	if struct["BundleTask"] then M.AssertBundleTask(struct["BundleTask"]) end
	for k,_ in pairs(struct) do
		assert(CancelBundleTaskResult_keys[k], "CancelBundleTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelBundleTaskResult
-- <p>Contains the output of CancelBundleTask.</p>
-- @param BundleTask [BundleTask] <p>Information about the bundle task.</p>
function M.CancelBundleTaskResult(BundleTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelBundleTaskResult")
	local t = { 
		["BundleTask"] = BundleTask,
	}
	M.AssertCancelBundleTaskResult(t)
	return t
end

local SecurityGroup_keys = { "IpPermissionsEgress" = true, "Description" = true, "Tags" = true, "IpPermissions" = true, "GroupName" = true, "VpcId" = true, "OwnerId" = true, "GroupId" = true, nil }

function M.AssertSecurityGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityGroup to be of type 'table'")
	if struct["IpPermissionsEgress"] then M.AssertIpPermissionList(struct["IpPermissionsEgress"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["IpPermissions"] then M.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(SecurityGroup_keys[k], "SecurityGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityGroup
-- <p>Describes a security group</p>
-- @param IpPermissionsEgress [IpPermissionList] <p>[EC2-VPC] One or more outbound rules associated with the security group.</p>
-- @param Description [String] <p>A description of the security group.</p>
-- @param Tags [TagList] <p>Any tags assigned to the security group.</p>
-- @param IpPermissions [IpPermissionList] <p>One or more inbound rules associated with the security group.</p>
-- @param GroupName [String] <p>The name of the security group.</p>
-- @param VpcId [String] <p>[EC2-VPC] The ID of the VPC for the security group.</p>
-- @param OwnerId [String] <p>The AWS account ID of the owner of the security group.</p>
-- @param GroupId [String] <p>The ID of the security group.</p>
function M.SecurityGroup(IpPermissionsEgress, Description, Tags, IpPermissions, GroupName, VpcId, OwnerId, GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SecurityGroup")
	local t = { 
		["IpPermissionsEgress"] = IpPermissionsEgress,
		["Description"] = Description,
		["Tags"] = Tags,
		["IpPermissions"] = IpPermissions,
		["GroupName"] = GroupName,
		["VpcId"] = VpcId,
		["OwnerId"] = OwnerId,
		["GroupId"] = GroupId,
	}
	M.AssertSecurityGroup(t)
	return t
end

local EnableVpcClassicLinkDnsSupportRequest_keys = { "VpcId" = true, nil }

function M.AssertEnableVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(EnableVpcClassicLinkDnsSupportRequest_keys[k], "EnableVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkDnsSupportRequest
-- <p>Contains the parameters for EnableVpcClassicLinkDnsSupport.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
function M.EnableVpcClassicLinkDnsSupportRequest(VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVpcClassicLinkDnsSupportRequest")
	local t = { 
		["VpcId"] = VpcId,
	}
	M.AssertEnableVpcClassicLinkDnsSupportRequest(t)
	return t
end

local ReportInstanceStatusRequest_keys = { "Status" = true, "ReasonCodes" = true, "DryRun" = true, "Description" = true, "Instances" = true, "StartTime" = true, "EndTime" = true, nil }

function M.AssertReportInstanceStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReportInstanceStatusRequest to be of type 'table'")
	assert(struct["Instances"], "Expected key Instances to exist in table")
	assert(struct["ReasonCodes"], "Expected key ReasonCodes to exist in table")
	assert(struct["Status"], "Expected key Status to exist in table")
	if struct["Status"] then M.AssertReportStatusType(struct["Status"]) end
	if struct["ReasonCodes"] then M.AssertReasonCodesList(struct["ReasonCodes"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Instances"] then M.AssertInstanceIdStringList(struct["Instances"]) end
	if struct["StartTime"] then M.AssertDateTime(struct["StartTime"]) end
	if struct["EndTime"] then M.AssertDateTime(struct["EndTime"]) end
	for k,_ in pairs(struct) do
		assert(ReportInstanceStatusRequest_keys[k], "ReportInstanceStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReportInstanceStatusRequest
-- <p>Contains the parameters for ReportInstanceStatus.</p>
-- @param Status [ReportStatusType] <p>The status of all instances listed.</p>
-- @param ReasonCodes [ReasonCodesList] <p>One or more reason codes that describes the health state of your instance.</p> <ul> <li> <p> <code>instance-stuck-in-state</code>: My instance is stuck in a state.</p> </li> <li> <p> <code>unresponsive</code>: My instance is unresponsive.</p> </li> <li> <p> <code>not-accepting-credentials</code>: My instance is not accepting my credentials.</p> </li> <li> <p> <code>password-not-available</code>: A password is not available for my instance.</p> </li> <li> <p> <code>performance-network</code>: My instance is experiencing performance problems which I believe are network related.</p> </li> <li> <p> <code>performance-instance-store</code>: My instance is experiencing performance problems which I believe are related to the instance stores.</p> </li> <li> <p> <code>performance-ebs-volume</code>: My instance is experiencing performance problems which I believe are related to an EBS volume.</p> </li> <li> <p> <code>performance-other</code>: My instance is experiencing performance problems.</p> </li> <li> <p> <code>other</code>: [explain using the description parameter]</p> </li> </ul>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>Descriptive text about the health state of your instance.</p>
-- @param Instances [InstanceIdStringList] <p>One or more instances.</p>
-- @param StartTime [DateTime] <p>The time at which the reported instance health state began.</p>
-- @param EndTime [DateTime] <p>The time at which the reported instance health state ended.</p>
-- Required parameter: Instances
-- Required parameter: ReasonCodes
-- Required parameter: Status
function M.ReportInstanceStatusRequest(Status, ReasonCodes, DryRun, Description, Instances, StartTime, EndTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReportInstanceStatusRequest")
	local t = { 
		["Status"] = Status,
		["ReasonCodes"] = ReasonCodes,
		["DryRun"] = DryRun,
		["Description"] = Description,
		["Instances"] = Instances,
		["StartTime"] = StartTime,
		["EndTime"] = EndTime,
	}
	M.AssertReportInstanceStatusRequest(t)
	return t
end

local DescribeVolumeAttributeResult_keys = { "AutoEnableIO" = true, "ProductCodes" = true, "VolumeId" = true, nil }

function M.AssertDescribeVolumeAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeAttributeResult to be of type 'table'")
	if struct["AutoEnableIO"] then M.AssertAttributeBooleanValue(struct["AutoEnableIO"]) end
	if struct["ProductCodes"] then M.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVolumeAttributeResult_keys[k], "DescribeVolumeAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeAttributeResult
-- <p>Contains the output of DescribeVolumeAttribute.</p>
-- @param AutoEnableIO [AttributeBooleanValue] <p>The state of <code>autoEnableIO</code> attribute.</p>
-- @param ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- @param VolumeId [String] <p>The ID of the volume.</p>
function M.DescribeVolumeAttributeResult(AutoEnableIO, ProductCodes, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumeAttributeResult")
	local t = { 
		["AutoEnableIO"] = AutoEnableIO,
		["ProductCodes"] = ProductCodes,
		["VolumeId"] = VolumeId,
	}
	M.AssertDescribeVolumeAttributeResult(t)
	return t
end

local ReservedInstancesId_keys = { "ReservedInstancesId" = true, nil }

function M.AssertReservedInstancesId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesId to be of type 'table'")
	if struct["ReservedInstancesId"] then M.AssertString(struct["ReservedInstancesId"]) end
	for k,_ in pairs(struct) do
		assert(ReservedInstancesId_keys[k], "ReservedInstancesId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesId
-- <p>Describes the ID of a Reserved Instance.</p>
-- @param ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
function M.ReservedInstancesId(ReservedInstancesId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesId")
	local t = { 
		["ReservedInstancesId"] = ReservedInstancesId,
	}
	M.AssertReservedInstancesId(t)
	return t
end

local AttributeValue_keys = { "Value" = true, nil }

function M.AssertAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttributeValue to be of type 'table'")
	if struct["Value"] then M.AssertString(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(AttributeValue_keys[k], "AttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttributeValue
-- <p>Describes a value for a resource attribute that is a String.</p>
-- @param Value [String] <p>The attribute value. Note that the value is case-sensitive.</p>
function M.AttributeValue(Value, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttributeValue")
	local t = { 
		["Value"] = Value,
	}
	M.AssertAttributeValue(t)
	return t
end

local DescribeVpcEndpointsRequest_keys = { "VpcEndpointIds" = true, "NextToken" = true, "DryRun" = true, "MaxResults" = true, "Filters" = true, nil }

function M.AssertDescribeVpcEndpointsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointsRequest to be of type 'table'")
	if struct["VpcEndpointIds"] then M.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcEndpointsRequest_keys[k], "DescribeVpcEndpointsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointsRequest
-- <p>Contains the parameters for DescribeVpcEndpoints.</p>
-- @param VpcEndpointIds [ValueStringList] <p>One or more endpoint IDs.</p>
-- @param NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>service-name</code>: The name of the AWS service.</p> </li> <li> <p> <code>vpc-id</code>: The ID of the VPC in which the endpoint resides.</p> </li> <li> <p> <code>vpc-endpoint-id</code>: The ID of the endpoint.</p> </li> <li> <p> <code>vpc-endpoint-state</code>: The state of the endpoint. (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>)</p> </li> </ul>
function M.DescribeVpcEndpointsRequest(VpcEndpointIds, NextToken, DryRun, MaxResults, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcEndpointsRequest")
	local t = { 
		["VpcEndpointIds"] = VpcEndpointIds,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
	}
	M.AssertDescribeVpcEndpointsRequest(t)
	return t
end

local TagDescription_keys = { "ResourceType" = true, "ResourceId" = true, "Value" = true, "Key" = true, nil }

function M.AssertTagDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TagDescription to be of type 'table'")
	if struct["ResourceType"] then M.AssertResourceType(struct["ResourceType"]) end
	if struct["ResourceId"] then M.AssertString(struct["ResourceId"]) end
	if struct["Value"] then M.AssertString(struct["Value"]) end
	if struct["Key"] then M.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(TagDescription_keys[k], "TagDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TagDescription
-- <p>Describes a tag.</p>
-- @param ResourceType [ResourceType] <p>The resource type.</p>
-- @param ResourceId [String] <p>The ID of the resource. For example, <code>ami-1a2b3c4d</code>.</p>
-- @param Value [String] <p>The tag value.</p>
-- @param Key [String] <p>The tag key.</p>
function M.TagDescription(ResourceType, ResourceId, Value, Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TagDescription")
	local t = { 
		["ResourceType"] = ResourceType,
		["ResourceId"] = ResourceId,
		["Value"] = Value,
		["Key"] = Key,
	}
	M.AssertTagDescription(t)
	return t
end

local DeleteVpcRequest_keys = { "VpcId" = true, "DryRun" = true, nil }

function M.AssertDeleteVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteVpcRequest_keys[k], "DeleteVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcRequest
-- <p>Contains the parameters for DeleteVpc.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.DeleteVpcRequest(VpcId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteVpcRequest(t)
	return t
end

local DescribeSnapshotsRequest_keys = { "OwnerIds" = true, "DryRun" = true, "SnapshotIds" = true, "MaxResults" = true, "Filters" = true, "RestorableByUserIds" = true, "NextToken" = true, nil }

function M.AssertDescribeSnapshotsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotsRequest to be of type 'table'")
	if struct["OwnerIds"] then M.AssertOwnerStringList(struct["OwnerIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotIds"] then M.AssertSnapshotIdStringList(struct["SnapshotIds"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["RestorableByUserIds"] then M.AssertRestorableByStringList(struct["RestorableByUserIds"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSnapshotsRequest_keys[k], "DescribeSnapshotsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotsRequest
-- <p>Contains the parameters for DescribeSnapshots.</p>
-- @param OwnerIds [OwnerStringList] <p>Returns the snapshots owned by the specified owner. Multiple owners can be specified.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param SnapshotIds [SnapshotIdStringList] <p>One or more snapshot IDs.</p> <p>Default: Describes snapshots for which you have launch permissions.</p>
-- @param MaxResults [Integer] <p>The maximum number of snapshot results returned by <code>DescribeSnapshots</code> in paginated output. When this parameter is used, <code>DescribeSnapshots</code> only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>DescribeSnapshots</code> request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then <code>DescribeSnapshots</code> returns all results. You cannot specify this parameter and the snapshot IDs parameter in the same request.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>description</code> - A description of the snapshot.</p> </li> <li> <p> <code>owner-alias</code> - Value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM consolew.</p> </li> <li> <p> <code>owner-id</code> - The ID of the AWS account that owns the snapshot.</p> </li> <li> <p> <code>progress</code> - The progress of the snapshot, as a percentage (for example, 80%).</p> </li> <li> <p> <code>snapshot-id</code> - The snapshot ID.</p> </li> <li> <p> <code>start-time</code> - The time stamp when the snapshot was initiated.</p> </li> <li> <p> <code>status</code> - The status of the snapshot (<code>pending</code> | <code>completed</code> | <code>error</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>volume-id</code> - The ID of the volume the snapshot is for.</p> </li> <li> <p> <code>volume-size</code> - The size of the volume, in GiB.</p> </li> </ul>
-- @param RestorableByUserIds [RestorableByStringList] <p>One or more AWS accounts IDs that can create volumes from the snapshot.</p>
-- @param NextToken [String] <p>The <code>NextToken</code> value returned from a previous paginated <code>DescribeSnapshots</code> request where <code>MaxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>NextToken</code> value. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeSnapshotsRequest(OwnerIds, DryRun, SnapshotIds, MaxResults, Filters, RestorableByUserIds, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSnapshotsRequest")
	local t = { 
		["OwnerIds"] = OwnerIds,
		["DryRun"] = DryRun,
		["SnapshotIds"] = SnapshotIds,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
		["RestorableByUserIds"] = RestorableByUserIds,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeSnapshotsRequest(t)
	return t
end

local VpnConnectionOptions_keys = { "StaticRoutesOnly" = true, nil }

function M.AssertVpnConnectionOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnectionOptions to be of type 'table'")
	if struct["StaticRoutesOnly"] then M.AssertBoolean(struct["StaticRoutesOnly"]) end
	for k,_ in pairs(struct) do
		assert(VpnConnectionOptions_keys[k], "VpnConnectionOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnectionOptions
-- <p>Describes VPN connection options.</p>
-- @param StaticRoutesOnly [Boolean] <p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>
function M.VpnConnectionOptions(StaticRoutesOnly, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnConnectionOptions")
	local t = { 
		["StaticRoutesOnly"] = StaticRoutesOnly,
	}
	M.AssertVpnConnectionOptions(t)
	return t
end

local BundleInstanceRequest_keys = { "InstanceId" = true, "DryRun" = true, "Storage" = true, nil }

function M.AssertBundleInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["Storage"], "Expected key Storage to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Storage"] then M.AssertStorage(struct["Storage"]) end
	for k,_ in pairs(struct) do
		assert(BundleInstanceRequest_keys[k], "BundleInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleInstanceRequest
-- <p>Contains the parameters for BundleInstance.</p>
-- @param InstanceId [String] <p>The ID of the instance to bundle.</p> <p>Type: String</p> <p>Default: None</p> <p>Required: Yes</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Storage [Storage] <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
-- Required parameter: InstanceId
-- Required parameter: Storage
function M.BundleInstanceRequest(InstanceId, DryRun, Storage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BundleInstanceRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["DryRun"] = DryRun,
		["Storage"] = Storage,
	}
	M.AssertBundleInstanceRequest(t)
	return t
end

local ImportVolumeTaskDetails_keys = { "BytesConverted" = true, "Volume" = true, "Image" = true, "AvailabilityZone" = true, "Description" = true, nil }

function M.AssertImportVolumeTaskDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeTaskDetails to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["BytesConverted"], "Expected key BytesConverted to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["BytesConverted"] then M.AssertLong(struct["BytesConverted"]) end
	if struct["Volume"] then M.AssertDiskImageVolumeDescription(struct["Volume"]) end
	if struct["Image"] then M.AssertDiskImageDescription(struct["Image"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(ImportVolumeTaskDetails_keys[k], "ImportVolumeTaskDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeTaskDetails
-- <p>Describes an import volume task.</p>
-- @param BytesConverted [Long] <p>The number of bytes converted so far.</p>
-- @param Volume [DiskImageVolumeDescription] <p>The volume.</p>
-- @param Image [DiskImageDescription] <p>The image.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone where the resulting volume will reside.</p>
-- @param Description [String] <p>The description you provided when starting the import volume task.</p>
-- Required parameter: AvailabilityZone
-- Required parameter: BytesConverted
-- Required parameter: Image
-- Required parameter: Volume
function M.ImportVolumeTaskDetails(BytesConverted, Volume, Image, AvailabilityZone, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportVolumeTaskDetails")
	local t = { 
		["BytesConverted"] = BytesConverted,
		["Volume"] = Volume,
		["Image"] = Image,
		["AvailabilityZone"] = AvailabilityZone,
		["Description"] = Description,
	}
	M.AssertImportVolumeTaskDetails(t)
	return t
end

local ImportSnapshotResult_keys = { "SnapshotTaskDetail" = true, "Description" = true, "ImportTaskId" = true, nil }

function M.AssertImportSnapshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotResult to be of type 'table'")
	if struct["SnapshotTaskDetail"] then M.AssertSnapshotTaskDetail(struct["SnapshotTaskDetail"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["ImportTaskId"] then M.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(ImportSnapshotResult_keys[k], "ImportSnapshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotResult
-- <p>Contains the output for ImportSnapshot.</p>
-- @param SnapshotTaskDetail [SnapshotTaskDetail] <p>Information about the import snapshot task.</p>
-- @param Description [String] <p>A description of the import snapshot task.</p>
-- @param ImportTaskId [String] <p>The ID of the import snapshot task.</p>
function M.ImportSnapshotResult(SnapshotTaskDetail, Description, ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportSnapshotResult")
	local t = { 
		["SnapshotTaskDetail"] = SnapshotTaskDetail,
		["Description"] = Description,
		["ImportTaskId"] = ImportTaskId,
	}
	M.AssertImportSnapshotResult(t)
	return t
end

local VolumeStatusEvent_keys = { "EventId" = true, "EventType" = true, "NotBefore" = true, "Description" = true, "NotAfter" = true, nil }

function M.AssertVolumeStatusEvent(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusEvent to be of type 'table'")
	if struct["EventId"] then M.AssertString(struct["EventId"]) end
	if struct["EventType"] then M.AssertString(struct["EventType"]) end
	if struct["NotBefore"] then M.AssertDateTime(struct["NotBefore"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["NotAfter"] then M.AssertDateTime(struct["NotAfter"]) end
	for k,_ in pairs(struct) do
		assert(VolumeStatusEvent_keys[k], "VolumeStatusEvent contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusEvent
-- <p>Describes a volume status event.</p>
-- @param EventId [String] <p>The ID of this event.</p>
-- @param EventType [String] <p>The type of this event.</p>
-- @param NotBefore [DateTime] <p>The earliest start time of the event.</p>
-- @param Description [String] <p>A description of the event.</p>
-- @param NotAfter [DateTime] <p>The latest end time of the event.</p>
function M.VolumeStatusEvent(EventId, EventType, NotBefore, Description, NotAfter, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusEvent")
	local t = { 
		["EventId"] = EventId,
		["EventType"] = EventType,
		["NotBefore"] = NotBefore,
		["Description"] = Description,
		["NotAfter"] = NotAfter,
	}
	M.AssertVolumeStatusEvent(t)
	return t
end

local RejectVpcPeeringConnectionResult_keys = { "Return" = true, nil }

function M.AssertRejectVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcPeeringConnectionResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(RejectVpcPeeringConnectionResult_keys[k], "RejectVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcPeeringConnectionResult
-- <p>Contains the output of RejectVpcPeeringConnection.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.RejectVpcPeeringConnectionResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RejectVpcPeeringConnectionResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertRejectVpcPeeringConnectionResult(t)
	return t
end

local DeleteFlowLogsResult_keys = { "Unsuccessful" = true, nil }

function M.AssertDeleteFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFlowLogsResult to be of type 'table'")
	if struct["Unsuccessful"] then M.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(DeleteFlowLogsResult_keys[k], "DeleteFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFlowLogsResult
-- <p>Contains the output of DeleteFlowLogs.</p>
-- @param Unsuccessful [UnsuccessfulItemSet] <p>Information about the flow logs that could not be deleted successfully.</p>
function M.DeleteFlowLogsResult(Unsuccessful, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteFlowLogsResult")
	local t = { 
		["Unsuccessful"] = Unsuccessful,
	}
	M.AssertDeleteFlowLogsResult(t)
	return t
end

local UserBucket_keys = { "S3Bucket" = true, "S3Key" = true, nil }

function M.AssertUserBucket(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserBucket to be of type 'table'")
	if struct["S3Bucket"] then M.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then M.AssertString(struct["S3Key"]) end
	for k,_ in pairs(struct) do
		assert(UserBucket_keys[k], "UserBucket contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserBucket
-- <p>Describes the S3 bucket for the disk image.</p>
-- @param S3Bucket [String] <p>The name of the S3 bucket where the disk image is located.</p>
-- @param S3Key [String] <p>The file name of the disk image.</p>
function M.UserBucket(S3Bucket, S3Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UserBucket")
	local t = { 
		["S3Bucket"] = S3Bucket,
		["S3Key"] = S3Key,
	}
	M.AssertUserBucket(t)
	return t
end

local CreateFlowLogsResult_keys = { "Unsuccessful" = true, "FlowLogIds" = true, "ClientToken" = true, nil }

function M.AssertCreateFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFlowLogsResult to be of type 'table'")
	if struct["Unsuccessful"] then M.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	if struct["FlowLogIds"] then M.AssertValueStringList(struct["FlowLogIds"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(CreateFlowLogsResult_keys[k], "CreateFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFlowLogsResult
-- <p>Contains the output of CreateFlowLogs.</p>
-- @param Unsuccessful [UnsuccessfulItemSet] <p>Information about the flow logs that could not be created successfully.</p>
-- @param FlowLogIds [ValueStringList] <p>The IDs of the flow logs.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
function M.CreateFlowLogsResult(Unsuccessful, FlowLogIds, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateFlowLogsResult")
	local t = { 
		["Unsuccessful"] = Unsuccessful,
		["FlowLogIds"] = FlowLogIds,
		["ClientToken"] = ClientToken,
	}
	M.AssertCreateFlowLogsResult(t)
	return t
end

local StopInstancesRequest_keys = { "Force" = true, "DryRun" = true, "InstanceIds" = true, nil }

function M.AssertStopInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["Force"] then M.AssertBoolean(struct["Force"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then M.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(StopInstancesRequest_keys[k], "StopInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopInstancesRequest
-- <p>Contains the parameters for StopInstances.</p>
-- @param Force [Boolean] <p>Forces the instances to stop. The instances do not have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures. This option is not recommended for Windows instances.</p> <p>Default: <code>false</code> </p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.StopInstancesRequest(Force, DryRun, InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StopInstancesRequest")
	local t = { 
		["Force"] = Force,
		["DryRun"] = DryRun,
		["InstanceIds"] = InstanceIds,
	}
	M.AssertStopInstancesRequest(t)
	return t
end

local StopInstancesResult_keys = { "StoppingInstances" = true, nil }

function M.AssertStopInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopInstancesResult to be of type 'table'")
	if struct["StoppingInstances"] then M.AssertInstanceStateChangeList(struct["StoppingInstances"]) end
	for k,_ in pairs(struct) do
		assert(StopInstancesResult_keys[k], "StopInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopInstancesResult
-- <p>Contains the output of StopInstances.</p>
-- @param StoppingInstances [InstanceStateChangeList] <p>Information about one or more stopped instances.</p>
function M.StopInstancesResult(StoppingInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StopInstancesResult")
	local t = { 
		["StoppingInstances"] = StoppingInstances,
	}
	M.AssertStopInstancesResult(t)
	return t
end

local DescribeReservedInstancesListingsRequest_keys = { "ReservedInstancesId" = true, "ReservedInstancesListingId" = true, "Filters" = true, nil }

function M.AssertDescribeReservedInstancesListingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesListingsRequest to be of type 'table'")
	if struct["ReservedInstancesId"] then M.AssertString(struct["ReservedInstancesId"]) end
	if struct["ReservedInstancesListingId"] then M.AssertString(struct["ReservedInstancesListingId"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeReservedInstancesListingsRequest_keys[k], "DescribeReservedInstancesListingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesListingsRequest
-- <p>Contains the parameters for DescribeReservedInstancesListings.</p>
-- @param ReservedInstancesId [String] <p>One or more Reserved Instance IDs.</p>
-- @param ReservedInstancesListingId [String] <p>One or more Reserved Instance listing IDs.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instances.</p> </li> <li> <p> <code>reserved-instances-listing-id</code> - The ID of the Reserved Instances listing.</p> </li> <li> <p> <code>status</code> - The status of the Reserved Instance listing (<code>pending</code> | <code>active</code> | <code>cancelled</code> | <code>closed</code>).</p> </li> <li> <p> <code>status-message</code> - The reason for the status.</p> </li> </ul>
function M.DescribeReservedInstancesListingsRequest(ReservedInstancesId, ReservedInstancesListingId, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesListingsRequest")
	local t = { 
		["ReservedInstancesId"] = ReservedInstancesId,
		["ReservedInstancesListingId"] = ReservedInstancesListingId,
		["Filters"] = Filters,
	}
	M.AssertDescribeReservedInstancesListingsRequest(t)
	return t
end

local ModifySubnetAttributeRequest_keys = { "SubnetId" = true, "MapPublicIpOnLaunch" = true, "AssignIpv6AddressOnCreation" = true, nil }

function M.AssertModifySubnetAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySubnetAttributeRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["MapPublicIpOnLaunch"] then M.AssertAttributeBooleanValue(struct["MapPublicIpOnLaunch"]) end
	if struct["AssignIpv6AddressOnCreation"] then M.AssertAttributeBooleanValue(struct["AssignIpv6AddressOnCreation"]) end
	for k,_ in pairs(struct) do
		assert(ModifySubnetAttributeRequest_keys[k], "ModifySubnetAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySubnetAttributeRequest
-- <p>Contains the parameters for ModifySubnetAttribute.</p>
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param MapPublicIpOnLaunch [AttributeBooleanValue] <p>Specify <code>true</code> to indicate that network interfaces created in the specified subnet should be assigned a public IPv4 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives a public IPv4 address).</p>
-- @param AssignIpv6AddressOnCreation [AttributeBooleanValue] <p>Specify <code>true</code> to indicate that network interfaces created in the specified subnet should be assigned an IPv6 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives an IPv6 address). </p> <p>If you enable the IPv6 addressing feature for your subnet, your network interface or instance only receives an IPv6 address if it's created using version <code>2016-11-15</code> or later of the Amazon EC2 API.</p>
-- Required parameter: SubnetId
function M.ModifySubnetAttributeRequest(SubnetId, MapPublicIpOnLaunch, AssignIpv6AddressOnCreation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifySubnetAttributeRequest")
	local t = { 
		["SubnetId"] = SubnetId,
		["MapPublicIpOnLaunch"] = MapPublicIpOnLaunch,
		["AssignIpv6AddressOnCreation"] = AssignIpv6AddressOnCreation,
	}
	M.AssertModifySubnetAttributeRequest(t)
	return t
end

local DisassociateAddressRequest_keys = { "PublicIp" = true, "AssociationId" = true, "DryRun" = true, nil }

function M.AssertDisassociateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateAddressRequest to be of type 'table'")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DisassociateAddressRequest_keys[k], "DisassociateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateAddressRequest
-- <p>Contains the parameters for DisassociateAddress.</p>
-- @param PublicIp [String] <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
-- @param AssociationId [String] <p>[EC2-VPC] The association ID. Required for EC2-VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.DisassociateAddressRequest(PublicIp, AssociationId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateAddressRequest")
	local t = { 
		["PublicIp"] = PublicIp,
		["AssociationId"] = AssociationId,
		["DryRun"] = DryRun,
	}
	M.AssertDisassociateAddressRequest(t)
	return t
end

local ExportTask_keys = { "Description" = true, "InstanceExportDetails" = true, "ExportTaskId" = true, "State" = true, "StatusMessage" = true, "ExportToS3Task" = true, nil }

function M.AssertExportTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportTask to be of type 'table'")
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["InstanceExportDetails"] then M.AssertInstanceExportDetails(struct["InstanceExportDetails"]) end
	if struct["ExportTaskId"] then M.AssertString(struct["ExportTaskId"]) end
	if struct["State"] then M.AssertExportTaskState(struct["State"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	if struct["ExportToS3Task"] then M.AssertExportToS3Task(struct["ExportToS3Task"]) end
	for k,_ in pairs(struct) do
		assert(ExportTask_keys[k], "ExportTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportTask
-- <p>Describes an instance export task.</p>
-- @param Description [String] <p>A description of the resource being exported.</p>
-- @param InstanceExportDetails [InstanceExportDetails] <p>Information about the instance to export.</p>
-- @param ExportTaskId [String] <p>The ID of the export task.</p>
-- @param State [ExportTaskState] <p>The state of the export task.</p>
-- @param StatusMessage [String] <p>The status message related to the export task.</p>
-- @param ExportToS3Task [ExportToS3Task] <p>Information about the export task.</p>
function M.ExportTask(Description, InstanceExportDetails, ExportTaskId, State, StatusMessage, ExportToS3Task, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ExportTask")
	local t = { 
		["Description"] = Description,
		["InstanceExportDetails"] = InstanceExportDetails,
		["ExportTaskId"] = ExportTaskId,
		["State"] = State,
		["StatusMessage"] = StatusMessage,
		["ExportToS3Task"] = ExportToS3Task,
	}
	M.AssertExportTask(t)
	return t
end

local ImportVolumeRequest_keys = { "Volume" = true, "Image" = true, "AvailabilityZone" = true, "DryRun" = true, "Description" = true, nil }

function M.AssertImportVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["Volume"] then M.AssertVolumeDetail(struct["Volume"]) end
	if struct["Image"] then M.AssertDiskImageDetail(struct["Image"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(ImportVolumeRequest_keys[k], "ImportVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeRequest
-- <p>Contains the parameters for ImportVolume.</p>
-- @param Volume [VolumeDetail] <p>The volume size.</p>
-- @param Image [DiskImageDetail] <p>The disk image.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone for the resulting EBS volume.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>A description of the volume.</p>
-- Required parameter: AvailabilityZone
-- Required parameter: Image
-- Required parameter: Volume
function M.ImportVolumeRequest(Volume, Image, AvailabilityZone, DryRun, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportVolumeRequest")
	local t = { 
		["Volume"] = Volume,
		["Image"] = Image,
		["AvailabilityZone"] = AvailabilityZone,
		["DryRun"] = DryRun,
		["Description"] = Description,
	}
	M.AssertImportVolumeRequest(t)
	return t
end

local DescribeVpnGatewaysResult_keys = { "VpnGateways" = true, nil }

function M.AssertDescribeVpnGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnGatewaysResult to be of type 'table'")
	if struct["VpnGateways"] then M.AssertVpnGatewayList(struct["VpnGateways"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpnGatewaysResult_keys[k], "DescribeVpnGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnGatewaysResult
-- <p>Contains the output of DescribeVpnGateways.</p>
-- @param VpnGateways [VpnGatewayList] <p>Information about one or more virtual private gateways.</p>
function M.DescribeVpnGatewaysResult(VpnGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpnGatewaysResult")
	local t = { 
		["VpnGateways"] = VpnGateways,
	}
	M.AssertDescribeVpnGatewaysResult(t)
	return t
end

local ImageDiskContainer_keys = { "DeviceName" = true, "Description" = true, "Format" = true, "Url" = true, "SnapshotId" = true, "UserBucket" = true, nil }

function M.AssertImageDiskContainer(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImageDiskContainer to be of type 'table'")
	if struct["DeviceName"] then M.AssertString(struct["DeviceName"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Format"] then M.AssertString(struct["Format"]) end
	if struct["Url"] then M.AssertString(struct["Url"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	if struct["UserBucket"] then M.AssertUserBucket(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(ImageDiskContainer_keys[k], "ImageDiskContainer contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImageDiskContainer
-- <p>Describes the disk container object for an import image task.</p>
-- @param DeviceName [String] <p>The block device mapping for the disk.</p>
-- @param Description [String] <p>The description of the disk image.</p>
-- @param Format [String] <p>The format of the disk image being imported.</p> <p>Valid values: <code>RAW</code> | <code>VHD</code> | <code>VMDK</code> | <code>OVA</code> </p>
-- @param Url [String] <p>The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an Amazon S3 URL (s3://..)</p>
-- @param SnapshotId [String] <p>The ID of the EBS snapshot to be used for importing the snapshot.</p>
-- @param UserBucket [UserBucket] <p>The S3 bucket for the disk image.</p>
function M.ImageDiskContainer(DeviceName, Description, Format, Url, SnapshotId, UserBucket, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImageDiskContainer")
	local t = { 
		["DeviceName"] = DeviceName,
		["Description"] = Description,
		["Format"] = Format,
		["Url"] = Url,
		["SnapshotId"] = SnapshotId,
		["UserBucket"] = UserBucket,
	}
	M.AssertImageDiskContainer(t)
	return t
end

local DescribeSpotPriceHistoryRequest_keys = { "NextToken" = true, "AvailabilityZone" = true, "DryRun" = true, "StartTime" = true, "InstanceTypes" = true, "MaxResults" = true, "ProductDescriptions" = true, "Filters" = true, "EndTime" = true, nil }

function M.AssertDescribeSpotPriceHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotPriceHistoryRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["StartTime"] then M.AssertDateTime(struct["StartTime"]) end
	if struct["InstanceTypes"] then M.AssertInstanceTypeList(struct["InstanceTypes"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["ProductDescriptions"] then M.AssertProductDescriptionList(struct["ProductDescriptions"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["EndTime"] then M.AssertDateTime(struct["EndTime"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotPriceHistoryRequest_keys[k], "DescribeSpotPriceHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotPriceHistoryRequest
-- <p>Contains the parameters for DescribeSpotPriceHistory.</p>
-- @param NextToken [String] <p>The token for the next set of results.</p>
-- @param AvailabilityZone [String] <p>Filters the results by the specified Availability Zone.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param StartTime [DateTime] <p>The date and time, up to the past 90 days, from which to start retrieving the price history data, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @param InstanceTypes [InstanceTypeList] <p>Filters the results by the specified instance types. Note that T2 and HS1 instance types are not supported.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param ProductDescriptions [ProductDescriptionList] <p>Filters the results by the specified basic product descriptions.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone for which prices should be returned.</p> </li> <li> <p> <code>instance-type</code> - The type of instance (for example, <code>m3.medium</code>).</p> </li> <li> <p> <code>product-description</code> - The product description for the Spot price (<code>Linux/UNIX</code> | <code>SUSE Linux</code> | <code>Windows</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Windows (Amazon VPC)</code>).</p> </li> <li> <p> <code>spot-price</code> - The Spot price. The value must match exactly (or use wildcards; greater than or less than comparison is not supported).</p> </li> <li> <p> <code>timestamp</code> - The timestamp of the Spot price history, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). You can use wildcards (* and ?). Greater than or less than comparison is not supported.</p> </li> </ul>
-- @param EndTime [DateTime] <p>The date and time, up to the current date, from which to stop retrieving the price history data, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
function M.DescribeSpotPriceHistoryRequest(NextToken, AvailabilityZone, DryRun, StartTime, InstanceTypes, MaxResults, ProductDescriptions, Filters, EndTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotPriceHistoryRequest")
	local t = { 
		["NextToken"] = NextToken,
		["AvailabilityZone"] = AvailabilityZone,
		["DryRun"] = DryRun,
		["StartTime"] = StartTime,
		["InstanceTypes"] = InstanceTypes,
		["MaxResults"] = MaxResults,
		["ProductDescriptions"] = ProductDescriptions,
		["Filters"] = Filters,
		["EndTime"] = EndTime,
	}
	M.AssertDescribeSpotPriceHistoryRequest(t)
	return t
end

local ModifyHostsRequest_keys = { "HostIds" = true, "AutoPlacement" = true, nil }

function M.AssertModifyHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyHostsRequest to be of type 'table'")
	assert(struct["AutoPlacement"], "Expected key AutoPlacement to exist in table")
	assert(struct["HostIds"], "Expected key HostIds to exist in table")
	if struct["HostIds"] then M.AssertRequestHostIdList(struct["HostIds"]) end
	if struct["AutoPlacement"] then M.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(ModifyHostsRequest_keys[k], "ModifyHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyHostsRequest
-- <p>Contains the parameters for ModifyHosts.</p>
-- @param HostIds [RequestHostIdList] <p>The host IDs of the Dedicated Hosts you want to modify.</p>
-- @param AutoPlacement [AutoPlacement] <p>Specify whether to enable or disable auto-placement.</p>
-- Required parameter: AutoPlacement
-- Required parameter: HostIds
function M.ModifyHostsRequest(HostIds, AutoPlacement, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyHostsRequest")
	local t = { 
		["HostIds"] = HostIds,
		["AutoPlacement"] = AutoPlacement,
	}
	M.AssertModifyHostsRequest(t)
	return t
end

local ResetImageAttributeRequest_keys = { "Attribute" = true, "DryRun" = true, "ImageId" = true, nil }

function M.AssertResetImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetImageAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["Attribute"] then M.AssertResetImageAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(ResetImageAttributeRequest_keys[k], "ResetImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetImageAttributeRequest
-- <p>Contains the parameters for ResetImageAttribute.</p>
-- @param Attribute [ResetImageAttributeName] <p>The attribute to reset (currently you can only reset the launch permission attribute).</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param ImageId [String] <p>The ID of the AMI.</p>
-- Required parameter: Attribute
-- Required parameter: ImageId
function M.ResetImageAttributeRequest(Attribute, DryRun, ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ResetImageAttributeRequest")
	local t = { 
		["Attribute"] = Attribute,
		["DryRun"] = DryRun,
		["ImageId"] = ImageId,
	}
	M.AssertResetImageAttributeRequest(t)
	return t
end

local DescribeAvailabilityZonesResult_keys = { "AvailabilityZones" = true, nil }

function M.AssertDescribeAvailabilityZonesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailabilityZonesResult to be of type 'table'")
	if struct["AvailabilityZones"] then M.AssertAvailabilityZoneList(struct["AvailabilityZones"]) end
	for k,_ in pairs(struct) do
		assert(DescribeAvailabilityZonesResult_keys[k], "DescribeAvailabilityZonesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailabilityZonesResult
-- <p>Contains the output of DescribeAvailabiltyZones.</p>
-- @param AvailabilityZones [AvailabilityZoneList] <p>Information about one or more Availability Zones.</p>
function M.DescribeAvailabilityZonesResult(AvailabilityZones, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAvailabilityZonesResult")
	local t = { 
		["AvailabilityZones"] = AvailabilityZones,
	}
	M.AssertDescribeAvailabilityZonesResult(t)
	return t
end

local RecurringCharge_keys = { "Amount" = true, "Frequency" = true, nil }

function M.AssertRecurringCharge(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RecurringCharge to be of type 'table'")
	if struct["Amount"] then M.AssertDouble(struct["Amount"]) end
	if struct["Frequency"] then M.AssertRecurringChargeFrequency(struct["Frequency"]) end
	for k,_ in pairs(struct) do
		assert(RecurringCharge_keys[k], "RecurringCharge contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RecurringCharge
-- <p>Describes a recurring charge.</p>
-- @param Amount [Double] <p>The amount of the recurring charge.</p>
-- @param Frequency [RecurringChargeFrequency] <p>The frequency of the recurring charge.</p>
function M.RecurringCharge(Amount, Frequency, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RecurringCharge")
	local t = { 
		["Amount"] = Amount,
		["Frequency"] = Frequency,
	}
	M.AssertRecurringCharge(t)
	return t
end

local InstanceStateChange_keys = { "InstanceId" = true, "CurrentState" = true, "PreviousState" = true, nil }

function M.AssertInstanceStateChange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStateChange to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["CurrentState"] then M.AssertInstanceState(struct["CurrentState"]) end
	if struct["PreviousState"] then M.AssertInstanceState(struct["PreviousState"]) end
	for k,_ in pairs(struct) do
		assert(InstanceStateChange_keys[k], "InstanceStateChange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStateChange
-- <p>Describes an instance state change.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param CurrentState [InstanceState] <p>The current state of the instance.</p>
-- @param PreviousState [InstanceState] <p>The previous state of the instance.</p>
function M.InstanceStateChange(InstanceId, CurrentState, PreviousState, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStateChange")
	local t = { 
		["InstanceId"] = InstanceId,
		["CurrentState"] = CurrentState,
		["PreviousState"] = PreviousState,
	}
	M.AssertInstanceStateChange(t)
	return t
end

local PurchaseRequest_keys = { "InstanceCount" = true, "PurchaseToken" = true, nil }

function M.AssertPurchaseRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseRequest to be of type 'table'")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["PurchaseToken"], "Expected key PurchaseToken to exist in table")
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	if struct["PurchaseToken"] then M.AssertString(struct["PurchaseToken"]) end
	for k,_ in pairs(struct) do
		assert(PurchaseRequest_keys[k], "PurchaseRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseRequest
-- <p>Describes a request to purchase Scheduled Instances.</p>
-- @param InstanceCount [Integer] <p>The number of instances.</p>
-- @param PurchaseToken [String] <p>The purchase token.</p>
-- Required parameter: InstanceCount
-- Required parameter: PurchaseToken
function M.PurchaseRequest(InstanceCount, PurchaseToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseRequest")
	local t = { 
		["InstanceCount"] = InstanceCount,
		["PurchaseToken"] = PurchaseToken,
	}
	M.AssertPurchaseRequest(t)
	return t
end

local ResetSnapshotAttributeRequest_keys = { "Attribute" = true, "DryRun" = true, "SnapshotId" = true, nil }

function M.AssertResetSnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetSnapshotAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["Attribute"] then M.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(ResetSnapshotAttributeRequest_keys[k], "ResetSnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetSnapshotAttributeRequest
-- <p>Contains the parameters for ResetSnapshotAttribute.</p>
-- @param Attribute [SnapshotAttributeName] <p>The attribute to reset. Currently, only the attribute for permission to create volumes can be reset.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param SnapshotId [String] <p>The ID of the snapshot.</p>
-- Required parameter: Attribute
-- Required parameter: SnapshotId
function M.ResetSnapshotAttributeRequest(Attribute, DryRun, SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ResetSnapshotAttributeRequest")
	local t = { 
		["Attribute"] = Attribute,
		["DryRun"] = DryRun,
		["SnapshotId"] = SnapshotId,
	}
	M.AssertResetSnapshotAttributeRequest(t)
	return t
end

local DescribeVolumesModificationsResult_keys = { "VolumesModifications" = true, "NextToken" = true, nil }

function M.AssertDescribeVolumesModificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesModificationsResult to be of type 'table'")
	if struct["VolumesModifications"] then M.AssertVolumeModificationList(struct["VolumesModifications"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVolumesModificationsResult_keys[k], "DescribeVolumesModificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesModificationsResult
--  
-- @param VolumesModifications [VolumeModificationList] <p>A list of returned <a>VolumeModification</a> objects.</p>
-- @param NextToken [String] <p>Token for pagination, null if there are no more results </p>
function M.DescribeVolumesModificationsResult(VolumesModifications, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumesModificationsResult")
	local t = { 
		["VolumesModifications"] = VolumesModifications,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeVolumesModificationsResult(t)
	return t
end

local ImportKeyPairRequest_keys = { "PublicKeyMaterial" = true, "KeyName" = true, "DryRun" = true, nil }

function M.AssertImportKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	assert(struct["PublicKeyMaterial"], "Expected key PublicKeyMaterial to exist in table")
	if struct["PublicKeyMaterial"] then M.AssertBlob(struct["PublicKeyMaterial"]) end
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(ImportKeyPairRequest_keys[k], "ImportKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportKeyPairRequest
-- <p>Contains the parameters for ImportKeyPair.</p>
-- @param PublicKeyMaterial [Blob] <p>The public key. For API calls, the text must be base64-encoded. For command line tools, base64 encoding is performed for you.</p>
-- @param KeyName [String] <p>A unique name for the key pair.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: KeyName
-- Required parameter: PublicKeyMaterial
function M.ImportKeyPairRequest(PublicKeyMaterial, KeyName, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportKeyPairRequest")
	local t = { 
		["PublicKeyMaterial"] = PublicKeyMaterial,
		["KeyName"] = KeyName,
		["DryRun"] = DryRun,
	}
	M.AssertImportKeyPairRequest(t)
	return t
end

local SpotFleetLaunchSpecification_keys = { "WeightedCapacity" = true, "UserData" = true, "SubnetId" = true, "Monitoring" = true, "ImageId" = true, "KeyName" = true, "BlockDeviceMappings" = true, "EbsOptimized" = true, "SecurityGroups" = true, "SpotPrice" = true, "RamdiskId" = true, "KernelId" = true, "Placement" = true, "IamInstanceProfile" = true, "InstanceType" = true, "AddressingType" = true, "NetworkInterfaces" = true, nil }

function M.AssertSpotFleetLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetLaunchSpecification to be of type 'table'")
	if struct["WeightedCapacity"] then M.AssertDouble(struct["WeightedCapacity"]) end
	if struct["UserData"] then M.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then M.AssertSpotFleetMonitoring(struct["Monitoring"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then M.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then M.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then M.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["SpotPrice"] then M.AssertString(struct["SpotPrice"]) end
	if struct["RamdiskId"] then M.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then M.AssertString(struct["KernelId"]) end
	if struct["Placement"] then M.AssertSpotPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then M.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then M.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then M.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(SpotFleetLaunchSpecification_keys[k], "SpotFleetLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetLaunchSpecification
-- <p>Describes the launch specification for one or more Spot instances.</p>
-- @param WeightedCapacity [Double] <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms (instances or a performance characteristic such as vCPUs, memory, or I/O).</p> <p>If the target capacity divided by this value is not a whole number, we round the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
-- @param UserData [String] <p>The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param SubnetId [String] <p>The ID of the subnet in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-a61dafcf, subnet-65ea5f08".</p>
-- @param Monitoring [SpotFleetMonitoring] <p>Enable or disable monitoring for the instances.</p>
-- @param ImageId [String] <p>The ID of the AMI.</p>
-- @param KeyName [String] <p>The name of the key pair.</p>
-- @param BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p>
-- @param EbsOptimized [Boolean] <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param SecurityGroups [GroupIdentifierList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- @param SpotPrice [String] <p>The bid price per unit hour for the specified instance type. If this value is not specified, the default is the Spot bid price specified for the fleet. To determine the bid price per unit hour, divide the Spot bid price by the value of <code>WeightedCapacity</code>.</p>
-- @param RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param KernelId [String] <p>The ID of the kernel.</p>
-- @param Placement [SpotPlacement] <p>The placement information.</p>
-- @param IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- @param InstanceType [InstanceType] <p>The instance type. Note that T2 and HS1 instance types are not supported.</p>
-- @param AddressingType [String] <p>Deprecated.</p>
-- @param NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
function M.SpotFleetLaunchSpecification(WeightedCapacity, UserData, SubnetId, Monitoring, ImageId, KeyName, BlockDeviceMappings, EbsOptimized, SecurityGroups, SpotPrice, RamdiskId, KernelId, Placement, IamInstanceProfile, InstanceType, AddressingType, NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotFleetLaunchSpecification")
	local t = { 
		["WeightedCapacity"] = WeightedCapacity,
		["UserData"] = UserData,
		["SubnetId"] = SubnetId,
		["Monitoring"] = Monitoring,
		["ImageId"] = ImageId,
		["KeyName"] = KeyName,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["EbsOptimized"] = EbsOptimized,
		["SecurityGroups"] = SecurityGroups,
		["SpotPrice"] = SpotPrice,
		["RamdiskId"] = RamdiskId,
		["KernelId"] = KernelId,
		["Placement"] = Placement,
		["IamInstanceProfile"] = IamInstanceProfile,
		["InstanceType"] = InstanceType,
		["AddressingType"] = AddressingType,
		["NetworkInterfaces"] = NetworkInterfaces,
	}
	M.AssertSpotFleetLaunchSpecification(t)
	return t
end

local DeleteNetworkAclRequest_keys = { "NetworkAclId" = true, "DryRun" = true, nil }

function M.AssertDeleteNetworkAclRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkAclRequest to be of type 'table'")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	if struct["NetworkAclId"] then M.AssertString(struct["NetworkAclId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteNetworkAclRequest_keys[k], "DeleteNetworkAclRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkAclRequest
-- <p>Contains the parameters for DeleteNetworkAcl.</p>
-- @param NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: NetworkAclId
function M.DeleteNetworkAclRequest(NetworkAclId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNetworkAclRequest")
	local t = { 
		["NetworkAclId"] = NetworkAclId,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteNetworkAclRequest(t)
	return t
end

local DescribePlacementGroupsRequest_keys = { "GroupNames" = true, "DryRun" = true, "Filters" = true, nil }

function M.AssertDescribePlacementGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePlacementGroupsRequest to be of type 'table'")
	if struct["GroupNames"] then M.AssertPlacementGroupStringList(struct["GroupNames"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribePlacementGroupsRequest_keys[k], "DescribePlacementGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePlacementGroupsRequest
-- <p>Contains the parameters for DescribePlacementGroups.</p>
-- @param GroupNames [PlacementGroupStringList] <p>One or more placement group names.</p> <p>Default: Describes all your placement groups, or only those otherwise specified.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>group-name</code> - The name of the placement group.</p> </li> <li> <p> <code>state</code> - The state of the placement group (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>strategy</code> - The strategy of the placement group (<code>cluster</code>).</p> </li> </ul>
function M.DescribePlacementGroupsRequest(GroupNames, DryRun, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribePlacementGroupsRequest")
	local t = { 
		["GroupNames"] = GroupNames,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
	}
	M.AssertDescribePlacementGroupsRequest(t)
	return t
end

local DescribeNetworkAclsRequest_keys = { "NetworkAclIds" = true, "DryRun" = true, "Filters" = true, nil }

function M.AssertDescribeNetworkAclsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkAclsRequest to be of type 'table'")
	if struct["NetworkAclIds"] then M.AssertValueStringList(struct["NetworkAclIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeNetworkAclsRequest_keys[k], "DescribeNetworkAclsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkAclsRequest
-- <p>Contains the parameters for DescribeNetworkAcls.</p>
-- @param NetworkAclIds [ValueStringList] <p>One or more network ACL IDs.</p> <p>Default: Describes all your network ACLs.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>association.association-id</code> - The ID of an association ID for the ACL.</p> </li> <li> <p> <code>association.network-acl-id</code> - The ID of the network ACL involved in the association.</p> </li> <li> <p> <code>association.subnet-id</code> - The ID of the subnet involved in the association.</p> </li> <li> <p> <code>default</code> - Indicates whether the ACL is the default network ACL for the VPC.</p> </li> <li> <p> <code>entry.cidr</code> - The IPv4 CIDR range specified in the entry.</p> </li> <li> <p> <code>entry.egress</code> - Indicates whether the entry applies to egress traffic.</p> </li> <li> <p> <code>entry.icmp.code</code> - The ICMP code specified in the entry, if any.</p> </li> <li> <p> <code>entry.icmp.type</code> - The ICMP type specified in the entry, if any.</p> </li> <li> <p> <code>entry.ipv6-cidr</code> - The IPv6 CIDR range specified in the entry.</p> </li> <li> <p> <code>entry.port-range.from</code> - The start of the port range specified in the entry. </p> </li> <li> <p> <code>entry.port-range.to</code> - The end of the port range specified in the entry. </p> </li> <li> <p> <code>entry.protocol</code> - The protocol specified in the entry (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p> </li> <li> <p> <code>entry.rule-action</code> - Allows or denies the matching traffic (<code>allow</code> | <code>deny</code>).</p> </li> <li> <p> <code>entry.rule-number</code> - The number of an entry (in other words, rule) in the ACL's set of entries.</p> </li> <li> <p> <code>network-acl-id</code> - The ID of the network ACL.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the network ACL.</p> </li> </ul>
function M.DescribeNetworkAclsRequest(NetworkAclIds, DryRun, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkAclsRequest")
	local t = { 
		["NetworkAclIds"] = NetworkAclIds,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
	}
	M.AssertDescribeNetworkAclsRequest(t)
	return t
end

local AssignIpv6AddressesRequest_keys = { "Ipv6Addresses" = true, "Ipv6AddressCount" = true, "NetworkInterfaceId" = true, nil }

function M.AssertAssignIpv6AddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignIpv6AddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Ipv6Addresses"] then M.AssertIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["Ipv6AddressCount"] then M.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(AssignIpv6AddressesRequest_keys[k], "AssignIpv6AddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignIpv6AddressesRequest
--  
-- @param Ipv6Addresses [Ipv6AddressList] <p>One or more specific IPv6 addresses to be assigned to the network interface. You can't use this option if you're specifying a number of IPv6 addresses.</p>
-- @param Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to the network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- Required parameter: NetworkInterfaceId
function M.AssignIpv6AddressesRequest(Ipv6Addresses, Ipv6AddressCount, NetworkInterfaceId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssignIpv6AddressesRequest")
	local t = { 
		["Ipv6Addresses"] = Ipv6Addresses,
		["Ipv6AddressCount"] = Ipv6AddressCount,
		["NetworkInterfaceId"] = NetworkInterfaceId,
	}
	M.AssertAssignIpv6AddressesRequest(t)
	return t
end

local MonitorInstancesResult_keys = { "InstanceMonitorings" = true, nil }

function M.AssertMonitorInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MonitorInstancesResult to be of type 'table'")
	if struct["InstanceMonitorings"] then M.AssertInstanceMonitoringList(struct["InstanceMonitorings"]) end
	for k,_ in pairs(struct) do
		assert(MonitorInstancesResult_keys[k], "MonitorInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MonitorInstancesResult
-- <p>Contains the output of MonitorInstances.</p>
-- @param InstanceMonitorings [InstanceMonitoringList] <p>The monitoring information.</p>
function M.MonitorInstancesResult(InstanceMonitorings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MonitorInstancesResult")
	local t = { 
		["InstanceMonitorings"] = InstanceMonitorings,
	}
	M.AssertMonitorInstancesResult(t)
	return t
end

local SlotDateTimeRangeRequest_keys = { "LatestTime" = true, "EarliestTime" = true, nil }

function M.AssertSlotDateTimeRangeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SlotDateTimeRangeRequest to be of type 'table'")
	assert(struct["EarliestTime"], "Expected key EarliestTime to exist in table")
	assert(struct["LatestTime"], "Expected key LatestTime to exist in table")
	if struct["LatestTime"] then M.AssertDateTime(struct["LatestTime"]) end
	if struct["EarliestTime"] then M.AssertDateTime(struct["EarliestTime"]) end
	for k,_ in pairs(struct) do
		assert(SlotDateTimeRangeRequest_keys[k], "SlotDateTimeRangeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SlotDateTimeRangeRequest
-- <p>Describes the time period for a Scheduled Instance to start its first schedule. The time period must span less than one day.</p>
-- @param LatestTime [DateTime] <p>The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.</p>
-- @param EarliestTime [DateTime] <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
-- Required parameter: EarliestTime
-- Required parameter: LatestTime
function M.SlotDateTimeRangeRequest(LatestTime, EarliestTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SlotDateTimeRangeRequest")
	local t = { 
		["LatestTime"] = LatestTime,
		["EarliestTime"] = EarliestTime,
	}
	M.AssertSlotDateTimeRangeRequest(t)
	return t
end

local DescribeVpcEndpointsResult_keys = { "NextToken" = true, "VpcEndpoints" = true, nil }

function M.AssertDescribeVpcEndpointsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointsResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["VpcEndpoints"] then M.AssertVpcEndpointSet(struct["VpcEndpoints"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcEndpointsResult_keys[k], "DescribeVpcEndpointsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointsResult
-- <p>Contains the output of DescribeVpcEndpoints.</p>
-- @param NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @param VpcEndpoints [VpcEndpointSet] <p>Information about the endpoints.</p>
function M.DescribeVpcEndpointsResult(NextToken, VpcEndpoints, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcEndpointsResult")
	local t = { 
		["NextToken"] = NextToken,
		["VpcEndpoints"] = VpcEndpoints,
	}
	M.AssertDescribeVpcEndpointsResult(t)
	return t
end

local FpgaImage_keys = { "OwnerAlias" = true, "UpdateTime" = true, "Name" = true, "ProductCodes" = true, "PciId" = true, "Tags" = true, "FpgaImageGlobalId" = true, "State" = true, "ShellVersion" = true, "OwnerId" = true, "FpgaImageId" = true, "CreateTime" = true, "Description" = true, nil }

function M.AssertFpgaImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FpgaImage to be of type 'table'")
	if struct["OwnerAlias"] then M.AssertString(struct["OwnerAlias"]) end
	if struct["UpdateTime"] then M.AssertDateTime(struct["UpdateTime"]) end
	if struct["Name"] then M.AssertString(struct["Name"]) end
	if struct["ProductCodes"] then M.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["PciId"] then M.AssertPciId(struct["PciId"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["FpgaImageGlobalId"] then M.AssertString(struct["FpgaImageGlobalId"]) end
	if struct["State"] then M.AssertFpgaImageState(struct["State"]) end
	if struct["ShellVersion"] then M.AssertString(struct["ShellVersion"]) end
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	if struct["FpgaImageId"] then M.AssertString(struct["FpgaImageId"]) end
	if struct["CreateTime"] then M.AssertDateTime(struct["CreateTime"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(FpgaImage_keys[k], "FpgaImage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FpgaImage
-- <p>Describes an Amazon FPGA image (AFI).</p>
-- @param OwnerAlias [String] <p>The alias of the AFI owner. Possible values include <code>self</code>, <code>amazon</code>, and <code>aws-marketplace</code>.</p>
-- @param UpdateTime [DateTime] <p>The time of the most recent update to the AFI.</p>
-- @param Name [String] <p>The name of the AFI.</p>
-- @param ProductCodes [ProductCodeList] <p>The product codes for the AFI.</p>
-- @param PciId [PciId] <p>Information about the PCI bus.</p>
-- @param Tags [TagList] <p>Any tags assigned to the AFI.</p>
-- @param FpgaImageGlobalId [String] <p>The global FPGA image identifier (AGFI ID).</p>
-- @param State [FpgaImageState] <p>Information about the state of the AFI.</p>
-- @param ShellVersion [String] <p>The version of the AWS Shell that was used to create the bitstream.</p>
-- @param OwnerId [String] <p>The AWS account ID of the AFI owner.</p>
-- @param FpgaImageId [String] <p>The FPGA image identifier (AFI ID).</p>
-- @param CreateTime [DateTime] <p>The date and time the AFI was created.</p>
-- @param Description [String] <p>The description of the AFI.</p>
function M.FpgaImage(OwnerAlias, UpdateTime, Name, ProductCodes, PciId, Tags, FpgaImageGlobalId, State, ShellVersion, OwnerId, FpgaImageId, CreateTime, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating FpgaImage")
	local t = { 
		["OwnerAlias"] = OwnerAlias,
		["UpdateTime"] = UpdateTime,
		["Name"] = Name,
		["ProductCodes"] = ProductCodes,
		["PciId"] = PciId,
		["Tags"] = Tags,
		["FpgaImageGlobalId"] = FpgaImageGlobalId,
		["State"] = State,
		["ShellVersion"] = ShellVersion,
		["OwnerId"] = OwnerId,
		["FpgaImageId"] = FpgaImageId,
		["CreateTime"] = CreateTime,
		["Description"] = Description,
	}
	M.AssertFpgaImage(t)
	return t
end

local DescribeKeyPairsRequest_keys = { "DryRun" = true, "Filters" = true, "KeyNames" = true, nil }

function M.AssertDescribeKeyPairsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeKeyPairsRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["KeyNames"] then M.AssertKeyNameStringList(struct["KeyNames"]) end
	for k,_ in pairs(struct) do
		assert(DescribeKeyPairsRequest_keys[k], "DescribeKeyPairsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeKeyPairsRequest
-- <p>Contains the parameters for DescribeKeyPairs.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>fingerprint</code> - The fingerprint of the key pair.</p> </li> <li> <p> <code>key-name</code> - The name of the key pair.</p> </li> </ul>
-- @param KeyNames [KeyNameStringList] <p>One or more key pair names.</p> <p>Default: Describes all your key pairs.</p>
function M.DescribeKeyPairsRequest(DryRun, Filters, KeyNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeKeyPairsRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Filters"] = Filters,
		["KeyNames"] = KeyNames,
	}
	M.AssertDescribeKeyPairsRequest(t)
	return t
end

local PurchaseReservedInstancesOfferingResult_keys = { "ReservedInstancesId" = true, nil }

function M.AssertPurchaseReservedInstancesOfferingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseReservedInstancesOfferingResult to be of type 'table'")
	if struct["ReservedInstancesId"] then M.AssertString(struct["ReservedInstancesId"]) end
	for k,_ in pairs(struct) do
		assert(PurchaseReservedInstancesOfferingResult_keys[k], "PurchaseReservedInstancesOfferingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseReservedInstancesOfferingResult
-- <p>Contains the output of PurchaseReservedInstancesOffering.</p>
-- @param ReservedInstancesId [String] <p>The IDs of the purchased Reserved Instances.</p>
function M.PurchaseReservedInstancesOfferingResult(ReservedInstancesId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseReservedInstancesOfferingResult")
	local t = { 
		["ReservedInstancesId"] = ReservedInstancesId,
	}
	M.AssertPurchaseReservedInstancesOfferingResult(t)
	return t
end

local CancelBundleTaskRequest_keys = { "DryRun" = true, "BundleId" = true, nil }

function M.AssertCancelBundleTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelBundleTaskRequest to be of type 'table'")
	assert(struct["BundleId"], "Expected key BundleId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["BundleId"] then M.AssertString(struct["BundleId"]) end
	for k,_ in pairs(struct) do
		assert(CancelBundleTaskRequest_keys[k], "CancelBundleTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelBundleTaskRequest
-- <p>Contains the parameters for CancelBundleTask.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param BundleId [String] <p>The ID of the bundle task.</p>
-- Required parameter: BundleId
function M.CancelBundleTaskRequest(DryRun, BundleId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelBundleTaskRequest")
	local t = { 
		["DryRun"] = DryRun,
		["BundleId"] = BundleId,
	}
	M.AssertCancelBundleTaskRequest(t)
	return t
end

local ReleaseAddressRequest_keys = { "PublicIp" = true, "DryRun" = true, "AllocationId" = true, nil }

function M.AssertReleaseAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseAddressRequest to be of type 'table'")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["AllocationId"] then M.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(ReleaseAddressRequest_keys[k], "ReleaseAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseAddressRequest
-- <p>Contains the parameters for ReleaseAddress.</p>
-- @param PublicIp [String] <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param AllocationId [String] <p>[EC2-VPC] The allocation ID. Required for EC2-VPC.</p>
function M.ReleaseAddressRequest(PublicIp, DryRun, AllocationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReleaseAddressRequest")
	local t = { 
		["PublicIp"] = PublicIp,
		["DryRun"] = DryRun,
		["AllocationId"] = AllocationId,
	}
	M.AssertReleaseAddressRequest(t)
	return t
end

local TerminateInstancesResult_keys = { "TerminatingInstances" = true, nil }

function M.AssertTerminateInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateInstancesResult to be of type 'table'")
	if struct["TerminatingInstances"] then M.AssertInstanceStateChangeList(struct["TerminatingInstances"]) end
	for k,_ in pairs(struct) do
		assert(TerminateInstancesResult_keys[k], "TerminateInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateInstancesResult
-- <p>Contains the output of TerminateInstances.</p>
-- @param TerminatingInstances [InstanceStateChangeList] <p>Information about one or more terminated instances.</p>
function M.TerminateInstancesResult(TerminatingInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TerminateInstancesResult")
	local t = { 
		["TerminatingInstances"] = TerminatingInstances,
	}
	M.AssertTerminateInstancesResult(t)
	return t
end

local InstanceMonitoring_keys = { "InstanceId" = true, "Monitoring" = true, nil }

function M.AssertInstanceMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceMonitoring to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Monitoring"] then M.AssertMonitoring(struct["Monitoring"]) end
	for k,_ in pairs(struct) do
		assert(InstanceMonitoring_keys[k], "InstanceMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceMonitoring
-- <p>Describes the monitoring of an instance.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param Monitoring [Monitoring] <p>The monitoring for the instance.</p>
function M.InstanceMonitoring(InstanceId, Monitoring, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceMonitoring")
	local t = { 
		["InstanceId"] = InstanceId,
		["Monitoring"] = Monitoring,
	}
	M.AssertInstanceMonitoring(t)
	return t
end

local DescribeRegionsResult_keys = { "Regions" = true, nil }

function M.AssertDescribeRegionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRegionsResult to be of type 'table'")
	if struct["Regions"] then M.AssertRegionList(struct["Regions"]) end
	for k,_ in pairs(struct) do
		assert(DescribeRegionsResult_keys[k], "DescribeRegionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRegionsResult
-- <p>Contains the output of DescribeRegions.</p>
-- @param Regions [RegionList] <p>Information about one or more regions.</p>
function M.DescribeRegionsResult(Regions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeRegionsResult")
	local t = { 
		["Regions"] = Regions,
	}
	M.AssertDescribeRegionsResult(t)
	return t
end

local VpcPeeringConnectionOptionsDescription_keys = { "AllowEgressFromLocalVpcToRemoteClassicLink" = true, "AllowDnsResolutionFromRemoteVpc" = true, "AllowEgressFromLocalClassicLinkToRemoteVpc" = true, nil }

function M.AssertVpcPeeringConnectionOptionsDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionOptionsDescription to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then M.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then M.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then M.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(VpcPeeringConnectionOptionsDescription_keys[k], "VpcPeeringConnectionOptionsDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionOptionsDescription
-- <p>Describes the VPC peering connection options.</p>
-- @param AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.</p>
-- @param AllowDnsResolutionFromRemoteVpc [Boolean] <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.</p>
-- @param AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.</p>
function M.VpcPeeringConnectionOptionsDescription(AllowEgressFromLocalVpcToRemoteClassicLink, AllowDnsResolutionFromRemoteVpc, AllowEgressFromLocalClassicLinkToRemoteVpc, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcPeeringConnectionOptionsDescription")
	local t = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = AllowEgressFromLocalVpcToRemoteClassicLink,
		["AllowDnsResolutionFromRemoteVpc"] = AllowDnsResolutionFromRemoteVpc,
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = AllowEgressFromLocalClassicLinkToRemoteVpc,
	}
	M.AssertVpcPeeringConnectionOptionsDescription(t)
	return t
end

local NatGateway_keys = { "NatGatewayAddresses" = true, "ProvisionedBandwidth" = true, "VpcId" = true, "State" = true, "FailureMessage" = true, "FailureCode" = true, "NatGatewayId" = true, "SubnetId" = true, "DeleteTime" = true, "CreateTime" = true, nil }

function M.AssertNatGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NatGateway to be of type 'table'")
	if struct["NatGatewayAddresses"] then M.AssertNatGatewayAddressList(struct["NatGatewayAddresses"]) end
	if struct["ProvisionedBandwidth"] then M.AssertProvisionedBandwidth(struct["ProvisionedBandwidth"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["State"] then M.AssertNatGatewayState(struct["State"]) end
	if struct["FailureMessage"] then M.AssertString(struct["FailureMessage"]) end
	if struct["FailureCode"] then M.AssertString(struct["FailureCode"]) end
	if struct["NatGatewayId"] then M.AssertString(struct["NatGatewayId"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["DeleteTime"] then M.AssertDateTime(struct["DeleteTime"]) end
	if struct["CreateTime"] then M.AssertDateTime(struct["CreateTime"]) end
	for k,_ in pairs(struct) do
		assert(NatGateway_keys[k], "NatGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NatGateway
-- <p>Describes a NAT gateway.</p>
-- @param NatGatewayAddresses [NatGatewayAddressList] <p>Information about the IP addresses and network interface associated with the NAT gateway.</p>
-- @param ProvisionedBandwidth [ProvisionedBandwidth] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param VpcId [String] <p>The ID of the VPC in which the NAT gateway is located.</p>
-- @param State [NatGatewayState] <p>The state of the NAT gateway.</p> <ul> <li> <p> <code>pending</code>: The NAT gateway is being created and is not ready to process traffic.</p> </li> <li> <p> <code>failed</code>: The NAT gateway could not be created. Check the <code>failureCode</code> and <code>failureMessage</code> fields for the reason.</p> </li> <li> <p> <code>available</code>: The NAT gateway is able to process traffic. This status remains until you delete the NAT gateway, and does not indicate the health of the NAT gateway.</p> </li> <li> <p> <code>deleting</code>: The NAT gateway is in the process of being terminated and may still be processing traffic.</p> </li> <li> <p> <code>deleted</code>: The NAT gateway has been terminated and is no longer processing traffic.</p> </li> </ul>
-- @param FailureMessage [String] <p>If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.</p> <ul> <li> <p>For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free addresses to create this NAT gateway"</p> </li> <li> <p>For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway attached"</p> </li> <li> <p>For InvalidAllocationID.NotFound: "Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway"</p> </li> <li> <p>For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx is already associated"</p> </li> <li> <p>For InternalError: "Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again."</p> </li> <li> <p>For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx does not exist or could not be found."</p> </li> </ul>
-- @param FailureCode [String] <p>If the NAT gateway could not be created, specifies the error code for the failure. (<code>InsufficientFreeAddressesInSubnet</code> | <code>Gateway.NotAttached</code> | <code>InvalidAllocationID.NotFound</code> | <code>Resource.AlreadyAssociated</code> | <code>InternalError</code> | <code>InvalidSubnetID.NotFound</code>)</p>
-- @param NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- @param SubnetId [String] <p>The ID of the subnet in which the NAT gateway is located.</p>
-- @param DeleteTime [DateTime] <p>The date and time the NAT gateway was deleted, if applicable.</p>
-- @param CreateTime [DateTime] <p>The date and time the NAT gateway was created.</p>
function M.NatGateway(NatGatewayAddresses, ProvisionedBandwidth, VpcId, State, FailureMessage, FailureCode, NatGatewayId, SubnetId, DeleteTime, CreateTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NatGateway")
	local t = { 
		["NatGatewayAddresses"] = NatGatewayAddresses,
		["ProvisionedBandwidth"] = ProvisionedBandwidth,
		["VpcId"] = VpcId,
		["State"] = State,
		["FailureMessage"] = FailureMessage,
		["FailureCode"] = FailureCode,
		["NatGatewayId"] = NatGatewayId,
		["SubnetId"] = SubnetId,
		["DeleteTime"] = DeleteTime,
		["CreateTime"] = CreateTime,
	}
	M.AssertNatGateway(t)
	return t
end

local DescribeVpnConnectionsRequest_keys = { "DryRun" = true, "VpnConnectionIds" = true, "Filters" = true, nil }

function M.AssertDescribeVpnConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnConnectionsRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VpnConnectionIds"] then M.AssertVpnConnectionIdStringList(struct["VpnConnectionIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpnConnectionsRequest_keys[k], "DescribeVpnConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnConnectionsRequest
-- <p>Contains the parameters for DescribeVpnConnections.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VpnConnectionIds [VpnConnectionIdStringList] <p>One or more VPN connection IDs.</p> <p>Default: Describes your VPN connections.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>customer-gateway-configuration</code> - The configuration information for the customer gateway.</p> </li> <li> <p> <code>customer-gateway-id</code> - The ID of a customer gateway associated with the VPN connection.</p> </li> <li> <p> <code>state</code> - The state of the VPN connection (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>option.static-routes-only</code> - Indicates whether the connection has static routes only. Used for devices that do not support Border Gateway Protocol (BGP).</p> </li> <li> <p> <code>route.destination-cidr-block</code> - The destination CIDR block. This corresponds to the subnet used in a customer data center.</p> </li> <li> <p> <code>bgp-asn</code> - The BGP Autonomous System Number (ASN) associated with a BGP device.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>type</code> - The type of VPN connection. Currently the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>vpn-connection-id</code> - The ID of the VPN connection.</p> </li> <li> <p> <code>vpn-gateway-id</code> - The ID of a virtual private gateway associated with the VPN connection.</p> </li> </ul>
function M.DescribeVpnConnectionsRequest(DryRun, VpnConnectionIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpnConnectionsRequest")
	local t = { 
		["DryRun"] = DryRun,
		["VpnConnectionIds"] = VpnConnectionIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeVpnConnectionsRequest(t)
	return t
end

local SpotDatafeedSubscription_keys = { "Fault" = true, "Prefix" = true, "Bucket" = true, "State" = true, "OwnerId" = true, nil }

function M.AssertSpotDatafeedSubscription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotDatafeedSubscription to be of type 'table'")
	if struct["Fault"] then M.AssertSpotInstanceStateFault(struct["Fault"]) end
	if struct["Prefix"] then M.AssertString(struct["Prefix"]) end
	if struct["Bucket"] then M.AssertString(struct["Bucket"]) end
	if struct["State"] then M.AssertDatafeedSubscriptionState(struct["State"]) end
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(SpotDatafeedSubscription_keys[k], "SpotDatafeedSubscription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotDatafeedSubscription
-- <p>Describes the data feed for a Spot instance.</p>
-- @param Fault [SpotInstanceStateFault] <p>The fault codes for the Spot instance request, if any.</p>
-- @param Prefix [String] <p>The prefix that is prepended to data feed files.</p>
-- @param Bucket [String] <p>The Amazon S3 bucket where the Spot instance data feed is located.</p>
-- @param State [DatafeedSubscriptionState] <p>The state of the Spot instance data feed subscription.</p>
-- @param OwnerId [String] <p>The AWS account ID of the account.</p>
function M.SpotDatafeedSubscription(Fault, Prefix, Bucket, State, OwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotDatafeedSubscription")
	local t = { 
		["Fault"] = Fault,
		["Prefix"] = Prefix,
		["Bucket"] = Bucket,
		["State"] = State,
		["OwnerId"] = OwnerId,
	}
	M.AssertSpotDatafeedSubscription(t)
	return t
end

local StorageLocation_keys = { "Bucket" = true, "Key" = true, nil }

function M.AssertStorageLocation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StorageLocation to be of type 'table'")
	if struct["Bucket"] then M.AssertString(struct["Bucket"]) end
	if struct["Key"] then M.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(StorageLocation_keys[k], "StorageLocation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StorageLocation
-- <p>Describes a storage location in Amazon S3.</p>
-- @param Bucket [String] <p>The name of the S3 bucket.</p>
-- @param Key [String] <p>The key.</p>
function M.StorageLocation(Bucket, Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StorageLocation")
	local t = { 
		["Bucket"] = Bucket,
		["Key"] = Key,
	}
	M.AssertStorageLocation(t)
	return t
end

local ModifyHostsResult_keys = { "Successful" = true, "Unsuccessful" = true, nil }

function M.AssertModifyHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyHostsResult to be of type 'table'")
	if struct["Successful"] then M.AssertResponseHostIdList(struct["Successful"]) end
	if struct["Unsuccessful"] then M.AssertUnsuccessfulItemList(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(ModifyHostsResult_keys[k], "ModifyHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyHostsResult
-- <p>Contains the output of ModifyHosts.</p>
-- @param Successful [ResponseHostIdList] <p>The IDs of the Dedicated Hosts that were successfully modified.</p>
-- @param Unsuccessful [UnsuccessfulItemList] <p>The IDs of the Dedicated Hosts that could not be modified. Check whether the setting you requested can be used.</p>
function M.ModifyHostsResult(Successful, Unsuccessful, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyHostsResult")
	local t = { 
		["Successful"] = Successful,
		["Unsuccessful"] = Unsuccessful,
	}
	M.AssertModifyHostsResult(t)
	return t
end

local CreateInternetGatewayRequest_keys = { "DryRun" = true, nil }

function M.AssertCreateInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInternetGatewayRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(CreateInternetGatewayRequest_keys[k], "CreateInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInternetGatewayRequest
-- <p>Contains the parameters for CreateInternetGateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.CreateInternetGatewayRequest(DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateInternetGatewayRequest")
	local t = { 
		["DryRun"] = DryRun,
	}
	M.AssertCreateInternetGatewayRequest(t)
	return t
end

local DescribeNetworkInterfacesResult_keys = { "NetworkInterfaces" = true, nil }

function M.AssertDescribeNetworkInterfacesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacesResult to be of type 'table'")
	if struct["NetworkInterfaces"] then M.AssertNetworkInterfaceList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(DescribeNetworkInterfacesResult_keys[k], "DescribeNetworkInterfacesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacesResult
-- <p>Contains the output of DescribeNetworkInterfaces.</p>
-- @param NetworkInterfaces [NetworkInterfaceList] <p>Information about one or more network interfaces.</p>
function M.DescribeNetworkInterfacesResult(NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkInterfacesResult")
	local t = { 
		["NetworkInterfaces"] = NetworkInterfaces,
	}
	M.AssertDescribeNetworkInterfacesResult(t)
	return t
end

local InstanceNetworkInterfaceAssociation_keys = { "PublicIp" = true, "PublicDnsName" = true, "IpOwnerId" = true, nil }

function M.AssertInstanceNetworkInterfaceAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceAssociation to be of type 'table'")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["PublicDnsName"] then M.AssertString(struct["PublicDnsName"]) end
	if struct["IpOwnerId"] then M.AssertString(struct["IpOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(InstanceNetworkInterfaceAssociation_keys[k], "InstanceNetworkInterfaceAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceAssociation
-- <p>Describes association information for an Elastic IP address (IPv4).</p>
-- @param PublicIp [String] <p>The public IP address or Elastic IP address bound to the network interface.</p>
-- @param PublicDnsName [String] <p>The public DNS name.</p>
-- @param IpOwnerId [String] <p>The ID of the owner of the Elastic IP address.</p>
function M.InstanceNetworkInterfaceAssociation(PublicIp, PublicDnsName, IpOwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceNetworkInterfaceAssociation")
	local t = { 
		["PublicIp"] = PublicIp,
		["PublicDnsName"] = PublicDnsName,
		["IpOwnerId"] = IpOwnerId,
	}
	M.AssertInstanceNetworkInterfaceAssociation(t)
	return t
end

local InstanceExportDetails_keys = { "InstanceId" = true, "TargetEnvironment" = true, nil }

function M.AssertInstanceExportDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceExportDetails to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["TargetEnvironment"] then M.AssertExportEnvironment(struct["TargetEnvironment"]) end
	for k,_ in pairs(struct) do
		assert(InstanceExportDetails_keys[k], "InstanceExportDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceExportDetails
-- <p>Describes an instance to export.</p>
-- @param InstanceId [String] <p>The ID of the resource being exported.</p>
-- @param TargetEnvironment [ExportEnvironment] <p>The target virtualization environment.</p>
function M.InstanceExportDetails(InstanceId, TargetEnvironment, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceExportDetails")
	local t = { 
		["InstanceId"] = InstanceId,
		["TargetEnvironment"] = TargetEnvironment,
	}
	M.AssertInstanceExportDetails(t)
	return t
end

local VpcClassicLink_keys = { "ClassicLinkEnabled" = true, "VpcId" = true, "Tags" = true, nil }

function M.AssertVpcClassicLink(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcClassicLink to be of type 'table'")
	if struct["ClassicLinkEnabled"] then M.AssertBoolean(struct["ClassicLinkEnabled"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(VpcClassicLink_keys[k], "VpcClassicLink contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcClassicLink
-- <p>Describes whether a VPC is enabled for ClassicLink.</p>
-- @param ClassicLinkEnabled [Boolean] <p>Indicates whether the VPC is enabled for ClassicLink.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param Tags [TagList] <p>Any tags assigned to the VPC.</p>
function M.VpcClassicLink(ClassicLinkEnabled, VpcId, Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcClassicLink")
	local t = { 
		["ClassicLinkEnabled"] = ClassicLinkEnabled,
		["VpcId"] = VpcId,
		["Tags"] = Tags,
	}
	M.AssertVpcClassicLink(t)
	return t
end

local NetworkInterfaceIpv6Address_keys = { "Ipv6Address" = true, nil }

function M.AssertNetworkInterfaceIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then M.AssertString(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(NetworkInterfaceIpv6Address_keys[k], "NetworkInterfaceIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceIpv6Address
-- <p>Describes an IPv6 address associated with a network interface.</p>
-- @param Ipv6Address [String] <p>The IPv6 address.</p>
function M.NetworkInterfaceIpv6Address(Ipv6Address, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfaceIpv6Address")
	local t = { 
		["Ipv6Address"] = Ipv6Address,
	}
	M.AssertNetworkInterfaceIpv6Address(t)
	return t
end

local DisableVpcClassicLinkRequest_keys = { "VpcId" = true, "DryRun" = true, nil }

function M.AssertDisableVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DisableVpcClassicLinkRequest_keys[k], "DisableVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkRequest
-- <p>Contains the parameters for DisableVpcClassicLink.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.DisableVpcClassicLinkRequest(VpcId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVpcClassicLinkRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
	}
	M.AssertDisableVpcClassicLinkRequest(t)
	return t
end

local SpotFleetRequestConfigData_keys = { "Type" = true, "FulfilledCapacity" = true, "TerminateInstancesWithExpiration" = true, "LaunchSpecifications" = true, "IamFleetRole" = true, "ValidUntil" = true, "ClientToken" = true, "TargetCapacity" = true, "ValidFrom" = true, "ExcessCapacityTerminationPolicy" = true, "ReplaceUnhealthyInstances" = true, "SpotPrice" = true, "AllocationStrategy" = true, nil }

function M.AssertSpotFleetRequestConfigData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetRequestConfigData to be of type 'table'")
	assert(struct["IamFleetRole"], "Expected key IamFleetRole to exist in table")
	assert(struct["LaunchSpecifications"], "Expected key LaunchSpecifications to exist in table")
	assert(struct["SpotPrice"], "Expected key SpotPrice to exist in table")
	assert(struct["TargetCapacity"], "Expected key TargetCapacity to exist in table")
	if struct["Type"] then M.AssertFleetType(struct["Type"]) end
	if struct["FulfilledCapacity"] then M.AssertDouble(struct["FulfilledCapacity"]) end
	if struct["TerminateInstancesWithExpiration"] then M.AssertBoolean(struct["TerminateInstancesWithExpiration"]) end
	if struct["LaunchSpecifications"] then M.AssertLaunchSpecsList(struct["LaunchSpecifications"]) end
	if struct["IamFleetRole"] then M.AssertString(struct["IamFleetRole"]) end
	if struct["ValidUntil"] then M.AssertDateTime(struct["ValidUntil"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["TargetCapacity"] then M.AssertInteger(struct["TargetCapacity"]) end
	if struct["ValidFrom"] then M.AssertDateTime(struct["ValidFrom"]) end
	if struct["ExcessCapacityTerminationPolicy"] then M.AssertExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	if struct["ReplaceUnhealthyInstances"] then M.AssertBoolean(struct["ReplaceUnhealthyInstances"]) end
	if struct["SpotPrice"] then M.AssertString(struct["SpotPrice"]) end
	if struct["AllocationStrategy"] then M.AssertAllocationStrategy(struct["AllocationStrategy"]) end
	for k,_ in pairs(struct) do
		assert(SpotFleetRequestConfigData_keys[k], "SpotFleetRequestConfigData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetRequestConfigData
-- <p>Describes the configuration of a Spot fleet request.</p>
-- @param Type [FleetType] <p>The type of request. Indicates whether the fleet will only <code>request</code> the target capacity or also attempt to <code>maintain</code> it. When you <code>request</code> a certain target capacity, the fleet will only place the required bids. It will not attempt to replenish Spot instances if capacity is diminished, nor will it submit bids in alternative Spot pools if capacity is not available. When you want to <code>maintain</code> a certain target capacity, fleet will place the required bids to meet this target capacity. It will also automatically replenish any interrupted instances. Default: <code>maintain</code>.</p>
-- @param FulfilledCapacity [Double] <p>The number of units fulfilled by this request compared to the set target capacity.</p>
-- @param TerminateInstancesWithExpiration [Boolean] <p>Indicates whether running Spot instances should be terminated when the Spot fleet request expires.</p>
-- @param LaunchSpecifications [LaunchSpecsList] <p>Information about the launch specifications for the Spot fleet request.</p>
-- @param IamFleetRole [String] <p>Grants the Spot fleet permission to terminate Spot instances on your behalf when you cancel its Spot fleet request using <a>CancelSpotFleetRequests</a> or when the Spot fleet request expires, if you set <code>terminateInstancesWithExpiration</code>.</p>
-- @param ValidUntil [DateTime] <p>The end date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). At this point, no new Spot instance requests are placed or enabled to fulfill the request.</p>
-- @param ClientToken [String] <p>A unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- @param TargetCapacity [Integer] <p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O.</p>
-- @param ValidFrom [DateTime] <p>The start date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The default is to start fulfilling the request immediately.</p>
-- @param ExcessCapacityTerminationPolicy [ExcessCapacityTerminationPolicy] <p>Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.</p>
-- @param ReplaceUnhealthyInstances [Boolean] <p>Indicates whether Spot fleet should replace unhealthy instances.</p>
-- @param SpotPrice [String] <p>The bid price per unit hour.</p>
-- @param AllocationStrategy [AllocationStrategy] <p>Indicates how to allocate the target capacity across the Spot pools specified by the Spot fleet request. The default is <code>lowestPrice</code>.</p>
-- Required parameter: IamFleetRole
-- Required parameter: LaunchSpecifications
-- Required parameter: SpotPrice
-- Required parameter: TargetCapacity
function M.SpotFleetRequestConfigData(Type, FulfilledCapacity, TerminateInstancesWithExpiration, LaunchSpecifications, IamFleetRole, ValidUntil, ClientToken, TargetCapacity, ValidFrom, ExcessCapacityTerminationPolicy, ReplaceUnhealthyInstances, SpotPrice, AllocationStrategy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotFleetRequestConfigData")
	local t = { 
		["Type"] = Type,
		["FulfilledCapacity"] = FulfilledCapacity,
		["TerminateInstancesWithExpiration"] = TerminateInstancesWithExpiration,
		["LaunchSpecifications"] = LaunchSpecifications,
		["IamFleetRole"] = IamFleetRole,
		["ValidUntil"] = ValidUntil,
		["ClientToken"] = ClientToken,
		["TargetCapacity"] = TargetCapacity,
		["ValidFrom"] = ValidFrom,
		["ExcessCapacityTerminationPolicy"] = ExcessCapacityTerminationPolicy,
		["ReplaceUnhealthyInstances"] = ReplaceUnhealthyInstances,
		["SpotPrice"] = SpotPrice,
		["AllocationStrategy"] = AllocationStrategy,
	}
	M.AssertSpotFleetRequestConfigData(t)
	return t
end

local VolumeStatusItem_keys = { "VolumeStatus" = true, "AvailabilityZone" = true, "Events" = true, "Actions" = true, "VolumeId" = true, nil }

function M.AssertVolumeStatusItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusItem to be of type 'table'")
	if struct["VolumeStatus"] then M.AssertVolumeStatusInfo(struct["VolumeStatus"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["Events"] then M.AssertVolumeStatusEventsList(struct["Events"]) end
	if struct["Actions"] then M.AssertVolumeStatusActionsList(struct["Actions"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(VolumeStatusItem_keys[k], "VolumeStatusItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusItem
-- <p>Describes the volume status.</p>
-- @param VolumeStatus [VolumeStatusInfo] <p>The volume status.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone of the volume.</p>
-- @param Events [VolumeStatusEventsList] <p>A list of events associated with the volume.</p>
-- @param Actions [VolumeStatusActionsList] <p>The details of the operation.</p>
-- @param VolumeId [String] <p>The volume ID.</p>
function M.VolumeStatusItem(VolumeStatus, AvailabilityZone, Events, Actions, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusItem")
	local t = { 
		["VolumeStatus"] = VolumeStatus,
		["AvailabilityZone"] = AvailabilityZone,
		["Events"] = Events,
		["Actions"] = Actions,
		["VolumeId"] = VolumeId,
	}
	M.AssertVolumeStatusItem(t)
	return t
end

local DescribeVpnGatewaysRequest_keys = { "DryRun" = true, "VpnGatewayIds" = true, "Filters" = true, nil }

function M.AssertDescribeVpnGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnGatewaysRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayIds"] then M.AssertVpnGatewayIdStringList(struct["VpnGatewayIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpnGatewaysRequest_keys[k], "DescribeVpnGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnGatewaysRequest
-- <p>Contains the parameters for DescribeVpnGateways.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VpnGatewayIds [VpnGatewayIdStringList] <p>One or more virtual private gateway IDs.</p> <p>Default: Describes all your virtual private gateways.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.state</code> - The current state of the attachment between the gateway and the VPC (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>attachment.vpc-id</code> - The ID of an attached VPC.</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone for the virtual private gateway (if applicable).</p> </li> <li> <p> <code>state</code> - The state of the virtual private gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>type</code> - The type of virtual private gateway. Currently the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>vpn-gateway-id</code> - The ID of the virtual private gateway.</p> </li> </ul>
function M.DescribeVpnGatewaysRequest(DryRun, VpnGatewayIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpnGatewaysRequest")
	local t = { 
		["DryRun"] = DryRun,
		["VpnGatewayIds"] = VpnGatewayIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeVpnGatewaysRequest(t)
	return t
end

local DescribeVpcAttributeResult_keys = { "EnableDnsSupport" = true, "VpcId" = true, "EnableDnsHostnames" = true, nil }

function M.AssertDescribeVpcAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcAttributeResult to be of type 'table'")
	if struct["EnableDnsSupport"] then M.AssertAttributeBooleanValue(struct["EnableDnsSupport"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["EnableDnsHostnames"] then M.AssertAttributeBooleanValue(struct["EnableDnsHostnames"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcAttributeResult_keys[k], "DescribeVpcAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcAttributeResult
-- <p>Contains the output of DescribeVpcAttribute.</p>
-- @param EnableDnsSupport [AttributeBooleanValue] <p>Indicates whether DNS resolution is enabled for the VPC. If this attribute is <code>true</code>, the Amazon DNS server resolves DNS hostnames for your instances to their corresponding IP addresses; otherwise, it does not.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param EnableDnsHostnames [AttributeBooleanValue] <p>Indicates whether the instances launched in the VPC get DNS hostnames. If this attribute is <code>true</code>, instances in the VPC get DNS hostnames; otherwise, they do not.</p>
function M.DescribeVpcAttributeResult(EnableDnsSupport, VpcId, EnableDnsHostnames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcAttributeResult")
	local t = { 
		["EnableDnsSupport"] = EnableDnsSupport,
		["VpcId"] = VpcId,
		["EnableDnsHostnames"] = EnableDnsHostnames,
	}
	M.AssertDescribeVpcAttributeResult(t)
	return t
end

local InstanceNetworkInterface_keys = { "Status" = true, "MacAddress" = true, "SourceDestCheck" = true, "VpcId" = true, "Description" = true, "NetworkInterfaceId" = true, "PrivateIpAddresses" = true, "PrivateDnsName" = true, "Attachment" = true, "Groups" = true, "Ipv6Addresses" = true, "OwnerId" = true, "PrivateIpAddress" = true, "SubnetId" = true, "Association" = true, nil }

function M.AssertInstanceNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterface to be of type 'table'")
	if struct["Status"] then M.AssertNetworkInterfaceStatus(struct["Status"]) end
	if struct["MacAddress"] then M.AssertString(struct["MacAddress"]) end
	if struct["SourceDestCheck"] then M.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PrivateIpAddresses"] then M.AssertInstancePrivateIpAddressList(struct["PrivateIpAddresses"]) end
	if struct["PrivateDnsName"] then M.AssertString(struct["PrivateDnsName"]) end
	if struct["Attachment"] then M.AssertInstanceNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then M.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then M.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["Association"] then M.AssertInstanceNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(InstanceNetworkInterface_keys[k], "InstanceNetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterface
-- <p>Describes a network interface.</p>
-- @param Status [NetworkInterfaceStatus] <p>The status of the network interface.</p>
-- @param MacAddress [String] <p>The MAC address.</p>
-- @param SourceDestCheck [Boolean] <p>Indicates whether to validate network traffic to or from this network interface.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param Description [String] <p>The description.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param PrivateIpAddresses [InstancePrivateIpAddressList] <p>One or more private IPv4 addresses associated with the network interface.</p>
-- @param PrivateDnsName [String] <p>The private DNS name.</p>
-- @param Attachment [InstanceNetworkInterfaceAttachment] <p>The network interface attachment.</p>
-- @param Groups [GroupIdentifierList] <p>One or more security groups.</p>
-- @param Ipv6Addresses [InstanceIpv6AddressList] <p>One or more IPv6 addresses associated with the network interface.</p>
-- @param OwnerId [String] <p>The ID of the AWS account that created the network interface.</p>
-- @param PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param Association [InstanceNetworkInterfaceAssociation] <p>The association information for an Elastic IPv4 associated with the network interface.</p>
function M.InstanceNetworkInterface(Status, MacAddress, SourceDestCheck, VpcId, Description, NetworkInterfaceId, PrivateIpAddresses, PrivateDnsName, Attachment, Groups, Ipv6Addresses, OwnerId, PrivateIpAddress, SubnetId, Association, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceNetworkInterface")
	local t = { 
		["Status"] = Status,
		["MacAddress"] = MacAddress,
		["SourceDestCheck"] = SourceDestCheck,
		["VpcId"] = VpcId,
		["Description"] = Description,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["PrivateIpAddresses"] = PrivateIpAddresses,
		["PrivateDnsName"] = PrivateDnsName,
		["Attachment"] = Attachment,
		["Groups"] = Groups,
		["Ipv6Addresses"] = Ipv6Addresses,
		["OwnerId"] = OwnerId,
		["PrivateIpAddress"] = PrivateIpAddress,
		["SubnetId"] = SubnetId,
		["Association"] = Association,
	}
	M.AssertInstanceNetworkInterface(t)
	return t
end

local DescribeExportTasksRequest_keys = { "ExportTaskIds" = true, nil }

function M.AssertDescribeExportTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeExportTasksRequest to be of type 'table'")
	if struct["ExportTaskIds"] then M.AssertExportTaskIdStringList(struct["ExportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeExportTasksRequest_keys[k], "DescribeExportTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeExportTasksRequest
-- <p>Contains the parameters for DescribeExportTasks.</p>
-- @param ExportTaskIds [ExportTaskIdStringList] <p>One or more export task IDs.</p>
function M.DescribeExportTasksRequest(ExportTaskIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeExportTasksRequest")
	local t = { 
		["ExportTaskIds"] = ExportTaskIds,
	}
	M.AssertDescribeExportTasksRequest(t)
	return t
end

local CreateKeyPairRequest_keys = { "KeyName" = true, "DryRun" = true, nil }

function M.AssertCreateKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(CreateKeyPairRequest_keys[k], "CreateKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateKeyPairRequest
-- <p>Contains the parameters for CreateKeyPair.</p>
-- @param KeyName [String] <p>A unique name for the key pair.</p> <p>Constraints: Up to 255 ASCII characters</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: KeyName
function M.CreateKeyPairRequest(KeyName, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateKeyPairRequest")
	local t = { 
		["KeyName"] = KeyName,
		["DryRun"] = DryRun,
	}
	M.AssertCreateKeyPairRequest(t)
	return t
end

local DeleteVolumeRequest_keys = { "DryRun" = true, "VolumeId" = true, nil }

function M.AssertDeleteVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(DeleteVolumeRequest_keys[k], "DeleteVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVolumeRequest
-- <p>Contains the parameters for DeleteVolume.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.DeleteVolumeRequest(DryRun, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVolumeRequest")
	local t = { 
		["DryRun"] = DryRun,
		["VolumeId"] = VolumeId,
	}
	M.AssertDeleteVolumeRequest(t)
	return t
end

local PurchaseScheduledInstancesRequest_keys = { "PurchaseRequests" = true, "DryRun" = true, "ClientToken" = true, nil }

function M.AssertPurchaseScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseScheduledInstancesRequest to be of type 'table'")
	assert(struct["PurchaseRequests"], "Expected key PurchaseRequests to exist in table")
	if struct["PurchaseRequests"] then M.AssertPurchaseRequestSet(struct["PurchaseRequests"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(PurchaseScheduledInstancesRequest_keys[k], "PurchaseScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseScheduledInstancesRequest
-- <p>Contains the parameters for PurchaseScheduledInstances.</p>
-- @param PurchaseRequests [PurchaseRequestSet] <p>One or more purchase requests.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required parameter: PurchaseRequests
function M.PurchaseScheduledInstancesRequest(PurchaseRequests, DryRun, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseScheduledInstancesRequest")
	local t = { 
		["PurchaseRequests"] = PurchaseRequests,
		["DryRun"] = DryRun,
		["ClientToken"] = ClientToken,
	}
	M.AssertPurchaseScheduledInstancesRequest(t)
	return t
end

local DescribeImportSnapshotTasksRequest_keys = { "NextToken" = true, "DryRun" = true, "MaxResults" = true, "Filters" = true, "ImportTaskIds" = true, nil }

function M.AssertDescribeImportSnapshotTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportSnapshotTasksRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["ImportTaskIds"] then M.AssertImportTaskIdList(struct["ImportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeImportSnapshotTasksRequest_keys[k], "DescribeImportSnapshotTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportSnapshotTasksRequest
-- <p>Contains the parameters for DescribeImportSnapshotTasks.</p>
-- @param NextToken [String] <p>A token that indicates the next page of results.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param Filters [FilterList] <p>One or more filters.</p>
-- @param ImportTaskIds [ImportTaskIdList] <p>A list of import snapshot task IDs.</p>
function M.DescribeImportSnapshotTasksRequest(NextToken, DryRun, MaxResults, Filters, ImportTaskIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImportSnapshotTasksRequest")
	local t = { 
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
		["ImportTaskIds"] = ImportTaskIds,
	}
	M.AssertDescribeImportSnapshotTasksRequest(t)
	return t
end

local CreateEgressOnlyInternetGatewayResult_keys = { "EgressOnlyInternetGateway" = true, "ClientToken" = true, nil }

function M.AssertCreateEgressOnlyInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateEgressOnlyInternetGatewayResult to be of type 'table'")
	if struct["EgressOnlyInternetGateway"] then M.AssertEgressOnlyInternetGateway(struct["EgressOnlyInternetGateway"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(CreateEgressOnlyInternetGatewayResult_keys[k], "CreateEgressOnlyInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateEgressOnlyInternetGatewayResult
--  
-- @param EgressOnlyInternetGateway [EgressOnlyInternetGateway] <p>Information about the egress-only Internet gateway.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
function M.CreateEgressOnlyInternetGatewayResult(EgressOnlyInternetGateway, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateEgressOnlyInternetGatewayResult")
	local t = { 
		["EgressOnlyInternetGateway"] = EgressOnlyInternetGateway,
		["ClientToken"] = ClientToken,
	}
	M.AssertCreateEgressOnlyInternetGatewayResult(t)
	return t
end

local DescribeClassicLinkInstancesResult_keys = { "Instances" = true, "NextToken" = true, nil }

function M.AssertDescribeClassicLinkInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeClassicLinkInstancesResult to be of type 'table'")
	if struct["Instances"] then M.AssertClassicLinkInstanceList(struct["Instances"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeClassicLinkInstancesResult_keys[k], "DescribeClassicLinkInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeClassicLinkInstancesResult
-- <p>Contains the output of DescribeClassicLinkInstances.</p>
-- @param Instances [ClassicLinkInstanceList] <p>Information about one or more linked EC2-Classic instances.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeClassicLinkInstancesResult(Instances, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeClassicLinkInstancesResult")
	local t = { 
		["Instances"] = Instances,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeClassicLinkInstancesResult(t)
	return t
end

local CopyImageRequest_keys = { "SourceRegion" = true, "DryRun" = true, "Name" = true, "Encrypted" = true, "SourceImageId" = true, "KmsKeyId" = true, "ClientToken" = true, "Description" = true, nil }

function M.AssertCopyImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyImageRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["SourceImageId"], "Expected key SourceImageId to exist in table")
	assert(struct["SourceRegion"], "Expected key SourceRegion to exist in table")
	if struct["SourceRegion"] then M.AssertString(struct["SourceRegion"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Name"] then M.AssertString(struct["Name"]) end
	if struct["Encrypted"] then M.AssertBoolean(struct["Encrypted"]) end
	if struct["SourceImageId"] then M.AssertString(struct["SourceImageId"]) end
	if struct["KmsKeyId"] then M.AssertString(struct["KmsKeyId"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(CopyImageRequest_keys[k], "CopyImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyImageRequest
-- <p>Contains the parameters for CopyImage.</p>
-- @param SourceRegion [String] <p>The name of the region that contains the AMI to copy.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Name [String] <p>The name of the new AMI in the destination region.</p>
-- @param Encrypted [Boolean] <p>Specifies whether the destination snapshots of the copied image should be encrypted. The default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with <code>KmsKeyId</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param SourceImageId [String] <p>The ID of the AMI to copy.</p>
-- @param KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when encrypting the snapshots of an image during a copy operation. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. The specified CMK must exist in the region that the snapshot is being copied to. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param Description [String] <p>A description for the new AMI in the destination region.</p>
-- Required parameter: Name
-- Required parameter: SourceImageId
-- Required parameter: SourceRegion
function M.CopyImageRequest(SourceRegion, DryRun, Name, Encrypted, SourceImageId, KmsKeyId, ClientToken, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CopyImageRequest")
	local t = { 
		["SourceRegion"] = SourceRegion,
		["DryRun"] = DryRun,
		["Name"] = Name,
		["Encrypted"] = Encrypted,
		["SourceImageId"] = SourceImageId,
		["KmsKeyId"] = KmsKeyId,
		["ClientToken"] = ClientToken,
		["Description"] = Description,
	}
	M.AssertCopyImageRequest(t)
	return t
end

local CreateNetworkAclRequest_keys = { "VpcId" = true, "DryRun" = true, nil }

function M.AssertCreateNetworkAclRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(CreateNetworkAclRequest_keys[k], "CreateNetworkAclRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclRequest
-- <p>Contains the parameters for CreateNetworkAcl.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.CreateNetworkAclRequest(VpcId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkAclRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
	}
	M.AssertCreateNetworkAclRequest(t)
	return t
end

local DisassociateRouteTableRequest_keys = { "AssociationId" = true, "DryRun" = true, nil }

function M.AssertDisassociateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateRouteTableRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DisassociateRouteTableRequest_keys[k], "DisassociateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateRouteTableRequest
-- <p>Contains the parameters for DisassociateRouteTable.</p>
-- @param AssociationId [String] <p>The association ID representing the current association between the route table and subnet.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: AssociationId
function M.DisassociateRouteTableRequest(AssociationId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateRouteTableRequest")
	local t = { 
		["AssociationId"] = AssociationId,
		["DryRun"] = DryRun,
	}
	M.AssertDisassociateRouteTableRequest(t)
	return t
end

local DescribeAddressesRequest_keys = { "PublicIps" = true, "DryRun" = true, "AllocationIds" = true, "Filters" = true, nil }

function M.AssertDescribeAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAddressesRequest to be of type 'table'")
	if struct["PublicIps"] then M.AssertPublicIpStringList(struct["PublicIps"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["AllocationIds"] then M.AssertAllocationIdList(struct["AllocationIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeAddressesRequest_keys[k], "DescribeAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAddressesRequest
-- <p>Contains the parameters for DescribeAddresses.</p>
-- @param PublicIps [PublicIpStringList] <p>[EC2-Classic] One or more Elastic IP addresses.</p> <p>Default: Describes all your Elastic IP addresses.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param AllocationIds [AllocationIdList] <p>[EC2-VPC] One or more allocation IDs.</p> <p>Default: Describes all your Elastic IP addresses.</p>
-- @param Filters [FilterList] <p>One or more filters. Filter names and values are case-sensitive.</p> <ul> <li> <p> <code>allocation-id</code> - [EC2-VPC] The allocation ID for the address.</p> </li> <li> <p> <code>association-id</code> - [EC2-VPC] The association ID for the address.</p> </li> <li> <p> <code>domain</code> - Indicates whether the address is for use in EC2-Classic (<code>standard</code>) or in a VPC (<code>vpc</code>).</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance the address is associated with, if any.</p> </li> <li> <p> <code>network-interface-id</code> - [EC2-VPC] The ID of the network interface that the address is associated with, if any.</p> </li> <li> <p> <code>network-interface-owner-id</code> - The AWS account ID of the owner.</p> </li> <li> <p> <code>private-ip-address</code> - [EC2-VPC] The private IP address associated with the Elastic IP address.</p> </li> <li> <p> <code>public-ip</code> - The Elastic IP address.</p> </li> </ul>
function M.DescribeAddressesRequest(PublicIps, DryRun, AllocationIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAddressesRequest")
	local t = { 
		["PublicIps"] = PublicIps,
		["DryRun"] = DryRun,
		["AllocationIds"] = AllocationIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeAddressesRequest(t)
	return t
end

local AllocateAddressResult_keys = { "PublicIp" = true, "Domain" = true, "AllocationId" = true, nil }

function M.AssertAllocateAddressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateAddressResult to be of type 'table'")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["Domain"] then M.AssertDomainType(struct["Domain"]) end
	if struct["AllocationId"] then M.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(AllocateAddressResult_keys[k], "AllocateAddressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateAddressResult
-- <p>Contains the output of AllocateAddress.</p>
-- @param PublicIp [String] <p>The Elastic IP address.</p>
-- @param Domain [DomainType] <p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
-- @param AllocationId [String] <p>[EC2-VPC] The ID that AWS assigns to represent the allocation of the Elastic IP address for use with instances in a VPC.</p>
function M.AllocateAddressResult(PublicIp, Domain, AllocationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AllocateAddressResult")
	local t = { 
		["PublicIp"] = PublicIp,
		["Domain"] = Domain,
		["AllocationId"] = AllocationId,
	}
	M.AssertAllocateAddressResult(t)
	return t
end

local FpgaImageState_keys = { "Message" = true, "Code" = true, nil }

function M.AssertFpgaImageState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FpgaImageState to be of type 'table'")
	if struct["Message"] then M.AssertString(struct["Message"]) end
	if struct["Code"] then M.AssertFpgaImageStateCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(FpgaImageState_keys[k], "FpgaImageState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FpgaImageState
-- <p>Describes the state of the bitstream generation process for an Amazon FPGA image (AFI).</p>
-- @param Message [String] <p>If the state is <code>failed</code>, this is the error message.</p>
-- @param Code [FpgaImageStateCode] <p>The state. The following are the possible values:</p> <ul> <li> <p> <code>pending</code> - AFI bitstream generation is in progress.</p> </li> <li> <p> <code>available</code> - The AFI is available for use.</p> </li> <li> <p> <code>failed</code> - AFI bitstream generation failed.</p> </li> <li> <p> <code>unavailable</code> - The AFI is no longer available for use.</p> </li> </ul>
function M.FpgaImageState(Message, Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating FpgaImageState")
	local t = { 
		["Message"] = Message,
		["Code"] = Code,
	}
	M.AssertFpgaImageState(t)
	return t
end

local DescribeNetworkInterfaceAttributeRequest_keys = { "Attribute" = true, "NetworkInterfaceId" = true, "DryRun" = true, nil }

function M.AssertDescribeNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Attribute"] then M.AssertNetworkInterfaceAttribute(struct["Attribute"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DescribeNetworkInterfaceAttributeRequest_keys[k], "DescribeNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for DescribeNetworkInterfaceAttribute.</p>
-- @param Attribute [NetworkInterfaceAttribute] <p>The attribute of the network interface. This parameter is required.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: NetworkInterfaceId
function M.DescribeNetworkInterfaceAttributeRequest(Attribute, NetworkInterfaceId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkInterfaceAttributeRequest")
	local t = { 
		["Attribute"] = Attribute,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["DryRun"] = DryRun,
	}
	M.AssertDescribeNetworkInterfaceAttributeRequest(t)
	return t
end

local DescribeSpotDatafeedSubscriptionRequest_keys = { "DryRun" = true, nil }

function M.AssertDescribeSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotDatafeedSubscriptionRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotDatafeedSubscriptionRequest_keys[k], "DescribeSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for DescribeSpotDatafeedSubscription.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.DescribeSpotDatafeedSubscriptionRequest(DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotDatafeedSubscriptionRequest")
	local t = { 
		["DryRun"] = DryRun,
	}
	M.AssertDescribeSpotDatafeedSubscriptionRequest(t)
	return t
end

local ReplaceNetworkAclAssociationRequest_keys = { "NetworkAclId" = true, "AssociationId" = true, "DryRun" = true, nil }

function M.AssertReplaceNetworkAclAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclAssociationRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	if struct["NetworkAclId"] then M.AssertString(struct["NetworkAclId"]) end
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(ReplaceNetworkAclAssociationRequest_keys[k], "ReplaceNetworkAclAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclAssociationRequest
-- <p>Contains the parameters for ReplaceNetworkAclAssociation.</p>
-- @param NetworkAclId [String] <p>The ID of the new network ACL to associate with the subnet.</p>
-- @param AssociationId [String] <p>The ID of the current association between the original network ACL and the subnet.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: AssociationId
-- Required parameter: NetworkAclId
function M.ReplaceNetworkAclAssociationRequest(NetworkAclId, AssociationId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceNetworkAclAssociationRequest")
	local t = { 
		["NetworkAclId"] = NetworkAclId,
		["AssociationId"] = AssociationId,
		["DryRun"] = DryRun,
	}
	M.AssertReplaceNetworkAclAssociationRequest(t)
	return t
end

local DeleteNetworkAclEntryRequest_keys = { "NetworkAclId" = true, "Egress" = true, "DryRun" = true, "RuleNumber" = true, nil }

function M.AssertDeleteNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["NetworkAclId"] then M.AssertString(struct["NetworkAclId"]) end
	if struct["Egress"] then M.AssertBoolean(struct["Egress"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["RuleNumber"] then M.AssertInteger(struct["RuleNumber"]) end
	for k,_ in pairs(struct) do
		assert(DeleteNetworkAclEntryRequest_keys[k], "DeleteNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkAclEntryRequest
-- <p>Contains the parameters for DeleteNetworkAclEntry.</p>
-- @param NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param Egress [Boolean] <p>Indicates whether the rule is an egress rule.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param RuleNumber [Integer] <p>The rule number of the entry to delete.</p>
-- Required parameter: Egress
-- Required parameter: NetworkAclId
-- Required parameter: RuleNumber
function M.DeleteNetworkAclEntryRequest(NetworkAclId, Egress, DryRun, RuleNumber, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNetworkAclEntryRequest")
	local t = { 
		["NetworkAclId"] = NetworkAclId,
		["Egress"] = Egress,
		["DryRun"] = DryRun,
		["RuleNumber"] = RuleNumber,
	}
	M.AssertDeleteNetworkAclEntryRequest(t)
	return t
end

local DeleteSpotDatafeedSubscriptionRequest_keys = { "DryRun" = true, nil }

function M.AssertDeleteSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSpotDatafeedSubscriptionRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteSpotDatafeedSubscriptionRequest_keys[k], "DeleteSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for DeleteSpotDatafeedSubscription.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.DeleteSpotDatafeedSubscriptionRequest(DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteSpotDatafeedSubscriptionRequest")
	local t = { 
		["DryRun"] = DryRun,
	}
	M.AssertDeleteSpotDatafeedSubscriptionRequest(t)
	return t
end

local DescribeBundleTasksResult_keys = { "BundleTasks" = true, nil }

function M.AssertDescribeBundleTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeBundleTasksResult to be of type 'table'")
	if struct["BundleTasks"] then M.AssertBundleTaskList(struct["BundleTasks"]) end
	for k,_ in pairs(struct) do
		assert(DescribeBundleTasksResult_keys[k], "DescribeBundleTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeBundleTasksResult
-- <p>Contains the output of DescribeBundleTasks.</p>
-- @param BundleTasks [BundleTaskList] <p>Information about one or more bundle tasks.</p>
function M.DescribeBundleTasksResult(BundleTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeBundleTasksResult")
	local t = { 
		["BundleTasks"] = BundleTasks,
	}
	M.AssertDescribeBundleTasksResult(t)
	return t
end

local ReplaceIamInstanceProfileAssociationRequest_keys = { "AssociationId" = true, "IamInstanceProfile" = true, nil }

function M.AssertReplaceIamInstanceProfileAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceIamInstanceProfileAssociationRequest to be of type 'table'")
	assert(struct["IamInstanceProfile"], "Expected key IamInstanceProfile to exist in table")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["IamInstanceProfile"] then M.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(ReplaceIamInstanceProfileAssociationRequest_keys[k], "ReplaceIamInstanceProfileAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceIamInstanceProfileAssociationRequest
--  
-- @param AssociationId [String] <p>The ID of the existing IAM instance profile association.</p>
-- @param IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- Required parameter: IamInstanceProfile
-- Required parameter: AssociationId
function M.ReplaceIamInstanceProfileAssociationRequest(AssociationId, IamInstanceProfile, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceIamInstanceProfileAssociationRequest")
	local t = { 
		["AssociationId"] = AssociationId,
		["IamInstanceProfile"] = IamInstanceProfile,
	}
	M.AssertReplaceIamInstanceProfileAssociationRequest(t)
	return t
end

local PurchaseHostReservationResult_keys = { "TotalHourlyPrice" = true, "Purchase" = true, "CurrencyCode" = true, "TotalUpfrontPrice" = true, "ClientToken" = true, nil }

function M.AssertPurchaseHostReservationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseHostReservationResult to be of type 'table'")
	if struct["TotalHourlyPrice"] then M.AssertString(struct["TotalHourlyPrice"]) end
	if struct["Purchase"] then M.AssertPurchaseSet(struct["Purchase"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["TotalUpfrontPrice"] then M.AssertString(struct["TotalUpfrontPrice"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(PurchaseHostReservationResult_keys[k], "PurchaseHostReservationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseHostReservationResult
--  
-- @param TotalHourlyPrice [String] <p>The total hourly price of the reservation calculated per hour.</p>
-- @param Purchase [PurchaseSet] <p>Describes the details of the purchase.</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param TotalUpfrontPrice [String] <p>The total amount that will be charged to your account when you purchase the reservation.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i> </p>
function M.PurchaseHostReservationResult(TotalHourlyPrice, Purchase, CurrencyCode, TotalUpfrontPrice, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseHostReservationResult")
	local t = { 
		["TotalHourlyPrice"] = TotalHourlyPrice,
		["Purchase"] = Purchase,
		["CurrencyCode"] = CurrencyCode,
		["TotalUpfrontPrice"] = TotalUpfrontPrice,
		["ClientToken"] = ClientToken,
	}
	M.AssertPurchaseHostReservationResult(t)
	return t
end

local ModifyVolumeAttributeRequest_keys = { "AutoEnableIO" = true, "DryRun" = true, "VolumeId" = true, nil }

function M.AssertModifyVolumeAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeAttributeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["AutoEnableIO"] then M.AssertAttributeBooleanValue(struct["AutoEnableIO"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(ModifyVolumeAttributeRequest_keys[k], "ModifyVolumeAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeAttributeRequest
-- <p>Contains the parameters for ModifyVolumeAttribute.</p>
-- @param AutoEnableIO [AttributeBooleanValue] <p>Indicates whether the volume should be auto-enabled for I/O operations.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.ModifyVolumeAttributeRequest(AutoEnableIO, DryRun, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVolumeAttributeRequest")
	local t = { 
		["AutoEnableIO"] = AutoEnableIO,
		["DryRun"] = DryRun,
		["VolumeId"] = VolumeId,
	}
	M.AssertModifyVolumeAttributeRequest(t)
	return t
end

local CreateRouteResult_keys = { "Return" = true, nil }

function M.AssertCreateRouteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(CreateRouteResult_keys[k], "CreateRouteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteResult
-- <p>Contains the output of CreateRoute.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.CreateRouteResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateRouteResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertCreateRouteResult(t)
	return t
end

local ImportInstanceLaunchSpecification_keys = { "AdditionalInfo" = true, "Monitoring" = true, "UserData" = true, "InstanceInitiatedShutdownBehavior" = true, "GroupNames" = true, "Architecture" = true, "SubnetId" = true, "Placement" = true, "InstanceType" = true, "PrivateIpAddress" = true, "GroupIds" = true, nil }

function M.AssertImportInstanceLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceLaunchSpecification to be of type 'table'")
	if struct["AdditionalInfo"] then M.AssertString(struct["AdditionalInfo"]) end
	if struct["Monitoring"] then M.AssertBoolean(struct["Monitoring"]) end
	if struct["UserData"] then M.AssertUserData(struct["UserData"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then M.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["GroupNames"] then M.AssertSecurityGroupStringList(struct["GroupNames"]) end
	if struct["Architecture"] then M.AssertArchitectureValues(struct["Architecture"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["Placement"] then M.AssertPlacement(struct["Placement"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	if struct["GroupIds"] then M.AssertSecurityGroupIdStringList(struct["GroupIds"]) end
	for k,_ in pairs(struct) do
		assert(ImportInstanceLaunchSpecification_keys[k], "ImportInstanceLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceLaunchSpecification
-- <p>Describes the launch specification for VM import.</p>
-- @param AdditionalInfo [String] <p>Reserved.</p>
-- @param Monitoring [Boolean] <p>Indicates whether monitoring is enabled.</p>
-- @param UserData [UserData] <p>The user data to make available to the instance. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- @param GroupNames [SecurityGroupStringList] <p>One or more security group names.</p>
-- @param Architecture [ArchitectureValues] <p>The architecture of the instance.</p>
-- @param SubnetId [String] <p>[EC2-VPC] The ID of the subnet in which to launch the instance.</p>
-- @param Placement [Placement] <p>The placement information for the instance.</p>
-- @param InstanceType [InstanceType] <p>The instance type. For more information about the instance types that you can import, see <a href="http://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html#vmimport-instance-types">Instance Types</a> in the VM Import/Export User Guide.</p>
-- @param PrivateIpAddress [String] <p>[EC2-VPC] An available IP address from the IP address range of the subnet.</p>
-- @param GroupIds [SecurityGroupIdStringList] <p>One or more security group IDs.</p>
function M.ImportInstanceLaunchSpecification(AdditionalInfo, Monitoring, UserData, InstanceInitiatedShutdownBehavior, GroupNames, Architecture, SubnetId, Placement, InstanceType, PrivateIpAddress, GroupIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceLaunchSpecification")
	local t = { 
		["AdditionalInfo"] = AdditionalInfo,
		["Monitoring"] = Monitoring,
		["UserData"] = UserData,
		["InstanceInitiatedShutdownBehavior"] = InstanceInitiatedShutdownBehavior,
		["GroupNames"] = GroupNames,
		["Architecture"] = Architecture,
		["SubnetId"] = SubnetId,
		["Placement"] = Placement,
		["InstanceType"] = InstanceType,
		["PrivateIpAddress"] = PrivateIpAddress,
		["GroupIds"] = GroupIds,
	}
	M.AssertImportInstanceLaunchSpecification(t)
	return t
end

local CreateDhcpOptionsRequest_keys = { "DryRun" = true, "DhcpConfigurations" = true, nil }

function M.AssertCreateDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpConfigurations"], "Expected key DhcpConfigurations to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpConfigurations"] then M.AssertNewDhcpConfigurationList(struct["DhcpConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(CreateDhcpOptionsRequest_keys[k], "CreateDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDhcpOptionsRequest
-- <p>Contains the parameters for CreateDhcpOptions.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param DhcpConfigurations [NewDhcpConfigurationList] <p>A DHCP configuration option.</p>
-- Required parameter: DhcpConfigurations
function M.CreateDhcpOptionsRequest(DryRun, DhcpConfigurations, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateDhcpOptionsRequest")
	local t = { 
		["DryRun"] = DryRun,
		["DhcpConfigurations"] = DhcpConfigurations,
	}
	M.AssertCreateDhcpOptionsRequest(t)
	return t
end

local DisassociateVpcCidrBlockResult_keys = { "Ipv6CidrBlockAssociation" = true, "VpcId" = true, nil }

function M.AssertDisassociateVpcCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateVpcCidrBlockResult to be of type 'table'")
	if struct["Ipv6CidrBlockAssociation"] then M.AssertVpcIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(DisassociateVpcCidrBlockResult_keys[k], "DisassociateVpcCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateVpcCidrBlockResult
--  
-- @param Ipv6CidrBlockAssociation [VpcIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
function M.DisassociateVpcCidrBlockResult(Ipv6CidrBlockAssociation, VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateVpcCidrBlockResult")
	local t = { 
		["Ipv6CidrBlockAssociation"] = Ipv6CidrBlockAssociation,
		["VpcId"] = VpcId,
	}
	M.AssertDisassociateVpcCidrBlockResult(t)
	return t
end

local DeleteVpnConnectionRequest_keys = { "VpnConnectionId" = true, "DryRun" = true, nil }

function M.AssertDeleteVpnConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnConnectionRequest to be of type 'table'")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then M.AssertString(struct["VpnConnectionId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteVpnConnectionRequest_keys[k], "DeleteVpnConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnConnectionRequest
-- <p>Contains the parameters for DeleteVpnConnection.</p>
-- @param VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpnConnectionId
function M.DeleteVpnConnectionRequest(VpnConnectionId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpnConnectionRequest")
	local t = { 
		["VpnConnectionId"] = VpnConnectionId,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteVpnConnectionRequest(t)
	return t
end

local CreateVpnGatewayResult_keys = { "VpnGateway" = true, nil }

function M.AssertCreateVpnGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnGatewayResult to be of type 'table'")
	if struct["VpnGateway"] then M.AssertVpnGateway(struct["VpnGateway"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpnGatewayResult_keys[k], "CreateVpnGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnGatewayResult
-- <p>Contains the output of CreateVpnGateway.</p>
-- @param VpnGateway [VpnGateway] <p>Information about the virtual private gateway.</p>
function M.CreateVpnGatewayResult(VpnGateway, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnGatewayResult")
	local t = { 
		["VpnGateway"] = VpnGateway,
	}
	M.AssertCreateVpnGatewayResult(t)
	return t
end

local ModifyIdentityIdFormatRequest_keys = { "UseLongIds" = true, "PrincipalArn" = true, "Resource" = true, nil }

function M.AssertModifyIdentityIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyIdentityIdFormatRequest to be of type 'table'")
	assert(struct["PrincipalArn"], "Expected key PrincipalArn to exist in table")
	assert(struct["Resource"], "Expected key Resource to exist in table")
	assert(struct["UseLongIds"], "Expected key UseLongIds to exist in table")
	if struct["UseLongIds"] then M.AssertBoolean(struct["UseLongIds"]) end
	if struct["PrincipalArn"] then M.AssertString(struct["PrincipalArn"]) end
	if struct["Resource"] then M.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(ModifyIdentityIdFormatRequest_keys[k], "ModifyIdentityIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyIdentityIdFormatRequest
-- <p>Contains the parameters of ModifyIdentityIdFormat.</p>
-- @param UseLongIds [Boolean] <p>Indicates whether the resource should use longer IDs (17-character IDs)</p>
-- @param PrincipalArn [String] <p>The ARN of the principal, which can be an IAM user, IAM role, or the root user. Specify <code>all</code> to modify the ID format for all IAM users, IAM roles, and the root user of the account.</p>
-- @param Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- Required parameter: PrincipalArn
-- Required parameter: Resource
-- Required parameter: UseLongIds
function M.ModifyIdentityIdFormatRequest(UseLongIds, PrincipalArn, Resource, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyIdentityIdFormatRequest")
	local t = { 
		["UseLongIds"] = UseLongIds,
		["PrincipalArn"] = PrincipalArn,
		["Resource"] = Resource,
	}
	M.AssertModifyIdentityIdFormatRequest(t)
	return t
end

local AttachVolumeRequest_keys = { "Device" = true, "InstanceId" = true, "DryRun" = true, "VolumeId" = true, nil }

function M.AssertAttachVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVolumeRequest to be of type 'table'")
	assert(struct["Device"], "Expected key Device to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Device"] then M.AssertString(struct["Device"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(AttachVolumeRequest_keys[k], "AttachVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVolumeRequest
-- <p>Contains the parameters for AttachVolume.</p>
-- @param Device [String] <p>The device name to expose to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VolumeId [String] <p>The ID of the EBS volume. The volume and instance must be within the same Availability Zone.</p>
-- Required parameter: Device
-- Required parameter: InstanceId
-- Required parameter: VolumeId
function M.AttachVolumeRequest(Device, InstanceId, DryRun, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachVolumeRequest")
	local t = { 
		["Device"] = Device,
		["InstanceId"] = InstanceId,
		["DryRun"] = DryRun,
		["VolumeId"] = VolumeId,
	}
	M.AssertAttachVolumeRequest(t)
	return t
end

local SnapshotDiskContainer_keys = { "Url" = true, "UserBucket" = true, "Description" = true, "Format" = true, nil }

function M.AssertSnapshotDiskContainer(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotDiskContainer to be of type 'table'")
	if struct["Url"] then M.AssertString(struct["Url"]) end
	if struct["UserBucket"] then M.AssertUserBucket(struct["UserBucket"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Format"] then M.AssertString(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(SnapshotDiskContainer_keys[k], "SnapshotDiskContainer contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotDiskContainer
-- <p>The disk container object for the import snapshot request.</p>
-- @param Url [String] <p>The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..).</p>
-- @param UserBucket [UserBucket] <p>The S3 bucket for the disk image.</p>
-- @param Description [String] <p>The description of the disk image being imported.</p>
-- @param Format [String] <p>The format of the disk image being imported.</p> <p>Valid values: <code>RAW</code> | <code>VHD</code> | <code>VMDK</code> | <code>OVA</code> </p>
function M.SnapshotDiskContainer(Url, UserBucket, Description, Format, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SnapshotDiskContainer")
	local t = { 
		["Url"] = Url,
		["UserBucket"] = UserBucket,
		["Description"] = Description,
		["Format"] = Format,
	}
	M.AssertSnapshotDiskContainer(t)
	return t
end

local InstanceStatusEvent_keys = { "Code" = true, "Description" = true, "NotBefore" = true, "NotAfter" = true, nil }

function M.AssertInstanceStatusEvent(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusEvent to be of type 'table'")
	if struct["Code"] then M.AssertEventCode(struct["Code"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["NotBefore"] then M.AssertDateTime(struct["NotBefore"]) end
	if struct["NotAfter"] then M.AssertDateTime(struct["NotAfter"]) end
	for k,_ in pairs(struct) do
		assert(InstanceStatusEvent_keys[k], "InstanceStatusEvent contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusEvent
-- <p>Describes a scheduled event for an instance.</p>
-- @param Code [EventCode] <p>The event code.</p>
-- @param Description [String] <p>A description of the event.</p> <p>After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].</p>
-- @param NotBefore [DateTime] <p>The earliest scheduled start time for the event.</p>
-- @param NotAfter [DateTime] <p>The latest scheduled end time for the event.</p>
function M.InstanceStatusEvent(Code, Description, NotBefore, NotAfter, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStatusEvent")
	local t = { 
		["Code"] = Code,
		["Description"] = Description,
		["NotBefore"] = NotBefore,
		["NotAfter"] = NotAfter,
	}
	M.AssertInstanceStatusEvent(t)
	return t
end

local BundleTask_keys = { "UpdateTime" = true, "InstanceId" = true, "Storage" = true, "BundleTaskError" = true, "State" = true, "StartTime" = true, "Progress" = true, "BundleId" = true, nil }

function M.AssertBundleTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleTask to be of type 'table'")
	if struct["UpdateTime"] then M.AssertDateTime(struct["UpdateTime"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Storage"] then M.AssertStorage(struct["Storage"]) end
	if struct["BundleTaskError"] then M.AssertBundleTaskError(struct["BundleTaskError"]) end
	if struct["State"] then M.AssertBundleTaskState(struct["State"]) end
	if struct["StartTime"] then M.AssertDateTime(struct["StartTime"]) end
	if struct["Progress"] then M.AssertString(struct["Progress"]) end
	if struct["BundleId"] then M.AssertString(struct["BundleId"]) end
	for k,_ in pairs(struct) do
		assert(BundleTask_keys[k], "BundleTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleTask
-- <p>Describes a bundle task.</p>
-- @param UpdateTime [DateTime] <p>The time of the most recent update for the task.</p>
-- @param InstanceId [String] <p>The ID of the instance associated with this bundle task.</p>
-- @param Storage [Storage] <p>The Amazon S3 storage locations.</p>
-- @param BundleTaskError [BundleTaskError] <p>If the task fails, a description of the error.</p>
-- @param State [BundleTaskState] <p>The state of the task.</p>
-- @param StartTime [DateTime] <p>The time this task started.</p>
-- @param Progress [String] <p>The level of task completion, as a percent (for example, 20%).</p>
-- @param BundleId [String] <p>The ID of the bundle task.</p>
function M.BundleTask(UpdateTime, InstanceId, Storage, BundleTaskError, State, StartTime, Progress, BundleId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BundleTask")
	local t = { 
		["UpdateTime"] = UpdateTime,
		["InstanceId"] = InstanceId,
		["Storage"] = Storage,
		["BundleTaskError"] = BundleTaskError,
		["State"] = State,
		["StartTime"] = StartTime,
		["Progress"] = Progress,
		["BundleId"] = BundleId,
	}
	M.AssertBundleTask(t)
	return t
end

local VpcPeeringConnectionVpcInfo_keys = { "PeeringOptions" = true, "Ipv6CidrBlockSet" = true, "VpcId" = true, "CidrBlock" = true, "OwnerId" = true, nil }

function M.AssertVpcPeeringConnectionVpcInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionVpcInfo to be of type 'table'")
	if struct["PeeringOptions"] then M.AssertVpcPeeringConnectionOptionsDescription(struct["PeeringOptions"]) end
	if struct["Ipv6CidrBlockSet"] then M.AssertIpv6CidrBlockSet(struct["Ipv6CidrBlockSet"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["CidrBlock"] then M.AssertString(struct["CidrBlock"]) end
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(VpcPeeringConnectionVpcInfo_keys[k], "VpcPeeringConnectionVpcInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionVpcInfo
-- <p>Describes a VPC in a VPC peering connection.</p>
-- @param PeeringOptions [VpcPeeringConnectionOptionsDescription] <p>Information about the VPC peering connection options for the accepter or requester VPC.</p>
-- @param Ipv6CidrBlockSet [Ipv6CidrBlockSet] <p>The IPv6 CIDR block for the VPC.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param CidrBlock [String] <p>The IPv4 CIDR block for the VPC.</p>
-- @param OwnerId [String] <p>The AWS account ID of the VPC owner.</p>
function M.VpcPeeringConnectionVpcInfo(PeeringOptions, Ipv6CidrBlockSet, VpcId, CidrBlock, OwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcPeeringConnectionVpcInfo")
	local t = { 
		["PeeringOptions"] = PeeringOptions,
		["Ipv6CidrBlockSet"] = Ipv6CidrBlockSet,
		["VpcId"] = VpcId,
		["CidrBlock"] = CidrBlock,
		["OwnerId"] = OwnerId,
	}
	M.AssertVpcPeeringConnectionVpcInfo(t)
	return t
end

local ImportImageResult_keys = { "Status" = true, "LicenseType" = true, "Description" = true, "Hypervisor" = true, "ImageId" = true, "Platform" = true, "Architecture" = true, "SnapshotDetails" = true, "Progress" = true, "StatusMessage" = true, "ImportTaskId" = true, nil }

function M.AssertImportImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageResult to be of type 'table'")
	if struct["Status"] then M.AssertString(struct["Status"]) end
	if struct["LicenseType"] then M.AssertString(struct["LicenseType"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Hypervisor"] then M.AssertString(struct["Hypervisor"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["Platform"] then M.AssertString(struct["Platform"]) end
	if struct["Architecture"] then M.AssertString(struct["Architecture"]) end
	if struct["SnapshotDetails"] then M.AssertSnapshotDetailList(struct["SnapshotDetails"]) end
	if struct["Progress"] then M.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	if struct["ImportTaskId"] then M.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(ImportImageResult_keys[k], "ImportImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageResult
-- <p>Contains the output for ImportImage.</p>
-- @param Status [String] <p>A brief status of the task.</p>
-- @param LicenseType [String] <p>The license type of the virtual machine.</p>
-- @param Description [String] <p>A description of the import task.</p>
-- @param Hypervisor [String] <p>The target hypervisor of the import task.</p>
-- @param ImageId [String] <p>The ID of the Amazon Machine Image (AMI) created by the import task.</p>
-- @param Platform [String] <p>The operating system of the virtual machine.</p>
-- @param Architecture [String] <p>The architecture of the virtual machine.</p>
-- @param SnapshotDetails [SnapshotDetailList] <p>Information about the snapshots.</p>
-- @param Progress [String] <p>The progress of the task.</p>
-- @param StatusMessage [String] <p>A detailed status message of the import task.</p>
-- @param ImportTaskId [String] <p>The task ID of the import image task.</p>
function M.ImportImageResult(Status, LicenseType, Description, Hypervisor, ImageId, Platform, Architecture, SnapshotDetails, Progress, StatusMessage, ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportImageResult")
	local t = { 
		["Status"] = Status,
		["LicenseType"] = LicenseType,
		["Description"] = Description,
		["Hypervisor"] = Hypervisor,
		["ImageId"] = ImageId,
		["Platform"] = Platform,
		["Architecture"] = Architecture,
		["SnapshotDetails"] = SnapshotDetails,
		["Progress"] = Progress,
		["StatusMessage"] = StatusMessage,
		["ImportTaskId"] = ImportTaskId,
	}
	M.AssertImportImageResult(t)
	return t
end

local CreateNetworkInterfaceResult_keys = { "NetworkInterface" = true, nil }

function M.AssertCreateNetworkInterfaceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfaceResult to be of type 'table'")
	if struct["NetworkInterface"] then M.AssertNetworkInterface(struct["NetworkInterface"]) end
	for k,_ in pairs(struct) do
		assert(CreateNetworkInterfaceResult_keys[k], "CreateNetworkInterfaceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfaceResult
-- <p>Contains the output of CreateNetworkInterface.</p>
-- @param NetworkInterface [NetworkInterface] <p>Information about the network interface.</p>
function M.CreateNetworkInterfaceResult(NetworkInterface, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkInterfaceResult")
	local t = { 
		["NetworkInterface"] = NetworkInterface,
	}
	M.AssertCreateNetworkInterfaceResult(t)
	return t
end

local ModifyImageAttributeRequest_keys = { "ProductCodes" = true, "UserGroups" = true, "DryRun" = true, "Description" = true, "Attribute" = true, "UserIds" = true, "Value" = true, "ImageId" = true, "OperationType" = true, "LaunchPermission" = true, nil }

function M.AssertModifyImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyImageAttributeRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["ProductCodes"] then M.AssertProductCodeStringList(struct["ProductCodes"]) end
	if struct["UserGroups"] then M.AssertUserGroupStringList(struct["UserGroups"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertAttributeValue(struct["Description"]) end
	if struct["Attribute"] then M.AssertString(struct["Attribute"]) end
	if struct["UserIds"] then M.AssertUserIdStringList(struct["UserIds"]) end
	if struct["Value"] then M.AssertString(struct["Value"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["OperationType"] then M.AssertOperationType(struct["OperationType"]) end
	if struct["LaunchPermission"] then M.AssertLaunchPermissionModifications(struct["LaunchPermission"]) end
	for k,_ in pairs(struct) do
		assert(ModifyImageAttributeRequest_keys[k], "ModifyImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyImageAttributeRequest
-- <p>Contains the parameters for ModifyImageAttribute.</p>
-- @param ProductCodes [ProductCodeStringList] <p>One or more product codes. After you add a product code to an AMI, it can't be removed. This is only valid when modifying the <code>productCodes</code> attribute.</p>
-- @param UserGroups [UserGroupStringList] <p>One or more user groups. This is only valid when modifying the <code>launchPermission</code> attribute.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [AttributeValue] <p>A description for the AMI.</p>
-- @param Attribute [String] <p>The name of the attribute to modify.</p>
-- @param UserIds [UserIdStringList] <p>One or more AWS account IDs. This is only valid when modifying the <code>launchPermission</code> attribute.</p>
-- @param Value [String] <p>The value of the attribute being modified. This is only valid when modifying the <code>description</code> attribute.</p>
-- @param ImageId [String] <p>The ID of the AMI.</p>
-- @param OperationType [OperationType] <p>The operation type.</p>
-- @param LaunchPermission [LaunchPermissionModifications] <p>A launch permission modification.</p>
-- Required parameter: ImageId
function M.ModifyImageAttributeRequest(ProductCodes, UserGroups, DryRun, Description, Attribute, UserIds, Value, ImageId, OperationType, LaunchPermission, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyImageAttributeRequest")
	local t = { 
		["ProductCodes"] = ProductCodes,
		["UserGroups"] = UserGroups,
		["DryRun"] = DryRun,
		["Description"] = Description,
		["Attribute"] = Attribute,
		["UserIds"] = UserIds,
		["Value"] = Value,
		["ImageId"] = ImageId,
		["OperationType"] = OperationType,
		["LaunchPermission"] = LaunchPermission,
	}
	M.AssertModifyImageAttributeRequest(t)
	return t
end

local DescribeSpotFleetRequestsResponse_keys = { "SpotFleetRequestConfigs" = true, "NextToken" = true, nil }

function M.AssertDescribeSpotFleetRequestsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestsResponse to be of type 'table'")
	assert(struct["SpotFleetRequestConfigs"], "Expected key SpotFleetRequestConfigs to exist in table")
	if struct["SpotFleetRequestConfigs"] then M.AssertSpotFleetRequestConfigSet(struct["SpotFleetRequestConfigs"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotFleetRequestsResponse_keys[k], "DescribeSpotFleetRequestsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestsResponse
-- <p>Contains the output of DescribeSpotFleetRequests.</p>
-- @param SpotFleetRequestConfigs [SpotFleetRequestConfigSet] <p>Information about the configuration of your Spot fleet.</p>
-- @param NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- Required parameter: SpotFleetRequestConfigs
function M.DescribeSpotFleetRequestsResponse(SpotFleetRequestConfigs, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetRequestsResponse")
	local t = { 
		["SpotFleetRequestConfigs"] = SpotFleetRequestConfigs,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeSpotFleetRequestsResponse(t)
	return t
end

local DescribeVpcEndpointServicesRequest_keys = { "NextToken" = true, "DryRun" = true, "MaxResults" = true, nil }

function M.AssertDescribeVpcEndpointServicesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicesRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcEndpointServicesRequest_keys[k], "DescribeVpcEndpointServicesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicesRequest
-- <p>Contains the parameters for DescribeVpcEndpointServices.</p>
-- @param NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
function M.DescribeVpcEndpointServicesRequest(NextToken, DryRun, MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcEndpointServicesRequest")
	local t = { 
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
	}
	M.AssertDescribeVpcEndpointServicesRequest(t)
	return t
end

local NewDhcpConfiguration_keys = { "Values" = true, "Key" = true, nil }

function M.AssertNewDhcpConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NewDhcpConfiguration to be of type 'table'")
	if struct["Values"] then M.AssertValueStringList(struct["Values"]) end
	if struct["Key"] then M.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(NewDhcpConfiguration_keys[k], "NewDhcpConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NewDhcpConfiguration
--  
-- @param Values [ValueStringList]  
-- @param Key [String]  
function M.NewDhcpConfiguration(Values, Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NewDhcpConfiguration")
	local t = { 
		["Values"] = Values,
		["Key"] = Key,
	}
	M.AssertNewDhcpConfiguration(t)
	return t
end

local ModifyVpcPeeringConnectionOptionsResult_keys = { "RequesterPeeringConnectionOptions" = true, "AccepterPeeringConnectionOptions" = true, nil }

function M.AssertModifyVpcPeeringConnectionOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcPeeringConnectionOptionsResult to be of type 'table'")
	if struct["RequesterPeeringConnectionOptions"] then M.AssertPeeringConnectionOptions(struct["RequesterPeeringConnectionOptions"]) end
	if struct["AccepterPeeringConnectionOptions"] then M.AssertPeeringConnectionOptions(struct["AccepterPeeringConnectionOptions"]) end
	for k,_ in pairs(struct) do
		assert(ModifyVpcPeeringConnectionOptionsResult_keys[k], "ModifyVpcPeeringConnectionOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcPeeringConnectionOptionsResult
--  
-- @param RequesterPeeringConnectionOptions [PeeringConnectionOptions] <p>Information about the VPC peering connection options for the requester VPC.</p>
-- @param AccepterPeeringConnectionOptions [PeeringConnectionOptions] <p>Information about the VPC peering connection options for the accepter VPC.</p>
function M.ModifyVpcPeeringConnectionOptionsResult(RequesterPeeringConnectionOptions, AccepterPeeringConnectionOptions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcPeeringConnectionOptionsResult")
	local t = { 
		["RequesterPeeringConnectionOptions"] = RequesterPeeringConnectionOptions,
		["AccepterPeeringConnectionOptions"] = AccepterPeeringConnectionOptions,
	}
	M.AssertModifyVpcPeeringConnectionOptionsResult(t)
	return t
end

local StateReason_keys = { "Message" = true, "Code" = true, nil }

function M.AssertStateReason(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StateReason to be of type 'table'")
	if struct["Message"] then M.AssertString(struct["Message"]) end
	if struct["Code"] then M.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(StateReason_keys[k], "StateReason contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StateReason
-- <p>Describes a state change.</p>
-- @param Message [String] <p>The message for the state change.</p> <ul> <li> <p> <code>Server.InsufficientInstanceCapacity</code>: There was insufficient instance capacity to satisfy the launch request.</p> </li> <li> <p> <code>Server.InternalError</code>: An internal error occurred during instance launch, resulting in termination.</p> </li> <li> <p> <code>Server.ScheduledStop</code>: The instance was stopped due to a scheduled retirement.</p> </li> <li> <p> <code>Server.SpotInstanceTermination</code>: A Spot instance was terminated due to an increase in the market price.</p> </li> <li> <p> <code>Client.InternalError</code>: A client error caused the instance to terminate on launch.</p> </li> <li> <p> <code>Client.InstanceInitiatedShutdown</code>: The instance was shut down using the <code>shutdown -h</code> command from the instance.</p> </li> <li> <p> <code>Client.UserInitiatedShutdown</code>: The instance was shut down using the Amazon EC2 API.</p> </li> <li> <p> <code>Client.VolumeLimitExceeded</code>: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your limits.</p> </li> <li> <p> <code>Client.InvalidSnapshot.NotFound</code>: The specified snapshot was not found.</p> </li> </ul>
-- @param Code [String] <p>The reason code for the state change.</p>
function M.StateReason(Message, Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StateReason")
	local t = { 
		["Message"] = Message,
		["Code"] = Code,
	}
	M.AssertStateReason(t)
	return t
end

local VpcPeeringConnectionStateReason_keys = { "Message" = true, "Code" = true, nil }

function M.AssertVpcPeeringConnectionStateReason(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionStateReason to be of type 'table'")
	if struct["Message"] then M.AssertString(struct["Message"]) end
	if struct["Code"] then M.AssertVpcPeeringConnectionStateReasonCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(VpcPeeringConnectionStateReason_keys[k], "VpcPeeringConnectionStateReason contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionStateReason
-- <p>Describes the status of a VPC peering connection.</p>
-- @param Message [String] <p>A message that provides more information about the status, if applicable.</p>
-- @param Code [VpcPeeringConnectionStateReasonCode] <p>The status of the VPC peering connection.</p>
function M.VpcPeeringConnectionStateReason(Message, Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcPeeringConnectionStateReason")
	local t = { 
		["Message"] = Message,
		["Code"] = Code,
	}
	M.AssertVpcPeeringConnectionStateReason(t)
	return t
end

local IamInstanceProfile_keys = { "Id" = true, "Arn" = true, nil }

function M.AssertIamInstanceProfile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfile to be of type 'table'")
	if struct["Id"] then M.AssertString(struct["Id"]) end
	if struct["Arn"] then M.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(IamInstanceProfile_keys[k], "IamInstanceProfile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfile
-- <p>Describes an IAM instance profile.</p>
-- @param Id [String] <p>The ID of the instance profile.</p>
-- @param Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
function M.IamInstanceProfile(Id, Arn, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IamInstanceProfile")
	local t = { 
		["Id"] = Id,
		["Arn"] = Arn,
	}
	M.AssertIamInstanceProfile(t)
	return t
end

local IpRange_keys = { "CidrIp" = true, nil }

function M.AssertIpRange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IpRange to be of type 'table'")
	if struct["CidrIp"] then M.AssertString(struct["CidrIp"]) end
	for k,_ in pairs(struct) do
		assert(IpRange_keys[k], "IpRange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IpRange
-- <p>Describes an IPv4 range.</p>
-- @param CidrIp [String] <p>The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix.</p>
function M.IpRange(CidrIp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IpRange")
	local t = { 
		["CidrIp"] = CidrIp,
	}
	M.AssertIpRange(t)
	return t
end

local InstanceCount_keys = { "State" = true, "InstanceCount" = true, nil }

function M.AssertInstanceCount(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCount to be of type 'table'")
	if struct["State"] then M.AssertListingState(struct["State"]) end
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(InstanceCount_keys[k], "InstanceCount contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCount
-- <p>Describes a Reserved Instance listing state.</p>
-- @param State [ListingState] <p>The states of the listed Reserved Instances.</p>
-- @param InstanceCount [Integer] <p>The number of listed Reserved Instances in the state specified by the <code>state</code>.</p>
function M.InstanceCount(State, InstanceCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceCount")
	local t = { 
		["State"] = State,
		["InstanceCount"] = InstanceCount,
	}
	M.AssertInstanceCount(t)
	return t
end

local ScheduledInstancesIamInstanceProfile_keys = { "Name" = true, "Arn" = true, nil }

function M.AssertScheduledInstancesIamInstanceProfile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesIamInstanceProfile to be of type 'table'")
	if struct["Name"] then M.AssertString(struct["Name"]) end
	if struct["Arn"] then M.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstancesIamInstanceProfile_keys[k], "ScheduledInstancesIamInstanceProfile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesIamInstanceProfile
-- <p>Describes an IAM instance profile for a Scheduled Instance.</p>
-- @param Name [String] <p>The name.</p>
-- @param Arn [String] <p>The Amazon Resource Name (ARN).</p>
function M.ScheduledInstancesIamInstanceProfile(Name, Arn, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesIamInstanceProfile")
	local t = { 
		["Name"] = Name,
		["Arn"] = Arn,
	}
	M.AssertScheduledInstancesIamInstanceProfile(t)
	return t
end

local VolumeStatusAction_keys = { "EventId" = true, "EventType" = true, "Code" = true, "Description" = true, nil }

function M.AssertVolumeStatusAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusAction to be of type 'table'")
	if struct["EventId"] then M.AssertString(struct["EventId"]) end
	if struct["EventType"] then M.AssertString(struct["EventType"]) end
	if struct["Code"] then M.AssertString(struct["Code"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(VolumeStatusAction_keys[k], "VolumeStatusAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusAction
-- <p>Describes a volume status operation code.</p>
-- @param EventId [String] <p>The ID of the event associated with this operation.</p>
-- @param EventType [String] <p>The event type associated with this operation.</p>
-- @param Code [String] <p>The code identifying the operation, for example, <code>enable-volume-io</code>.</p>
-- @param Description [String] <p>A description of the operation.</p>
function M.VolumeStatusAction(EventId, EventType, Code, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusAction")
	local t = { 
		["EventId"] = EventId,
		["EventType"] = EventType,
		["Code"] = Code,
		["Description"] = Description,
	}
	M.AssertVolumeStatusAction(t)
	return t
end

local VgwTelemetry_keys = { "Status" = true, "AcceptedRouteCount" = true, "LastStatusChange" = true, "OutsideIpAddress" = true, "StatusMessage" = true, nil }

function M.AssertVgwTelemetry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VgwTelemetry to be of type 'table'")
	if struct["Status"] then M.AssertTelemetryStatus(struct["Status"]) end
	if struct["AcceptedRouteCount"] then M.AssertInteger(struct["AcceptedRouteCount"]) end
	if struct["LastStatusChange"] then M.AssertDateTime(struct["LastStatusChange"]) end
	if struct["OutsideIpAddress"] then M.AssertString(struct["OutsideIpAddress"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(VgwTelemetry_keys[k], "VgwTelemetry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VgwTelemetry
-- <p>Describes telemetry for a VPN tunnel.</p>
-- @param Status [TelemetryStatus] <p>The status of the VPN tunnel.</p>
-- @param AcceptedRouteCount [Integer] <p>The number of accepted routes.</p>
-- @param LastStatusChange [DateTime] <p>The date and time of the last change in status.</p>
-- @param OutsideIpAddress [String] <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
-- @param StatusMessage [String] <p>If an error occurs, a description of the error.</p>
function M.VgwTelemetry(Status, AcceptedRouteCount, LastStatusChange, OutsideIpAddress, StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VgwTelemetry")
	local t = { 
		["Status"] = Status,
		["AcceptedRouteCount"] = AcceptedRouteCount,
		["LastStatusChange"] = LastStatusChange,
		["OutsideIpAddress"] = OutsideIpAddress,
		["StatusMessage"] = StatusMessage,
	}
	M.AssertVgwTelemetry(t)
	return t
end

local VpcEndpoint_keys = { "VpcId" = true, "ServiceName" = true, "State" = true, "PolicyDocument" = true, "RouteTableIds" = true, "VpcEndpointId" = true, "CreationTimestamp" = true, nil }

function M.AssertVpcEndpoint(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcEndpoint to be of type 'table'")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["ServiceName"] then M.AssertString(struct["ServiceName"]) end
	if struct["State"] then M.AssertState(struct["State"]) end
	if struct["PolicyDocument"] then M.AssertString(struct["PolicyDocument"]) end
	if struct["RouteTableIds"] then M.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["VpcEndpointId"] then M.AssertString(struct["VpcEndpointId"]) end
	if struct["CreationTimestamp"] then M.AssertDateTime(struct["CreationTimestamp"]) end
	for k,_ in pairs(struct) do
		assert(VpcEndpoint_keys[k], "VpcEndpoint contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcEndpoint
-- <p>Describes a VPC endpoint.</p>
-- @param VpcId [String] <p>The ID of the VPC to which the endpoint is associated.</p>
-- @param ServiceName [String] <p>The name of the AWS service to which the endpoint is associated.</p>
-- @param State [State] <p>The state of the VPC endpoint.</p>
-- @param PolicyDocument [String] <p>The policy document associated with the endpoint.</p>
-- @param RouteTableIds [ValueStringList] <p>One or more route tables associated with the endpoint.</p>
-- @param VpcEndpointId [String] <p>The ID of the VPC endpoint.</p>
-- @param CreationTimestamp [DateTime] <p>The date and time the VPC endpoint was created.</p>
function M.VpcEndpoint(VpcId, ServiceName, State, PolicyDocument, RouteTableIds, VpcEndpointId, CreationTimestamp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcEndpoint")
	local t = { 
		["VpcId"] = VpcId,
		["ServiceName"] = ServiceName,
		["State"] = State,
		["PolicyDocument"] = PolicyDocument,
		["RouteTableIds"] = RouteTableIds,
		["VpcEndpointId"] = VpcEndpointId,
		["CreationTimestamp"] = CreationTimestamp,
	}
	M.AssertVpcEndpoint(t)
	return t
end

local AssociateAddressResult_keys = { "AssociationId" = true, nil }

function M.AssertAssociateAddressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateAddressResult to be of type 'table'")
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(AssociateAddressResult_keys[k], "AssociateAddressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateAddressResult
-- <p>Contains the output of AssociateAddress.</p>
-- @param AssociationId [String] <p>[EC2-VPC] The ID that represents the association of the Elastic IP address with an instance.</p>
function M.AssociateAddressResult(AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateAddressResult")
	local t = { 
		["AssociationId"] = AssociationId,
	}
	M.AssertAssociateAddressResult(t)
	return t
end

local InternetGatewayAttachment_keys = { "State" = true, "VpcId" = true, nil }

function M.AssertInternetGatewayAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InternetGatewayAttachment to be of type 'table'")
	if struct["State"] then M.AssertAttachmentStatus(struct["State"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(InternetGatewayAttachment_keys[k], "InternetGatewayAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InternetGatewayAttachment
-- <p>Describes the attachment of a VPC to an Internet gateway or an egress-only Internet gateway.</p>
-- @param State [AttachmentStatus] <p>The current state of the attachment.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
function M.InternetGatewayAttachment(State, VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InternetGatewayAttachment")
	local t = { 
		["State"] = State,
		["VpcId"] = VpcId,
	}
	M.AssertInternetGatewayAttachment(t)
	return t
end

local CancelSpotFleetRequestsSuccessItem_keys = { "PreviousSpotFleetRequestState" = true, "CurrentSpotFleetRequestState" = true, "SpotFleetRequestId" = true, nil }

function M.AssertCancelSpotFleetRequestsSuccessItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsSuccessItem to be of type 'table'")
	assert(struct["CurrentSpotFleetRequestState"], "Expected key CurrentSpotFleetRequestState to exist in table")
	assert(struct["PreviousSpotFleetRequestState"], "Expected key PreviousSpotFleetRequestState to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["PreviousSpotFleetRequestState"] then M.AssertBatchState(struct["PreviousSpotFleetRequestState"]) end
	if struct["CurrentSpotFleetRequestState"] then M.AssertBatchState(struct["CurrentSpotFleetRequestState"]) end
	if struct["SpotFleetRequestId"] then M.AssertString(struct["SpotFleetRequestId"]) end
	for k,_ in pairs(struct) do
		assert(CancelSpotFleetRequestsSuccessItem_keys[k], "CancelSpotFleetRequestsSuccessItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsSuccessItem
-- <p>Describes a Spot fleet request that was successfully canceled.</p>
-- @param PreviousSpotFleetRequestState [BatchState] <p>The previous state of the Spot fleet request.</p>
-- @param CurrentSpotFleetRequestState [BatchState] <p>The current state of the Spot fleet request.</p>
-- @param SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- Required parameter: CurrentSpotFleetRequestState
-- Required parameter: PreviousSpotFleetRequestState
-- Required parameter: SpotFleetRequestId
function M.CancelSpotFleetRequestsSuccessItem(PreviousSpotFleetRequestState, CurrentSpotFleetRequestState, SpotFleetRequestId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsSuccessItem")
	local t = { 
		["PreviousSpotFleetRequestState"] = PreviousSpotFleetRequestState,
		["CurrentSpotFleetRequestState"] = CurrentSpotFleetRequestState,
		["SpotFleetRequestId"] = SpotFleetRequestId,
	}
	M.AssertCancelSpotFleetRequestsSuccessItem(t)
	return t
end

local RevokeSecurityGroupEgressRequest_keys = { "DryRun" = true, "CidrIp" = true, "IpPermissions" = true, "FromPort" = true, "SourceSecurityGroupOwnerId" = true, "SourceSecurityGroupName" = true, "ToPort" = true, "IpProtocol" = true, "GroupId" = true, nil }

function M.AssertRevokeSecurityGroupEgressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RevokeSecurityGroupEgressRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["CidrIp"] then M.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then M.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then M.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then M.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then M.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then M.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then M.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(RevokeSecurityGroupEgressRequest_keys[k], "RevokeSecurityGroupEgressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RevokeSecurityGroupEgressRequest
-- <p>Contains the parameters for RevokeSecurityGroupEgress.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param CidrIp [String] <p>The CIDR IP address range. We recommend that you specify the CIDR range in a set of IP permissions instead.</p>
-- @param IpPermissions [IpPermissionList] <p>A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.</p>
-- @param FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- @param SourceSecurityGroupOwnerId [String] <p>The AWS account number for a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- @param SourceSecurityGroupName [String] <p>The name of a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- @param ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- @param IpProtocol [String] <p>The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.</p>
-- @param GroupId [String] <p>The ID of the security group.</p>
-- Required parameter: GroupId
function M.RevokeSecurityGroupEgressRequest(DryRun, CidrIp, IpPermissions, FromPort, SourceSecurityGroupOwnerId, SourceSecurityGroupName, ToPort, IpProtocol, GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RevokeSecurityGroupEgressRequest")
	local t = { 
		["DryRun"] = DryRun,
		["CidrIp"] = CidrIp,
		["IpPermissions"] = IpPermissions,
		["FromPort"] = FromPort,
		["SourceSecurityGroupOwnerId"] = SourceSecurityGroupOwnerId,
		["SourceSecurityGroupName"] = SourceSecurityGroupName,
		["ToPort"] = ToPort,
		["IpProtocol"] = IpProtocol,
		["GroupId"] = GroupId,
	}
	M.AssertRevokeSecurityGroupEgressRequest(t)
	return t
end

local DescribeImportImageTasksRequest_keys = { "NextToken" = true, "DryRun" = true, "MaxResults" = true, "Filters" = true, "ImportTaskIds" = true, nil }

function M.AssertDescribeImportImageTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportImageTasksRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["ImportTaskIds"] then M.AssertImportTaskIdList(struct["ImportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeImportImageTasksRequest_keys[k], "DescribeImportImageTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportImageTasksRequest
-- <p>Contains the parameters for DescribeImportImageTasks.</p>
-- @param NextToken [String] <p>A token that indicates the next page of results.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param Filters [FilterList] <p>Filter tasks using the <code>task-state</code> filter and one of the following values: active, completed, deleting, deleted.</p>
-- @param ImportTaskIds [ImportTaskIdList] <p>A list of import image task IDs.</p>
function M.DescribeImportImageTasksRequest(NextToken, DryRun, MaxResults, Filters, ImportTaskIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImportImageTasksRequest")
	local t = { 
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
		["ImportTaskIds"] = ImportTaskIds,
	}
	M.AssertDescribeImportImageTasksRequest(t)
	return t
end

local DescribeVpcClassicLinkDnsSupportResult_keys = { "Vpcs" = true, "NextToken" = true, nil }

function M.AssertDescribeVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Vpcs"] then M.AssertClassicLinkDnsSupportList(struct["Vpcs"]) end
	if struct["NextToken"] then M.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcClassicLinkDnsSupportResult_keys[k], "DescribeVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkDnsSupportResult
-- <p>Contains the output of DescribeVpcClassicLinkDnsSupport.</p>
-- @param Vpcs [ClassicLinkDnsSupportList] <p>Information about the ClassicLink DNS support status of the VPCs.</p>
-- @param NextToken [NextToken] <p>The token to use when requesting the next set of items.</p>
function M.DescribeVpcClassicLinkDnsSupportResult(Vpcs, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcClassicLinkDnsSupportResult")
	local t = { 
		["Vpcs"] = Vpcs,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeVpcClassicLinkDnsSupportResult(t)
	return t
end

local RegisterImageRequest_keys = { "VirtualizationType" = true, "DryRun" = true, "Description" = true, "EnaSupport" = true, "SriovNetSupport" = true, "BlockDeviceMappings" = true, "Architecture" = true, "BillingProducts" = true, "ImageLocation" = true, "KernelId" = true, "RamdiskId" = true, "RootDeviceName" = true, "Name" = true, nil }

function M.AssertRegisterImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterImageRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["VirtualizationType"] then M.AssertString(struct["VirtualizationType"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["EnaSupport"] then M.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then M.AssertString(struct["SriovNetSupport"]) end
	if struct["BlockDeviceMappings"] then M.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then M.AssertArchitectureValues(struct["Architecture"]) end
	if struct["BillingProducts"] then M.AssertBillingProductList(struct["BillingProducts"]) end
	if struct["ImageLocation"] then M.AssertString(struct["ImageLocation"]) end
	if struct["KernelId"] then M.AssertString(struct["KernelId"]) end
	if struct["RamdiskId"] then M.AssertString(struct["RamdiskId"]) end
	if struct["RootDeviceName"] then M.AssertString(struct["RootDeviceName"]) end
	if struct["Name"] then M.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(RegisterImageRequest_keys[k], "RegisterImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterImageRequest
-- <p>Contains the parameters for RegisterImage.</p>
-- @param VirtualizationType [String] <p>The type of virtualization.</p> <p>Default: <code>paravirtual</code> </p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>A description for your AMI.</p>
-- @param EnaSupport [Boolean] <p>Set to <code>true</code> to enable enhanced networking with ENA for the AMI and any instances that you launch from the AMI.</p> <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
-- @param SriovNetSupport [String] <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI.</p> <p>There is no way to disable <code>sriovNetSupport</code> at this time.</p> <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
-- @param BlockDeviceMappings [BlockDeviceMappingRequestList] <p>One or more block device mapping entries.</p>
-- @param Architecture [ArchitectureValues] <p>The architecture of the AMI.</p> <p>Default: For Amazon EBS-backed AMIs, <code>i386</code>. For instance store-backed AMIs, the architecture specified in the manifest file.</p>
-- @param BillingProducts [BillingProductList] <p>The billing product codes. Your account must be authorized to specify billing product codes. Otherwise, you can use the AWS Marketplace to bill for the use of an AMI.</p>
-- @param ImageLocation [String] <p>The full path to your AMI manifest in Amazon S3 storage.</p>
-- @param KernelId [String] <p>The ID of the kernel.</p>
-- @param RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param RootDeviceName [String] <p>The name of the root device (for example, <code>/dev/sda1</code>, or <code>/dev/xvda</code>).</p>
-- @param Name [String] <p>A name for your AMI.</p> <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
-- Required parameter: Name
function M.RegisterImageRequest(VirtualizationType, DryRun, Description, EnaSupport, SriovNetSupport, BlockDeviceMappings, Architecture, BillingProducts, ImageLocation, KernelId, RamdiskId, RootDeviceName, Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RegisterImageRequest")
	local t = { 
		["VirtualizationType"] = VirtualizationType,
		["DryRun"] = DryRun,
		["Description"] = Description,
		["EnaSupport"] = EnaSupport,
		["SriovNetSupport"] = SriovNetSupport,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["Architecture"] = Architecture,
		["BillingProducts"] = BillingProducts,
		["ImageLocation"] = ImageLocation,
		["KernelId"] = KernelId,
		["RamdiskId"] = RamdiskId,
		["RootDeviceName"] = RootDeviceName,
		["Name"] = Name,
	}
	M.AssertRegisterImageRequest(t)
	return t
end

local IcmpTypeCode_keys = { "Code" = true, "Type" = true, nil }

function M.AssertIcmpTypeCode(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IcmpTypeCode to be of type 'table'")
	if struct["Code"] then M.AssertInteger(struct["Code"]) end
	if struct["Type"] then M.AssertInteger(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(IcmpTypeCode_keys[k], "IcmpTypeCode contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IcmpTypeCode
-- <p>Describes the ICMP type and code.</p>
-- @param Code [Integer] <p>The ICMP code. A value of -1 means all codes for the specified ICMP type.</p>
-- @param Type [Integer] <p>The ICMP type. A value of -1 means all types.</p>
function M.IcmpTypeCode(Code, Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IcmpTypeCode")
	local t = { 
		["Code"] = Code,
		["Type"] = Type,
	}
	M.AssertIcmpTypeCode(t)
	return t
end

local DescribeInternetGatewaysRequest_keys = { "DryRun" = true, "InternetGatewayIds" = true, "Filters" = true, nil }

function M.AssertDescribeInternetGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInternetGatewaysRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayIds"] then M.AssertValueStringList(struct["InternetGatewayIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeInternetGatewaysRequest_keys[k], "DescribeInternetGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInternetGatewaysRequest
-- <p>Contains the parameters for DescribeInternetGateways.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InternetGatewayIds [ValueStringList] <p>One or more Internet gateway IDs.</p> <p>Default: Describes all your Internet gateways.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.state</code> - The current state of the attachment between the gateway and the VPC (<code>available</code>). Present only if a VPC is attached.</p> </li> <li> <p> <code>attachment.vpc-id</code> - The ID of an attached VPC.</p> </li> <li> <p> <code>internet-gateway-id</code> - The ID of the Internet gateway.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
function M.DescribeInternetGatewaysRequest(DryRun, InternetGatewayIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInternetGatewaysRequest")
	local t = { 
		["DryRun"] = DryRun,
		["InternetGatewayIds"] = InternetGatewayIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeInternetGatewaysRequest(t)
	return t
end

local CreateVpcPeeringConnectionResult_keys = { "VpcPeeringConnection" = true, nil }

function M.AssertCreateVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcPeeringConnectionResult to be of type 'table'")
	if struct["VpcPeeringConnection"] then M.AssertVpcPeeringConnection(struct["VpcPeeringConnection"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpcPeeringConnectionResult_keys[k], "CreateVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcPeeringConnectionResult
-- <p>Contains the output of CreateVpcPeeringConnection.</p>
-- @param VpcPeeringConnection [VpcPeeringConnection] <p>Information about the VPC peering connection.</p>
function M.CreateVpcPeeringConnectionResult(VpcPeeringConnection, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcPeeringConnectionResult")
	local t = { 
		["VpcPeeringConnection"] = VpcPeeringConnection,
	}
	M.AssertCreateVpcPeeringConnectionResult(t)
	return t
end

local NetworkInterfaceAttachmentChanges_keys = { "DeleteOnTermination" = true, "AttachmentId" = true, nil }

function M.AssertNetworkInterfaceAttachmentChanges(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAttachmentChanges to be of type 'table'")
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then M.AssertString(struct["AttachmentId"]) end
	for k,_ in pairs(struct) do
		assert(NetworkInterfaceAttachmentChanges_keys[k], "NetworkInterfaceAttachmentChanges contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAttachmentChanges
-- <p>Describes an attachment change.</p>
-- @param DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- @param AttachmentId [String] <p>The ID of the network interface attachment.</p>
function M.NetworkInterfaceAttachmentChanges(DeleteOnTermination, AttachmentId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfaceAttachmentChanges")
	local t = { 
		["DeleteOnTermination"] = DeleteOnTermination,
		["AttachmentId"] = AttachmentId,
	}
	M.AssertNetworkInterfaceAttachmentChanges(t)
	return t
end

local CreateNetworkInterfaceRequest_keys = { "DryRun" = true, "Description" = true, "Ipv6AddressCount" = true, "PrivateIpAddresses" = true, "SubnetId" = true, "SecondaryPrivateIpAddressCount" = true, "Groups" = true, "Ipv6Addresses" = true, "PrivateIpAddress" = true, nil }

function M.AssertCreateNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfaceRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then M.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then M.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["SecondaryPrivateIpAddressCount"] then M.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	if struct["Groups"] then M.AssertSecurityGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then M.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(CreateNetworkInterfaceRequest_keys[k], "CreateNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfaceRequest
-- <p>Contains the parameters for CreateNetworkInterface.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>A description for the network interface.</p>
-- @param Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses. If your subnet has the <code>AssignIpv6AddressOnCreation</code> attribute set to <code>true</code>, you can specify <code>0</code> to override this setting.</p>
-- @param PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses.</p>
-- @param SubnetId [String] <p>The ID of the subnet to associate with the network interface.</p>
-- @param SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using <code>privateIpAddresses</code>.</p> <p>The number of IP addresses you can assign to a network interface varies by instance type. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI">IP Addresses Per ENI Per Instance Type</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- @param Groups [SecurityGroupIdStringList] <p>The IDs of one or more security groups.</p>
-- @param Ipv6Addresses [InstanceIpv6AddressList] <p>One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.</p>
-- @param PrivateIpAddress [String] <p>The primary private IPv4 address of the network interface. If you don't specify an IPv4 address, Amazon EC2 selects one for you from the subnet's IPv4 CIDR range. If you specify an IP address, you cannot indicate any IP addresses specified in <code>privateIpAddresses</code> as primary (only one IP address can be designated as primary).</p>
-- Required parameter: SubnetId
function M.CreateNetworkInterfaceRequest(DryRun, Description, Ipv6AddressCount, PrivateIpAddresses, SubnetId, SecondaryPrivateIpAddressCount, Groups, Ipv6Addresses, PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkInterfaceRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Description"] = Description,
		["Ipv6AddressCount"] = Ipv6AddressCount,
		["PrivateIpAddresses"] = PrivateIpAddresses,
		["SubnetId"] = SubnetId,
		["SecondaryPrivateIpAddressCount"] = SecondaryPrivateIpAddressCount,
		["Groups"] = Groups,
		["Ipv6Addresses"] = Ipv6Addresses,
		["PrivateIpAddress"] = PrivateIpAddress,
	}
	M.AssertCreateNetworkInterfaceRequest(t)
	return t
end

local DescribeImportSnapshotTasksResult_keys = { "NextToken" = true, "ImportSnapshotTasks" = true, nil }

function M.AssertDescribeImportSnapshotTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportSnapshotTasksResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["ImportSnapshotTasks"] then M.AssertImportSnapshotTaskList(struct["ImportSnapshotTasks"]) end
	for k,_ in pairs(struct) do
		assert(DescribeImportSnapshotTasksResult_keys[k], "DescribeImportSnapshotTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportSnapshotTasksResult
-- <p>Contains the output for DescribeImportSnapshotTasks.</p>
-- @param NextToken [String] <p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param ImportSnapshotTasks [ImportSnapshotTaskList] <p>A list of zero or more import snapshot tasks that are currently active or were completed or canceled in the previous 7 days.</p>
function M.DescribeImportSnapshotTasksResult(NextToken, ImportSnapshotTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImportSnapshotTasksResult")
	local t = { 
		["NextToken"] = NextToken,
		["ImportSnapshotTasks"] = ImportSnapshotTasks,
	}
	M.AssertDescribeImportSnapshotTasksResult(t)
	return t
end

local DescribeStaleSecurityGroupsResult_keys = { "StaleSecurityGroupSet" = true, "NextToken" = true, nil }

function M.AssertDescribeStaleSecurityGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStaleSecurityGroupsResult to be of type 'table'")
	if struct["StaleSecurityGroupSet"] then M.AssertStaleSecurityGroupSet(struct["StaleSecurityGroupSet"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeStaleSecurityGroupsResult_keys[k], "DescribeStaleSecurityGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStaleSecurityGroupsResult
--  
-- @param StaleSecurityGroupSet [StaleSecurityGroupSet] <p>Information about the stale security groups.</p>
-- @param NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
function M.DescribeStaleSecurityGroupsResult(StaleSecurityGroupSet, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeStaleSecurityGroupsResult")
	local t = { 
		["StaleSecurityGroupSet"] = StaleSecurityGroupSet,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeStaleSecurityGroupsResult(t)
	return t
end

local PriceScheduleSpecification_keys = { "Term" = true, "CurrencyCode" = true, "Price" = true, nil }

function M.AssertPriceScheduleSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PriceScheduleSpecification to be of type 'table'")
	if struct["Term"] then M.AssertLong(struct["Term"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Price"] then M.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(PriceScheduleSpecification_keys[k], "PriceScheduleSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PriceScheduleSpecification
-- <p>Describes the price for a Reserved Instance.</p>
-- @param Term [Long] <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>
-- @param Price [Double] <p>The fixed price for the term.</p>
function M.PriceScheduleSpecification(Term, CurrencyCode, Price, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PriceScheduleSpecification")
	local t = { 
		["Term"] = Term,
		["CurrencyCode"] = CurrencyCode,
		["Price"] = Price,
	}
	M.AssertPriceScheduleSpecification(t)
	return t
end

local UnassignIpv6AddressesResult_keys = { "NetworkInterfaceId" = true, "UnassignedIpv6Addresses" = true, nil }

function M.AssertUnassignIpv6AddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignIpv6AddressesResult to be of type 'table'")
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["UnassignedIpv6Addresses"] then M.AssertIpv6AddressList(struct["UnassignedIpv6Addresses"]) end
	for k,_ in pairs(struct) do
		assert(UnassignIpv6AddressesResult_keys[k], "UnassignIpv6AddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignIpv6AddressesResult
--  
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param UnassignedIpv6Addresses [Ipv6AddressList] <p>The IPv6 addresses that have been unassigned from the network interface.</p>
function M.UnassignIpv6AddressesResult(NetworkInterfaceId, UnassignedIpv6Addresses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnassignIpv6AddressesResult")
	local t = { 
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["UnassignedIpv6Addresses"] = UnassignedIpv6Addresses,
	}
	M.AssertUnassignIpv6AddressesResult(t)
	return t
end

local DescribeImageAttributeRequest_keys = { "Attribute" = true, "DryRun" = true, "ImageId" = true, nil }

function M.AssertDescribeImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImageAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["Attribute"] then M.AssertImageAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(DescribeImageAttributeRequest_keys[k], "DescribeImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImageAttributeRequest
-- <p>Contains the parameters for DescribeImageAttribute.</p>
-- @param Attribute [ImageAttributeName] <p>The AMI attribute.</p> <p> <b>Note</b>: Depending on your account privileges, the <code>blockDeviceMapping</code> attribute may return a <code>Client.AuthFailure</code> error. If this happens, use <a>DescribeImages</a> to get information about the block device mapping for the AMI.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param ImageId [String] <p>The ID of the AMI.</p>
-- Required parameter: Attribute
-- Required parameter: ImageId
function M.DescribeImageAttributeRequest(Attribute, DryRun, ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImageAttributeRequest")
	local t = { 
		["Attribute"] = Attribute,
		["DryRun"] = DryRun,
		["ImageId"] = ImageId,
	}
	M.AssertDescribeImageAttributeRequest(t)
	return t
end

local DescribeEgressOnlyInternetGatewaysResult_keys = { "NextToken" = true, "EgressOnlyInternetGateways" = true, nil }

function M.AssertDescribeEgressOnlyInternetGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEgressOnlyInternetGatewaysResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["EgressOnlyInternetGateways"] then M.AssertEgressOnlyInternetGatewayList(struct["EgressOnlyInternetGateways"]) end
	for k,_ in pairs(struct) do
		assert(DescribeEgressOnlyInternetGatewaysResult_keys[k], "DescribeEgressOnlyInternetGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEgressOnlyInternetGatewaysResult
--  
-- @param NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- @param EgressOnlyInternetGateways [EgressOnlyInternetGatewayList] <p>Information about the egress-only Internet gateways.</p>
function M.DescribeEgressOnlyInternetGatewaysResult(NextToken, EgressOnlyInternetGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeEgressOnlyInternetGatewaysResult")
	local t = { 
		["NextToken"] = NextToken,
		["EgressOnlyInternetGateways"] = EgressOnlyInternetGateways,
	}
	M.AssertDescribeEgressOnlyInternetGatewaysResult(t)
	return t
end

local InstanceNetworkInterfaceAttachment_keys = { "Status" = true, "DeviceIndex" = true, "DeleteOnTermination" = true, "AttachmentId" = true, "AttachTime" = true, nil }

function M.AssertInstanceNetworkInterfaceAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceAttachment to be of type 'table'")
	if struct["Status"] then M.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeviceIndex"] then M.AssertInteger(struct["DeviceIndex"]) end
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then M.AssertString(struct["AttachmentId"]) end
	if struct["AttachTime"] then M.AssertDateTime(struct["AttachTime"]) end
	for k,_ in pairs(struct) do
		assert(InstanceNetworkInterfaceAttachment_keys[k], "InstanceNetworkInterfaceAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceAttachment
-- <p>Describes a network interface attachment.</p>
-- @param Status [AttachmentStatus] <p>The attachment state.</p>
-- @param DeviceIndex [Integer] <p>The index of the device on the instance for the network interface attachment.</p>
-- @param DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- @param AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- @param AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
function M.InstanceNetworkInterfaceAttachment(Status, DeviceIndex, DeleteOnTermination, AttachmentId, AttachTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceNetworkInterfaceAttachment")
	local t = { 
		["Status"] = Status,
		["DeviceIndex"] = DeviceIndex,
		["DeleteOnTermination"] = DeleteOnTermination,
		["AttachmentId"] = AttachmentId,
		["AttachTime"] = AttachTime,
	}
	M.AssertInstanceNetworkInterfaceAttachment(t)
	return t
end

local DescribeSubnetsRequest_keys = { "SubnetIds" = true, "DryRun" = true, "Filters" = true, nil }

function M.AssertDescribeSubnetsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSubnetsRequest to be of type 'table'")
	if struct["SubnetIds"] then M.AssertSubnetIdStringList(struct["SubnetIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSubnetsRequest_keys[k], "DescribeSubnetsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSubnetsRequest
-- <p>Contains the parameters for DescribeSubnets.</p>
-- @param SubnetIds [SubnetIdStringList] <p>One or more subnet IDs.</p> <p>Default: Describes all your subnets.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availabilityZone</code> - The Availability Zone for the subnet. You can also use <code>availability-zone</code> as the filter name.</p> </li> <li> <p> <code>available-ip-address-count</code> - The number of IPv4 addresses in the subnet that are available.</p> </li> <li> <p> <code>cidrBlock</code> - The IPv4 CIDR block of the subnet. The CIDR block you specify must exactly match the subnet's CIDR block for information to be returned for the subnet. You can also use <code>cidr</code> or <code>cidr-block</code> as the filter names.</p> </li> <li> <p> <code>defaultForAz</code> - Indicates whether this is the default subnet for the Availability Zone. You can also use <code>default-for-az</code> as the filter name.</p> </li> <li> <p> <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>ipv6-cidr-block-association.association-id</code> - An association ID for an IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>state</code> - The state of the subnet (<code>pending</code> | <code>available</code>).</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the subnet.</p> </li> </ul>
function M.DescribeSubnetsRequest(SubnetIds, DryRun, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSubnetsRequest")
	local t = { 
		["SubnetIds"] = SubnetIds,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
	}
	M.AssertDescribeSubnetsRequest(t)
	return t
end

local CreateSubnetRequest_keys = { "VpcId" = true, "Ipv6CidrBlock" = true, "DryRun" = true, "AvailabilityZone" = true, "CidrBlock" = true, nil }

function M.AssertCreateSubnetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSubnetRequest to be of type 'table'")
	assert(struct["CidrBlock"], "Expected key CidrBlock to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["Ipv6CidrBlock"] then M.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["CidrBlock"] then M.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(CreateSubnetRequest_keys[k], "CreateSubnetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSubnetRequest
-- <p>Contains the parameters for CreateSubnet.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param Ipv6CidrBlock [String] <p>The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone for the subnet.</p> <p>Default: AWS selects one for you. If you create more than one subnet in your VPC, we may not necessarily select a different zone for each subnet.</p>
-- @param CidrBlock [String] <p>The IPv4 network range for the subnet, in CIDR notation. For example, <code>10.0.0.0/24</code>.</p>
-- Required parameter: CidrBlock
-- Required parameter: VpcId
function M.CreateSubnetRequest(VpcId, Ipv6CidrBlock, DryRun, AvailabilityZone, CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSubnetRequest")
	local t = { 
		["VpcId"] = VpcId,
		["Ipv6CidrBlock"] = Ipv6CidrBlock,
		["DryRun"] = DryRun,
		["AvailabilityZone"] = AvailabilityZone,
		["CidrBlock"] = CidrBlock,
	}
	M.AssertCreateSubnetRequest(t)
	return t
end

local ConfirmProductInstanceRequest_keys = { "InstanceId" = true, "ProductCode" = true, "DryRun" = true, nil }

function M.AssertConfirmProductInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConfirmProductInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["ProductCode"], "Expected key ProductCode to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["ProductCode"] then M.AssertString(struct["ProductCode"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(ConfirmProductInstanceRequest_keys[k], "ConfirmProductInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConfirmProductInstanceRequest
-- <p>Contains the parameters for ConfirmProductInstance.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param ProductCode [String] <p>The product code. This must be a product code that you own.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
-- Required parameter: ProductCode
function M.ConfirmProductInstanceRequest(InstanceId, ProductCode, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ConfirmProductInstanceRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["ProductCode"] = ProductCode,
		["DryRun"] = DryRun,
	}
	M.AssertConfirmProductInstanceRequest(t)
	return t
end

local ScheduledInstanceRecurrenceRequest_keys = { "OccurrenceDays" = true, "Interval" = true, "Frequency" = true, "OccurrenceRelativeToEnd" = true, "OccurrenceUnit" = true, nil }

function M.AssertScheduledInstanceRecurrenceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceRecurrenceRequest to be of type 'table'")
	if struct["OccurrenceDays"] then M.AssertOccurrenceDayRequestSet(struct["OccurrenceDays"]) end
	if struct["Interval"] then M.AssertInteger(struct["Interval"]) end
	if struct["Frequency"] then M.AssertString(struct["Frequency"]) end
	if struct["OccurrenceRelativeToEnd"] then M.AssertBoolean(struct["OccurrenceRelativeToEnd"]) end
	if struct["OccurrenceUnit"] then M.AssertString(struct["OccurrenceUnit"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstanceRecurrenceRequest_keys[k], "ScheduledInstanceRecurrenceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceRecurrenceRequest
-- <p>Describes the recurring schedule for a Scheduled Instance.</p>
-- @param OccurrenceDays [OccurrenceDayRequestSet] <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday). You can't specify this value with a daily schedule. If the occurrence is relative to the end of the month, you can specify only a single day.</p>
-- @param Interval [Integer] <p>The interval quantity. The interval unit depends on the value of <code>Frequency</code>. For example, every 2 weeks or every 2 months.</p>
-- @param Frequency [String] <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
-- @param OccurrenceRelativeToEnd [Boolean] <p>Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.</p>
-- @param OccurrenceUnit [String] <p>The unit for <code>OccurrenceDays</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>). This value is required for a monthly schedule. You can't specify <code>DayOfWeek</code> with a weekly schedule. You can't specify this value with a daily schedule.</p>
function M.ScheduledInstanceRecurrenceRequest(OccurrenceDays, Interval, Frequency, OccurrenceRelativeToEnd, OccurrenceUnit, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstanceRecurrenceRequest")
	local t = { 
		["OccurrenceDays"] = OccurrenceDays,
		["Interval"] = Interval,
		["Frequency"] = Frequency,
		["OccurrenceRelativeToEnd"] = OccurrenceRelativeToEnd,
		["OccurrenceUnit"] = OccurrenceUnit,
	}
	M.AssertScheduledInstanceRecurrenceRequest(t)
	return t
end

local DescribeStaleSecurityGroupsRequest_keys = { "VpcId" = true, "NextToken" = true, "DryRun" = true, "MaxResults" = true, nil }

function M.AssertDescribeStaleSecurityGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStaleSecurityGroupsRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["NextToken"] then M.AssertNextToken(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(DescribeStaleSecurityGroupsRequest_keys[k], "DescribeStaleSecurityGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStaleSecurityGroupsRequest
--  
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.</p>
-- @param MaxResults [MaxResults] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required parameter: VpcId
function M.DescribeStaleSecurityGroupsRequest(VpcId, NextToken, DryRun, MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeStaleSecurityGroupsRequest")
	local t = { 
		["VpcId"] = VpcId,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
	}
	M.AssertDescribeStaleSecurityGroupsRequest(t)
	return t
end

local ReservationValue_keys = { "RemainingUpfrontValue" = true, "HourlyPrice" = true, "RemainingTotalValue" = true, nil }

function M.AssertReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservationValue to be of type 'table'")
	if struct["RemainingUpfrontValue"] then M.AssertString(struct["RemainingUpfrontValue"]) end
	if struct["HourlyPrice"] then M.AssertString(struct["HourlyPrice"]) end
	if struct["RemainingTotalValue"] then M.AssertString(struct["RemainingTotalValue"]) end
	for k,_ in pairs(struct) do
		assert(ReservationValue_keys[k], "ReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservationValue
-- <p>The cost associated with the Reserved Instance.</p>
-- @param RemainingUpfrontValue [String] <p>The remaining upfront cost of the reservation.</p>
-- @param HourlyPrice [String] <p>The hourly rate of the reservation.</p>
-- @param RemainingTotalValue [String] <p>The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).</p>
function M.ReservationValue(RemainingUpfrontValue, HourlyPrice, RemainingTotalValue, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservationValue")
	local t = { 
		["RemainingUpfrontValue"] = RemainingUpfrontValue,
		["HourlyPrice"] = HourlyPrice,
		["RemainingTotalValue"] = RemainingTotalValue,
	}
	M.AssertReservationValue(t)
	return t
end

local AssociateVpcCidrBlockRequest_keys = { "VpcId" = true, "AmazonProvidedIpv6CidrBlock" = true, nil }

function M.AssertAssociateVpcCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateVpcCidrBlockRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["AmazonProvidedIpv6CidrBlock"] then M.AssertBoolean(struct["AmazonProvidedIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(AssociateVpcCidrBlockRequest_keys[k], "AssociateVpcCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateVpcCidrBlockRequest
--  
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param AmazonProvidedIpv6CidrBlock [Boolean] <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.</p>
-- Required parameter: VpcId
function M.AssociateVpcCidrBlockRequest(VpcId, AmazonProvidedIpv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateVpcCidrBlockRequest")
	local t = { 
		["VpcId"] = VpcId,
		["AmazonProvidedIpv6CidrBlock"] = AmazonProvidedIpv6CidrBlock,
	}
	M.AssertAssociateVpcCidrBlockRequest(t)
	return t
end

local ExportToS3Task_keys = { "S3Bucket" = true, "S3Key" = true, "DiskImageFormat" = true, "ContainerFormat" = true, nil }

function M.AssertExportToS3Task(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportToS3Task to be of type 'table'")
	if struct["S3Bucket"] then M.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then M.AssertString(struct["S3Key"]) end
	if struct["DiskImageFormat"] then M.AssertDiskImageFormat(struct["DiskImageFormat"]) end
	if struct["ContainerFormat"] then M.AssertContainerFormat(struct["ContainerFormat"]) end
	for k,_ in pairs(struct) do
		assert(ExportToS3Task_keys[k], "ExportToS3Task contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportToS3Task
-- <p>Describes the format and location for an instance export task.</p>
-- @param S3Bucket [String] <p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>
-- @param S3Key [String] <p>The encryption key for your S3 bucket.</p>
-- @param DiskImageFormat [DiskImageFormat] <p>The format for the exported image.</p>
-- @param ContainerFormat [ContainerFormat] <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>
function M.ExportToS3Task(S3Bucket, S3Key, DiskImageFormat, ContainerFormat, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ExportToS3Task")
	local t = { 
		["S3Bucket"] = S3Bucket,
		["S3Key"] = S3Key,
		["DiskImageFormat"] = DiskImageFormat,
		["ContainerFormat"] = ContainerFormat,
	}
	M.AssertExportToS3Task(t)
	return t
end

local AuthorizeSecurityGroupIngressRequest_keys = { "DryRun" = true, "GroupName" = true, "CidrIp" = true, "IpPermissions" = true, "FromPort" = true, "SourceSecurityGroupOwnerId" = true, "SourceSecurityGroupName" = true, "ToPort" = true, "IpProtocol" = true, "GroupId" = true, nil }

function M.AssertAuthorizeSecurityGroupIngressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizeSecurityGroupIngressRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["CidrIp"] then M.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then M.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then M.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then M.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then M.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then M.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then M.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(AuthorizeSecurityGroupIngressRequest_keys[k], "AuthorizeSecurityGroupIngressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizeSecurityGroupIngressRequest
-- <p>Contains the parameters for AuthorizeSecurityGroupIngress.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group.</p>
-- @param CidrIp [String] <p>The CIDR IPv4 address range. You can't specify this parameter when specifying a source security group.</p>
-- @param IpPermissions [IpPermissionList] <p>A set of IP permissions. Can be used to specify multiple rules in a single command.</p>
-- @param FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. For the ICMP/ICMPv6 type number, use <code>-1</code> to specify all types.</p>
-- @param SourceSecurityGroupOwnerId [String] <p>[EC2-Classic] The AWS account number for the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead.</p>
-- @param SourceSecurityGroupName [String] <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead. For EC2-VPC, the source security group must be in the same VPC.</p>
-- @param ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code number. For the ICMP/ICMPv6 code number, use <code>-1</code> to specify all codes.</p>
-- @param IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). (VPC only) Use <code>-1</code> to specify all protocols. If you specify <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>58</code> (ICMPv6), traffic on all ports is allowed, regardless of any ports you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For protocol <code>58</code> (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed.</p>
-- @param GroupId [String] <p>The ID of the security group. Required for a nondefault VPC.</p>
function M.AuthorizeSecurityGroupIngressRequest(DryRun, GroupName, CidrIp, IpPermissions, FromPort, SourceSecurityGroupOwnerId, SourceSecurityGroupName, ToPort, IpProtocol, GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AuthorizeSecurityGroupIngressRequest")
	local t = { 
		["DryRun"] = DryRun,
		["GroupName"] = GroupName,
		["CidrIp"] = CidrIp,
		["IpPermissions"] = IpPermissions,
		["FromPort"] = FromPort,
		["SourceSecurityGroupOwnerId"] = SourceSecurityGroupOwnerId,
		["SourceSecurityGroupName"] = SourceSecurityGroupName,
		["ToPort"] = ToPort,
		["IpProtocol"] = IpProtocol,
		["GroupId"] = GroupId,
	}
	M.AssertAuthorizeSecurityGroupIngressRequest(t)
	return t
end

local DescribeAccountAttributesRequest_keys = { "DryRun" = true, "AttributeNames" = true, nil }

function M.AssertDescribeAccountAttributesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAttributesRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["AttributeNames"] then M.AssertAccountAttributeNameStringList(struct["AttributeNames"]) end
	for k,_ in pairs(struct) do
		assert(DescribeAccountAttributesRequest_keys[k], "DescribeAccountAttributesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAttributesRequest
-- <p>Contains the parameters for DescribeAccountAttributes.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param AttributeNames [AccountAttributeNameStringList] <p>One or more account attribute names.</p>
function M.DescribeAccountAttributesRequest(DryRun, AttributeNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAccountAttributesRequest")
	local t = { 
		["DryRun"] = DryRun,
		["AttributeNames"] = AttributeNames,
	}
	M.AssertDescribeAccountAttributesRequest(t)
	return t
end

local VpcPeeringConnection_keys = { "Status" = true, "Tags" = true, "RequesterVpcInfo" = true, "VpcPeeringConnectionId" = true, "ExpirationTime" = true, "AccepterVpcInfo" = true, nil }

function M.AssertVpcPeeringConnection(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnection to be of type 'table'")
	if struct["Status"] then M.AssertVpcPeeringConnectionStateReason(struct["Status"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["RequesterVpcInfo"] then M.AssertVpcPeeringConnectionVpcInfo(struct["RequesterVpcInfo"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["ExpirationTime"] then M.AssertDateTime(struct["ExpirationTime"]) end
	if struct["AccepterVpcInfo"] then M.AssertVpcPeeringConnectionVpcInfo(struct["AccepterVpcInfo"]) end
	for k,_ in pairs(struct) do
		assert(VpcPeeringConnection_keys[k], "VpcPeeringConnection contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnection
-- <p>Describes a VPC peering connection.</p>
-- @param Status [VpcPeeringConnectionStateReason] <p>The status of the VPC peering connection.</p>
-- @param Tags [TagList] <p>Any tags assigned to the resource.</p>
-- @param RequesterVpcInfo [VpcPeeringConnectionVpcInfo] <p>Information about the requester VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- @param ExpirationTime [DateTime] <p>The time that an unaccepted VPC peering connection will expire.</p>
-- @param AccepterVpcInfo [VpcPeeringConnectionVpcInfo] <p>Information about the accepter VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
function M.VpcPeeringConnection(Status, Tags, RequesterVpcInfo, VpcPeeringConnectionId, ExpirationTime, AccepterVpcInfo, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcPeeringConnection")
	local t = { 
		["Status"] = Status,
		["Tags"] = Tags,
		["RequesterVpcInfo"] = RequesterVpcInfo,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
		["ExpirationTime"] = ExpirationTime,
		["AccepterVpcInfo"] = AccepterVpcInfo,
	}
	M.AssertVpcPeeringConnection(t)
	return t
end

local DescribeScheduledInstanceAvailabilityResult_keys = { "NextToken" = true, "ScheduledInstanceAvailabilitySet" = true, nil }

function M.AssertDescribeScheduledInstanceAvailabilityResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstanceAvailabilityResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["ScheduledInstanceAvailabilitySet"] then M.AssertScheduledInstanceAvailabilitySet(struct["ScheduledInstanceAvailabilitySet"]) end
	for k,_ in pairs(struct) do
		assert(DescribeScheduledInstanceAvailabilityResult_keys[k], "DescribeScheduledInstanceAvailabilityResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstanceAvailabilityResult
-- <p>Contains the output of DescribeScheduledInstanceAvailability.</p>
-- @param NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param ScheduledInstanceAvailabilitySet [ScheduledInstanceAvailabilitySet] <p>Information about the available Scheduled Instances.</p>
function M.DescribeScheduledInstanceAvailabilityResult(NextToken, ScheduledInstanceAvailabilitySet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeScheduledInstanceAvailabilityResult")
	local t = { 
		["NextToken"] = NextToken,
		["ScheduledInstanceAvailabilitySet"] = ScheduledInstanceAvailabilitySet,
	}
	M.AssertDescribeScheduledInstanceAvailabilityResult(t)
	return t
end

local DescribeIamInstanceProfileAssociationsRequest_keys = { "NextToken" = true, "MaxResults" = true, "Filters" = true, "AssociationIds" = true, nil }

function M.AssertDescribeIamInstanceProfileAssociationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIamInstanceProfileAssociationsRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then M.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["AssociationIds"] then M.AssertAssociationIdList(struct["AssociationIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeIamInstanceProfileAssociationsRequest_keys[k], "DescribeIamInstanceProfileAssociationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIamInstanceProfileAssociationsRequest
--  
-- @param NextToken [NextToken] <p>The token to request the next page of results.</p>
-- @param MaxResults [MaxResults] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>state</code> - The state of the association (<code>associating</code> | <code>associated</code> | <code>disassociating</code> | <code>disassociated</code>).</p> </li> </ul>
-- @param AssociationIds [AssociationIdList] <p>One or more IAM instance profile associations.</p>
function M.DescribeIamInstanceProfileAssociationsRequest(NextToken, MaxResults, Filters, AssociationIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIamInstanceProfileAssociationsRequest")
	local t = { 
		["NextToken"] = NextToken,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
		["AssociationIds"] = AssociationIds,
	}
	M.AssertDescribeIamInstanceProfileAssociationsRequest(t)
	return t
end

local ConversionTask_keys = { "ImportInstance" = true, "ImportVolume" = true, "Tags" = true, "ConversionTaskId" = true, "State" = true, "ExpirationTime" = true, "StatusMessage" = true, nil }

function M.AssertConversionTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConversionTask to be of type 'table'")
	assert(struct["ConversionTaskId"], "Expected key ConversionTaskId to exist in table")
	assert(struct["State"], "Expected key State to exist in table")
	if struct["ImportInstance"] then M.AssertImportInstanceTaskDetails(struct["ImportInstance"]) end
	if struct["ImportVolume"] then M.AssertImportVolumeTaskDetails(struct["ImportVolume"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["ConversionTaskId"] then M.AssertString(struct["ConversionTaskId"]) end
	if struct["State"] then M.AssertConversionTaskState(struct["State"]) end
	if struct["ExpirationTime"] then M.AssertString(struct["ExpirationTime"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(ConversionTask_keys[k], "ConversionTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConversionTask
-- <p>Describes a conversion task.</p>
-- @param ImportInstance [ImportInstanceTaskDetails] <p>If the task is for importing an instance, this contains information about the import instance task.</p>
-- @param ImportVolume [ImportVolumeTaskDetails] <p>If the task is for importing a volume, this contains information about the import volume task.</p>
-- @param Tags [TagList] <p>Any tags assigned to the task.</p>
-- @param ConversionTaskId [String] <p>The ID of the conversion task.</p>
-- @param State [ConversionTaskState] <p>The state of the conversion task.</p>
-- @param ExpirationTime [String] <p>The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel the task.</p>
-- @param StatusMessage [String] <p>The status message related to the conversion task.</p>
-- Required parameter: ConversionTaskId
-- Required parameter: State
function M.ConversionTask(ImportInstance, ImportVolume, Tags, ConversionTaskId, State, ExpirationTime, StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ConversionTask")
	local t = { 
		["ImportInstance"] = ImportInstance,
		["ImportVolume"] = ImportVolume,
		["Tags"] = Tags,
		["ConversionTaskId"] = ConversionTaskId,
		["State"] = State,
		["ExpirationTime"] = ExpirationTime,
		["StatusMessage"] = StatusMessage,
	}
	M.AssertConversionTask(t)
	return t
end

local CreateVpcEndpointResult_keys = { "VpcEndpoint" = true, "ClientToken" = true, nil }

function M.AssertCreateVpcEndpointResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointResult to be of type 'table'")
	if struct["VpcEndpoint"] then M.AssertVpcEndpoint(struct["VpcEndpoint"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpcEndpointResult_keys[k], "CreateVpcEndpointResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointResult
-- <p>Contains the output of CreateVpcEndpoint.</p>
-- @param VpcEndpoint [VpcEndpoint] <p>Information about the endpoint.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
function M.CreateVpcEndpointResult(VpcEndpoint, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcEndpointResult")
	local t = { 
		["VpcEndpoint"] = VpcEndpoint,
		["ClientToken"] = ClientToken,
	}
	M.AssertCreateVpcEndpointResult(t)
	return t
end

local DescribeSpotPriceHistoryResult_keys = { "NextToken" = true, "SpotPriceHistory" = true, nil }

function M.AssertDescribeSpotPriceHistoryResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotPriceHistoryResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["SpotPriceHistory"] then M.AssertSpotPriceHistoryList(struct["SpotPriceHistory"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotPriceHistoryResult_keys[k], "DescribeSpotPriceHistoryResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotPriceHistoryResult
-- <p>Contains the output of DescribeSpotPriceHistory.</p>
-- @param NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param SpotPriceHistory [SpotPriceHistoryList] <p>The historical Spot prices.</p>
function M.DescribeSpotPriceHistoryResult(NextToken, SpotPriceHistory, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotPriceHistoryResult")
	local t = { 
		["NextToken"] = NextToken,
		["SpotPriceHistory"] = SpotPriceHistory,
	}
	M.AssertDescribeSpotPriceHistoryResult(t)
	return t
end

local DescribeScheduledInstanceAvailabilityRequest_keys = { "DryRun" = true, "Filters" = true, "MinSlotDurationInHours" = true, "MaxResults" = true, "FirstSlotStartTimeRange" = true, "Recurrence" = true, "MaxSlotDurationInHours" = true, "NextToken" = true, nil }

function M.AssertDescribeScheduledInstanceAvailabilityRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstanceAvailabilityRequest to be of type 'table'")
	assert(struct["FirstSlotStartTimeRange"], "Expected key FirstSlotStartTimeRange to exist in table")
	assert(struct["Recurrence"], "Expected key Recurrence to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["MinSlotDurationInHours"] then M.AssertInteger(struct["MinSlotDurationInHours"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["FirstSlotStartTimeRange"] then M.AssertSlotDateTimeRangeRequest(struct["FirstSlotStartTimeRange"]) end
	if struct["Recurrence"] then M.AssertScheduledInstanceRecurrenceRequest(struct["Recurrence"]) end
	if struct["MaxSlotDurationInHours"] then M.AssertInteger(struct["MaxSlotDurationInHours"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeScheduledInstanceAvailabilityRequest_keys[k], "DescribeScheduledInstanceAvailabilityRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstanceAvailabilityRequest
-- <p>Contains the parameters for DescribeScheduledInstanceAvailability.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p> </li> <li> <p> <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p> </li> <li> <p> <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p> </li> <li> <p> <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p> </li> </ul>
-- @param MinSlotDurationInHours [Integer] <p>The minimum available duration, in hours. The minimum required duration is 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 300. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param FirstSlotStartTimeRange [SlotDateTimeRangeRequest] <p>The time period for the first schedule to start.</p>
-- @param Recurrence [ScheduledInstanceRecurrenceRequest] <p>The schedule recurrence.</p>
-- @param MaxSlotDurationInHours [Integer] <p>The maximum available duration, in hours. This value must be greater than <code>MinSlotDurationInHours</code> and less than 1,720.</p>
-- @param NextToken [String] <p>The token for the next set of results.</p>
-- Required parameter: FirstSlotStartTimeRange
-- Required parameter: Recurrence
function M.DescribeScheduledInstanceAvailabilityRequest(DryRun, Filters, MinSlotDurationInHours, MaxResults, FirstSlotStartTimeRange, Recurrence, MaxSlotDurationInHours, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeScheduledInstanceAvailabilityRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Filters"] = Filters,
		["MinSlotDurationInHours"] = MinSlotDurationInHours,
		["MaxResults"] = MaxResults,
		["FirstSlotStartTimeRange"] = FirstSlotStartTimeRange,
		["Recurrence"] = Recurrence,
		["MaxSlotDurationInHours"] = MaxSlotDurationInHours,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeScheduledInstanceAvailabilityRequest(t)
	return t
end

local DescribeNatGatewaysResult_keys = { "NextToken" = true, "NatGateways" = true, nil }

function M.AssertDescribeNatGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNatGatewaysResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["NatGateways"] then M.AssertNatGatewayList(struct["NatGateways"]) end
	for k,_ in pairs(struct) do
		assert(DescribeNatGatewaysResult_keys[k], "DescribeNatGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNatGatewaysResult
-- <p>Contains the output of DescribeNatGateways.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param NatGateways [NatGatewayList] <p>Information about the NAT gateways.</p>
function M.DescribeNatGatewaysResult(NextToken, NatGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNatGatewaysResult")
	local t = { 
		["NextToken"] = NextToken,
		["NatGateways"] = NatGateways,
	}
	M.AssertDescribeNatGatewaysResult(t)
	return t
end

local ReplaceIamInstanceProfileAssociationResult_keys = { "IamInstanceProfileAssociation" = true, nil }

function M.AssertReplaceIamInstanceProfileAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceIamInstanceProfileAssociationResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then M.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(ReplaceIamInstanceProfileAssociationResult_keys[k], "ReplaceIamInstanceProfileAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceIamInstanceProfileAssociationResult
--  
-- @param IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
function M.ReplaceIamInstanceProfileAssociationResult(IamInstanceProfileAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceIamInstanceProfileAssociationResult")
	local t = { 
		["IamInstanceProfileAssociation"] = IamInstanceProfileAssociation,
	}
	M.AssertReplaceIamInstanceProfileAssociationResult(t)
	return t
end

local ProvisionedBandwidth_keys = { "Status" = true, "Provisioned" = true, "RequestTime" = true, "Requested" = true, "ProvisionTime" = true, nil }

function M.AssertProvisionedBandwidth(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProvisionedBandwidth to be of type 'table'")
	if struct["Status"] then M.AssertString(struct["Status"]) end
	if struct["Provisioned"] then M.AssertString(struct["Provisioned"]) end
	if struct["RequestTime"] then M.AssertDateTime(struct["RequestTime"]) end
	if struct["Requested"] then M.AssertString(struct["Requested"]) end
	if struct["ProvisionTime"] then M.AssertDateTime(struct["ProvisionTime"]) end
	for k,_ in pairs(struct) do
		assert(ProvisionedBandwidth_keys[k], "ProvisionedBandwidth contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProvisionedBandwidth
-- <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param Status [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param Provisioned [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param RequestTime [DateTime] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param Requested [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param ProvisionTime [DateTime] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
function M.ProvisionedBandwidth(Status, Provisioned, RequestTime, Requested, ProvisionTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ProvisionedBandwidth")
	local t = { 
		["Status"] = Status,
		["Provisioned"] = Provisioned,
		["RequestTime"] = RequestTime,
		["Requested"] = Requested,
		["ProvisionTime"] = ProvisionTime,
	}
	M.AssertProvisionedBandwidth(t)
	return t
end

local DescribePlacementGroupsResult_keys = { "PlacementGroups" = true, nil }

function M.AssertDescribePlacementGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePlacementGroupsResult to be of type 'table'")
	if struct["PlacementGroups"] then M.AssertPlacementGroupList(struct["PlacementGroups"]) end
	for k,_ in pairs(struct) do
		assert(DescribePlacementGroupsResult_keys[k], "DescribePlacementGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePlacementGroupsResult
-- <p>Contains the output of DescribePlacementGroups.</p>
-- @param PlacementGroups [PlacementGroupList] <p>One or more placement groups.</p>
function M.DescribePlacementGroupsResult(PlacementGroups, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribePlacementGroupsResult")
	local t = { 
		["PlacementGroups"] = PlacementGroups,
	}
	M.AssertDescribePlacementGroupsResult(t)
	return t
end

local UnmonitorInstancesRequest_keys = { "DryRun" = true, "InstanceIds" = true, nil }

function M.AssertUnmonitorInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnmonitorInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then M.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(UnmonitorInstancesRequest_keys[k], "UnmonitorInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnmonitorInstancesRequest
-- <p>Contains the parameters for UnmonitorInstances.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.UnmonitorInstancesRequest(DryRun, InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnmonitorInstancesRequest")
	local t = { 
		["DryRun"] = DryRun,
		["InstanceIds"] = InstanceIds,
	}
	M.AssertUnmonitorInstancesRequest(t)
	return t
end

local BundleInstanceResult_keys = { "BundleTask" = true, nil }

function M.AssertBundleInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleInstanceResult to be of type 'table'")
	if struct["BundleTask"] then M.AssertBundleTask(struct["BundleTask"]) end
	for k,_ in pairs(struct) do
		assert(BundleInstanceResult_keys[k], "BundleInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleInstanceResult
-- <p>Contains the output of BundleInstance.</p>
-- @param BundleTask [BundleTask] <p>Information about the bundle task.</p>
function M.BundleInstanceResult(BundleTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BundleInstanceResult")
	local t = { 
		["BundleTask"] = BundleTask,
	}
	M.AssertBundleInstanceResult(t)
	return t
end

local AccountAttributeValue_keys = { "AttributeValue" = true, nil }

function M.AssertAccountAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AccountAttributeValue to be of type 'table'")
	if struct["AttributeValue"] then M.AssertString(struct["AttributeValue"]) end
	for k,_ in pairs(struct) do
		assert(AccountAttributeValue_keys[k], "AccountAttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AccountAttributeValue
-- <p>Describes a value of an account attribute.</p>
-- @param AttributeValue [String] <p>The value of the attribute.</p>
function M.AccountAttributeValue(AttributeValue, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AccountAttributeValue")
	local t = { 
		["AttributeValue"] = AttributeValue,
	}
	M.AssertAccountAttributeValue(t)
	return t
end

local DescribeHostReservationsRequest_keys = { "Filter" = true, "HostReservationIdSet" = true, "NextToken" = true, "MaxResults" = true, nil }

function M.AssertDescribeHostReservationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationsRequest to be of type 'table'")
	if struct["Filter"] then M.AssertFilterList(struct["Filter"]) end
	if struct["HostReservationIdSet"] then M.AssertHostReservationIdSet(struct["HostReservationIdSet"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(DescribeHostReservationsRequest_keys[k], "DescribeHostReservationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationsRequest
--  
-- @param Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-family</code> - The instance family (e.g., <code>m4</code>).</p> </li> <li> <p> <code>payment-option</code> - The payment option (<code>NoUpfront</code> | <code>PartialUpfront</code> | <code>AllUpfront</code>).</p> </li> <li> <p> <code>state</code> - The state of the reservation (<code>payment-pending</code> | <code>payment-failed</code> | <code>active</code> | <code>retired</code>).</p> </li> </ul>
-- @param HostReservationIdSet [HostReservationIdSet] <p>One or more host reservation IDs.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500; if <code>maxResults</code> is given a larger value than 500, you will receive an error.</p>
function M.DescribeHostReservationsRequest(Filter, HostReservationIdSet, NextToken, MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostReservationsRequest")
	local t = { 
		["Filter"] = Filter,
		["HostReservationIdSet"] = HostReservationIdSet,
		["NextToken"] = NextToken,
		["MaxResults"] = MaxResults,
	}
	M.AssertDescribeHostReservationsRequest(t)
	return t
end

local DescribeScheduledInstancesRequest_keys = { "ScheduledInstanceIds" = true, "DryRun" = true, "MaxResults" = true, "SlotStartTimeRange" = true, "Filters" = true, "NextToken" = true, nil }

function M.AssertDescribeScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstancesRequest to be of type 'table'")
	if struct["ScheduledInstanceIds"] then M.AssertScheduledInstanceIdRequestSet(struct["ScheduledInstanceIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["SlotStartTimeRange"] then M.AssertSlotStartTimeRangeRequest(struct["SlotStartTimeRange"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeScheduledInstancesRequest_keys[k], "DescribeScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstancesRequest
-- <p>Contains the parameters for DescribeScheduledInstances.</p>
-- @param ScheduledInstanceIds [ScheduledInstanceIdRequestSet] <p>One or more Scheduled Instance IDs.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 100. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param SlotStartTimeRange [SlotStartTimeRangeRequest] <p>The time period for the first schedule to start.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p> </li> <li> <p> <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p> </li> <li> <p> <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p> </li> <li> <p> <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p> </li> </ul>
-- @param NextToken [String] <p>The token for the next set of results.</p>
function M.DescribeScheduledInstancesRequest(ScheduledInstanceIds, DryRun, MaxResults, SlotStartTimeRange, Filters, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeScheduledInstancesRequest")
	local t = { 
		["ScheduledInstanceIds"] = ScheduledInstanceIds,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
		["SlotStartTimeRange"] = SlotStartTimeRange,
		["Filters"] = Filters,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeScheduledInstancesRequest(t)
	return t
end

local GetConsoleScreenshotRequest_keys = { "InstanceId" = true, "WakeUp" = true, "DryRun" = true, nil }

function M.AssertGetConsoleScreenshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleScreenshotRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["WakeUp"] then M.AssertBoolean(struct["WakeUp"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(GetConsoleScreenshotRequest_keys[k], "GetConsoleScreenshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleScreenshotRequest
-- <p>Contains the parameters for the request.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param WakeUp [Boolean] <p>When set to <code>true</code>, acts as keystroke input and wakes up an instance that's in standby or "sleep" mode.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
function M.GetConsoleScreenshotRequest(InstanceId, WakeUp, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetConsoleScreenshotRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["WakeUp"] = WakeUp,
		["DryRun"] = DryRun,
	}
	M.AssertGetConsoleScreenshotRequest(t)
	return t
end

local NetworkAclAssociation_keys = { "SubnetId" = true, "NetworkAclId" = true, "NetworkAclAssociationId" = true, nil }

function M.AssertNetworkAclAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAclAssociation to be of type 'table'")
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["NetworkAclId"] then M.AssertString(struct["NetworkAclId"]) end
	if struct["NetworkAclAssociationId"] then M.AssertString(struct["NetworkAclAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(NetworkAclAssociation_keys[k], "NetworkAclAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAclAssociation
-- <p>Describes an association between a network ACL and a subnet.</p>
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param NetworkAclAssociationId [String] <p>The ID of the association between a network ACL and a subnet.</p>
function M.NetworkAclAssociation(SubnetId, NetworkAclId, NetworkAclAssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkAclAssociation")
	local t = { 
		["SubnetId"] = SubnetId,
		["NetworkAclId"] = NetworkAclId,
		["NetworkAclAssociationId"] = NetworkAclAssociationId,
	}
	M.AssertNetworkAclAssociation(t)
	return t
end

local DescribeExportTasksResult_keys = { "ExportTasks" = true, nil }

function M.AssertDescribeExportTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeExportTasksResult to be of type 'table'")
	if struct["ExportTasks"] then M.AssertExportTaskList(struct["ExportTasks"]) end
	for k,_ in pairs(struct) do
		assert(DescribeExportTasksResult_keys[k], "DescribeExportTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeExportTasksResult
-- <p>Contains the output for DescribeExportTasks.</p>
-- @param ExportTasks [ExportTaskList] <p>Information about the export tasks.</p>
function M.DescribeExportTasksResult(ExportTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeExportTasksResult")
	local t = { 
		["ExportTasks"] = ExportTasks,
	}
	M.AssertDescribeExportTasksResult(t)
	return t
end

local CancelSpotFleetRequestsRequest_keys = { "SpotFleetRequestIds" = true, "DryRun" = true, "TerminateInstances" = true, nil }

function M.AssertCancelSpotFleetRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsRequest to be of type 'table'")
	assert(struct["SpotFleetRequestIds"], "Expected key SpotFleetRequestIds to exist in table")
	assert(struct["TerminateInstances"], "Expected key TerminateInstances to exist in table")
	if struct["SpotFleetRequestIds"] then M.AssertValueStringList(struct["SpotFleetRequestIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["TerminateInstances"] then M.AssertBoolean(struct["TerminateInstances"]) end
	for k,_ in pairs(struct) do
		assert(CancelSpotFleetRequestsRequest_keys[k], "CancelSpotFleetRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsRequest
-- <p>Contains the parameters for CancelSpotFleetRequests.</p>
-- @param SpotFleetRequestIds [ValueStringList] <p>The IDs of the Spot fleet requests.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param TerminateInstances [Boolean] <p>Indicates whether to terminate instances for a Spot fleet request if it is canceled successfully.</p>
-- Required parameter: SpotFleetRequestIds
-- Required parameter: TerminateInstances
function M.CancelSpotFleetRequestsRequest(SpotFleetRequestIds, DryRun, TerminateInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsRequest")
	local t = { 
		["SpotFleetRequestIds"] = SpotFleetRequestIds,
		["DryRun"] = DryRun,
		["TerminateInstances"] = TerminateInstances,
	}
	M.AssertCancelSpotFleetRequestsRequest(t)
	return t
end

local DiskImage_keys = { "Volume" = true, "Image" = true, "Description" = true, nil }

function M.AssertDiskImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImage to be of type 'table'")
	if struct["Volume"] then M.AssertVolumeDetail(struct["Volume"]) end
	if struct["Image"] then M.AssertDiskImageDetail(struct["Image"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(DiskImage_keys[k], "DiskImage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImage
-- <p>Describes a disk image.</p>
-- @param Volume [VolumeDetail] <p>Information about the volume.</p>
-- @param Image [DiskImageDetail] <p>Information about the disk image.</p>
-- @param Description [String] <p>A description of the disk image.</p>
function M.DiskImage(Volume, Image, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DiskImage")
	local t = { 
		["Volume"] = Volume,
		["Image"] = Image,
		["Description"] = Description,
	}
	M.AssertDiskImage(t)
	return t
end

local AttachInternetGatewayRequest_keys = { "VpcId" = true, "DryRun" = true, "InternetGatewayId" = true, nil }

function M.AssertAttachInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then M.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(AttachInternetGatewayRequest_keys[k], "AttachInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachInternetGatewayRequest
-- <p>Contains the parameters for AttachInternetGateway.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- Required parameter: InternetGatewayId
-- Required parameter: VpcId
function M.AttachInternetGatewayRequest(VpcId, DryRun, InternetGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachInternetGatewayRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
		["InternetGatewayId"] = InternetGatewayId,
	}
	M.AssertAttachInternetGatewayRequest(t)
	return t
end

local AttachClassicLinkVpcRequest_keys = { "InstanceId" = true, "VpcId" = true, "DryRun" = true, "Groups" = true, nil }

function M.AssertAttachClassicLinkVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachClassicLinkVpcRequest to be of type 'table'")
	assert(struct["Groups"], "Expected key Groups to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Groups"] then M.AssertGroupIdStringList(struct["Groups"]) end
	for k,_ in pairs(struct) do
		assert(AttachClassicLinkVpcRequest_keys[k], "AttachClassicLinkVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachClassicLinkVpcRequest
-- <p>Contains the parameters for AttachClassicLinkVpc.</p>
-- @param InstanceId [String] <p>The ID of an EC2-Classic instance to link to the ClassicLink-enabled VPC.</p>
-- @param VpcId [String] <p>The ID of a ClassicLink-enabled VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Groups [GroupIdStringList] <p>The ID of one or more of the VPC's security groups. You cannot specify security groups from a different VPC.</p>
-- Required parameter: Groups
-- Required parameter: InstanceId
-- Required parameter: VpcId
function M.AttachClassicLinkVpcRequest(InstanceId, VpcId, DryRun, Groups, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachClassicLinkVpcRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
		["Groups"] = Groups,
	}
	M.AssertAttachClassicLinkVpcRequest(t)
	return t
end

local Storage_keys = { "S3" = true, nil }

function M.AssertStorage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Storage to be of type 'table'")
	if struct["S3"] then M.AssertS3Storage(struct["S3"]) end
	for k,_ in pairs(struct) do
		assert(Storage_keys[k], "Storage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Storage
-- <p>Describes the storage location for an instance store-backed AMI.</p>
-- @param S3 [S3Storage] <p>An Amazon S3 storage location.</p>
function M.Storage(S3, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Storage")
	local t = { 
		["S3"] = S3,
	}
	M.AssertStorage(t)
	return t
end

local DescribeMovingAddressesRequest_keys = { "PublicIps" = true, "NextToken" = true, "DryRun" = true, "MaxResults" = true, "Filters" = true, nil }

function M.AssertDescribeMovingAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMovingAddressesRequest to be of type 'table'")
	if struct["PublicIps"] then M.AssertValueStringList(struct["PublicIps"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeMovingAddressesRequest_keys[k], "DescribeMovingAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMovingAddressesRequest
-- <p>Contains the parameters for DescribeMovingAddresses.</p>
-- @param PublicIps [ValueStringList] <p>One or more Elastic IP addresses.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value outside of this range, an error is returned.</p> <p>Default: If no value is provided, the default is 1000.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>moving-status</code> - The status of the Elastic IP address (<code>MovingToVpc</code> | <code>RestoringToClassic</code>).</p> </li> </ul>
function M.DescribeMovingAddressesRequest(PublicIps, NextToken, DryRun, MaxResults, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeMovingAddressesRequest")
	local t = { 
		["PublicIps"] = PublicIps,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
	}
	M.AssertDescribeMovingAddressesRequest(t)
	return t
end

local CopySnapshotRequest_keys = { "DryRun" = true, "Description" = true, "Encrypted" = true, "PresignedUrl" = true, "SourceRegion" = true, "KmsKeyId" = true, "SourceSnapshotId" = true, "DestinationRegion" = true, nil }

function M.AssertCopySnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopySnapshotRequest to be of type 'table'")
	assert(struct["SourceRegion"], "Expected key SourceRegion to exist in table")
	assert(struct["SourceSnapshotId"], "Expected key SourceSnapshotId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Encrypted"] then M.AssertBoolean(struct["Encrypted"]) end
	if struct["PresignedUrl"] then M.AssertString(struct["PresignedUrl"]) end
	if struct["SourceRegion"] then M.AssertString(struct["SourceRegion"]) end
	if struct["KmsKeyId"] then M.AssertString(struct["KmsKeyId"]) end
	if struct["SourceSnapshotId"] then M.AssertString(struct["SourceSnapshotId"]) end
	if struct["DestinationRegion"] then M.AssertString(struct["DestinationRegion"]) end
	for k,_ in pairs(struct) do
		assert(CopySnapshotRequest_keys[k], "CopySnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopySnapshotRequest
-- <p>Contains the parameters for CopySnapshot.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>A description for the EBS snapshot.</p>
-- @param Encrypted [Boolean] <p>Specifies whether the destination snapshot should be encrypted. You can encrypt a copy of an unencrypted snapshot using this flag, but you cannot use it to create an unencrypted copy from an encrypted snapshot. Your default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with <code>KmsKeyId</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param PresignedUrl [String] <p>The pre-signed URL that facilitates copying an encrypted snapshot. This parameter is only required when copying an encrypted snapshot with the Amazon EC2 Query API; it is available as an optional parameter in all other cases. The <code>PresignedUrl</code> should use the snapshot source endpoint, the <code>CopySnapshot</code> action, and include the <code>SourceRegion</code>, <code>SourceSnapshotId</code>, and <code>DestinationRegion</code> parameters. The <code>PresignedUrl</code> must be signed using AWS Signature Version 4. Because EBS snapshots are stored in Amazon S3, the signing algorithm for this parameter uses the same logic that is described in <a href="http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">Authenticating Requests by Using Query Parameters (AWS Signature Version 4)</a> in the <i>Amazon Simple Storage Service API Reference</i>. An invalid or improperly signed <code>PresignedUrl</code> will cause the copy operation to fail asynchronously, and the snapshot will move to an <code>error</code> state.</p>
-- @param SourceRegion [String] <p>The ID of the region that contains the snapshot to be copied.</p>
-- @param KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when creating the snapshot copy. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. The specified CMK must exist in the region that the snapshot is being copied to. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set.</p>
-- @param SourceSnapshotId [String] <p>The ID of the EBS snapshot to copy.</p>
-- @param DestinationRegion [String] <p>The destination region to use in the <code>PresignedUrl</code> parameter of a snapshot copy operation. This parameter is only valid for specifying the destination region in a <code>PresignedUrl</code> parameter, where it is required.</p> <note> <p> <code>CopySnapshot</code> sends the snapshot copy to the regional endpoint that you send the HTTP request to, such as <code>ec2.us-east-1.amazonaws.com</code> (in the AWS CLI, this is specified with the <code>--region</code> parameter or the default region in your AWS configuration file).</p> </note>
-- Required parameter: SourceRegion
-- Required parameter: SourceSnapshotId
function M.CopySnapshotRequest(DryRun, Description, Encrypted, PresignedUrl, SourceRegion, KmsKeyId, SourceSnapshotId, DestinationRegion, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CopySnapshotRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Description"] = Description,
		["Encrypted"] = Encrypted,
		["PresignedUrl"] = PresignedUrl,
		["SourceRegion"] = SourceRegion,
		["KmsKeyId"] = KmsKeyId,
		["SourceSnapshotId"] = SourceSnapshotId,
		["DestinationRegion"] = DestinationRegion,
	}
	M.AssertCopySnapshotRequest(t)
	return t
end

local ModifyVpcPeeringConnectionOptionsRequest_keys = { "DryRun" = true, "RequesterPeeringConnectionOptions" = true, "VpcPeeringConnectionId" = true, "AccepterPeeringConnectionOptions" = true, nil }

function M.AssertModifyVpcPeeringConnectionOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcPeeringConnectionOptionsRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["RequesterPeeringConnectionOptions"] then M.AssertPeeringConnectionOptionsRequest(struct["RequesterPeeringConnectionOptions"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["AccepterPeeringConnectionOptions"] then M.AssertPeeringConnectionOptionsRequest(struct["AccepterPeeringConnectionOptions"]) end
	for k,_ in pairs(struct) do
		assert(ModifyVpcPeeringConnectionOptionsRequest_keys[k], "ModifyVpcPeeringConnectionOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcPeeringConnectionOptionsRequest
--  
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param RequesterPeeringConnectionOptions [PeeringConnectionOptionsRequest] <p>The VPC peering connection options for the requester VPC.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- @param AccepterPeeringConnectionOptions [PeeringConnectionOptionsRequest] <p>The VPC peering connection options for the accepter VPC.</p>
-- Required parameter: VpcPeeringConnectionId
function M.ModifyVpcPeeringConnectionOptionsRequest(DryRun, RequesterPeeringConnectionOptions, VpcPeeringConnectionId, AccepterPeeringConnectionOptions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcPeeringConnectionOptionsRequest")
	local t = { 
		["DryRun"] = DryRun,
		["RequesterPeeringConnectionOptions"] = RequesterPeeringConnectionOptions,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
		["AccepterPeeringConnectionOptions"] = AccepterPeeringConnectionOptions,
	}
	M.AssertModifyVpcPeeringConnectionOptionsRequest(t)
	return t
end

local RequestSpotInstancesResult_keys = { "SpotInstanceRequests" = true, nil }

function M.AssertRequestSpotInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotInstancesResult to be of type 'table'")
	if struct["SpotInstanceRequests"] then M.AssertSpotInstanceRequestList(struct["SpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(RequestSpotInstancesResult_keys[k], "RequestSpotInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotInstancesResult
-- <p>Contains the output of RequestSpotInstances.</p>
-- @param SpotInstanceRequests [SpotInstanceRequestList] <p>One or more Spot instance requests.</p>
function M.RequestSpotInstancesResult(SpotInstanceRequests, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotInstancesResult")
	local t = { 
		["SpotInstanceRequests"] = SpotInstanceRequests,
	}
	M.AssertRequestSpotInstancesResult(t)
	return t
end

local DeleteVpnGatewayRequest_keys = { "DryRun" = true, "VpnGatewayId" = true, nil }

function M.AssertDeleteVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnGatewayRequest to be of type 'table'")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then M.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(DeleteVpnGatewayRequest_keys[k], "DeleteVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnGatewayRequest
-- <p>Contains the parameters for DeleteVpnGateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required parameter: VpnGatewayId
function M.DeleteVpnGatewayRequest(DryRun, VpnGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpnGatewayRequest")
	local t = { 
		["DryRun"] = DryRun,
		["VpnGatewayId"] = VpnGatewayId,
	}
	M.AssertDeleteVpnGatewayRequest(t)
	return t
end

local InstanceAttribute_keys = { "ProductCodes" = true, "SourceDestCheck" = true, "UserData" = true, "InstanceId" = true, "EnaSupport" = true, "SriovNetSupport" = true, "InstanceInitiatedShutdownBehavior" = true, "BlockDeviceMappings" = true, "EbsOptimized" = true, "Groups" = true, "KernelId" = true, "RamdiskId" = true, "RootDeviceName" = true, "DisableApiTermination" = true, "InstanceType" = true, nil }

function M.AssertInstanceAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceAttribute to be of type 'table'")
	if struct["ProductCodes"] then M.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["SourceDestCheck"] then M.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["UserData"] then M.AssertAttributeValue(struct["UserData"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["EnaSupport"] then M.AssertAttributeBooleanValue(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then M.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then M.AssertAttributeValue(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["BlockDeviceMappings"] then M.AssertInstanceBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then M.AssertAttributeBooleanValue(struct["EbsOptimized"]) end
	if struct["Groups"] then M.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["KernelId"] then M.AssertAttributeValue(struct["KernelId"]) end
	if struct["RamdiskId"] then M.AssertAttributeValue(struct["RamdiskId"]) end
	if struct["RootDeviceName"] then M.AssertAttributeValue(struct["RootDeviceName"]) end
	if struct["DisableApiTermination"] then M.AssertAttributeBooleanValue(struct["DisableApiTermination"]) end
	if struct["InstanceType"] then M.AssertAttributeValue(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(InstanceAttribute_keys[k], "InstanceAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceAttribute
-- <p>Describes an instance attribute.</p>
-- @param ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- @param SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT.</p>
-- @param UserData [AttributeValue] <p>The user data.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param EnaSupport [AttributeBooleanValue] <p>Indicates whether enhanced networking with ENA is enabled.</p>
-- @param SriovNetSupport [AttributeValue] <p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- @param InstanceInitiatedShutdownBehavior [AttributeValue] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- @param BlockDeviceMappings [InstanceBlockDeviceMappingList] <p>The block device mapping of the instance.</p>
-- @param EbsOptimized [AttributeBooleanValue] <p>Indicates whether the instance is optimized for EBS I/O.</p>
-- @param Groups [GroupIdentifierList] <p>The security groups associated with the instance.</p>
-- @param KernelId [AttributeValue] <p>The kernel ID.</p>
-- @param RamdiskId [AttributeValue] <p>The RAM disk ID.</p>
-- @param RootDeviceName [AttributeValue] <p>The name of the root device (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p>
-- @param DisableApiTermination [AttributeBooleanValue] <p>If the value is <code>true</code>, you can't terminate the instance through the Amazon EC2 console, CLI, or API; otherwise, you can.</p>
-- @param InstanceType [AttributeValue] <p>The instance type.</p>
function M.InstanceAttribute(ProductCodes, SourceDestCheck, UserData, InstanceId, EnaSupport, SriovNetSupport, InstanceInitiatedShutdownBehavior, BlockDeviceMappings, EbsOptimized, Groups, KernelId, RamdiskId, RootDeviceName, DisableApiTermination, InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceAttribute")
	local t = { 
		["ProductCodes"] = ProductCodes,
		["SourceDestCheck"] = SourceDestCheck,
		["UserData"] = UserData,
		["InstanceId"] = InstanceId,
		["EnaSupport"] = EnaSupport,
		["SriovNetSupport"] = SriovNetSupport,
		["InstanceInitiatedShutdownBehavior"] = InstanceInitiatedShutdownBehavior,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["EbsOptimized"] = EbsOptimized,
		["Groups"] = Groups,
		["KernelId"] = KernelId,
		["RamdiskId"] = RamdiskId,
		["RootDeviceName"] = RootDeviceName,
		["DisableApiTermination"] = DisableApiTermination,
		["InstanceType"] = InstanceType,
	}
	M.AssertInstanceAttribute(t)
	return t
end

local DeleteEgressOnlyInternetGatewayResult_keys = { "ReturnCode" = true, nil }

function M.AssertDeleteEgressOnlyInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteEgressOnlyInternetGatewayResult to be of type 'table'")
	if struct["ReturnCode"] then M.AssertBoolean(struct["ReturnCode"]) end
	for k,_ in pairs(struct) do
		assert(DeleteEgressOnlyInternetGatewayResult_keys[k], "DeleteEgressOnlyInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteEgressOnlyInternetGatewayResult
--  
-- @param ReturnCode [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DeleteEgressOnlyInternetGatewayResult(ReturnCode, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteEgressOnlyInternetGatewayResult")
	local t = { 
		["ReturnCode"] = ReturnCode,
	}
	M.AssertDeleteEgressOnlyInternetGatewayResult(t)
	return t
end

local DeleteNatGatewayRequest_keys = { "NatGatewayId" = true, nil }

function M.AssertDeleteNatGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNatGatewayRequest to be of type 'table'")
	assert(struct["NatGatewayId"], "Expected key NatGatewayId to exist in table")
	if struct["NatGatewayId"] then M.AssertString(struct["NatGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(DeleteNatGatewayRequest_keys[k], "DeleteNatGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNatGatewayRequest
-- <p>Contains the parameters for DeleteNatGateway.</p>
-- @param NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- Required parameter: NatGatewayId
function M.DeleteNatGatewayRequest(NatGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNatGatewayRequest")
	local t = { 
		["NatGatewayId"] = NatGatewayId,
	}
	M.AssertDeleteNatGatewayRequest(t)
	return t
end

local CopySnapshotResult_keys = { "SnapshotId" = true, nil }

function M.AssertCopySnapshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopySnapshotResult to be of type 'table'")
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(CopySnapshotResult_keys[k], "CopySnapshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopySnapshotResult
-- <p>Contains the output of CopySnapshot.</p>
-- @param SnapshotId [String] <p>The ID of the new snapshot.</p>
function M.CopySnapshotResult(SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CopySnapshotResult")
	local t = { 
		["SnapshotId"] = SnapshotId,
	}
	M.AssertCopySnapshotResult(t)
	return t
end

local InstanceBlockDeviceMappingSpecification_keys = { "VirtualName" = true, "DeviceName" = true, "NoDevice" = true, "Ebs" = true, nil }

function M.AssertInstanceBlockDeviceMappingSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceBlockDeviceMappingSpecification to be of type 'table'")
	if struct["VirtualName"] then M.AssertString(struct["VirtualName"]) end
	if struct["DeviceName"] then M.AssertString(struct["DeviceName"]) end
	if struct["NoDevice"] then M.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then M.AssertEbsInstanceBlockDeviceSpecification(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(InstanceBlockDeviceMappingSpecification_keys[k], "InstanceBlockDeviceMappingSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceBlockDeviceMappingSpecification
-- <p>Describes a block device mapping entry.</p>
-- @param VirtualName [String] <p>The virtual device name.</p>
-- @param DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param NoDevice [String] <p>suppress the specified device included in the block device mapping.</p>
-- @param Ebs [EbsInstanceBlockDeviceSpecification] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
function M.InstanceBlockDeviceMappingSpecification(VirtualName, DeviceName, NoDevice, Ebs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceBlockDeviceMappingSpecification")
	local t = { 
		["VirtualName"] = VirtualName,
		["DeviceName"] = DeviceName,
		["NoDevice"] = NoDevice,
		["Ebs"] = Ebs,
	}
	M.AssertInstanceBlockDeviceMappingSpecification(t)
	return t
end

local StartInstancesRequest_keys = { "AdditionalInfo" = true, "DryRun" = true, "InstanceIds" = true, nil }

function M.AssertStartInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["AdditionalInfo"] then M.AssertString(struct["AdditionalInfo"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then M.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(StartInstancesRequest_keys[k], "StartInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartInstancesRequest
-- <p>Contains the parameters for StartInstances.</p>
-- @param AdditionalInfo [String] <p>Reserved.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.StartInstancesRequest(AdditionalInfo, DryRun, InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StartInstancesRequest")
	local t = { 
		["AdditionalInfo"] = AdditionalInfo,
		["DryRun"] = DryRun,
		["InstanceIds"] = InstanceIds,
	}
	M.AssertStartInstancesRequest(t)
	return t
end

local DescribeIdFormatResult_keys = { "Statuses" = true, nil }

function M.AssertDescribeIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdFormatResult to be of type 'table'")
	if struct["Statuses"] then M.AssertIdFormatList(struct["Statuses"]) end
	for k,_ in pairs(struct) do
		assert(DescribeIdFormatResult_keys[k], "DescribeIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdFormatResult
-- <p>Contains the output of DescribeIdFormat.</p>
-- @param Statuses [IdFormatList] <p>Information about the ID format for the resource.</p>
function M.DescribeIdFormatResult(Statuses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIdFormatResult")
	local t = { 
		["Statuses"] = Statuses,
	}
	M.AssertDescribeIdFormatResult(t)
	return t
end

local CancelReservedInstancesListingResult_keys = { "ReservedInstancesListings" = true, nil }

function M.AssertCancelReservedInstancesListingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelReservedInstancesListingResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then M.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(CancelReservedInstancesListingResult_keys[k], "CancelReservedInstancesListingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelReservedInstancesListingResult
-- <p>Contains the output of CancelReservedInstancesListing.</p>
-- @param ReservedInstancesListings [ReservedInstancesListingList] <p>The Reserved Instance listing.</p>
function M.CancelReservedInstancesListingResult(ReservedInstancesListings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelReservedInstancesListingResult")
	local t = { 
		["ReservedInstancesListings"] = ReservedInstancesListings,
	}
	M.AssertCancelReservedInstancesListingResult(t)
	return t
end

local RestoreAddressToClassicResult_keys = { "PublicIp" = true, "Status" = true, nil }

function M.AssertRestoreAddressToClassicResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RestoreAddressToClassicResult to be of type 'table'")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["Status"] then M.AssertStatus(struct["Status"]) end
	for k,_ in pairs(struct) do
		assert(RestoreAddressToClassicResult_keys[k], "RestoreAddressToClassicResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RestoreAddressToClassicResult
-- <p>Contains the output of RestoreAddressToClassic.</p>
-- @param PublicIp [String] <p>The Elastic IP address.</p>
-- @param Status [Status] <p>The move status for the IP address.</p>
function M.RestoreAddressToClassicResult(PublicIp, Status, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RestoreAddressToClassicResult")
	local t = { 
		["PublicIp"] = PublicIp,
		["Status"] = Status,
	}
	M.AssertRestoreAddressToClassicResult(t)
	return t
end

local PrefixListId_keys = { "PrefixListId" = true, nil }

function M.AssertPrefixListId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrefixListId to be of type 'table'")
	if struct["PrefixListId"] then M.AssertString(struct["PrefixListId"]) end
	for k,_ in pairs(struct) do
		assert(PrefixListId_keys[k], "PrefixListId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrefixListId
-- <p>The ID of the prefix.</p>
-- @param PrefixListId [String] <p>The ID of the prefix.</p>
function M.PrefixListId(PrefixListId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PrefixListId")
	local t = { 
		["PrefixListId"] = PrefixListId,
	}
	M.AssertPrefixListId(t)
	return t
end

local Placement_keys = { "HostId" = true, "AvailabilityZone" = true, "SpreadDomain" = true, "GroupName" = true, "Tenancy" = true, "Affinity" = true, nil }

function M.AssertPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Placement to be of type 'table'")
	if struct["HostId"] then M.AssertString(struct["HostId"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["SpreadDomain"] then M.AssertString(struct["SpreadDomain"]) end
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["Tenancy"] then M.AssertTenancy(struct["Tenancy"]) end
	if struct["Affinity"] then M.AssertString(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(Placement_keys[k], "Placement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Placement
-- <p>Describes the placement of an instance.</p>
-- @param HostId [String] <p>The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the <a>ImportInstance</a> command.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone of the instance.</p>
-- @param SpreadDomain [String] <p>Reserved for future use.</p>
-- @param GroupName [String] <p>The name of the placement group the instance is in (for cluster compute instances).</p>
-- @param Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for the <a>ImportInstance</a> command.</p>
-- @param Affinity [String] <p>The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the <a>ImportInstance</a> command.</p>
function M.Placement(HostId, AvailabilityZone, SpreadDomain, GroupName, Tenancy, Affinity, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Placement")
	local t = { 
		["HostId"] = HostId,
		["AvailabilityZone"] = AvailabilityZone,
		["SpreadDomain"] = SpreadDomain,
		["GroupName"] = GroupName,
		["Tenancy"] = Tenancy,
		["Affinity"] = Affinity,
	}
	M.AssertPlacement(t)
	return t
end

local ScheduledInstancesBlockDeviceMapping_keys = { "VirtualName" = true, "DeviceName" = true, "NoDevice" = true, "Ebs" = true, nil }

function M.AssertScheduledInstancesBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesBlockDeviceMapping to be of type 'table'")
	if struct["VirtualName"] then M.AssertString(struct["VirtualName"]) end
	if struct["DeviceName"] then M.AssertString(struct["DeviceName"]) end
	if struct["NoDevice"] then M.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then M.AssertScheduledInstancesEbs(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstancesBlockDeviceMapping_keys[k], "ScheduledInstancesBlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesBlockDeviceMapping
-- <p>Describes a block device mapping for a Scheduled Instance.</p>
-- @param VirtualName [String] <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with two available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
-- @param DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- @param Ebs [ScheduledInstancesEbs] <p>Parameters used to set up EBS volumes automatically when the instance is launched.</p>
function M.ScheduledInstancesBlockDeviceMapping(VirtualName, DeviceName, NoDevice, Ebs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesBlockDeviceMapping")
	local t = { 
		["VirtualName"] = VirtualName,
		["DeviceName"] = DeviceName,
		["NoDevice"] = NoDevice,
		["Ebs"] = Ebs,
	}
	M.AssertScheduledInstancesBlockDeviceMapping(t)
	return t
end

local CreateVolumePermissionModifications_keys = { "Add" = true, "Remove" = true, nil }

function M.AssertCreateVolumePermissionModifications(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumePermissionModifications to be of type 'table'")
	if struct["Add"] then M.AssertCreateVolumePermissionList(struct["Add"]) end
	if struct["Remove"] then M.AssertCreateVolumePermissionList(struct["Remove"]) end
	for k,_ in pairs(struct) do
		assert(CreateVolumePermissionModifications_keys[k], "CreateVolumePermissionModifications contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumePermissionModifications
-- <p>Describes modifications to the permissions for a volume.</p>
-- @param Add [CreateVolumePermissionList] <p>Adds a specific AWS account ID or group to a volume's list of create volume permissions.</p>
-- @param Remove [CreateVolumePermissionList] <p>Removes a specific AWS account ID or group from a volume's list of create volume permissions.</p>
function M.CreateVolumePermissionModifications(Add, Remove, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVolumePermissionModifications")
	local t = { 
		["Add"] = Add,
		["Remove"] = Remove,
	}
	M.AssertCreateVolumePermissionModifications(t)
	return t
end

local EbsBlockDevice_keys = { "VolumeSize" = true, "Encrypted" = true, "VolumeType" = true, "DeleteOnTermination" = true, "SnapshotId" = true, "Iops" = true, nil }

function M.AssertEbsBlockDevice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsBlockDevice to be of type 'table'")
	if struct["VolumeSize"] then M.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then M.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then M.AssertVolumeType(struct["VolumeType"]) end
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then M.AssertInteger(struct["Iops"]) end
	for k,_ in pairs(struct) do
		assert(EbsBlockDevice_keys[k], "EbsBlockDevice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsBlockDevice
-- <p>Describes a block device for an EBS volume.</p>
-- @param VolumeSize [Integer] <p>The size of the volume, in GiB.</p> <p>Constraints: 1-16384 for General Purpose SSD (<code>gp2</code>), 4-16384 for Provisioned IOPS SSD (<code>io1</code>), 500-16384 for Throughput Optimized HDD (<code>st1</code>), 500-16384 for Cold HDD (<code>sc1</code>), and 1-1024 for Magnetic (<code>standard</code>) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- @param Encrypted [Boolean] <p>Indicates whether the EBS volume is encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption.</p>
-- @param VolumeType [VolumeType] <p>The volume type: <code>gp2</code>, <code>io1</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code>.</p> <p>Default: <code>standard</code> </p>
-- @param DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- @param SnapshotId [String] <p>The ID of the snapshot.</p>
-- @param Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For <code>io1</code>, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code>, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for <code>io1</code> volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
function M.EbsBlockDevice(VolumeSize, Encrypted, VolumeType, DeleteOnTermination, SnapshotId, Iops, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EbsBlockDevice")
	local t = { 
		["VolumeSize"] = VolumeSize,
		["Encrypted"] = Encrypted,
		["VolumeType"] = VolumeType,
		["DeleteOnTermination"] = DeleteOnTermination,
		["SnapshotId"] = SnapshotId,
		["Iops"] = Iops,
	}
	M.AssertEbsBlockDevice(t)
	return t
end

local TargetConfiguration_keys = { "InstanceCount" = true, "OfferingId" = true, nil }

function M.AssertTargetConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetConfiguration to be of type 'table'")
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	if struct["OfferingId"] then M.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(TargetConfiguration_keys[k], "TargetConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetConfiguration
-- <p>Information about the Convertible Reserved Instance offering.</p>
-- @param InstanceCount [Integer] <p>The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>
-- @param OfferingId [String] <p>The ID of the Convertible Reserved Instance offering.</p>
function M.TargetConfiguration(InstanceCount, OfferingId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TargetConfiguration")
	local t = { 
		["InstanceCount"] = InstanceCount,
		["OfferingId"] = OfferingId,
	}
	M.AssertTargetConfiguration(t)
	return t
end

local DescribeVolumesModificationsRequest_keys = { "MaxResults" = true, "NextToken" = true, "DryRun" = true, "VolumeIds" = true, "Filters" = true, nil }

function M.AssertDescribeVolumesModificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesModificationsRequest to be of type 'table'")
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeIds"] then M.AssertVolumeIdStringList(struct["VolumeIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVolumesModificationsRequest_keys[k], "DescribeVolumesModificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesModificationsRequest
--  
-- @param MaxResults [Integer] <p>The maximum number of results (up to a limit of 500) to be returned in a paginated request.</p>
-- @param NextToken [String] <p>The <code>nextToken</code> value returned by a previous paginated request.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VolumeIds [VolumeIdStringList] <p>One or more volume IDs for which in-progress modifications will be described.</p>
-- @param Filters [FilterList] <p>One or more filters. Supported filters: <code>volume-id</code>, <code>modification-state</code>, <code>target-size</code>, <code>target-iops</code>, <code>target-volume-type</code>, <code>original-size</code>, <code>original-iops</code>, <code>original-volume-type</code>, <code>start-time</code>. </p>
function M.DescribeVolumesModificationsRequest(MaxResults, NextToken, DryRun, VolumeIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumesModificationsRequest")
	local t = { 
		["MaxResults"] = MaxResults,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["VolumeIds"] = VolumeIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeVolumesModificationsRequest(t)
	return t
end

local UserData_keys = { "Data" = true, nil }

function M.AssertUserData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserData to be of type 'table'")
	if struct["Data"] then M.AssertString(struct["Data"]) end
	for k,_ in pairs(struct) do
		assert(UserData_keys[k], "UserData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserData
-- <p>Describes the user data for an instance.</p>
-- @param Data [String] <p>The user data. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
function M.UserData(Data, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UserData")
	local t = { 
		["Data"] = Data,
	}
	M.AssertUserData(t)
	return t
end

local ImportInstanceVolumeDetailItem_keys = { "Status" = true, "AvailabilityZone" = true, "Description" = true, "Image" = true, "Volume" = true, "BytesConverted" = true, "StatusMessage" = true, nil }

function M.AssertImportInstanceVolumeDetailItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceVolumeDetailItem to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["BytesConverted"], "Expected key BytesConverted to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Status"], "Expected key Status to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["Status"] then M.AssertString(struct["Status"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Image"] then M.AssertDiskImageDescription(struct["Image"]) end
	if struct["Volume"] then M.AssertDiskImageVolumeDescription(struct["Volume"]) end
	if struct["BytesConverted"] then M.AssertLong(struct["BytesConverted"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(ImportInstanceVolumeDetailItem_keys[k], "ImportInstanceVolumeDetailItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceVolumeDetailItem
-- <p>Describes an import volume task.</p>
-- @param Status [String] <p>The status of the import of this particular disk image.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone where the resulting instance will reside.</p>
-- @param Description [String] <p>A description of the task.</p>
-- @param Image [DiskImageDescription] <p>The image.</p>
-- @param Volume [DiskImageVolumeDescription] <p>The volume.</p>
-- @param BytesConverted [Long] <p>The number of bytes converted so far.</p>
-- @param StatusMessage [String] <p>The status information or errors related to the disk image.</p>
-- Required parameter: AvailabilityZone
-- Required parameter: BytesConverted
-- Required parameter: Image
-- Required parameter: Status
-- Required parameter: Volume
function M.ImportInstanceVolumeDetailItem(Status, AvailabilityZone, Description, Image, Volume, BytesConverted, StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceVolumeDetailItem")
	local t = { 
		["Status"] = Status,
		["AvailabilityZone"] = AvailabilityZone,
		["Description"] = Description,
		["Image"] = Image,
		["Volume"] = Volume,
		["BytesConverted"] = BytesConverted,
		["StatusMessage"] = StatusMessage,
	}
	M.AssertImportInstanceVolumeDetailItem(t)
	return t
end

local DescribeReservedInstancesModificationsRequest_keys = { "NextToken" = true, "ReservedInstancesModificationIds" = true, "Filters" = true, nil }

function M.AssertDescribeReservedInstancesModificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesModificationsRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesModificationIds"] then M.AssertReservedInstancesModificationIdStringList(struct["ReservedInstancesModificationIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeReservedInstancesModificationsRequest_keys[k], "DescribeReservedInstancesModificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesModificationsRequest
-- <p>Contains the parameters for DescribeReservedInstancesModifications.</p>
-- @param NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param ReservedInstancesModificationIds [ReservedInstancesModificationIdStringList] <p>IDs for the submitted modification request.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>client-token</code> - The idempotency token for the modification request.</p> </li> <li> <p> <code>create-date</code> - The time when the modification request was created.</p> </li> <li> <p> <code>effective-date</code> - The time when the modification becomes effective.</p> </li> <li> <p> <code>modification-result.reserved-instances-id</code> - The ID for the Reserved Instances created as part of the modification request. This ID is only available when the status of the modification is <code>fulfilled</code>.</p> </li> <li> <p> <code>modification-result.target-configuration.availability-zone</code> - The Availability Zone for the new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.instance-count </code> - The number of new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.instance-type</code> - The instance type of the new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.platform</code> - The network platform of the new Reserved Instances (<code>EC2-Classic</code> | <code>EC2-VPC</code>).</p> </li> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instances modified.</p> </li> <li> <p> <code>reserved-instances-modification-id</code> - The ID of the modification request.</p> </li> <li> <p> <code>status</code> - The status of the Reserved Instances modification request (<code>processing</code> | <code>fulfilled</code> | <code>failed</code>).</p> </li> <li> <p> <code>status-message</code> - The reason for the status.</p> </li> <li> <p> <code>update-date</code> - The time when the modification request was last updated.</p> </li> </ul>
function M.DescribeReservedInstancesModificationsRequest(NextToken, ReservedInstancesModificationIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesModificationsRequest")
	local t = { 
		["NextToken"] = NextToken,
		["ReservedInstancesModificationIds"] = ReservedInstancesModificationIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeReservedInstancesModificationsRequest(t)
	return t
end

local DescribeIdFormatRequest_keys = { "Resource" = true, nil }

function M.AssertDescribeIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdFormatRequest to be of type 'table'")
	if struct["Resource"] then M.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(DescribeIdFormatRequest_keys[k], "DescribeIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdFormatRequest
-- <p>Contains the parameters for DescribeIdFormat.</p>
-- @param Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
function M.DescribeIdFormatRequest(Resource, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIdFormatRequest")
	local t = { 
		["Resource"] = Resource,
	}
	M.AssertDescribeIdFormatRequest(t)
	return t
end

local CreateSecurityGroupRequest_keys = { "GroupName" = true, "VpcId" = true, "DryRun" = true, "Description" = true, nil }

function M.AssertCreateSecurityGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityGroupRequest to be of type 'table'")
	assert(struct["Description"], "Expected key Description to exist in table")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(CreateSecurityGroupRequest_keys[k], "CreateSecurityGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityGroupRequest
-- <p>Contains the parameters for CreateSecurityGroup.</p>
-- @param GroupName [String] <p>The name of the security group.</p> <p>Constraints: Up to 255 characters in length</p> <p>Constraints for EC2-Classic: ASCII characters</p> <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
-- @param VpcId [String] <p>[EC2-VPC] The ID of the VPC. Required for EC2-VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>A description for the security group. This is informational only.</p> <p>Constraints: Up to 255 characters in length</p> <p>Constraints for EC2-Classic: ASCII characters</p> <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
-- Required parameter: Description
-- Required parameter: GroupName
function M.CreateSecurityGroupRequest(GroupName, VpcId, DryRun, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSecurityGroupRequest")
	local t = { 
		["GroupName"] = GroupName,
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
		["Description"] = Description,
	}
	M.AssertCreateSecurityGroupRequest(t)
	return t
end

local BundleTaskError_keys = { "Message" = true, "Code" = true, nil }

function M.AssertBundleTaskError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleTaskError to be of type 'table'")
	if struct["Message"] then M.AssertString(struct["Message"]) end
	if struct["Code"] then M.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(BundleTaskError_keys[k], "BundleTaskError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleTaskError
-- <p>Describes an error for <a>BundleInstance</a>.</p>
-- @param Message [String] <p>The error message.</p>
-- @param Code [String] <p>The error code.</p>
function M.BundleTaskError(Message, Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BundleTaskError")
	local t = { 
		["Message"] = Message,
		["Code"] = Code,
	}
	M.AssertBundleTaskError(t)
	return t
end

local CreateFlowLogsRequest_keys = { "ResourceType" = true, "LogGroupName" = true, "TrafficType" = true, "ResourceIds" = true, "DeliverLogsPermissionArn" = true, "ClientToken" = true, nil }

function M.AssertCreateFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFlowLogsRequest to be of type 'table'")
	assert(struct["DeliverLogsPermissionArn"], "Expected key DeliverLogsPermissionArn to exist in table")
	assert(struct["LogGroupName"], "Expected key LogGroupName to exist in table")
	assert(struct["ResourceIds"], "Expected key ResourceIds to exist in table")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	assert(struct["TrafficType"], "Expected key TrafficType to exist in table")
	if struct["ResourceType"] then M.AssertFlowLogsResourceType(struct["ResourceType"]) end
	if struct["LogGroupName"] then M.AssertString(struct["LogGroupName"]) end
	if struct["TrafficType"] then M.AssertTrafficType(struct["TrafficType"]) end
	if struct["ResourceIds"] then M.AssertValueStringList(struct["ResourceIds"]) end
	if struct["DeliverLogsPermissionArn"] then M.AssertString(struct["DeliverLogsPermissionArn"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(CreateFlowLogsRequest_keys[k], "CreateFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFlowLogsRequest
-- <p>Contains the parameters for CreateFlowLogs.</p>
-- @param ResourceType [FlowLogsResourceType] <p>The type of resource on which to create the flow log.</p>
-- @param LogGroupName [String] <p>The name of the CloudWatch log group.</p>
-- @param TrafficType [TrafficType] <p>The type of traffic to log.</p>
-- @param ResourceIds [ValueStringList] <p>One or more subnet, network interface, or VPC IDs.</p> <p>Constraints: Maximum of 1000 resources</p>
-- @param DeliverLogsPermissionArn [String] <p>The ARN for the IAM role that's used to post flow logs to a CloudWatch Logs log group.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required parameter: DeliverLogsPermissionArn
-- Required parameter: LogGroupName
-- Required parameter: ResourceIds
-- Required parameter: ResourceType
-- Required parameter: TrafficType
function M.CreateFlowLogsRequest(ResourceType, LogGroupName, TrafficType, ResourceIds, DeliverLogsPermissionArn, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateFlowLogsRequest")
	local t = { 
		["ResourceType"] = ResourceType,
		["LogGroupName"] = LogGroupName,
		["TrafficType"] = TrafficType,
		["ResourceIds"] = ResourceIds,
		["DeliverLogsPermissionArn"] = DeliverLogsPermissionArn,
		["ClientToken"] = ClientToken,
	}
	M.AssertCreateFlowLogsRequest(t)
	return t
end

local S3Storage_keys = { "UploadPolicySignature" = true, "Prefix" = true, "AWSAccessKeyId" = true, "Bucket" = true, "UploadPolicy" = true, nil }

function M.AssertS3Storage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected S3Storage to be of type 'table'")
	if struct["UploadPolicySignature"] then M.AssertString(struct["UploadPolicySignature"]) end
	if struct["Prefix"] then M.AssertString(struct["Prefix"]) end
	if struct["AWSAccessKeyId"] then M.AssertString(struct["AWSAccessKeyId"]) end
	if struct["Bucket"] then M.AssertString(struct["Bucket"]) end
	if struct["UploadPolicy"] then M.AssertBlob(struct["UploadPolicy"]) end
	for k,_ in pairs(struct) do
		assert(S3Storage_keys[k], "S3Storage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type S3Storage
-- <p>Describes the storage parameters for S3 and S3 buckets for an instance store-backed AMI.</p>
-- @param UploadPolicySignature [String] <p>The signature of the JSON document.</p>
-- @param Prefix [String] <p>The beginning of the file name of the AMI.</p>
-- @param AWSAccessKeyId [String] <p>The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance in <a href="http://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html">Best Practices for Managing AWS Access Keys</a>.</p>
-- @param Bucket [String] <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
-- @param UploadPolicy [Blob] <p>An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.</p>
function M.S3Storage(UploadPolicySignature, Prefix, AWSAccessKeyId, Bucket, UploadPolicy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating S3Storage")
	local t = { 
		["UploadPolicySignature"] = UploadPolicySignature,
		["Prefix"] = Prefix,
		["AWSAccessKeyId"] = AWSAccessKeyId,
		["Bucket"] = Bucket,
		["UploadPolicy"] = UploadPolicy,
	}
	M.AssertS3Storage(t)
	return t
end

local EnableVgwRoutePropagationRequest_keys = { "GatewayId" = true, "RouteTableId" = true, nil }

function M.AssertEnableVgwRoutePropagationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVgwRoutePropagationRequest to be of type 'table'")
	assert(struct["GatewayId"], "Expected key GatewayId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["GatewayId"] then M.AssertString(struct["GatewayId"]) end
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(EnableVgwRoutePropagationRequest_keys[k], "EnableVgwRoutePropagationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVgwRoutePropagationRequest
-- <p>Contains the parameters for EnableVgwRoutePropagation.</p>
-- @param GatewayId [String] <p>The ID of the virtual private gateway.</p>
-- @param RouteTableId [String] <p>The ID of the route table.</p>
-- Required parameter: GatewayId
-- Required parameter: RouteTableId
function M.EnableVgwRoutePropagationRequest(GatewayId, RouteTableId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVgwRoutePropagationRequest")
	local t = { 
		["GatewayId"] = GatewayId,
		["RouteTableId"] = RouteTableId,
	}
	M.AssertEnableVgwRoutePropagationRequest(t)
	return t
end

local IamInstanceProfileAssociation_keys = { "InstanceId" = true, "Timestamp" = true, "State" = true, "AssociationId" = true, "IamInstanceProfile" = true, nil }

function M.AssertIamInstanceProfileAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfileAssociation to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Timestamp"] then M.AssertDateTime(struct["Timestamp"]) end
	if struct["State"] then M.AssertIamInstanceProfileAssociationState(struct["State"]) end
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["IamInstanceProfile"] then M.AssertIamInstanceProfile(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(IamInstanceProfileAssociation_keys[k], "IamInstanceProfileAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfileAssociation
-- <p>Describes an association between an IAM instance profile and an instance.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param Timestamp [DateTime] <p>The time the IAM instance profile was associated with the instance.</p>
-- @param State [IamInstanceProfileAssociationState] <p>The state of the association.</p>
-- @param AssociationId [String] <p>The ID of the association.</p>
-- @param IamInstanceProfile [IamInstanceProfile] <p>The IAM instance profile.</p>
function M.IamInstanceProfileAssociation(InstanceId, Timestamp, State, AssociationId, IamInstanceProfile, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IamInstanceProfileAssociation")
	local t = { 
		["InstanceId"] = InstanceId,
		["Timestamp"] = Timestamp,
		["State"] = State,
		["AssociationId"] = AssociationId,
		["IamInstanceProfile"] = IamInstanceProfile,
	}
	M.AssertIamInstanceProfileAssociation(t)
	return t
end

local ScheduledInstance_keys = { "AvailabilityZone" = true, "ScheduledInstanceId" = true, "HourlyPrice" = true, "CreateDate" = true, "Recurrence" = true, "Platform" = true, "TermEndDate" = true, "InstanceCount" = true, "SlotDurationInHours" = true, "PreviousSlotEndTime" = true, "TermStartDate" = true, "NetworkPlatform" = true, "TotalScheduledInstanceHours" = true, "NextSlotStartTime" = true, "InstanceType" = true, nil }

function M.AssertScheduledInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstance to be of type 'table'")
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["ScheduledInstanceId"] then M.AssertString(struct["ScheduledInstanceId"]) end
	if struct["HourlyPrice"] then M.AssertString(struct["HourlyPrice"]) end
	if struct["CreateDate"] then M.AssertDateTime(struct["CreateDate"]) end
	if struct["Recurrence"] then M.AssertScheduledInstanceRecurrence(struct["Recurrence"]) end
	if struct["Platform"] then M.AssertString(struct["Platform"]) end
	if struct["TermEndDate"] then M.AssertDateTime(struct["TermEndDate"]) end
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	if struct["SlotDurationInHours"] then M.AssertInteger(struct["SlotDurationInHours"]) end
	if struct["PreviousSlotEndTime"] then M.AssertDateTime(struct["PreviousSlotEndTime"]) end
	if struct["TermStartDate"] then M.AssertDateTime(struct["TermStartDate"]) end
	if struct["NetworkPlatform"] then M.AssertString(struct["NetworkPlatform"]) end
	if struct["TotalScheduledInstanceHours"] then M.AssertInteger(struct["TotalScheduledInstanceHours"]) end
	if struct["NextSlotStartTime"] then M.AssertDateTime(struct["NextSlotStartTime"]) end
	if struct["InstanceType"] then M.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstance_keys[k], "ScheduledInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstance
-- <p>Describes a Scheduled Instance.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone.</p>
-- @param ScheduledInstanceId [String] <p>The Scheduled Instance ID.</p>
-- @param HourlyPrice [String] <p>The hourly price for a single instance.</p>
-- @param CreateDate [DateTime] <p>The date when the Scheduled Instance was purchased.</p>
-- @param Recurrence [ScheduledInstanceRecurrence] <p>The schedule recurrence.</p>
-- @param Platform [String] <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
-- @param TermEndDate [DateTime] <p>The end date for the Scheduled Instance.</p>
-- @param InstanceCount [Integer] <p>The number of instances.</p>
-- @param SlotDurationInHours [Integer] <p>The number of hours in the schedule.</p>
-- @param PreviousSlotEndTime [DateTime] <p>The time that the previous schedule ended or will end.</p>
-- @param TermStartDate [DateTime] <p>The start date for the Scheduled Instance.</p>
-- @param NetworkPlatform [String] <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
-- @param TotalScheduledInstanceHours [Integer] <p>The total number of hours for a single instance for the entire term.</p>
-- @param NextSlotStartTime [DateTime] <p>The time for the next schedule to start.</p>
-- @param InstanceType [String] <p>The instance type.</p>
function M.ScheduledInstance(AvailabilityZone, ScheduledInstanceId, HourlyPrice, CreateDate, Recurrence, Platform, TermEndDate, InstanceCount, SlotDurationInHours, PreviousSlotEndTime, TermStartDate, NetworkPlatform, TotalScheduledInstanceHours, NextSlotStartTime, InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstance")
	local t = { 
		["AvailabilityZone"] = AvailabilityZone,
		["ScheduledInstanceId"] = ScheduledInstanceId,
		["HourlyPrice"] = HourlyPrice,
		["CreateDate"] = CreateDate,
		["Recurrence"] = Recurrence,
		["Platform"] = Platform,
		["TermEndDate"] = TermEndDate,
		["InstanceCount"] = InstanceCount,
		["SlotDurationInHours"] = SlotDurationInHours,
		["PreviousSlotEndTime"] = PreviousSlotEndTime,
		["TermStartDate"] = TermStartDate,
		["NetworkPlatform"] = NetworkPlatform,
		["TotalScheduledInstanceHours"] = TotalScheduledInstanceHours,
		["NextSlotStartTime"] = NextSlotStartTime,
		["InstanceType"] = InstanceType,
	}
	M.AssertScheduledInstance(t)
	return t
end

local HostInstance_keys = { "InstanceId" = true, "InstanceType" = true, nil }

function M.AssertHostInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostInstance to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["InstanceType"] then M.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(HostInstance_keys[k], "HostInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostInstance
-- <p>Describes an instance running on a Dedicated Host.</p>
-- @param InstanceId [String] <p>the IDs of instances that are running on the Dedicated Host.</p>
-- @param InstanceType [String] <p>The instance type size (for example, <code>m3.medium</code>) of the running instance.</p>
function M.HostInstance(InstanceId, InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HostInstance")
	local t = { 
		["InstanceId"] = InstanceId,
		["InstanceType"] = InstanceType,
	}
	M.AssertHostInstance(t)
	return t
end

local Monitoring_keys = { "State" = true, nil }

function M.AssertMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Monitoring to be of type 'table'")
	if struct["State"] then M.AssertMonitoringState(struct["State"]) end
	for k,_ in pairs(struct) do
		assert(Monitoring_keys[k], "Monitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Monitoring
-- <p>Describes the monitoring of an instance.</p>
-- @param State [MonitoringState] <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
function M.Monitoring(State, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Monitoring")
	local t = { 
		["State"] = State,
	}
	M.AssertMonitoring(t)
	return t
end

local AttachVpnGatewayResult_keys = { "VpcAttachment" = true, nil }

function M.AssertAttachVpnGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVpnGatewayResult to be of type 'table'")
	if struct["VpcAttachment"] then M.AssertVpcAttachment(struct["VpcAttachment"]) end
	for k,_ in pairs(struct) do
		assert(AttachVpnGatewayResult_keys[k], "AttachVpnGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVpnGatewayResult
-- <p>Contains the output of AttachVpnGateway.</p>
-- @param VpcAttachment [VpcAttachment] <p>Information about the attachment.</p>
function M.AttachVpnGatewayResult(VpcAttachment, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachVpnGatewayResult")
	local t = { 
		["VpcAttachment"] = VpcAttachment,
	}
	M.AssertAttachVpnGatewayResult(t)
	return t
end

local DeletePlacementGroupRequest_keys = { "GroupName" = true, "DryRun" = true, nil }

function M.AssertDeletePlacementGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeletePlacementGroupRequest to be of type 'table'")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeletePlacementGroupRequest_keys[k], "DeletePlacementGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeletePlacementGroupRequest
-- <p>Contains the parameters for DeletePlacementGroup.</p>
-- @param GroupName [String] <p>The name of the placement group.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: GroupName
function M.DeletePlacementGroupRequest(GroupName, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeletePlacementGroupRequest")
	local t = { 
		["GroupName"] = GroupName,
		["DryRun"] = DryRun,
	}
	M.AssertDeletePlacementGroupRequest(t)
	return t
end

local MoveAddressToVpcRequest_keys = { "PublicIp" = true, "DryRun" = true, nil }

function M.AssertMoveAddressToVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MoveAddressToVpcRequest to be of type 'table'")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(MoveAddressToVpcRequest_keys[k], "MoveAddressToVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MoveAddressToVpcRequest
-- <p>Contains the parameters for MoveAddressToVpc.</p>
-- @param PublicIp [String] <p>The Elastic IP address.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: PublicIp
function M.MoveAddressToVpcRequest(PublicIp, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MoveAddressToVpcRequest")
	local t = { 
		["PublicIp"] = PublicIp,
		["DryRun"] = DryRun,
	}
	M.AssertMoveAddressToVpcRequest(t)
	return t
end

local CreateNatGatewayResult_keys = { "NatGateway" = true, "ClientToken" = true, nil }

function M.AssertCreateNatGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNatGatewayResult to be of type 'table'")
	if struct["NatGateway"] then M.AssertNatGateway(struct["NatGateway"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(CreateNatGatewayResult_keys[k], "CreateNatGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNatGatewayResult
-- <p>Contains the output of CreateNatGateway.</p>
-- @param NatGateway [NatGateway] <p>Information about the NAT gateway.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.</p>
function M.CreateNatGatewayResult(NatGateway, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNatGatewayResult")
	local t = { 
		["NatGateway"] = NatGateway,
		["ClientToken"] = ClientToken,
	}
	M.AssertCreateNatGatewayResult(t)
	return t
end

local DisassociateSubnetCidrBlockRequest_keys = { "AssociationId" = true, nil }

function M.AssertDisassociateSubnetCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateSubnetCidrBlockRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(DisassociateSubnetCidrBlockRequest_keys[k], "DisassociateSubnetCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateSubnetCidrBlockRequest
--  
-- @param AssociationId [String] <p>The association ID for the CIDR block.</p>
-- Required parameter: AssociationId
function M.DisassociateSubnetCidrBlockRequest(AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateSubnetCidrBlockRequest")
	local t = { 
		["AssociationId"] = AssociationId,
	}
	M.AssertDisassociateSubnetCidrBlockRequest(t)
	return t
end

local InternetGateway_keys = { "Tags" = true, "Attachments" = true, "InternetGatewayId" = true, nil }

function M.AssertInternetGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InternetGateway to be of type 'table'")
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["Attachments"] then M.AssertInternetGatewayAttachmentList(struct["Attachments"]) end
	if struct["InternetGatewayId"] then M.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(InternetGateway_keys[k], "InternetGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InternetGateway
-- <p>Describes an Internet gateway.</p>
-- @param Tags [TagList] <p>Any tags assigned to the Internet gateway.</p>
-- @param Attachments [InternetGatewayAttachmentList] <p>Any VPCs attached to the Internet gateway.</p>
-- @param InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
function M.InternetGateway(Tags, Attachments, InternetGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InternetGateway")
	local t = { 
		["Tags"] = Tags,
		["Attachments"] = Attachments,
		["InternetGatewayId"] = InternetGatewayId,
	}
	M.AssertInternetGateway(t)
	return t
end

local AccountAttribute_keys = { "AttributeName" = true, "AttributeValues" = true, nil }

function M.AssertAccountAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AccountAttribute to be of type 'table'")
	if struct["AttributeName"] then M.AssertString(struct["AttributeName"]) end
	if struct["AttributeValues"] then M.AssertAccountAttributeValueList(struct["AttributeValues"]) end
	for k,_ in pairs(struct) do
		assert(AccountAttribute_keys[k], "AccountAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AccountAttribute
-- <p>Describes an account attribute.</p>
-- @param AttributeName [String] <p>The name of the account attribute.</p>
-- @param AttributeValues [AccountAttributeValueList] <p>One or more values for the account attribute.</p>
function M.AccountAttribute(AttributeName, AttributeValues, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AccountAttribute")
	local t = { 
		["AttributeName"] = AttributeName,
		["AttributeValues"] = AttributeValues,
	}
	M.AssertAccountAttribute(t)
	return t
end

local DescribeDhcpOptionsResult_keys = { "DhcpOptions" = true, nil }

function M.AssertDescribeDhcpOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDhcpOptionsResult to be of type 'table'")
	if struct["DhcpOptions"] then M.AssertDhcpOptionsList(struct["DhcpOptions"]) end
	for k,_ in pairs(struct) do
		assert(DescribeDhcpOptionsResult_keys[k], "DescribeDhcpOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDhcpOptionsResult
-- <p>Contains the output of DescribeDhcpOptions.</p>
-- @param DhcpOptions [DhcpOptionsList] <p>Information about one or more DHCP options sets.</p>
function M.DescribeDhcpOptionsResult(DhcpOptions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeDhcpOptionsResult")
	local t = { 
		["DhcpOptions"] = DhcpOptions,
	}
	M.AssertDescribeDhcpOptionsResult(t)
	return t
end

local DeleteTagsRequest_keys = { "DryRun" = true, "Resources" = true, "Tags" = true, nil }

function M.AssertDeleteTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteTagsRequest to be of type 'table'")
	assert(struct["Resources"], "Expected key Resources to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Resources"] then M.AssertResourceIdList(struct["Resources"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(DeleteTagsRequest_keys[k], "DeleteTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteTagsRequest
-- <p>Contains the parameters for DeleteTags.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Resources [ResourceIdList] <p>The ID of the resource. For example, ami-1a2b3c4d. You can specify more than one resource ID.</p>
-- @param Tags [TagList] <p>One or more tags to delete. If you omit the <code>value</code> parameter, we delete the tag regardless of its value. If you specify this parameter with an empty string as the value, we delete the key only if its value is an empty string.</p>
-- Required parameter: Resources
function M.DeleteTagsRequest(DryRun, Resources, Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteTagsRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Resources"] = Resources,
		["Tags"] = Tags,
	}
	M.AssertDeleteTagsRequest(t)
	return t
end

local ModifyVpcAttributeRequest_keys = { "VpcId" = true, "EnableDnsSupport" = true, "EnableDnsHostnames" = true, nil }

function M.AssertModifyVpcAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcAttributeRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["EnableDnsSupport"] then M.AssertAttributeBooleanValue(struct["EnableDnsSupport"]) end
	if struct["EnableDnsHostnames"] then M.AssertAttributeBooleanValue(struct["EnableDnsHostnames"]) end
	for k,_ in pairs(struct) do
		assert(ModifyVpcAttributeRequest_keys[k], "ModifyVpcAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcAttributeRequest
-- <p>Contains the parameters for ModifyVpcAttribute.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param EnableDnsSupport [AttributeBooleanValue] <p>Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" will succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled.</p> <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute.</p>
-- @param EnableDnsHostnames [AttributeBooleanValue] <p>Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not.</p> <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute. You can only enable DNS hostnames if you've enabled DNS support.</p>
-- Required parameter: VpcId
function M.ModifyVpcAttributeRequest(VpcId, EnableDnsSupport, EnableDnsHostnames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcAttributeRequest")
	local t = { 
		["VpcId"] = VpcId,
		["EnableDnsSupport"] = EnableDnsSupport,
		["EnableDnsHostnames"] = EnableDnsHostnames,
	}
	M.AssertModifyVpcAttributeRequest(t)
	return t
end

local ScheduledInstancesIpv6Address_keys = { "Ipv6Address" = true, nil }

function M.AssertScheduledInstancesIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then M.AssertIpv6Address(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstancesIpv6Address_keys[k], "ScheduledInstancesIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesIpv6Address
-- <p>Describes an IPv6 address.</p>
-- @param Ipv6Address [Ipv6Address] <p>The IPv6 address.</p>
function M.ScheduledInstancesIpv6Address(Ipv6Address, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesIpv6Address")
	local t = { 
		["Ipv6Address"] = Ipv6Address,
	}
	M.AssertScheduledInstancesIpv6Address(t)
	return t
end

local SpotInstanceRequest_keys = { "Status" = true, "ActualBlockHourlyPrice" = true, "ValidUntil" = true, "LaunchGroup" = true, "Tags" = true, "InstanceId" = true, "Fault" = true, "BlockDurationMinutes" = true, "SpotInstanceRequestId" = true, "State" = true, "ProductDescription" = true, "AvailabilityZoneGroup" = true, "LaunchSpecification" = true, "ValidFrom" = true, "Type" = true, "CreateTime" = true, "SpotPrice" = true, "LaunchedAvailabilityZone" = true, nil }

function M.AssertSpotInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceRequest to be of type 'table'")
	if struct["Status"] then M.AssertSpotInstanceStatus(struct["Status"]) end
	if struct["ActualBlockHourlyPrice"] then M.AssertString(struct["ActualBlockHourlyPrice"]) end
	if struct["ValidUntil"] then M.AssertDateTime(struct["ValidUntil"]) end
	if struct["LaunchGroup"] then M.AssertString(struct["LaunchGroup"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Fault"] then M.AssertSpotInstanceStateFault(struct["Fault"]) end
	if struct["BlockDurationMinutes"] then M.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["SpotInstanceRequestId"] then M.AssertString(struct["SpotInstanceRequestId"]) end
	if struct["State"] then M.AssertSpotInstanceState(struct["State"]) end
	if struct["ProductDescription"] then M.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["AvailabilityZoneGroup"] then M.AssertString(struct["AvailabilityZoneGroup"]) end
	if struct["LaunchSpecification"] then M.AssertLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["ValidFrom"] then M.AssertDateTime(struct["ValidFrom"]) end
	if struct["Type"] then M.AssertSpotInstanceType(struct["Type"]) end
	if struct["CreateTime"] then M.AssertDateTime(struct["CreateTime"]) end
	if struct["SpotPrice"] then M.AssertString(struct["SpotPrice"]) end
	if struct["LaunchedAvailabilityZone"] then M.AssertString(struct["LaunchedAvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(SpotInstanceRequest_keys[k], "SpotInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceRequest
-- <p>Describes a Spot instance request.</p>
-- @param Status [SpotInstanceStatus] <p>The status code and status message describing the Spot instance request.</p>
-- @param ActualBlockHourlyPrice [String] <p>If you specified a duration and your Spot instance request was fulfilled, this is the fixed hourly price in effect for the Spot instance while it runs.</p>
-- @param ValidUntil [DateTime] <p>The end date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). If this is a one-time request, it remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date is reached.</p>
-- @param LaunchGroup [String] <p>The instance launch group. Launch groups are Spot instances that launch together and terminate together.</p>
-- @param Tags [TagList] <p>Any tags assigned to the resource.</p>
-- @param InstanceId [String] <p>The instance ID, if an instance has been launched to fulfill the Spot instance request.</p>
-- @param Fault [SpotInstanceStateFault] <p>The fault codes for the Spot instance request, if any.</p>
-- @param BlockDurationMinutes [Integer] <p>The duration for the Spot instance, in minutes.</p>
-- @param SpotInstanceRequestId [String] <p>The ID of the Spot instance request.</p>
-- @param State [SpotInstanceState] <p>The state of the Spot instance request. Spot bid status information can help you track your Spot instance requests. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot Bid Status</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param ProductDescription [RIProductDescription] <p>The product description associated with the Spot instance.</p>
-- @param AvailabilityZoneGroup [String] <p>The Availability Zone group. If you specify the same Availability Zone group for all Spot instance requests, all Spot instances are launched in the same Availability Zone.</p>
-- @param LaunchSpecification [LaunchSpecification] <p>Additional information for launching instances.</p>
-- @param ValidFrom [DateTime] <p>The start date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The request becomes active at this date and time.</p>
-- @param Type [SpotInstanceType] <p>The Spot instance request type.</p>
-- @param CreateTime [DateTime] <p>The date and time when the Spot instance request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @param SpotPrice [String] <p>The maximum hourly price (bid) for the Spot instance launched to fulfill the request.</p>
-- @param LaunchedAvailabilityZone [String] <p>The Availability Zone in which the bid is launched.</p>
function M.SpotInstanceRequest(Status, ActualBlockHourlyPrice, ValidUntil, LaunchGroup, Tags, InstanceId, Fault, BlockDurationMinutes, SpotInstanceRequestId, State, ProductDescription, AvailabilityZoneGroup, LaunchSpecification, ValidFrom, Type, CreateTime, SpotPrice, LaunchedAvailabilityZone, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotInstanceRequest")
	local t = { 
		["Status"] = Status,
		["ActualBlockHourlyPrice"] = ActualBlockHourlyPrice,
		["ValidUntil"] = ValidUntil,
		["LaunchGroup"] = LaunchGroup,
		["Tags"] = Tags,
		["InstanceId"] = InstanceId,
		["Fault"] = Fault,
		["BlockDurationMinutes"] = BlockDurationMinutes,
		["SpotInstanceRequestId"] = SpotInstanceRequestId,
		["State"] = State,
		["ProductDescription"] = ProductDescription,
		["AvailabilityZoneGroup"] = AvailabilityZoneGroup,
		["LaunchSpecification"] = LaunchSpecification,
		["ValidFrom"] = ValidFrom,
		["Type"] = Type,
		["CreateTime"] = CreateTime,
		["SpotPrice"] = SpotPrice,
		["LaunchedAvailabilityZone"] = LaunchedAvailabilityZone,
	}
	M.AssertSpotInstanceRequest(t)
	return t
end

local DescribeReservedInstancesResult_keys = { "ReservedInstances" = true, nil }

function M.AssertDescribeReservedInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesResult to be of type 'table'")
	if struct["ReservedInstances"] then M.AssertReservedInstancesList(struct["ReservedInstances"]) end
	for k,_ in pairs(struct) do
		assert(DescribeReservedInstancesResult_keys[k], "DescribeReservedInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesResult
-- <p>Contains the output for DescribeReservedInstances.</p>
-- @param ReservedInstances [ReservedInstancesList] <p>A list of Reserved Instances.</p>
function M.DescribeReservedInstancesResult(ReservedInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesResult")
	local t = { 
		["ReservedInstances"] = ReservedInstances,
	}
	M.AssertDescribeReservedInstancesResult(t)
	return t
end

local DescribeAccountAttributesResult_keys = { "AccountAttributes" = true, nil }

function M.AssertDescribeAccountAttributesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAttributesResult to be of type 'table'")
	if struct["AccountAttributes"] then M.AssertAccountAttributeList(struct["AccountAttributes"]) end
	for k,_ in pairs(struct) do
		assert(DescribeAccountAttributesResult_keys[k], "DescribeAccountAttributesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAttributesResult
-- <p>Contains the output of DescribeAccountAttributes.</p>
-- @param AccountAttributes [AccountAttributeList] <p>Information about one or more account attributes.</p>
function M.DescribeAccountAttributesResult(AccountAttributes, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAccountAttributesResult")
	local t = { 
		["AccountAttributes"] = AccountAttributes,
	}
	M.AssertDescribeAccountAttributesResult(t)
	return t
end

local UserIdGroupPair_keys = { "VpcId" = true, "PeeringStatus" = true, "UserId" = true, "GroupName" = true, "VpcPeeringConnectionId" = true, "GroupId" = true, nil }

function M.AssertUserIdGroupPair(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserIdGroupPair to be of type 'table'")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["PeeringStatus"] then M.AssertString(struct["PeeringStatus"]) end
	if struct["UserId"] then M.AssertString(struct["UserId"]) end
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(UserIdGroupPair_keys[k], "UserIdGroupPair contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserIdGroupPair
-- <p>Describes a security group and AWS account ID pair.</p>
-- @param VpcId [String] <p>The ID of the VPC for the referenced security group, if applicable.</p>
-- @param PeeringStatus [String] <p>The status of a VPC peering connection, if applicable.</p>
-- @param UserId [String] <p>The ID of an AWS account. For a referenced security group in another VPC, the account ID of the referenced security group is returned.</p> <p>[EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.</p>
-- @param GroupName [String] <p>The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection, if applicable.</p>
-- @param GroupId [String] <p>The ID of the security group.</p>
function M.UserIdGroupPair(VpcId, PeeringStatus, UserId, GroupName, VpcPeeringConnectionId, GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UserIdGroupPair")
	local t = { 
		["VpcId"] = VpcId,
		["PeeringStatus"] = PeeringStatus,
		["UserId"] = UserId,
		["GroupName"] = GroupName,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
		["GroupId"] = GroupId,
	}
	M.AssertUserIdGroupPair(t)
	return t
end

local DescribeRouteTablesRequest_keys = { "RouteTableIds" = true, "DryRun" = true, "Filters" = true, nil }

function M.AssertDescribeRouteTablesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRouteTablesRequest to be of type 'table'")
	if struct["RouteTableIds"] then M.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeRouteTablesRequest_keys[k], "DescribeRouteTablesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRouteTablesRequest
-- <p>Contains the parameters for DescribeRouteTables.</p>
-- @param RouteTableIds [ValueStringList] <p>One or more route table IDs.</p> <p>Default: Describes all your route tables.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>association.route-table-association-id</code> - The ID of an association ID for the route table.</p> </li> <li> <p> <code>association.route-table-id</code> - The ID of the route table involved in the association.</p> </li> <li> <p> <code>association.subnet-id</code> - The ID of the subnet involved in the association.</p> </li> <li> <p> <code>association.main</code> - Indicates whether the route table is the main route table for the VPC (<code>true</code> | <code>false</code>). Route tables that do not have an association ID are not returned in the response.</p> </li> <li> <p> <code>route-table-id</code> - The ID of the route table.</p> </li> <li> <p> <code>route.destination-cidr-block</code> - The IPv4 CIDR range specified in a route in the table.</p> </li> <li> <p> <code>route.destination-ipv6-cidr-block</code> - The IPv6 CIDR range specified in a route in the route table.</p> </li> <li> <p> <code>route.destination-prefix-list-id</code> - The ID (prefix) of the AWS service specified in a route in the table.</p> </li> <li> <p> <code>route.egress-only-internet-gateway-id</code> - The ID of an egress-only Internet gateway specified in a route in the route table.</p> </li> <li> <p> <code>route.gateway-id</code> - The ID of a gateway specified in a route in the table.</p> </li> <li> <p> <code>route.instance-id</code> - The ID of an instance specified in a route in the table.</p> </li> <li> <p> <code>route.nat-gateway-id</code> - The ID of a NAT gateway.</p> </li> <li> <p> <code>route.origin</code> - Describes how the route was created. <code>CreateRouteTable</code> indicates that the route was automatically created when the route table was created; <code>CreateRoute</code> indicates that the route was manually added to the route table; <code>EnableVgwRoutePropagation</code> indicates that the route was propagated by route propagation.</p> </li> <li> <p> <code>route.state</code> - The state of a route in the route table (<code>active</code> | <code>blackhole</code>). The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, the specified NAT instance has been terminated, and so on).</p> </li> <li> <p> <code>route.vpc-peering-connection-id</code> - The ID of a VPC peering connection specified in a route in the table.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the route table.</p> </li> </ul>
function M.DescribeRouteTablesRequest(RouteTableIds, DryRun, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeRouteTablesRequest")
	local t = { 
		["RouteTableIds"] = RouteTableIds,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
	}
	M.AssertDescribeRouteTablesRequest(t)
	return t
end

local DescribeInternetGatewaysResult_keys = { "InternetGateways" = true, nil }

function M.AssertDescribeInternetGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInternetGatewaysResult to be of type 'table'")
	if struct["InternetGateways"] then M.AssertInternetGatewayList(struct["InternetGateways"]) end
	for k,_ in pairs(struct) do
		assert(DescribeInternetGatewaysResult_keys[k], "DescribeInternetGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInternetGatewaysResult
-- <p>Contains the output of DescribeInternetGateways.</p>
-- @param InternetGateways [InternetGatewayList] <p>Information about one or more Internet gateways.</p>
function M.DescribeInternetGatewaysResult(InternetGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInternetGatewaysResult")
	local t = { 
		["InternetGateways"] = InternetGateways,
	}
	M.AssertDescribeInternetGatewaysResult(t)
	return t
end

local DescribeSecurityGroupReferencesRequest_keys = { "DryRun" = true, "GroupId" = true, nil }

function M.AssertDescribeSecurityGroupReferencesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupReferencesRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then M.AssertGroupIds(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSecurityGroupReferencesRequest_keys[k], "DescribeSecurityGroupReferencesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupReferencesRequest
--  
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.</p>
-- @param GroupId [GroupIds] <p>One or more security group IDs in your account.</p>
-- Required parameter: GroupId
function M.DescribeSecurityGroupReferencesRequest(DryRun, GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSecurityGroupReferencesRequest")
	local t = { 
		["DryRun"] = DryRun,
		["GroupId"] = GroupId,
	}
	M.AssertDescribeSecurityGroupReferencesRequest(t)
	return t
end

local ImportImageRequest_keys = { "LicenseType" = true, "DryRun" = true, "Description" = true, "ClientData" = true, "Hypervisor" = true, "DiskContainers" = true, "Platform" = true, "Architecture" = true, "ClientToken" = true, "RoleName" = true, nil }

function M.AssertImportImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageRequest to be of type 'table'")
	if struct["LicenseType"] then M.AssertString(struct["LicenseType"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["ClientData"] then M.AssertClientData(struct["ClientData"]) end
	if struct["Hypervisor"] then M.AssertString(struct["Hypervisor"]) end
	if struct["DiskContainers"] then M.AssertImageDiskContainerList(struct["DiskContainers"]) end
	if struct["Platform"] then M.AssertString(struct["Platform"]) end
	if struct["Architecture"] then M.AssertString(struct["Architecture"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["RoleName"] then M.AssertString(struct["RoleName"]) end
	for k,_ in pairs(struct) do
		assert(ImportImageRequest_keys[k], "ImportImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageRequest
-- <p>Contains the parameters for ImportImage.</p>
-- @param LicenseType [String] <p>The license type to be used for the Amazon Machine Image (AMI) after importing.</p> <p> <b>Note:</b> You may only use BYOL if you have existing licenses with rights to use these licenses in a third party cloud like AWS. For more information, see <a href="http://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html#prerequisites-image">Prerequisites</a> in the VM Import/Export User Guide.</p> <p>Valid values: <code>AWS</code> | <code>BYOL</code> </p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [String] <p>A description string for the import image task.</p>
-- @param ClientData [ClientData] <p>The client-specific data.</p>
-- @param Hypervisor [String] <p>The target hypervisor platform.</p> <p>Valid values: <code>xen</code> </p>
-- @param DiskContainers [ImageDiskContainerList] <p>Information about the disk containers.</p>
-- @param Platform [String] <p>The operating system of the virtual machine.</p> <p>Valid values: <code>Windows</code> | <code>Linux</code> </p>
-- @param Architecture [String] <p>The architecture of the virtual machine.</p> <p>Valid values: <code>i386</code> | <code>x86_64</code> </p>
-- @param ClientToken [String] <p>The token to enable idempotency for VM import requests.</p>
-- @param RoleName [String] <p>The name of the role to use when not using the default role, 'vmimport'.</p>
function M.ImportImageRequest(LicenseType, DryRun, Description, ClientData, Hypervisor, DiskContainers, Platform, Architecture, ClientToken, RoleName, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportImageRequest")
	local t = { 
		["LicenseType"] = LicenseType,
		["DryRun"] = DryRun,
		["Description"] = Description,
		["ClientData"] = ClientData,
		["Hypervisor"] = Hypervisor,
		["DiskContainers"] = DiskContainers,
		["Platform"] = Platform,
		["Architecture"] = Architecture,
		["ClientToken"] = ClientToken,
		["RoleName"] = RoleName,
	}
	M.AssertImportImageRequest(t)
	return t
end

local DescribeReservedInstancesOfferingsResult_keys = { "NextToken" = true, "ReservedInstancesOfferings" = true, nil }

function M.AssertDescribeReservedInstancesOfferingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesOfferingsResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesOfferings"] then M.AssertReservedInstancesOfferingList(struct["ReservedInstancesOfferings"]) end
	for k,_ in pairs(struct) do
		assert(DescribeReservedInstancesOfferingsResult_keys[k], "DescribeReservedInstancesOfferingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesOfferingsResult
-- <p>Contains the output of DescribeReservedInstancesOfferings.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param ReservedInstancesOfferings [ReservedInstancesOfferingList] <p>A list of Reserved Instances offerings.</p>
function M.DescribeReservedInstancesOfferingsResult(NextToken, ReservedInstancesOfferings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesOfferingsResult")
	local t = { 
		["NextToken"] = NextToken,
		["ReservedInstancesOfferings"] = ReservedInstancesOfferings,
	}
	M.AssertDescribeReservedInstancesOfferingsResult(t)
	return t
end

local ScheduledInstancesMonitoring_keys = { "Enabled" = true, nil }

function M.AssertScheduledInstancesMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesMonitoring to be of type 'table'")
	if struct["Enabled"] then M.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstancesMonitoring_keys[k], "ScheduledInstancesMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesMonitoring
-- <p>Describes whether monitoring is enabled for a Scheduled Instance.</p>
-- @param Enabled [Boolean] <p>Indicates whether monitoring is enabled.</p>
function M.ScheduledInstancesMonitoring(Enabled, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesMonitoring")
	local t = { 
		["Enabled"] = Enabled,
	}
	M.AssertScheduledInstancesMonitoring(t)
	return t
end

local ScheduledInstancesLaunchSpecification_keys = { "UserData" = true, "SubnetId" = true, "Monitoring" = true, "ImageId" = true, "KeyName" = true, "BlockDeviceMappings" = true, "EbsOptimized" = true, "SecurityGroupIds" = true, "RamdiskId" = true, "KernelId" = true, "Placement" = true, "IamInstanceProfile" = true, "InstanceType" = true, "NetworkInterfaces" = true, nil }

function M.AssertScheduledInstancesLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesLaunchSpecification to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["UserData"] then M.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then M.AssertScheduledInstancesMonitoring(struct["Monitoring"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then M.AssertScheduledInstancesBlockDeviceMappingSet(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then M.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroupIds"] then M.AssertScheduledInstancesSecurityGroupIdSet(struct["SecurityGroupIds"]) end
	if struct["RamdiskId"] then M.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then M.AssertString(struct["KernelId"]) end
	if struct["Placement"] then M.AssertScheduledInstancesPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then M.AssertScheduledInstancesIamInstanceProfile(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then M.AssertString(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then M.AssertScheduledInstancesNetworkInterfaceSet(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstancesLaunchSpecification_keys[k], "ScheduledInstancesLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesLaunchSpecification
-- <p>Describes the launch specification for a Scheduled Instance.</p> <p>If you are launching the Scheduled Instance in EC2-VPC, you must specify the ID of the subnet. You can specify the subnet using either <code>SubnetId</code> or <code>NetworkInterface</code>.</p>
-- @param UserData [String] <p>The base64-encoded MIME user data.</p>
-- @param SubnetId [String] <p>The ID of the subnet in which to launch the instances.</p>
-- @param Monitoring [ScheduledInstancesMonitoring] <p>Enable or disable monitoring for the instances.</p>
-- @param ImageId [String] <p>The ID of the Amazon Machine Image (AMI).</p>
-- @param KeyName [String] <p>The name of the key pair.</p>
-- @param BlockDeviceMappings [ScheduledInstancesBlockDeviceMappingSet] <p>One or more block device mapping entries.</p>
-- @param EbsOptimized [Boolean] <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param SecurityGroupIds [ScheduledInstancesSecurityGroupIdSet] <p>The IDs of one or more security groups.</p>
-- @param RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param KernelId [String] <p>The ID of the kernel.</p>
-- @param Placement [ScheduledInstancesPlacement] <p>The placement information.</p>
-- @param IamInstanceProfile [ScheduledInstancesIamInstanceProfile] <p>The IAM instance profile.</p>
-- @param InstanceType [String] <p>The instance type.</p>
-- @param NetworkInterfaces [ScheduledInstancesNetworkInterfaceSet] <p>One or more network interfaces.</p>
-- Required parameter: ImageId
function M.ScheduledInstancesLaunchSpecification(UserData, SubnetId, Monitoring, ImageId, KeyName, BlockDeviceMappings, EbsOptimized, SecurityGroupIds, RamdiskId, KernelId, Placement, IamInstanceProfile, InstanceType, NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesLaunchSpecification")
	local t = { 
		["UserData"] = UserData,
		["SubnetId"] = SubnetId,
		["Monitoring"] = Monitoring,
		["ImageId"] = ImageId,
		["KeyName"] = KeyName,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["EbsOptimized"] = EbsOptimized,
		["SecurityGroupIds"] = SecurityGroupIds,
		["RamdiskId"] = RamdiskId,
		["KernelId"] = KernelId,
		["Placement"] = Placement,
		["IamInstanceProfile"] = IamInstanceProfile,
		["InstanceType"] = InstanceType,
		["NetworkInterfaces"] = NetworkInterfaces,
	}
	M.AssertScheduledInstancesLaunchSpecification(t)
	return t
end

local InstanceCapacity_keys = { "AvailableCapacity" = true, "InstanceType" = true, "TotalCapacity" = true, nil }

function M.AssertInstanceCapacity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCapacity to be of type 'table'")
	if struct["AvailableCapacity"] then M.AssertInteger(struct["AvailableCapacity"]) end
	if struct["InstanceType"] then M.AssertString(struct["InstanceType"]) end
	if struct["TotalCapacity"] then M.AssertInteger(struct["TotalCapacity"]) end
	for k,_ in pairs(struct) do
		assert(InstanceCapacity_keys[k], "InstanceCapacity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCapacity
-- <p>Information about the instance type that the Dedicated Host supports.</p>
-- @param AvailableCapacity [Integer] <p>The number of instances that can still be launched onto the Dedicated Host.</p>
-- @param InstanceType [String] <p>The instance type size supported by the Dedicated Host.</p>
-- @param TotalCapacity [Integer] <p>The total number of instances that can be launched onto the Dedicated Host.</p>
function M.InstanceCapacity(AvailableCapacity, InstanceType, TotalCapacity, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceCapacity")
	local t = { 
		["AvailableCapacity"] = AvailableCapacity,
		["InstanceType"] = InstanceType,
		["TotalCapacity"] = TotalCapacity,
	}
	M.AssertInstanceCapacity(t)
	return t
end

local DescribeInstancesRequest_keys = { "MaxResults" = true, "NextToken" = true, "DryRun" = true, "InstanceIds" = true, "Filters" = true, nil }

function M.AssertDescribeInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancesRequest to be of type 'table'")
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then M.AssertInstanceIdStringList(struct["InstanceIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeInstancesRequest_keys[k], "DescribeInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancesRequest
-- <p>Contains the parameters for DescribeInstances.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter or tag filters in the same call.</p>
-- @param NextToken [String] <p>The token to request the next page of results.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Default: Describes all your instances.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>affinity</code> - The affinity setting for an instance running on a Dedicated Host (<code>default</code> | <code>host</code>).</p> </li> <li> <p> <code>architecture</code> - The instance architecture (<code>i386</code> | <code>x86_64</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>block-device-mapping.attach-time</code> - The attach time for an EBS volume mapped to the instance, for example, <code>2010-09-15T17:15:20.000Z</code>.</p> </li> <li> <p> <code>block-device-mapping.delete-on-termination</code> - A Boolean that indicates whether the EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>block-device-mapping.device-name</code> - The device name for the EBS volume (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p> </li> <li> <p> <code>block-device-mapping.status</code> - The status for the EBS volume (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>block-device-mapping.volume-id</code> - The volume ID of the EBS volume.</p> </li> <li> <p> <code>client-token</code> - The idempotency token you provided when you launched the instance.</p> </li> <li> <p> <code>dns-name</code> - The public DNS name of the instance.</p> </li> <li> <p> <code>group-id</code> - The ID of the security group for the instance. EC2-Classic only.</p> </li> <li> <p> <code>group-name</code> - The name of the security group for the instance. EC2-Classic only.</p> </li> <li> <p> <code>host-id</code> - The ID of the Dedicated Host on which the instance is running, if applicable.</p> </li> <li> <p> <code>hypervisor</code> - The hypervisor type of the instance (<code>ovm</code> | <code>xen</code>).</p> </li> <li> <p> <code>iam-instance-profile.arn</code> - The instance profile associated with the instance. Specified as an ARN.</p> </li> <li> <p> <code>image-id</code> - The ID of the image used to launch the instance.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>instance-lifecycle</code> - Indicates whether this is a Spot Instance or a Scheduled Instance (<code>spot</code> | <code>scheduled</code>).</p> </li> <li> <p> <code>instance-state-code</code> - The state of the instance, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are: 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).</p> </li> <li> <p> <code>instance-state-name</code> - The state of the instance (<code>pending</code> | <code>running</code> | <code>shutting-down</code> | <code>terminated</code> | <code>stopping</code> | <code>stopped</code>).</p> </li> <li> <p> <code>instance-type</code> - The type of instance (for example, <code>t2.micro</code>).</p> </li> <li> <p> <code>instance.group-id</code> - The ID of the security group for the instance. </p> </li> <li> <p> <code>instance.group-name</code> - The name of the security group for the instance. </p> </li> <li> <p> <code>ip-address</code> - The public IPv4 address of the instance.</p> </li> <li> <p> <code>kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>key-name</code> - The name of the key pair used when the instance was launched.</p> </li> <li> <p> <code>launch-index</code> - When launching multiple instances, this is the index for the instance in the launch group (for example, 0, 1, 2, and so on). </p> </li> <li> <p> <code>launch-time</code> - The time when the instance was launched.</p> </li> <li> <p> <code>monitoring-state</code> - Indicates whether detailed monitoring is enabled (<code>disabled</code> | <code>enabled</code>).</p> </li> <li> <p> <code>network-interface.addresses.private-ip-address</code> - The private IPv4 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.addresses.primary</code> - Specifies whether the IPv4 address of the network interface is the primary private IPv4 address.</p> </li> <li> <p> <code>network-interface.addresses.association.public-ip</code> - The ID of the association of an Elastic IP address (IPv4) with a network interface.</p> </li> <li> <p> <code>network-interface.addresses.association.ip-owner-id</code> - The owner ID of the private IPv4 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.association.public-ip</code> - The address of the Elastic IP address (IPv4) bound to the network interface.</p> </li> <li> <p> <code>network-interface.association.ip-owner-id</code> - The owner of the Elastic IP address (IPv4) associated with the network interface.</p> </li> <li> <p> <code>network-interface.association.allocation-id</code> - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.</p> </li> <li> <p> <code>network-interface.association.association-id</code> - The association ID returned when the network interface was associated with an IPv4 address.</p> </li> <li> <p> <code>network-interface.attachment.attachment-id</code> - The ID of the interface attachment.</p> </li> <li> <p> <code>network-interface.attachment.instance-id</code> - The ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.instance-owner-id</code> - The owner ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.device-index</code> - The device index to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.status</code> - The status of the attachment (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>network-interface.attachment.attach-time</code> - The time that the network interface was attached to an instance.</p> </li> <li> <p> <code>network-interface.attachment.delete-on-termination</code> - Specifies whether the attachment is deleted when an instance is terminated.</p> </li> <li> <p> <code>network-interface.availability-zone</code> - The Availability Zone for the network interface.</p> </li> <li> <p> <code>network-interface.description</code> - The description of the network interface.</p> </li> <li> <p> <code>network-interface.group-id</code> - The ID of a security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.group-name</code> - The name of a security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.ipv6-addresses.ipv6-address</code> - The IPv6 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.mac-address</code> - The MAC address of the network interface.</p> </li> <li> <p> <code>network-interface.network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>network-interface.owner-id</code> - The ID of the owner of the network interface.</p> </li> <li> <p> <code>network-interface.private-dns-name</code> - The private DNS name of the network interface.</p> </li> <li> <p> <code>network-interface.requester-id</code> - The requester ID for the network interface.</p> </li> <li> <p> <code>network-interface.requester-managed</code> - Indicates whether the network interface is being managed by AWS.</p> </li> <li> <p> <code>network-interface.status</code> - The status of the network interface (<code>available</code>) | <code>in-use</code>).</p> </li> <li> <p> <code>network-interface.source-dest-check</code> - Whether the network interface performs source/destination checking. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the network interface to perform network address translation (NAT) in your VPC.</p> </li> <li> <p> <code>network-interface.subnet-id</code> - The ID of the subnet for the network interface.</p> </li> <li> <p> <code>network-interface.vpc-id</code> - The ID of the VPC for the network interface.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the instance owner.</p> </li> <li> <p> <code>placement-group-name</code> - The name of the placement group for the instance.</p> </li> <li> <p> <code>platform</code> - The platform. Use <code>windows</code> if you have Windows instances; otherwise, leave blank.</p> </li> <li> <p> <code>private-dns-name</code> - The private IPv4 DNS name of the instance.</p> </li> <li> <p> <code>private-ip-address</code> - The private IPv4 address of the instance.</p> </li> <li> <p> <code>product-code</code> - The product code associated with the AMI used to launch the instance.</p> </li> <li> <p> <code>product-code.type</code> - The type of product code (<code>devpay</code> | <code>marketplace</code>).</p> </li> <li> <p> <code>ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>reason</code> - The reason for the current state of the instance (for example, shows "User Initiated [date]" when you stop or terminate the instance). Similar to the state-reason-code filter.</p> </li> <li> <p> <code>requester-id</code> - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>reservation-id</code> - The ID of the instance's reservation. A reservation ID is created any time you launch an instance. A reservation ID has a one-to-one relationship with an instance launch request, but can be associated with more than one instance if you launch multiple instances using the same launch request. For example, if you launch one instance, you'll get one reservation ID. If you launch ten instances using the same launch request, you'll also get one reservation ID.</p> </li> <li> <p> <code>root-device-name</code> - The name of the root device for the instance (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p> </li> <li> <p> <code>root-device-type</code> - The type of root device that the instance uses (<code>ebs</code> | <code>instance-store</code>).</p> </li> <li> <p> <code>source-dest-check</code> - Indicates whether the instance performs source/destination checking. A value of <code>true</code> means that checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the instance to perform network address translation (NAT) in your VPC. </p> </li> <li> <p> <code>spot-instance-request-id</code> - The ID of the Spot instance request.</p> </li> <li> <p> <code>state-reason-code</code> - The reason code for the state change.</p> </li> <li> <p> <code>state-reason-message</code> - A message that describes the state change.</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet for the instance.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>tenancy</code> - The tenancy of an instance (<code>dedicated</code> | <code>default</code> | <code>host</code>).</p> </li> <li> <p> <code>virtualization-type</code> - The virtualization type of the instance (<code>paravirtual</code> | <code>hvm</code>).</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC that the instance is running in.</p> </li> </ul>
function M.DescribeInstancesRequest(MaxResults, NextToken, DryRun, InstanceIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstancesRequest")
	local t = { 
		["MaxResults"] = MaxResults,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["InstanceIds"] = InstanceIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeInstancesRequest(t)
	return t
end

local ReservedInstancesModificationResult_keys = { "ReservedInstancesId" = true, "TargetConfiguration" = true, nil }

function M.AssertReservedInstancesModificationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesModificationResult to be of type 'table'")
	if struct["ReservedInstancesId"] then M.AssertString(struct["ReservedInstancesId"]) end
	if struct["TargetConfiguration"] then M.AssertReservedInstancesConfiguration(struct["TargetConfiguration"]) end
	for k,_ in pairs(struct) do
		assert(ReservedInstancesModificationResult_keys[k], "ReservedInstancesModificationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesModificationResult
-- <p>Describes the modification request/s.</p>
-- @param ReservedInstancesId [String] <p>The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.</p>
-- @param TargetConfiguration [ReservedInstancesConfiguration] <p>The target Reserved Instances configurations supplied as part of the modification request.</p>
function M.ReservedInstancesModificationResult(ReservedInstancesId, TargetConfiguration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesModificationResult")
	local t = { 
		["ReservedInstancesId"] = ReservedInstancesId,
		["TargetConfiguration"] = TargetConfiguration,
	}
	M.AssertReservedInstancesModificationResult(t)
	return t
end

local CreateRouteTableRequest_keys = { "VpcId" = true, "DryRun" = true, nil }

function M.AssertCreateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteTableRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(CreateRouteTableRequest_keys[k], "CreateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteTableRequest
-- <p>Contains the parameters for CreateRouteTable.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.CreateRouteTableRequest(VpcId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateRouteTableRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
	}
	M.AssertCreateRouteTableRequest(t)
	return t
end

local DescribeSpotDatafeedSubscriptionResult_keys = { "SpotDatafeedSubscription" = true, nil }

function M.AssertDescribeSpotDatafeedSubscriptionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotDatafeedSubscriptionResult to be of type 'table'")
	if struct["SpotDatafeedSubscription"] then M.AssertSpotDatafeedSubscription(struct["SpotDatafeedSubscription"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotDatafeedSubscriptionResult_keys[k], "DescribeSpotDatafeedSubscriptionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotDatafeedSubscriptionResult
-- <p>Contains the output of DescribeSpotDatafeedSubscription.</p>
-- @param SpotDatafeedSubscription [SpotDatafeedSubscription] <p>The Spot instance data feed subscription.</p>
function M.DescribeSpotDatafeedSubscriptionResult(SpotDatafeedSubscription, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotDatafeedSubscriptionResult")
	local t = { 
		["SpotDatafeedSubscription"] = SpotDatafeedSubscription,
	}
	M.AssertDescribeSpotDatafeedSubscriptionResult(t)
	return t
end

local DescribeCustomerGatewaysRequest_keys = { "CustomerGatewayIds" = true, "DryRun" = true, "Filters" = true, nil }

function M.AssertDescribeCustomerGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCustomerGatewaysRequest to be of type 'table'")
	if struct["CustomerGatewayIds"] then M.AssertCustomerGatewayIdStringList(struct["CustomerGatewayIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeCustomerGatewaysRequest_keys[k], "DescribeCustomerGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCustomerGatewaysRequest
-- <p>Contains the parameters for DescribeCustomerGateways.</p>
-- @param CustomerGatewayIds [CustomerGatewayIdStringList] <p>One or more customer gateway IDs.</p> <p>Default: Describes all your customer gateways.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>bgp-asn</code> - The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p> </li> <li> <p> <code>customer-gateway-id</code> - The ID of the customer gateway.</p> </li> <li> <p> <code>ip-address</code> - The IP address of the customer gateway's Internet-routable external interface.</p> </li> <li> <p> <code>state</code> - The state of the customer gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>type</code> - The type of customer gateway. Currently, the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
function M.DescribeCustomerGatewaysRequest(CustomerGatewayIds, DryRun, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeCustomerGatewaysRequest")
	local t = { 
		["CustomerGatewayIds"] = CustomerGatewayIds,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
	}
	M.AssertDescribeCustomerGatewaysRequest(t)
	return t
end

local CancelledSpotInstanceRequest_keys = { "State" = true, "SpotInstanceRequestId" = true, nil }

function M.AssertCancelledSpotInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelledSpotInstanceRequest to be of type 'table'")
	if struct["State"] then M.AssertCancelSpotInstanceRequestState(struct["State"]) end
	if struct["SpotInstanceRequestId"] then M.AssertString(struct["SpotInstanceRequestId"]) end
	for k,_ in pairs(struct) do
		assert(CancelledSpotInstanceRequest_keys[k], "CancelledSpotInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelledSpotInstanceRequest
-- <p>Describes a request to cancel a Spot instance.</p>
-- @param State [CancelSpotInstanceRequestState] <p>The state of the Spot instance request.</p>
-- @param SpotInstanceRequestId [String] <p>The ID of the Spot instance request.</p>
function M.CancelledSpotInstanceRequest(State, SpotInstanceRequestId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelledSpotInstanceRequest")
	local t = { 
		["State"] = State,
		["SpotInstanceRequestId"] = SpotInstanceRequestId,
	}
	M.AssertCancelledSpotInstanceRequest(t)
	return t
end

local ScheduledInstanceAvailability_keys = { "AvailabilityZone" = true, "TotalScheduledInstanceHours" = true, "HourlyPrice" = true, "MinTermDurationInDays" = true, "AvailableInstanceCount" = true, "SlotDurationInHours" = true, "Recurrence" = true, "MaxTermDurationInDays" = true, "FirstSlotStartTime" = true, "Platform" = true, "NetworkPlatform" = true, "InstanceType" = true, "PurchaseToken" = true, nil }

function M.AssertScheduledInstanceAvailability(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceAvailability to be of type 'table'")
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["TotalScheduledInstanceHours"] then M.AssertInteger(struct["TotalScheduledInstanceHours"]) end
	if struct["HourlyPrice"] then M.AssertString(struct["HourlyPrice"]) end
	if struct["MinTermDurationInDays"] then M.AssertInteger(struct["MinTermDurationInDays"]) end
	if struct["AvailableInstanceCount"] then M.AssertInteger(struct["AvailableInstanceCount"]) end
	if struct["SlotDurationInHours"] then M.AssertInteger(struct["SlotDurationInHours"]) end
	if struct["Recurrence"] then M.AssertScheduledInstanceRecurrence(struct["Recurrence"]) end
	if struct["MaxTermDurationInDays"] then M.AssertInteger(struct["MaxTermDurationInDays"]) end
	if struct["FirstSlotStartTime"] then M.AssertDateTime(struct["FirstSlotStartTime"]) end
	if struct["Platform"] then M.AssertString(struct["Platform"]) end
	if struct["NetworkPlatform"] then M.AssertString(struct["NetworkPlatform"]) end
	if struct["InstanceType"] then M.AssertString(struct["InstanceType"]) end
	if struct["PurchaseToken"] then M.AssertString(struct["PurchaseToken"]) end
	for k,_ in pairs(struct) do
		assert(ScheduledInstanceAvailability_keys[k], "ScheduledInstanceAvailability contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceAvailability
-- <p>Describes a schedule that is available for your Scheduled Instances.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone.</p>
-- @param TotalScheduledInstanceHours [Integer] <p>The total number of hours for a single instance for the entire term.</p>
-- @param HourlyPrice [String] <p>The hourly price for a single instance.</p>
-- @param MinTermDurationInDays [Integer] <p>The minimum term. The only possible value is 365 days.</p>
-- @param AvailableInstanceCount [Integer] <p>The number of available instances.</p>
-- @param SlotDurationInHours [Integer] <p>The number of hours in the schedule.</p>
-- @param Recurrence [ScheduledInstanceRecurrence] <p>The schedule recurrence.</p>
-- @param MaxTermDurationInDays [Integer] <p>The maximum term. The only possible value is 365 days.</p>
-- @param FirstSlotStartTime [DateTime] <p>The time period for the first schedule to start.</p>
-- @param Platform [String] <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
-- @param NetworkPlatform [String] <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
-- @param InstanceType [String] <p>The instance type. You can specify one of the C3, C4, M4, or R3 instance types.</p>
-- @param PurchaseToken [String] <p>The purchase token. This token expires in two hours.</p>
function M.ScheduledInstanceAvailability(AvailabilityZone, TotalScheduledInstanceHours, HourlyPrice, MinTermDurationInDays, AvailableInstanceCount, SlotDurationInHours, Recurrence, MaxTermDurationInDays, FirstSlotStartTime, Platform, NetworkPlatform, InstanceType, PurchaseToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstanceAvailability")
	local t = { 
		["AvailabilityZone"] = AvailabilityZone,
		["TotalScheduledInstanceHours"] = TotalScheduledInstanceHours,
		["HourlyPrice"] = HourlyPrice,
		["MinTermDurationInDays"] = MinTermDurationInDays,
		["AvailableInstanceCount"] = AvailableInstanceCount,
		["SlotDurationInHours"] = SlotDurationInHours,
		["Recurrence"] = Recurrence,
		["MaxTermDurationInDays"] = MaxTermDurationInDays,
		["FirstSlotStartTime"] = FirstSlotStartTime,
		["Platform"] = Platform,
		["NetworkPlatform"] = NetworkPlatform,
		["InstanceType"] = InstanceType,
		["PurchaseToken"] = PurchaseToken,
	}
	M.AssertScheduledInstanceAvailability(t)
	return t
end

local DescribeSnapshotsResult_keys = { "NextToken" = true, "Snapshots" = true, nil }

function M.AssertDescribeSnapshotsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotsResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["Snapshots"] then M.AssertSnapshotList(struct["Snapshots"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSnapshotsResult_keys[k], "DescribeSnapshotsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotsResult
-- <p>Contains the output of DescribeSnapshots.</p>
-- @param NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeSnapshots</code> request. When the results of a <code>DescribeSnapshots</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param Snapshots [SnapshotList] <p>Information about the snapshots.</p>
function M.DescribeSnapshotsResult(NextToken, Snapshots, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSnapshotsResult")
	local t = { 
		["NextToken"] = NextToken,
		["Snapshots"] = Snapshots,
	}
	M.AssertDescribeSnapshotsResult(t)
	return t
end

local DeleteInternetGatewayRequest_keys = { "DryRun" = true, "InternetGatewayId" = true, nil }

function M.AssertDeleteInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then M.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(DeleteInternetGatewayRequest_keys[k], "DeleteInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteInternetGatewayRequest
-- <p>Contains the parameters for DeleteInternetGateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- Required parameter: InternetGatewayId
function M.DeleteInternetGatewayRequest(DryRun, InternetGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteInternetGatewayRequest")
	local t = { 
		["DryRun"] = DryRun,
		["InternetGatewayId"] = InternetGatewayId,
	}
	M.AssertDeleteInternetGatewayRequest(t)
	return t
end

local UnmonitorInstancesResult_keys = { "InstanceMonitorings" = true, nil }

function M.AssertUnmonitorInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnmonitorInstancesResult to be of type 'table'")
	if struct["InstanceMonitorings"] then M.AssertInstanceMonitoringList(struct["InstanceMonitorings"]) end
	for k,_ in pairs(struct) do
		assert(UnmonitorInstancesResult_keys[k], "UnmonitorInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnmonitorInstancesResult
-- <p>Contains the output of UnmonitorInstances.</p>
-- @param InstanceMonitorings [InstanceMonitoringList] <p>The monitoring information.</p>
function M.UnmonitorInstancesResult(InstanceMonitorings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnmonitorInstancesResult")
	local t = { 
		["InstanceMonitorings"] = InstanceMonitorings,
	}
	M.AssertUnmonitorInstancesResult(t)
	return t
end

local StaleIpPermission_keys = { "PrefixListIds" = true, "FromPort" = true, "IpRanges" = true, "ToPort" = true, "IpProtocol" = true, "UserIdGroupPairs" = true, nil }

function M.AssertStaleIpPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StaleIpPermission to be of type 'table'")
	if struct["PrefixListIds"] then M.AssertPrefixListIdSet(struct["PrefixListIds"]) end
	if struct["FromPort"] then M.AssertInteger(struct["FromPort"]) end
	if struct["IpRanges"] then M.AssertIpRanges(struct["IpRanges"]) end
	if struct["ToPort"] then M.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then M.AssertString(struct["IpProtocol"]) end
	if struct["UserIdGroupPairs"] then M.AssertUserIdGroupPairSet(struct["UserIdGroupPairs"]) end
	for k,_ in pairs(struct) do
		assert(StaleIpPermission_keys[k], "StaleIpPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StaleIpPermission
-- <p>Describes a stale rule in a security group.</p>
-- @param PrefixListIds [PrefixListIdSet] <p>One or more prefix list IDs for an AWS service. Not applicable for stale security group rules.</p>
-- @param FromPort [Integer] <p>The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>
-- @param IpRanges [IpRanges] <p>One or more IP ranges. Not applicable for stale security group rules.</p>
-- @param ToPort [Integer] <p>The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>
-- @param IpProtocol [String] <p>The IP protocol name (for <code>tcp</code>, <code>udp</code>, and <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers)</a>.</p>
-- @param UserIdGroupPairs [UserIdGroupPairSet] <p>One or more security group pairs. Returns the ID of the referenced security group and VPC, and the ID and status of the VPC peering connection.</p>
function M.StaleIpPermission(PrefixListIds, FromPort, IpRanges, ToPort, IpProtocol, UserIdGroupPairs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StaleIpPermission")
	local t = { 
		["PrefixListIds"] = PrefixListIds,
		["FromPort"] = FromPort,
		["IpRanges"] = IpRanges,
		["ToPort"] = ToPort,
		["IpProtocol"] = IpProtocol,
		["UserIdGroupPairs"] = UserIdGroupPairs,
	}
	M.AssertStaleIpPermission(t)
	return t
end

local DescribeRegionsRequest_keys = { "DryRun" = true, "Filters" = true, "RegionNames" = true, nil }

function M.AssertDescribeRegionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRegionsRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["RegionNames"] then M.AssertRegionNameStringList(struct["RegionNames"]) end
	for k,_ in pairs(struct) do
		assert(DescribeRegionsRequest_keys[k], "DescribeRegionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRegionsRequest
-- <p>Contains the parameters for DescribeRegions.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>endpoint</code> - The endpoint of the region (for example, <code>ec2.us-east-1.amazonaws.com</code>).</p> </li> <li> <p> <code>region-name</code> - The name of the region (for example, <code>us-east-1</code>).</p> </li> </ul>
-- @param RegionNames [RegionNameStringList] <p>The names of one or more regions.</p>
function M.DescribeRegionsRequest(DryRun, Filters, RegionNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeRegionsRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Filters"] = Filters,
		["RegionNames"] = RegionNames,
	}
	M.AssertDescribeRegionsRequest(t)
	return t
end

local CancelSpotFleetRequestsResponse_keys = { "SuccessfulFleetRequests" = true, "UnsuccessfulFleetRequests" = true, nil }

function M.AssertCancelSpotFleetRequestsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsResponse to be of type 'table'")
	if struct["SuccessfulFleetRequests"] then M.AssertCancelSpotFleetRequestsSuccessSet(struct["SuccessfulFleetRequests"]) end
	if struct["UnsuccessfulFleetRequests"] then M.AssertCancelSpotFleetRequestsErrorSet(struct["UnsuccessfulFleetRequests"]) end
	for k,_ in pairs(struct) do
		assert(CancelSpotFleetRequestsResponse_keys[k], "CancelSpotFleetRequestsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsResponse
-- <p>Contains the output of CancelSpotFleetRequests.</p>
-- @param SuccessfulFleetRequests [CancelSpotFleetRequestsSuccessSet] <p>Information about the Spot fleet requests that are successfully canceled.</p>
-- @param UnsuccessfulFleetRequests [CancelSpotFleetRequestsErrorSet] <p>Information about the Spot fleet requests that are not successfully canceled.</p>
function M.CancelSpotFleetRequestsResponse(SuccessfulFleetRequests, UnsuccessfulFleetRequests, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsResponse")
	local t = { 
		["SuccessfulFleetRequests"] = SuccessfulFleetRequests,
		["UnsuccessfulFleetRequests"] = UnsuccessfulFleetRequests,
	}
	M.AssertCancelSpotFleetRequestsResponse(t)
	return t
end

local PlacementGroup_keys = { "GroupName" = true, "State" = true, "Strategy" = true, nil }

function M.AssertPlacementGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PlacementGroup to be of type 'table'")
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["State"] then M.AssertPlacementGroupState(struct["State"]) end
	if struct["Strategy"] then M.AssertPlacementStrategy(struct["Strategy"]) end
	for k,_ in pairs(struct) do
		assert(PlacementGroup_keys[k], "PlacementGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PlacementGroup
-- <p>Describes a placement group.</p>
-- @param GroupName [String] <p>The name of the placement group.</p>
-- @param State [PlacementGroupState] <p>The state of the placement group.</p>
-- @param Strategy [PlacementStrategy] <p>The placement strategy.</p>
function M.PlacementGroup(GroupName, State, Strategy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PlacementGroup")
	local t = { 
		["GroupName"] = GroupName,
		["State"] = State,
		["Strategy"] = Strategy,
	}
	M.AssertPlacementGroup(t)
	return t
end

local AssociateIamInstanceProfileRequest_keys = { "InstanceId" = true, "IamInstanceProfile" = true, nil }

function M.AssertAssociateIamInstanceProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateIamInstanceProfileRequest to be of type 'table'")
	assert(struct["IamInstanceProfile"], "Expected key IamInstanceProfile to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["IamInstanceProfile"] then M.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(AssociateIamInstanceProfileRequest_keys[k], "AssociateIamInstanceProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateIamInstanceProfileRequest
--  
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- Required parameter: IamInstanceProfile
-- Required parameter: InstanceId
function M.AssociateIamInstanceProfileRequest(InstanceId, IamInstanceProfile, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateIamInstanceProfileRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["IamInstanceProfile"] = IamInstanceProfile,
	}
	M.AssertAssociateIamInstanceProfileRequest(t)
	return t
end

local CreateNatGatewayRequest_keys = { "SubnetId" = true, "AllocationId" = true, "ClientToken" = true, nil }

function M.AssertCreateNatGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNatGatewayRequest to be of type 'table'")
	assert(struct["AllocationId"], "Expected key AllocationId to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["AllocationId"] then M.AssertString(struct["AllocationId"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(CreateNatGatewayRequest_keys[k], "CreateNatGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNatGatewayRequest
-- <p>Contains the parameters for CreateNatGateway.</p>
-- @param SubnetId [String] <p>The subnet in which to create the NAT gateway.</p>
-- @param AllocationId [String] <p>The allocation ID of an Elastic IP address to associate with the NAT gateway. If the Elastic IP address is associated with another resource, you must first disassociate it.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p> <p>Constraint: Maximum 64 ASCII characters.</p>
-- Required parameter: AllocationId
-- Required parameter: SubnetId
function M.CreateNatGatewayRequest(SubnetId, AllocationId, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNatGatewayRequest")
	local t = { 
		["SubnetId"] = SubnetId,
		["AllocationId"] = AllocationId,
		["ClientToken"] = ClientToken,
	}
	M.AssertCreateNatGatewayRequest(t)
	return t
end

local PricingDetail_keys = { "Count" = true, "Price" = true, nil }

function M.AssertPricingDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PricingDetail to be of type 'table'")
	if struct["Count"] then M.AssertInteger(struct["Count"]) end
	if struct["Price"] then M.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(PricingDetail_keys[k], "PricingDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PricingDetail
-- <p>Describes a Reserved Instance offering.</p>
-- @param Count [Integer] <p>The number of reservations available for the price.</p>
-- @param Price [Double] <p>The price per instance.</p>
function M.PricingDetail(Count, Price, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PricingDetail")
	local t = { 
		["Count"] = Count,
		["Price"] = Price,
	}
	M.AssertPricingDetail(t)
	return t
end

local UnassignIpv6AddressesRequest_keys = { "Ipv6Addresses" = true, "NetworkInterfaceId" = true, nil }

function M.AssertUnassignIpv6AddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignIpv6AddressesRequest to be of type 'table'")
	assert(struct["Ipv6Addresses"], "Expected key Ipv6Addresses to exist in table")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Ipv6Addresses"] then M.AssertIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(UnassignIpv6AddressesRequest_keys[k], "UnassignIpv6AddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignIpv6AddressesRequest
--  
-- @param Ipv6Addresses [Ipv6AddressList] <p>The IPv6 addresses to unassign from the network interface.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- Required parameter: Ipv6Addresses
-- Required parameter: NetworkInterfaceId
function M.UnassignIpv6AddressesRequest(Ipv6Addresses, NetworkInterfaceId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnassignIpv6AddressesRequest")
	local t = { 
		["Ipv6Addresses"] = Ipv6Addresses,
		["NetworkInterfaceId"] = NetworkInterfaceId,
	}
	M.AssertUnassignIpv6AddressesRequest(t)
	return t
end

local EnableVpcClassicLinkResult_keys = { "Return" = true, nil }

function M.AssertEnableVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(EnableVpcClassicLinkResult_keys[k], "EnableVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkResult
-- <p>Contains the output of EnableVpcClassicLink.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.EnableVpcClassicLinkResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVpcClassicLinkResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertEnableVpcClassicLinkResult(t)
	return t
end

local SpotPlacement_keys = { "Tenancy" = true, "GroupName" = true, "AvailabilityZone" = true, nil }

function M.AssertSpotPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotPlacement to be of type 'table'")
	if struct["Tenancy"] then M.AssertTenancy(struct["Tenancy"]) end
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(SpotPlacement_keys[k], "SpotPlacement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotPlacement
-- <p>Describes Spot instance placement.</p>
-- @param Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for Spot instances.</p>
-- @param GroupName [String] <p>The name of the placement group (for cluster instances).</p>
-- @param AvailabilityZone [String] <p>The Availability Zone.</p> <p>[Spot fleet only] To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".</p>
function M.SpotPlacement(Tenancy, GroupName, AvailabilityZone, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotPlacement")
	local t = { 
		["Tenancy"] = Tenancy,
		["GroupName"] = GroupName,
		["AvailabilityZone"] = AvailabilityZone,
	}
	M.AssertSpotPlacement(t)
	return t
end

local DeleteVpcEndpointsResult_keys = { "Unsuccessful" = true, nil }

function M.AssertDeleteVpcEndpointsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointsResult to be of type 'table'")
	if struct["Unsuccessful"] then M.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(DeleteVpcEndpointsResult_keys[k], "DeleteVpcEndpointsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointsResult
-- <p>Contains the output of DeleteVpcEndpoints.</p>
-- @param Unsuccessful [UnsuccessfulItemSet] <p>Information about the endpoints that were not successfully deleted.</p>
function M.DeleteVpcEndpointsResult(Unsuccessful, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcEndpointsResult")
	local t = { 
		["Unsuccessful"] = Unsuccessful,
	}
	M.AssertDeleteVpcEndpointsResult(t)
	return t
end

local EbsInstanceBlockDevice_keys = { "Status" = true, "DeleteOnTermination" = true, "VolumeId" = true, "AttachTime" = true, nil }

function M.AssertEbsInstanceBlockDevice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsInstanceBlockDevice to be of type 'table'")
	if struct["Status"] then M.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	if struct["AttachTime"] then M.AssertDateTime(struct["AttachTime"]) end
	for k,_ in pairs(struct) do
		assert(EbsInstanceBlockDevice_keys[k], "EbsInstanceBlockDevice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsInstanceBlockDevice
-- <p>Describes a parameter used to set up an EBS volume in a block device mapping.</p>
-- @param Status [AttachmentStatus] <p>The attachment state.</p>
-- @param DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- @param VolumeId [String] <p>The ID of the EBS volume.</p>
-- @param AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
function M.EbsInstanceBlockDevice(Status, DeleteOnTermination, VolumeId, AttachTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EbsInstanceBlockDevice")
	local t = { 
		["Status"] = Status,
		["DeleteOnTermination"] = DeleteOnTermination,
		["VolumeId"] = VolumeId,
		["AttachTime"] = AttachTime,
	}
	M.AssertEbsInstanceBlockDevice(t)
	return t
end

local VolumeStatusDetails_keys = { "Status" = true, "Name" = true, nil }

function M.AssertVolumeStatusDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusDetails to be of type 'table'")
	if struct["Status"] then M.AssertString(struct["Status"]) end
	if struct["Name"] then M.AssertVolumeStatusName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(VolumeStatusDetails_keys[k], "VolumeStatusDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusDetails
-- <p>Describes a volume status.</p>
-- @param Status [String] <p>The intended status of the volume status.</p>
-- @param Name [VolumeStatusName] <p>The name of the volume status.</p>
function M.VolumeStatusDetails(Status, Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusDetails")
	local t = { 
		["Status"] = Status,
		["Name"] = Name,
	}
	M.AssertVolumeStatusDetails(t)
	return t
end

local DescribeHostReservationOfferingsRequest_keys = { "OfferingId" = true, "MaxResults" = true, "Filter" = true, "MinDuration" = true, "NextToken" = true, "MaxDuration" = true, nil }

function M.AssertDescribeHostReservationOfferingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationOfferingsRequest to be of type 'table'")
	if struct["OfferingId"] then M.AssertString(struct["OfferingId"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filter"] then M.AssertFilterList(struct["Filter"]) end
	if struct["MinDuration"] then M.AssertInteger(struct["MinDuration"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["MaxDuration"] then M.AssertInteger(struct["MaxDuration"]) end
	for k,_ in pairs(struct) do
		assert(DescribeHostReservationOfferingsRequest_keys[k], "DescribeHostReservationOfferingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationOfferingsRequest
--  
-- @param OfferingId [String] <p>The ID of the reservation offering.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500; if <code>maxResults</code> is given a larger value than 500, you will receive an error.</p>
-- @param Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-family</code> - The instance family of the offering (e.g., <code>m4</code>).</p> </li> <li> <p> <code>payment-option</code> - The payment option (<code>NoUpfront</code> | <code>PartialUpfront</code> | <code>AllUpfront</code>).</p> </li> </ul>
-- @param MinDuration [Integer] <p>This is the minimum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 31536000 for one year.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- @param MaxDuration [Integer] <p>This is the maximum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 94608000 for three years.</p>
function M.DescribeHostReservationOfferingsRequest(OfferingId, MaxResults, Filter, MinDuration, NextToken, MaxDuration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostReservationOfferingsRequest")
	local t = { 
		["OfferingId"] = OfferingId,
		["MaxResults"] = MaxResults,
		["Filter"] = Filter,
		["MinDuration"] = MinDuration,
		["NextToken"] = NextToken,
		["MaxDuration"] = MaxDuration,
	}
	M.AssertDescribeHostReservationOfferingsRequest(t)
	return t
end

local StartInstancesResult_keys = { "StartingInstances" = true, nil }

function M.AssertStartInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartInstancesResult to be of type 'table'")
	if struct["StartingInstances"] then M.AssertInstanceStateChangeList(struct["StartingInstances"]) end
	for k,_ in pairs(struct) do
		assert(StartInstancesResult_keys[k], "StartInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartInstancesResult
-- <p>Contains the output of StartInstances.</p>
-- @param StartingInstances [InstanceStateChangeList] <p>Information about one or more started instances.</p>
function M.StartInstancesResult(StartingInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StartInstancesResult")
	local t = { 
		["StartingInstances"] = StartingInstances,
	}
	M.AssertStartInstancesResult(t)
	return t
end

local Address_keys = { "Domain" = true, "InstanceId" = true, "NetworkInterfaceId" = true, "AssociationId" = true, "NetworkInterfaceOwnerId" = true, "PublicIp" = true, "AllocationId" = true, "PrivateIpAddress" = true, nil }

function M.AssertAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Address to be of type 'table'")
	if struct["Domain"] then M.AssertDomainType(struct["Domain"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["NetworkInterfaceOwnerId"] then M.AssertString(struct["NetworkInterfaceOwnerId"]) end
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["AllocationId"] then M.AssertString(struct["AllocationId"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(Address_keys[k], "Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Address
-- <p>Describes an Elastic IP address.</p>
-- @param Domain [DomainType] <p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
-- @param InstanceId [String] <p>The ID of the instance that the address is associated with (if any).</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param AssociationId [String] <p>The ID representing the association of the address with an instance in a VPC.</p>
-- @param NetworkInterfaceOwnerId [String] <p>The ID of the AWS account that owns the network interface.</p>
-- @param PublicIp [String] <p>The Elastic IP address.</p>
-- @param AllocationId [String] <p>The ID representing the allocation of the address for use with EC2-VPC.</p>
-- @param PrivateIpAddress [String] <p>The private IP address associated with the Elastic IP address.</p>
function M.Address(Domain, InstanceId, NetworkInterfaceId, AssociationId, NetworkInterfaceOwnerId, PublicIp, AllocationId, PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Address")
	local t = { 
		["Domain"] = Domain,
		["InstanceId"] = InstanceId,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["AssociationId"] = AssociationId,
		["NetworkInterfaceOwnerId"] = NetworkInterfaceOwnerId,
		["PublicIp"] = PublicIp,
		["AllocationId"] = AllocationId,
		["PrivateIpAddress"] = PrivateIpAddress,
	}
	M.AssertAddress(t)
	return t
end

local VpnGateway_keys = { "AvailabilityZone" = true, "Tags" = true, "VpcAttachments" = true, "State" = true, "VpnGatewayId" = true, "Type" = true, nil }

function M.AssertVpnGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnGateway to be of type 'table'")
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["VpcAttachments"] then M.AssertVpcAttachmentList(struct["VpcAttachments"]) end
	if struct["State"] then M.AssertVpnState(struct["State"]) end
	if struct["VpnGatewayId"] then M.AssertString(struct["VpnGatewayId"]) end
	if struct["Type"] then M.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(VpnGateway_keys[k], "VpnGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnGateway
-- <p>Describes a virtual private gateway.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.</p>
-- @param Tags [TagList] <p>Any tags assigned to the virtual private gateway.</p>
-- @param VpcAttachments [VpcAttachmentList] <p>Any VPCs attached to the virtual private gateway.</p>
-- @param State [VpnState] <p>The current state of the virtual private gateway.</p>
-- @param VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- @param Type [GatewayType] <p>The type of VPN connection the virtual private gateway supports.</p>
function M.VpnGateway(AvailabilityZone, Tags, VpcAttachments, State, VpnGatewayId, Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnGateway")
	local t = { 
		["AvailabilityZone"] = AvailabilityZone,
		["Tags"] = Tags,
		["VpcAttachments"] = VpcAttachments,
		["State"] = State,
		["VpnGatewayId"] = VpnGatewayId,
		["Type"] = Type,
	}
	M.AssertVpnGateway(t)
	return t
end

local ReleaseHostsRequest_keys = { "HostIds" = true, nil }

function M.AssertReleaseHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseHostsRequest to be of type 'table'")
	assert(struct["HostIds"], "Expected key HostIds to exist in table")
	if struct["HostIds"] then M.AssertRequestHostIdList(struct["HostIds"]) end
	for k,_ in pairs(struct) do
		assert(ReleaseHostsRequest_keys[k], "ReleaseHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseHostsRequest
-- <p>Contains the parameters for ReleaseHosts.</p>
-- @param HostIds [RequestHostIdList] <p>The IDs of the Dedicated Hosts you want to release.</p>
-- Required parameter: HostIds
function M.ReleaseHostsRequest(HostIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReleaseHostsRequest")
	local t = { 
		["HostIds"] = HostIds,
	}
	M.AssertReleaseHostsRequest(t)
	return t
end

local EbsInstanceBlockDeviceSpecification_keys = { "DeleteOnTermination" = true, "VolumeId" = true, nil }

function M.AssertEbsInstanceBlockDeviceSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsInstanceBlockDeviceSpecification to be of type 'table'")
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(EbsInstanceBlockDeviceSpecification_keys[k], "EbsInstanceBlockDeviceSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsInstanceBlockDeviceSpecification
-- <p>Describes information used to set up an EBS volume specified in a block device mapping.</p>
-- @param DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- @param VolumeId [String] <p>The ID of the EBS volume.</p>
function M.EbsInstanceBlockDeviceSpecification(DeleteOnTermination, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EbsInstanceBlockDeviceSpecification")
	local t = { 
		["DeleteOnTermination"] = DeleteOnTermination,
		["VolumeId"] = VolumeId,
	}
	M.AssertEbsInstanceBlockDeviceSpecification(t)
	return t
end

local EnableVolumeIORequest_keys = { "DryRun" = true, "VolumeId" = true, nil }

function M.AssertEnableVolumeIORequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVolumeIORequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(EnableVolumeIORequest_keys[k], "EnableVolumeIORequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVolumeIORequest
-- <p>Contains the parameters for EnableVolumeIO.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.EnableVolumeIORequest(DryRun, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVolumeIORequest")
	local t = { 
		["DryRun"] = DryRun,
		["VolumeId"] = VolumeId,
	}
	M.AssertEnableVolumeIORequest(t)
	return t
end

local DescribeScheduledInstancesResult_keys = { "NextToken" = true, "ScheduledInstanceSet" = true, nil }

function M.AssertDescribeScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstancesResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["ScheduledInstanceSet"] then M.AssertScheduledInstanceSet(struct["ScheduledInstanceSet"]) end
	for k,_ in pairs(struct) do
		assert(DescribeScheduledInstancesResult_keys[k], "DescribeScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstancesResult
-- <p>Contains the output of DescribeScheduledInstances.</p>
-- @param NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param ScheduledInstanceSet [ScheduledInstanceSet] <p>Information about the Scheduled Instances.</p>
function M.DescribeScheduledInstancesResult(NextToken, ScheduledInstanceSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeScheduledInstancesResult")
	local t = { 
		["NextToken"] = NextToken,
		["ScheduledInstanceSet"] = ScheduledInstanceSet,
	}
	M.AssertDescribeScheduledInstancesResult(t)
	return t
end

local AssociateVpcCidrBlockResult_keys = { "Ipv6CidrBlockAssociation" = true, "VpcId" = true, nil }

function M.AssertAssociateVpcCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateVpcCidrBlockResult to be of type 'table'")
	if struct["Ipv6CidrBlockAssociation"] then M.AssertVpcIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(AssociateVpcCidrBlockResult_keys[k], "AssociateVpcCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateVpcCidrBlockResult
--  
-- @param Ipv6CidrBlockAssociation [VpcIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
function M.AssociateVpcCidrBlockResult(Ipv6CidrBlockAssociation, VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateVpcCidrBlockResult")
	local t = { 
		["Ipv6CidrBlockAssociation"] = Ipv6CidrBlockAssociation,
		["VpcId"] = VpcId,
	}
	M.AssertAssociateVpcCidrBlockResult(t)
	return t
end

local PciId_keys = { "SubsystemVendorId" = true, "VendorId" = true, "DeviceId" = true, "SubsystemId" = true, nil }

function M.AssertPciId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PciId to be of type 'table'")
	if struct["SubsystemVendorId"] then M.AssertString(struct["SubsystemVendorId"]) end
	if struct["VendorId"] then M.AssertString(struct["VendorId"]) end
	if struct["DeviceId"] then M.AssertString(struct["DeviceId"]) end
	if struct["SubsystemId"] then M.AssertString(struct["SubsystemId"]) end
	for k,_ in pairs(struct) do
		assert(PciId_keys[k], "PciId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PciId
-- <p>Describes the data that identifies an Amazon FPGA image (AFI) on the PCI bus.</p>
-- @param SubsystemVendorId [String] <p>The ID of the vendor for the subsystem.</p>
-- @param VendorId [String] <p>The ID of the vendor.</p>
-- @param DeviceId [String] <p>The ID of the device.</p>
-- @param SubsystemId [String] <p>The ID of the subsystem.</p>
function M.PciId(SubsystemVendorId, VendorId, DeviceId, SubsystemId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PciId")
	local t = { 
		["SubsystemVendorId"] = SubsystemVendorId,
		["VendorId"] = VendorId,
		["DeviceId"] = DeviceId,
		["SubsystemId"] = SubsystemId,
	}
	M.AssertPciId(t)
	return t
end

local RequestSpotLaunchSpecification_keys = { "UserData" = true, "SubnetId" = true, "Monitoring" = true, "KeyName" = true, "SecurityGroupIds" = true, "ImageId" = true, "BlockDeviceMappings" = true, "EbsOptimized" = true, "SecurityGroups" = true, "RamdiskId" = true, "KernelId" = true, "Placement" = true, "IamInstanceProfile" = true, "InstanceType" = true, "AddressingType" = true, "NetworkInterfaces" = true, nil }

function M.AssertRequestSpotLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotLaunchSpecification to be of type 'table'")
	if struct["UserData"] then M.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then M.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["SecurityGroupIds"] then M.AssertValueStringList(struct["SecurityGroupIds"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["BlockDeviceMappings"] then M.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then M.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then M.AssertValueStringList(struct["SecurityGroups"]) end
	if struct["RamdiskId"] then M.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then M.AssertString(struct["KernelId"]) end
	if struct["Placement"] then M.AssertSpotPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then M.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then M.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then M.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(RequestSpotLaunchSpecification_keys[k], "RequestSpotLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotLaunchSpecification
-- <p>Describes the launch specification for an instance.</p>
-- @param UserData [String] <p>The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param SubnetId [String] <p>The ID of the subnet in which to launch the instance.</p>
-- @param Monitoring [RunInstancesMonitoringEnabled] <p>Indicates whether basic or detailed monitoring is enabled for the instance.</p> <p>Default: Disabled</p>
-- @param KeyName [String] <p>The name of the key pair.</p>
-- @param SecurityGroupIds [ValueStringList] <p>One or more security group IDs.</p>
-- @param ImageId [String] <p>The ID of the AMI.</p>
-- @param BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p> <p>Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.</p>
-- @param EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param SecurityGroups [ValueStringList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- @param RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param KernelId [String] <p>The ID of the kernel.</p>
-- @param Placement [SpotPlacement] <p>The placement information for the instance.</p>
-- @param IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- @param InstanceType [InstanceType] <p>The instance type.</p>
-- @param AddressingType [String] <p>Deprecated.</p>
-- @param NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
function M.RequestSpotLaunchSpecification(UserData, SubnetId, Monitoring, KeyName, SecurityGroupIds, ImageId, BlockDeviceMappings, EbsOptimized, SecurityGroups, RamdiskId, KernelId, Placement, IamInstanceProfile, InstanceType, AddressingType, NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotLaunchSpecification")
	local t = { 
		["UserData"] = UserData,
		["SubnetId"] = SubnetId,
		["Monitoring"] = Monitoring,
		["KeyName"] = KeyName,
		["SecurityGroupIds"] = SecurityGroupIds,
		["ImageId"] = ImageId,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["EbsOptimized"] = EbsOptimized,
		["SecurityGroups"] = SecurityGroups,
		["RamdiskId"] = RamdiskId,
		["KernelId"] = KernelId,
		["Placement"] = Placement,
		["IamInstanceProfile"] = IamInstanceProfile,
		["InstanceType"] = InstanceType,
		["AddressingType"] = AddressingType,
		["NetworkInterfaces"] = NetworkInterfaces,
	}
	M.AssertRequestSpotLaunchSpecification(t)
	return t
end

local CustomerGateway_keys = { "Tags" = true, "IpAddress" = true, "State" = true, "CustomerGatewayId" = true, "BgpAsn" = true, "Type" = true, nil }

function M.AssertCustomerGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CustomerGateway to be of type 'table'")
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["IpAddress"] then M.AssertString(struct["IpAddress"]) end
	if struct["State"] then M.AssertString(struct["State"]) end
	if struct["CustomerGatewayId"] then M.AssertString(struct["CustomerGatewayId"]) end
	if struct["BgpAsn"] then M.AssertString(struct["BgpAsn"]) end
	if struct["Type"] then M.AssertString(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(CustomerGateway_keys[k], "CustomerGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CustomerGateway
-- <p>Describes a customer gateway.</p>
-- @param Tags [TagList] <p>Any tags assigned to the customer gateway.</p>
-- @param IpAddress [String] <p>The Internet-routable IP address of the customer gateway's outside interface.</p>
-- @param State [String] <p>The current state of the customer gateway (<code>pending | available | deleting | deleted</code>).</p>
-- @param CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- @param BgpAsn [String] <p>The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p>
-- @param Type [String] <p>The type of VPN connection the customer gateway supports (<code>ipsec.1</code>).</p>
function M.CustomerGateway(Tags, IpAddress, State, CustomerGatewayId, BgpAsn, Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CustomerGateway")
	local t = { 
		["Tags"] = Tags,
		["IpAddress"] = IpAddress,
		["State"] = State,
		["CustomerGatewayId"] = CustomerGatewayId,
		["BgpAsn"] = BgpAsn,
		["Type"] = Type,
	}
	M.AssertCustomerGateway(t)
	return t
end

local CreateSpotDatafeedSubscriptionRequest_keys = { "DryRun" = true, "Prefix" = true, "Bucket" = true, nil }

function M.AssertCreateSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSpotDatafeedSubscriptionRequest to be of type 'table'")
	assert(struct["Bucket"], "Expected key Bucket to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Prefix"] then M.AssertString(struct["Prefix"]) end
	if struct["Bucket"] then M.AssertString(struct["Bucket"]) end
	for k,_ in pairs(struct) do
		assert(CreateSpotDatafeedSubscriptionRequest_keys[k], "CreateSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for CreateSpotDatafeedSubscription.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Prefix [String] <p>A prefix for the data feed file names.</p>
-- @param Bucket [String] <p>The Amazon S3 bucket in which to store the Spot instance data feed.</p>
-- Required parameter: Bucket
function M.CreateSpotDatafeedSubscriptionRequest(DryRun, Prefix, Bucket, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSpotDatafeedSubscriptionRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Prefix"] = Prefix,
		["Bucket"] = Bucket,
	}
	M.AssertCreateSpotDatafeedSubscriptionRequest(t)
	return t
end

local DeleteFlowLogsRequest_keys = { "FlowLogIds" = true, nil }

function M.AssertDeleteFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFlowLogsRequest to be of type 'table'")
	assert(struct["FlowLogIds"], "Expected key FlowLogIds to exist in table")
	if struct["FlowLogIds"] then M.AssertValueStringList(struct["FlowLogIds"]) end
	for k,_ in pairs(struct) do
		assert(DeleteFlowLogsRequest_keys[k], "DeleteFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFlowLogsRequest
-- <p>Contains the parameters for DeleteFlowLogs.</p>
-- @param FlowLogIds [ValueStringList] <p>One or more flow log IDs.</p>
-- Required parameter: FlowLogIds
function M.DeleteFlowLogsRequest(FlowLogIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteFlowLogsRequest")
	local t = { 
		["FlowLogIds"] = FlowLogIds,
	}
	M.AssertDeleteFlowLogsRequest(t)
	return t
end

local DescribeSpotFleetInstancesRequest_keys = { "SpotFleetRequestId" = true, "NextToken" = true, "DryRun" = true, "MaxResults" = true, nil }

function M.AssertDescribeSpotFleetInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetInstancesRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then M.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotFleetInstancesRequest_keys[k], "DescribeSpotFleetInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetInstancesRequest
-- <p>Contains the parameters for DescribeSpotFleetInstances.</p>
-- @param SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param NextToken [String] <p>The token for the next set of results.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- Required parameter: SpotFleetRequestId
function M.DescribeSpotFleetInstancesRequest(SpotFleetRequestId, NextToken, DryRun, MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetInstancesRequest")
	local t = { 
		["SpotFleetRequestId"] = SpotFleetRequestId,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
	}
	M.AssertDescribeSpotFleetInstancesRequest(t)
	return t
end

local AvailableCapacity_keys = { "AvailableInstanceCapacity" = true, "AvailableVCpus" = true, nil }

function M.AssertAvailableCapacity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailableCapacity to be of type 'table'")
	if struct["AvailableInstanceCapacity"] then M.AssertAvailableInstanceCapacityList(struct["AvailableInstanceCapacity"]) end
	if struct["AvailableVCpus"] then M.AssertInteger(struct["AvailableVCpus"]) end
	for k,_ in pairs(struct) do
		assert(AvailableCapacity_keys[k], "AvailableCapacity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailableCapacity
-- <p>The capacity information for instances launched onto the Dedicated Host.</p>
-- @param AvailableInstanceCapacity [AvailableInstanceCapacityList] <p>The total number of instances that the Dedicated Host supports.</p>
-- @param AvailableVCpus [Integer] <p>The number of vCPUs available on the Dedicated Host.</p>
function M.AvailableCapacity(AvailableInstanceCapacity, AvailableVCpus, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AvailableCapacity")
	local t = { 
		["AvailableInstanceCapacity"] = AvailableInstanceCapacity,
		["AvailableVCpus"] = AvailableVCpus,
	}
	M.AssertAvailableCapacity(t)
	return t
end

local LaunchPermissionModifications_keys = { "Add" = true, "Remove" = true, nil }

function M.AssertLaunchPermissionModifications(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchPermissionModifications to be of type 'table'")
	if struct["Add"] then M.AssertLaunchPermissionList(struct["Add"]) end
	if struct["Remove"] then M.AssertLaunchPermissionList(struct["Remove"]) end
	for k,_ in pairs(struct) do
		assert(LaunchPermissionModifications_keys[k], "LaunchPermissionModifications contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchPermissionModifications
-- <p>Describes a launch permission modification.</p>
-- @param Add [LaunchPermissionList] <p>The AWS account ID to add to the list of launch permissions for the AMI.</p>
-- @param Remove [LaunchPermissionList] <p>The AWS account ID to remove from the list of launch permissions for the AMI.</p>
function M.LaunchPermissionModifications(Add, Remove, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating LaunchPermissionModifications")
	local t = { 
		["Add"] = Add,
		["Remove"] = Remove,
	}
	M.AssertLaunchPermissionModifications(t)
	return t
end

local GetReservedInstancesExchangeQuoteRequest_keys = { "ReservedInstanceIds" = true, "DryRun" = true, "TargetConfigurations" = true, nil }

function M.AssertGetReservedInstancesExchangeQuoteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetReservedInstancesExchangeQuoteRequest to be of type 'table'")
	assert(struct["ReservedInstanceIds"], "Expected key ReservedInstanceIds to exist in table")
	if struct["ReservedInstanceIds"] then M.AssertReservedInstanceIdSet(struct["ReservedInstanceIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["TargetConfigurations"] then M.AssertTargetConfigurationRequestSet(struct["TargetConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(GetReservedInstancesExchangeQuoteRequest_keys[k], "GetReservedInstancesExchangeQuoteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetReservedInstancesExchangeQuoteRequest
-- <p>Contains the parameters for GetReservedInstanceExchangeQuote.</p>
-- @param ReservedInstanceIds [ReservedInstanceIdSet] <p>The IDs of the Convertible Reserved Instances to exchange.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param TargetConfigurations [TargetConfigurationRequestSet] <p>The configuration requirements of the Convertible Reserved Instances to exchange for your current Convertible Reserved Instances.</p>
-- Required parameter: ReservedInstanceIds
function M.GetReservedInstancesExchangeQuoteRequest(ReservedInstanceIds, DryRun, TargetConfigurations, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetReservedInstancesExchangeQuoteRequest")
	local t = { 
		["ReservedInstanceIds"] = ReservedInstanceIds,
		["DryRun"] = DryRun,
		["TargetConfigurations"] = TargetConfigurations,
	}
	M.AssertGetReservedInstancesExchangeQuoteRequest(t)
	return t
end

local VpnStaticRoute_keys = { "DestinationCidrBlock" = true, "State" = true, "Source" = true, nil }

function M.AssertVpnStaticRoute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnStaticRoute to be of type 'table'")
	if struct["DestinationCidrBlock"] then M.AssertString(struct["DestinationCidrBlock"]) end
	if struct["State"] then M.AssertVpnState(struct["State"]) end
	if struct["Source"] then M.AssertVpnStaticRouteSource(struct["Source"]) end
	for k,_ in pairs(struct) do
		assert(VpnStaticRoute_keys[k], "VpnStaticRoute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnStaticRoute
-- <p>Describes a static route for a VPN connection.</p>
-- @param DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer data center.</p>
-- @param State [VpnState] <p>The current state of the static route.</p>
-- @param Source [VpnStaticRouteSource] <p>Indicates how the routes were provided.</p>
function M.VpnStaticRoute(DestinationCidrBlock, State, Source, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnStaticRoute")
	local t = { 
		["DestinationCidrBlock"] = DestinationCidrBlock,
		["State"] = State,
		["Source"] = Source,
	}
	M.AssertVpnStaticRoute(t)
	return t
end

local DeleteVpcPeeringConnectionRequest_keys = { "DryRun" = true, "VpcPeeringConnectionId" = true, nil }

function M.AssertDeleteVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcPeeringConnectionRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(DeleteVpcPeeringConnectionRequest_keys[k], "DeleteVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcPeeringConnectionRequest
-- <p>Contains the parameters for DeleteVpcPeeringConnection.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required parameter: VpcPeeringConnectionId
function M.DeleteVpcPeeringConnectionRequest(DryRun, VpcPeeringConnectionId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcPeeringConnectionRequest")
	local t = { 
		["DryRun"] = DryRun,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
	}
	M.AssertDeleteVpcPeeringConnectionRequest(t)
	return t
end

local DescribeReservedInstancesModificationsResult_keys = { "NextToken" = true, "ReservedInstancesModifications" = true, nil }

function M.AssertDescribeReservedInstancesModificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesModificationsResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesModifications"] then M.AssertReservedInstancesModificationList(struct["ReservedInstancesModifications"]) end
	for k,_ in pairs(struct) do
		assert(DescribeReservedInstancesModificationsResult_keys[k], "DescribeReservedInstancesModificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesModificationsResult
-- <p>Contains the output of DescribeReservedInstancesModifications.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param ReservedInstancesModifications [ReservedInstancesModificationList] <p>The Reserved Instance modification information.</p>
function M.DescribeReservedInstancesModificationsResult(NextToken, ReservedInstancesModifications, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesModificationsResult")
	local t = { 
		["NextToken"] = NextToken,
		["ReservedInstancesModifications"] = ReservedInstancesModifications,
	}
	M.AssertDescribeReservedInstancesModificationsResult(t)
	return t
end

local IdFormat_keys = { "Resource" = true, "Deadline" = true, "UseLongIds" = true, nil }

function M.AssertIdFormat(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IdFormat to be of type 'table'")
	if struct["Resource"] then M.AssertString(struct["Resource"]) end
	if struct["Deadline"] then M.AssertDateTime(struct["Deadline"]) end
	if struct["UseLongIds"] then M.AssertBoolean(struct["UseLongIds"]) end
	for k,_ in pairs(struct) do
		assert(IdFormat_keys[k], "IdFormat contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IdFormat
-- <p>Describes the ID format for a resource.</p>
-- @param Resource [String] <p>The type of resource.</p>
-- @param Deadline [DateTime] <p>The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.</p>
-- @param UseLongIds [Boolean] <p>Indicates whether longer IDs (17-character IDs) are enabled for the resource.</p>
function M.IdFormat(Resource, Deadline, UseLongIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IdFormat")
	local t = { 
		["Resource"] = Resource,
		["Deadline"] = Deadline,
		["UseLongIds"] = UseLongIds,
	}
	M.AssertIdFormat(t)
	return t
end

local TargetConfigurationRequest_keys = { "InstanceCount" = true, "OfferingId" = true, nil }

function M.AssertTargetConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetConfigurationRequest to be of type 'table'")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	if struct["OfferingId"] then M.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(TargetConfigurationRequest_keys[k], "TargetConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetConfigurationRequest
-- <p>Details about the target configuration.</p>
-- @param InstanceCount [Integer] <p>The number of instances the Covertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>
-- @param OfferingId [String] <p>The Convertible Reserved Instance offering ID.</p>
-- Required parameter: OfferingId
function M.TargetConfigurationRequest(InstanceCount, OfferingId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TargetConfigurationRequest")
	local t = { 
		["InstanceCount"] = InstanceCount,
		["OfferingId"] = OfferingId,
	}
	M.AssertTargetConfigurationRequest(t)
	return t
end

local InstanceState_keys = { "Code" = true, "Name" = true, nil }

function M.AssertInstanceState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceState to be of type 'table'")
	if struct["Code"] then M.AssertInteger(struct["Code"]) end
	if struct["Name"] then M.AssertInstanceStateName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(InstanceState_keys[k], "InstanceState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceState
-- <p>Describes the current state of an instance.</p>
-- @param Code [Integer] <p>The low byte represents the state. The high byte is an opaque internal value and should be ignored.</p> <ul> <li> <p> <code>0</code> : <code>pending</code> </p> </li> <li> <p> <code>16</code> : <code>running</code> </p> </li> <li> <p> <code>32</code> : <code>shutting-down</code> </p> </li> <li> <p> <code>48</code> : <code>terminated</code> </p> </li> <li> <p> <code>64</code> : <code>stopping</code> </p> </li> <li> <p> <code>80</code> : <code>stopped</code> </p> </li> </ul>
-- @param Name [InstanceStateName] <p>The current state of the instance.</p>
function M.InstanceState(Code, Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceState")
	local t = { 
		["Code"] = Code,
		["Name"] = Name,
	}
	M.AssertInstanceState(t)
	return t
end

local AttachClassicLinkVpcResult_keys = { "Return" = true, nil }

function M.AssertAttachClassicLinkVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachClassicLinkVpcResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(AttachClassicLinkVpcResult_keys[k], "AttachClassicLinkVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachClassicLinkVpcResult
-- <p>Contains the output of AttachClassicLinkVpc.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.AttachClassicLinkVpcResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachClassicLinkVpcResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertAttachClassicLinkVpcResult(t)
	return t
end

local DetachClassicLinkVpcResult_keys = { "Return" = true, nil }

function M.AssertDetachClassicLinkVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachClassicLinkVpcResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(DetachClassicLinkVpcResult_keys[k], "DetachClassicLinkVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachClassicLinkVpcResult
-- <p>Contains the output of DetachClassicLinkVpc.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DetachClassicLinkVpcResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachClassicLinkVpcResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertDetachClassicLinkVpcResult(t)
	return t
end

local DisassociateSubnetCidrBlockResult_keys = { "SubnetId" = true, "Ipv6CidrBlockAssociation" = true, nil }

function M.AssertDisassociateSubnetCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateSubnetCidrBlockResult to be of type 'table'")
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlockAssociation"] then M.AssertSubnetIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	for k,_ in pairs(struct) do
		assert(DisassociateSubnetCidrBlockResult_keys[k], "DisassociateSubnetCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateSubnetCidrBlockResult
--  
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param Ipv6CidrBlockAssociation [SubnetIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
function M.DisassociateSubnetCidrBlockResult(SubnetId, Ipv6CidrBlockAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateSubnetCidrBlockResult")
	local t = { 
		["SubnetId"] = SubnetId,
		["Ipv6CidrBlockAssociation"] = Ipv6CidrBlockAssociation,
	}
	M.AssertDisassociateSubnetCidrBlockResult(t)
	return t
end

local ModifyInstanceAttributeRequest_keys = { "Ramdisk" = true, "Kernel" = true, "SourceDestCheck" = true, "DryRun" = true, "UserData" = true, "InstanceId" = true, "Attribute" = true, "EnaSupport" = true, "SriovNetSupport" = true, "InstanceInitiatedShutdownBehavior" = true, "BlockDeviceMappings" = true, "Value" = true, "Groups" = true, "EbsOptimized" = true, "DisableApiTermination" = true, "InstanceType" = true, nil }

function M.AssertModifyInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstanceAttributeRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["Ramdisk"] then M.AssertAttributeValue(struct["Ramdisk"]) end
	if struct["Kernel"] then M.AssertAttributeValue(struct["Kernel"]) end
	if struct["SourceDestCheck"] then M.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["UserData"] then M.AssertBlobAttributeValue(struct["UserData"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then M.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["EnaSupport"] then M.AssertAttributeBooleanValue(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then M.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then M.AssertAttributeValue(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["BlockDeviceMappings"] then M.AssertInstanceBlockDeviceMappingSpecificationList(struct["BlockDeviceMappings"]) end
	if struct["Value"] then M.AssertString(struct["Value"]) end
	if struct["Groups"] then M.AssertGroupIdStringList(struct["Groups"]) end
	if struct["EbsOptimized"] then M.AssertAttributeBooleanValue(struct["EbsOptimized"]) end
	if struct["DisableApiTermination"] then M.AssertAttributeBooleanValue(struct["DisableApiTermination"]) end
	if struct["InstanceType"] then M.AssertAttributeValue(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(ModifyInstanceAttributeRequest_keys[k], "ModifyInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstanceAttributeRequest
-- <p>Contains the parameters for ModifyInstanceAttribute.</p>
-- @param Ramdisk [AttributeValue] <p>Changes the instance's RAM disk to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
-- @param Kernel [AttributeValue] <p>Changes the instance's kernel to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
-- @param SourceDestCheck [AttributeBooleanValue] <p>Specifies whether source/destination checking is enabled. A value of <code>true</code> means that checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param UserData [BlobAttributeValue] <p>Changes the instance's user data to the specified value. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param Attribute [InstanceAttributeName] <p>The name of the attribute.</p>
-- @param EnaSupport [AttributeBooleanValue] <p>Set to <code>true</code> to enable enhanced networking with ENA for the instance.</p> <p>This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.</p>
-- @param SriovNetSupport [AttributeValue] <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual Function interface for the instance.</p> <p>There is no way to disable enhanced networking with the Intel 82599 Virtual Function interface at this time.</p> <p>This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.</p>
-- @param InstanceInitiatedShutdownBehavior [AttributeValue] <p>Specifies whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- @param BlockDeviceMappings [InstanceBlockDeviceMappingSpecificationList] <p>Modifies the <code>DeleteOnTermination</code> attribute for volumes that are currently attached. The volume must be owned by the caller. If no value is specified for <code>DeleteOnTermination</code>, the default is <code>true</code> and the volume is deleted when the instance is terminated.</p> <p>To add instance store volumes to an Amazon EBS-backed instance, you must add them when you launch the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html#Using_OverridingAMIBDM">Updating the Block Device Mapping when Launching an Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param Value [String] <p>A new value for the attribute. Use only with the <code>kernel</code>, <code>ramdisk</code>, <code>userData</code>, <code>disableApiTermination</code>, or <code>instanceInitiatedShutdownBehavior</code> attribute.</p>
-- @param Groups [GroupIdStringList] <p>[EC2-VPC] Changes the security groups of the instance. You must specify at least one security group, even if it's just the default security group for the VPC. You must specify the security group ID, not the security group name.</p>
-- @param EbsOptimized [AttributeBooleanValue] <p>Specifies whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
-- @param DisableApiTermination [AttributeBooleanValue] <p>If the value is <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this paramater for Spot Instances.</p>
-- @param InstanceType [AttributeValue] <p>Changes the instance type to the specified value. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a>. If the instance type is not valid, the error returned is <code>InvalidInstanceAttributeValue</code>.</p>
-- Required parameter: InstanceId
function M.ModifyInstanceAttributeRequest(Ramdisk, Kernel, SourceDestCheck, DryRun, UserData, InstanceId, Attribute, EnaSupport, SriovNetSupport, InstanceInitiatedShutdownBehavior, BlockDeviceMappings, Value, Groups, EbsOptimized, DisableApiTermination, InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyInstanceAttributeRequest")
	local t = { 
		["Ramdisk"] = Ramdisk,
		["Kernel"] = Kernel,
		["SourceDestCheck"] = SourceDestCheck,
		["DryRun"] = DryRun,
		["UserData"] = UserData,
		["InstanceId"] = InstanceId,
		["Attribute"] = Attribute,
		["EnaSupport"] = EnaSupport,
		["SriovNetSupport"] = SriovNetSupport,
		["InstanceInitiatedShutdownBehavior"] = InstanceInitiatedShutdownBehavior,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["Value"] = Value,
		["Groups"] = Groups,
		["EbsOptimized"] = EbsOptimized,
		["DisableApiTermination"] = DisableApiTermination,
		["InstanceType"] = InstanceType,
	}
	M.AssertModifyInstanceAttributeRequest(t)
	return t
end

local GetHostReservationPurchasePreviewRequest_keys = { "HostIdSet" = true, "OfferingId" = true, nil }

function M.AssertGetHostReservationPurchasePreviewRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetHostReservationPurchasePreviewRequest to be of type 'table'")
	assert(struct["HostIdSet"], "Expected key HostIdSet to exist in table")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["HostIdSet"] then M.AssertRequestHostIdSet(struct["HostIdSet"]) end
	if struct["OfferingId"] then M.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(GetHostReservationPurchasePreviewRequest_keys[k], "GetHostReservationPurchasePreviewRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetHostReservationPurchasePreviewRequest
--  
-- @param HostIdSet [RequestHostIdSet] <p>The ID/s of the Dedicated Host/s that the reservation will be associated with.</p>
-- @param OfferingId [String] <p>The offering ID of the reservation.</p>
-- Required parameter: HostIdSet
-- Required parameter: OfferingId
function M.GetHostReservationPurchasePreviewRequest(HostIdSet, OfferingId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetHostReservationPurchasePreviewRequest")
	local t = { 
		["HostIdSet"] = HostIdSet,
		["OfferingId"] = OfferingId,
	}
	M.AssertGetHostReservationPurchasePreviewRequest(t)
	return t
end

local EnableVpcClassicLinkDnsSupportResult_keys = { "Return" = true, nil }

function M.AssertEnableVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Return"] then M.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(EnableVpcClassicLinkDnsSupportResult_keys[k], "EnableVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkDnsSupportResult
-- <p>Contains the output of EnableVpcClassicLinkDnsSupport.</p>
-- @param Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.EnableVpcClassicLinkDnsSupportResult(Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVpcClassicLinkDnsSupportResult")
	local t = { 
		["Return"] = Return,
	}
	M.AssertEnableVpcClassicLinkDnsSupportResult(t)
	return t
end

local GetPasswordDataResult_keys = { "InstanceId" = true, "Timestamp" = true, "PasswordData" = true, nil }

function M.AssertGetPasswordDataResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPasswordDataResult to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Timestamp"] then M.AssertDateTime(struct["Timestamp"]) end
	if struct["PasswordData"] then M.AssertString(struct["PasswordData"]) end
	for k,_ in pairs(struct) do
		assert(GetPasswordDataResult_keys[k], "GetPasswordDataResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPasswordDataResult
-- <p>Contains the output of GetPasswordData.</p>
-- @param InstanceId [String] <p>The ID of the Windows instance.</p>
-- @param Timestamp [DateTime] <p>The time the data was last updated.</p>
-- @param PasswordData [String] <p>The password of the instance.</p>
function M.GetPasswordDataResult(InstanceId, Timestamp, PasswordData, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetPasswordDataResult")
	local t = { 
		["InstanceId"] = InstanceId,
		["Timestamp"] = Timestamp,
		["PasswordData"] = PasswordData,
	}
	M.AssertGetPasswordDataResult(t)
	return t
end

local KeyPairInfo_keys = { "KeyName" = true, "KeyFingerprint" = true, nil }

function M.AssertKeyPairInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KeyPairInfo to be of type 'table'")
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then M.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(KeyPairInfo_keys[k], "KeyPairInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KeyPairInfo
-- <p>Describes a key pair.</p>
-- @param KeyName [String] <p>The name of the key pair.</p>
-- @param KeyFingerprint [String] <p>If you used <a>CreateKeyPair</a> to create the key pair, this is the SHA-1 digest of the DER encoded private key. If you used <a>ImportKeyPair</a> to provide AWS the public key, this is the MD5 public key fingerprint as specified in section 4 of RFC4716.</p>
function M.KeyPairInfo(KeyName, KeyFingerprint, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating KeyPairInfo")
	local t = { 
		["KeyName"] = KeyName,
		["KeyFingerprint"] = KeyFingerprint,
	}
	M.AssertKeyPairInfo(t)
	return t
end

local DescribeVpcClassicLinkResult_keys = { "Vpcs" = true, nil }

function M.AssertDescribeVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkResult to be of type 'table'")
	if struct["Vpcs"] then M.AssertVpcClassicLinkList(struct["Vpcs"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcClassicLinkResult_keys[k], "DescribeVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkResult
-- <p>Contains the output of DescribeVpcClassicLink.</p>
-- @param Vpcs [VpcClassicLinkList] <p>The ClassicLink status of one or more VPCs.</p>
function M.DescribeVpcClassicLinkResult(Vpcs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcClassicLinkResult")
	local t = { 
		["Vpcs"] = Vpcs,
	}
	M.AssertDescribeVpcClassicLinkResult(t)
	return t
end

local DescribeEgressOnlyInternetGatewaysRequest_keys = { "EgressOnlyInternetGatewayIds" = true, "NextToken" = true, "DryRun" = true, "MaxResults" = true, nil }

function M.AssertDescribeEgressOnlyInternetGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEgressOnlyInternetGatewaysRequest to be of type 'table'")
	if struct["EgressOnlyInternetGatewayIds"] then M.AssertEgressOnlyInternetGatewayIdList(struct["EgressOnlyInternetGatewayIds"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(DescribeEgressOnlyInternetGatewaysRequest_keys[k], "DescribeEgressOnlyInternetGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEgressOnlyInternetGatewaysRequest
--  
-- @param EgressOnlyInternetGatewayIds [EgressOnlyInternetGatewayIdList] <p>One or more egress-only Internet gateway IDs.</p>
-- @param NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned.</p>
function M.DescribeEgressOnlyInternetGatewaysRequest(EgressOnlyInternetGatewayIds, NextToken, DryRun, MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeEgressOnlyInternetGatewaysRequest")
	local t = { 
		["EgressOnlyInternetGatewayIds"] = EgressOnlyInternetGatewayIds,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
	}
	M.AssertDescribeEgressOnlyInternetGatewaysRequest(t)
	return t
end

local DetachVpnGatewayRequest_keys = { "VpcId" = true, "DryRun" = true, "VpnGatewayId" = true, nil }

function M.AssertDetachVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachVpnGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then M.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(DetachVpnGatewayRequest_keys[k], "DetachVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachVpnGatewayRequest
-- <p>Contains the parameters for DetachVpnGateway.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required parameter: VpcId
-- Required parameter: VpnGatewayId
function M.DetachVpnGatewayRequest(VpcId, DryRun, VpnGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachVpnGatewayRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
		["VpnGatewayId"] = VpnGatewayId,
	}
	M.AssertDetachVpnGatewayRequest(t)
	return t
end

local DescribeBundleTasksRequest_keys = { "DryRun" = true, "Filters" = true, "BundleIds" = true, nil }

function M.AssertDescribeBundleTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeBundleTasksRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["BundleIds"] then M.AssertBundleIdStringList(struct["BundleIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeBundleTasksRequest_keys[k], "DescribeBundleTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeBundleTasksRequest
-- <p>Contains the parameters for DescribeBundleTasks.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>bundle-id</code> - The ID of the bundle task.</p> </li> <li> <p> <code>error-code</code> - If the task failed, the error code returned.</p> </li> <li> <p> <code>error-message</code> - If the task failed, the error message returned.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>progress</code> - The level of task completion, as a percentage (for example, 20%).</p> </li> <li> <p> <code>s3-bucket</code> - The Amazon S3 bucket to store the AMI.</p> </li> <li> <p> <code>s3-prefix</code> - The beginning of the AMI name.</p> </li> <li> <p> <code>start-time</code> - The time the task started (for example, 2013-09-15T17:15:20.000Z).</p> </li> <li> <p> <code>state</code> - The state of the task (<code>pending</code> | <code>waiting-for-shutdown</code> | <code>bundling</code> | <code>storing</code> | <code>cancelling</code> | <code>complete</code> | <code>failed</code>).</p> </li> <li> <p> <code>update-time</code> - The time of the most recent update for the task.</p> </li> </ul>
-- @param BundleIds [BundleIdStringList] <p>One or more bundle task IDs.</p> <p>Default: Describes all your bundle tasks.</p>
function M.DescribeBundleTasksRequest(DryRun, Filters, BundleIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeBundleTasksRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Filters"] = Filters,
		["BundleIds"] = BundleIds,
	}
	M.AssertDescribeBundleTasksRequest(t)
	return t
end

local PurchaseHostReservationRequest_keys = { "CurrencyCode" = true, "OfferingId" = true, "LimitPrice" = true, "HostIdSet" = true, "ClientToken" = true, nil }

function M.AssertPurchaseHostReservationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseHostReservationRequest to be of type 'table'")
	assert(struct["HostIdSet"], "Expected key HostIdSet to exist in table")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["OfferingId"] then M.AssertString(struct["OfferingId"]) end
	if struct["LimitPrice"] then M.AssertString(struct["LimitPrice"]) end
	if struct["HostIdSet"] then M.AssertRequestHostIdSet(struct["HostIdSet"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(PurchaseHostReservationRequest_keys[k], "PurchaseHostReservationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseHostReservationRequest
--  
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code>, <code>LimitPrice</code>, and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param OfferingId [String] <p>The ID of the offering.</p>
-- @param LimitPrice [String] <p>The specified limit is checked against the total upfront cost of the reservation (calculated as the offering's upfront cost multiplied by the host count). If the total upfront cost is greater than the specified price limit, the request will fail. This is used to ensure that the purchase does not exceed the expected upfront cost of the purchase. At this time, the only supported currency is <code>USD</code>. For example, to indicate a limit price of USD 100, specify 100.00.</p>
-- @param HostIdSet [RequestHostIdSet] <p>The ID/s of the Dedicated Host/s that the reservation will be associated with.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- Required parameter: HostIdSet
-- Required parameter: OfferingId
function M.PurchaseHostReservationRequest(CurrencyCode, OfferingId, LimitPrice, HostIdSet, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseHostReservationRequest")
	local t = { 
		["CurrencyCode"] = CurrencyCode,
		["OfferingId"] = OfferingId,
		["LimitPrice"] = LimitPrice,
		["HostIdSet"] = HostIdSet,
		["ClientToken"] = ClientToken,
	}
	M.AssertPurchaseHostReservationRequest(t)
	return t
end

local ReleaseHostsResult_keys = { "Successful" = true, "Unsuccessful" = true, nil }

function M.AssertReleaseHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseHostsResult to be of type 'table'")
	if struct["Successful"] then M.AssertResponseHostIdList(struct["Successful"]) end
	if struct["Unsuccessful"] then M.AssertUnsuccessfulItemList(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(ReleaseHostsResult_keys[k], "ReleaseHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseHostsResult
-- <p>Contains the output of ReleaseHosts.</p>
-- @param Successful [ResponseHostIdList] <p>The IDs of the Dedicated Hosts that were successfully released.</p>
-- @param Unsuccessful [UnsuccessfulItemList] <p>The IDs of the Dedicated Hosts that could not be released, including an error message.</p>
function M.ReleaseHostsResult(Successful, Unsuccessful, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReleaseHostsResult")
	local t = { 
		["Successful"] = Successful,
		["Unsuccessful"] = Unsuccessful,
	}
	M.AssertReleaseHostsResult(t)
	return t
end

local LaunchSpecification_keys = { "UserData" = true, "SubnetId" = true, "Placement" = true, "Monitoring" = true, "ImageId" = true, "KeyName" = true, "BlockDeviceMappings" = true, "EbsOptimized" = true, "SecurityGroups" = true, "KernelId" = true, "RamdiskId" = true, "IamInstanceProfile" = true, "InstanceType" = true, "AddressingType" = true, "NetworkInterfaces" = true, nil }

function M.AssertLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchSpecification to be of type 'table'")
	if struct["UserData"] then M.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["Placement"] then M.AssertSpotPlacement(struct["Placement"]) end
	if struct["Monitoring"] then M.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then M.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then M.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then M.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["KernelId"] then M.AssertString(struct["KernelId"]) end
	if struct["RamdiskId"] then M.AssertString(struct["RamdiskId"]) end
	if struct["IamInstanceProfile"] then M.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then M.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then M.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(LaunchSpecification_keys[k], "LaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchSpecification
-- <p>Describes the launch specification for an instance.</p>
-- @param UserData [String] <p>The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param SubnetId [String] <p>The ID of the subnet in which to launch the instance.</p>
-- @param Placement [SpotPlacement] <p>The placement information for the instance.</p>
-- @param Monitoring [RunInstancesMonitoringEnabled] <p>Describes the launch specification for an instance.</p>
-- @param ImageId [String] <p>The ID of the AMI.</p>
-- @param KeyName [String] <p>The name of the key pair.</p>
-- @param BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p> <p>Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.</p>
-- @param EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param SecurityGroups [GroupIdentifierList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- @param KernelId [String] <p>The ID of the kernel.</p>
-- @param RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- @param InstanceType [InstanceType] <p>The instance type.</p>
-- @param AddressingType [String] <p>Deprecated.</p>
-- @param NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
function M.LaunchSpecification(UserData, SubnetId, Placement, Monitoring, ImageId, KeyName, BlockDeviceMappings, EbsOptimized, SecurityGroups, KernelId, RamdiskId, IamInstanceProfile, InstanceType, AddressingType, NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating LaunchSpecification")
	local t = { 
		["UserData"] = UserData,
		["SubnetId"] = SubnetId,
		["Placement"] = Placement,
		["Monitoring"] = Monitoring,
		["ImageId"] = ImageId,
		["KeyName"] = KeyName,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["EbsOptimized"] = EbsOptimized,
		["SecurityGroups"] = SecurityGroups,
		["KernelId"] = KernelId,
		["RamdiskId"] = RamdiskId,
		["IamInstanceProfile"] = IamInstanceProfile,
		["InstanceType"] = InstanceType,
		["AddressingType"] = AddressingType,
		["NetworkInterfaces"] = NetworkInterfaces,
	}
	M.AssertLaunchSpecification(t)
	return t
end

local CreateRouteRequest_keys = { "DestinationCidrBlock" = true, "EgressOnlyInternetGatewayId" = true, "DryRun" = true, "InstanceId" = true, "NetworkInterfaceId" = true, "RouteTableId" = true, "NatGatewayId" = true, "VpcPeeringConnectionId" = true, "GatewayId" = true, "DestinationIpv6CidrBlock" = true, nil }

function M.AssertCreateRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then M.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then M.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	if struct["NatGatewayId"] then M.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then M.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then M.AssertString(struct["DestinationIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(CreateRouteRequest_keys[k], "CreateRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteRequest
-- <p>Contains the parameters for CreateRoute.</p>
-- @param DestinationCidrBlock [String] <p>The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match.</p>
-- @param EgressOnlyInternetGatewayId [String] <p>[IPv6 traffic only] The ID of an egress-only Internet gateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceId [String] <p>The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.</p>
-- @param NetworkInterfaceId [String] <p>The ID of a network interface.</p>
-- @param RouteTableId [String] <p>The ID of the route table for the route.</p>
-- @param NatGatewayId [String] <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of a VPC peering connection.</p>
-- @param GatewayId [String] <p>The ID of an Internet gateway or virtual private gateway attached to your VPC.</p>
-- @param DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.</p>
-- Required parameter: RouteTableId
function M.CreateRouteRequest(DestinationCidrBlock, EgressOnlyInternetGatewayId, DryRun, InstanceId, NetworkInterfaceId, RouteTableId, NatGatewayId, VpcPeeringConnectionId, GatewayId, DestinationIpv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateRouteRequest")
	local t = { 
		["DestinationCidrBlock"] = DestinationCidrBlock,
		["EgressOnlyInternetGatewayId"] = EgressOnlyInternetGatewayId,
		["DryRun"] = DryRun,
		["InstanceId"] = InstanceId,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["RouteTableId"] = RouteTableId,
		["NatGatewayId"] = NatGatewayId,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
		["GatewayId"] = GatewayId,
		["DestinationIpv6CidrBlock"] = DestinationIpv6CidrBlock,
	}
	M.AssertCreateRouteRequest(t)
	return t
end

local AssociateIamInstanceProfileResult_keys = { "IamInstanceProfileAssociation" = true, nil }

function M.AssertAssociateIamInstanceProfileResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateIamInstanceProfileResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then M.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(AssociateIamInstanceProfileResult_keys[k], "AssociateIamInstanceProfileResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateIamInstanceProfileResult
--  
-- @param IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
function M.AssociateIamInstanceProfileResult(IamInstanceProfileAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateIamInstanceProfileResult")
	local t = { 
		["IamInstanceProfileAssociation"] = IamInstanceProfileAssociation,
	}
	M.AssertAssociateIamInstanceProfileResult(t)
	return t
end

local MoveAddressToVpcResult_keys = { "Status" = true, "AllocationId" = true, nil }

function M.AssertMoveAddressToVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MoveAddressToVpcResult to be of type 'table'")
	if struct["Status"] then M.AssertStatus(struct["Status"]) end
	if struct["AllocationId"] then M.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(MoveAddressToVpcResult_keys[k], "MoveAddressToVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MoveAddressToVpcResult
-- <p>Contains the output of MoveAddressToVpc.</p>
-- @param Status [Status] <p>The status of the move of the IP address.</p>
-- @param AllocationId [String] <p>The allocation ID for the Elastic IP address.</p>
function M.MoveAddressToVpcResult(Status, AllocationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MoveAddressToVpcResult")
	local t = { 
		["Status"] = Status,
		["AllocationId"] = AllocationId,
	}
	M.AssertMoveAddressToVpcResult(t)
	return t
end

local AssociateDhcpOptionsRequest_keys = { "VpcId" = true, "DryRun" = true, "DhcpOptionsId" = true, nil }

function M.AssertAssociateDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpOptionsId"], "Expected key DhcpOptionsId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpOptionsId"] then M.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(AssociateDhcpOptionsRequest_keys[k], "AssociateDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateDhcpOptionsRequest
-- <p>Contains the parameters for AssociateDhcpOptions.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param DhcpOptionsId [String] <p>The ID of the DHCP options set, or <code>default</code> to associate no DHCP options with the VPC.</p>
-- Required parameter: DhcpOptionsId
-- Required parameter: VpcId
function M.AssociateDhcpOptionsRequest(VpcId, DryRun, DhcpOptionsId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateDhcpOptionsRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
		["DhcpOptionsId"] = DhcpOptionsId,
	}
	M.AssertAssociateDhcpOptionsRequest(t)
	return t
end

local MovingAddressStatus_keys = { "PublicIp" = true, "MoveStatus" = true, nil }

function M.AssertMovingAddressStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MovingAddressStatus to be of type 'table'")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["MoveStatus"] then M.AssertMoveStatus(struct["MoveStatus"]) end
	for k,_ in pairs(struct) do
		assert(MovingAddressStatus_keys[k], "MovingAddressStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MovingAddressStatus
-- <p>Describes the status of a moving Elastic IP address.</p>
-- @param PublicIp [String] <p>The Elastic IP address.</p>
-- @param MoveStatus [MoveStatus] <p>The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.</p>
function M.MovingAddressStatus(PublicIp, MoveStatus, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MovingAddressStatus")
	local t = { 
		["PublicIp"] = PublicIp,
		["MoveStatus"] = MoveStatus,
	}
	M.AssertMovingAddressStatus(t)
	return t
end

local DeleteSubnetRequest_keys = { "SubnetId" = true, "DryRun" = true, nil }

function M.AssertDeleteSubnetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSubnetRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteSubnetRequest_keys[k], "DeleteSubnetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSubnetRequest
-- <p>Contains the parameters for DeleteSubnet.</p>
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: SubnetId
function M.DeleteSubnetRequest(SubnetId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteSubnetRequest")
	local t = { 
		["SubnetId"] = SubnetId,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteSubnetRequest(t)
	return t
end

local SpotInstanceStateFault_keys = { "Message" = true, "Code" = true, nil }

function M.AssertSpotInstanceStateFault(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceStateFault to be of type 'table'")
	if struct["Message"] then M.AssertString(struct["Message"]) end
	if struct["Code"] then M.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(SpotInstanceStateFault_keys[k], "SpotInstanceStateFault contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceStateFault
-- <p>Describes a Spot instance state change.</p>
-- @param Message [String] <p>The message for the Spot instance state change.</p>
-- @param Code [String] <p>The reason code for the Spot instance state change.</p>
function M.SpotInstanceStateFault(Message, Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotInstanceStateFault")
	local t = { 
		["Message"] = Message,
		["Code"] = Code,
	}
	M.AssertSpotInstanceStateFault(t)
	return t
end

local DhcpConfiguration_keys = { "Values" = true, "Key" = true, nil }

function M.AssertDhcpConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DhcpConfiguration to be of type 'table'")
	if struct["Values"] then M.AssertDhcpConfigurationValueList(struct["Values"]) end
	if struct["Key"] then M.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(DhcpConfiguration_keys[k], "DhcpConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DhcpConfiguration
-- <p>Describes a DHCP configuration option.</p>
-- @param Values [DhcpConfigurationValueList] <p>One or more values for the DHCP option.</p>
-- @param Key [String] <p>The name of a DHCP option.</p>
function M.DhcpConfiguration(Values, Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DhcpConfiguration")
	local t = { 
		["Values"] = Values,
		["Key"] = Key,
	}
	M.AssertDhcpConfiguration(t)
	return t
end

local VolumeDetail_keys = { "Size" = true, nil }

function M.AssertVolumeDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeDetail to be of type 'table'")
	assert(struct["Size"], "Expected key Size to exist in table")
	if struct["Size"] then M.AssertLong(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(VolumeDetail_keys[k], "VolumeDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeDetail
-- <p>Describes an EBS volume.</p>
-- @param Size [Long] <p>The size of the volume, in GiB.</p>
-- Required parameter: Size
function M.VolumeDetail(Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeDetail")
	local t = { 
		["Size"] = Size,
	}
	M.AssertVolumeDetail(t)
	return t
end

local DisassociateVpcCidrBlockRequest_keys = { "AssociationId" = true, nil }

function M.AssertDisassociateVpcCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateVpcCidrBlockRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(DisassociateVpcCidrBlockRequest_keys[k], "DisassociateVpcCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateVpcCidrBlockRequest
--  
-- @param AssociationId [String] <p>The association ID for the CIDR block.</p>
-- Required parameter: AssociationId
function M.DisassociateVpcCidrBlockRequest(AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateVpcCidrBlockRequest")
	local t = { 
		["AssociationId"] = AssociationId,
	}
	M.AssertDisassociateVpcCidrBlockRequest(t)
	return t
end

local Instance_keys = { "Monitoring" = true, "StateReason" = true, "PublicDnsName" = true, "Platform" = true, "State" = true, "EbsOptimized" = true, "LaunchTime" = true, "PublicIpAddress" = true, "RamdiskId" = true, "PrivateIpAddress" = true, "ProductCodes" = true, "VpcId" = true, "StateTransitionReason" = true, "InstanceId" = true, "EnaSupport" = true, "SriovNetSupport" = true, "ImageId" = true, "PrivateDnsName" = true, "KeyName" = true, "SecurityGroups" = true, "ClientToken" = true, "SubnetId" = true, "InstanceType" = true, "NetworkInterfaces" = true, "SourceDestCheck" = true, "Placement" = true, "Hypervisor" = true, "InstanceLifecycle" = true, "BlockDeviceMappings" = true, "Architecture" = true, "KernelId" = true, "IamInstanceProfile" = true, "RootDeviceName" = true, "VirtualizationType" = true, "RootDeviceType" = true, "Tags" = true, "SpotInstanceRequestId" = true, "AmiLaunchIndex" = true, nil }

function M.AssertInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Instance to be of type 'table'")
	if struct["Monitoring"] then M.AssertMonitoring(struct["Monitoring"]) end
	if struct["StateReason"] then M.AssertStateReason(struct["StateReason"]) end
	if struct["PublicDnsName"] then M.AssertString(struct["PublicDnsName"]) end
	if struct["Platform"] then M.AssertPlatformValues(struct["Platform"]) end
	if struct["State"] then M.AssertInstanceState(struct["State"]) end
	if struct["EbsOptimized"] then M.AssertBoolean(struct["EbsOptimized"]) end
	if struct["LaunchTime"] then M.AssertDateTime(struct["LaunchTime"]) end
	if struct["PublicIpAddress"] then M.AssertString(struct["PublicIpAddress"]) end
	if struct["RamdiskId"] then M.AssertString(struct["RamdiskId"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	if struct["ProductCodes"] then M.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["StateTransitionReason"] then M.AssertString(struct["StateTransitionReason"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["EnaSupport"] then M.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then M.AssertString(struct["SriovNetSupport"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["PrivateDnsName"] then M.AssertString(struct["PrivateDnsName"]) end
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then M.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then M.AssertInstanceNetworkInterfaceList(struct["NetworkInterfaces"]) end
	if struct["SourceDestCheck"] then M.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["Placement"] then M.AssertPlacement(struct["Placement"]) end
	if struct["Hypervisor"] then M.AssertHypervisorType(struct["Hypervisor"]) end
	if struct["InstanceLifecycle"] then M.AssertInstanceLifecycleType(struct["InstanceLifecycle"]) end
	if struct["BlockDeviceMappings"] then M.AssertInstanceBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then M.AssertArchitectureValues(struct["Architecture"]) end
	if struct["KernelId"] then M.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then M.AssertIamInstanceProfile(struct["IamInstanceProfile"]) end
	if struct["RootDeviceName"] then M.AssertString(struct["RootDeviceName"]) end
	if struct["VirtualizationType"] then M.AssertVirtualizationType(struct["VirtualizationType"]) end
	if struct["RootDeviceType"] then M.AssertDeviceType(struct["RootDeviceType"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["SpotInstanceRequestId"] then M.AssertString(struct["SpotInstanceRequestId"]) end
	if struct["AmiLaunchIndex"] then M.AssertInteger(struct["AmiLaunchIndex"]) end
	for k,_ in pairs(struct) do
		assert(Instance_keys[k], "Instance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Instance
-- <p>Describes an instance.</p>
-- @param Monitoring [Monitoring] <p>The monitoring for the instance.</p>
-- @param StateReason [StateReason] <p>The reason for the most recent state transition.</p>
-- @param PublicDnsName [String] <p>(IPv4 only) The public DNS name assigned to the instance. This name is not available until the instance enters the <code>running</code> state. For EC2-VPC, this name is only available if you've enabled DNS hostnames for your VPC.</p>
-- @param Platform [PlatformValues] <p>The value is <code>Windows</code> for Windows instances; otherwise blank.</p>
-- @param State [InstanceState] <p>The current state of the instance.</p>
-- @param EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
-- @param LaunchTime [DateTime] <p>The time the instance was launched.</p>
-- @param PublicIpAddress [String] <p>The public IPv4 address assigned to the instance, if applicable.</p>
-- @param RamdiskId [String] <p>The RAM disk associated with this instance, if applicable.</p>
-- @param PrivateIpAddress [String] <p>The private IPv4 address assigned to the instance.</p>
-- @param ProductCodes [ProductCodeList] <p>The product codes attached to this instance, if applicable.</p>
-- @param VpcId [String] <p>[EC2-VPC] The ID of the VPC in which the instance is running.</p>
-- @param StateTransitionReason [String] <p>The reason for the most recent state transition. This might be an empty string.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param EnaSupport [Boolean] <p>Specifies whether enhanced networking with ENA is enabled.</p>
-- @param SriovNetSupport [String] <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- @param ImageId [String] <p>The ID of the AMI used to launch the instance.</p>
-- @param PrivateDnsName [String] <p>(IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the <code>running</code> state. </p> <p>[EC2-VPC] The Amazon-provided DNS server will resolve Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.</p>
-- @param KeyName [String] <p>The name of the key pair, if this instance was launched with an associated key pair.</p>
-- @param SecurityGroups [GroupIdentifierList] <p>One or more security groups for the instance.</p>
-- @param ClientToken [String] <p>The idempotency token you provided when you launched the instance, if applicable.</p>
-- @param SubnetId [String] <p>[EC2-VPC] The ID of the subnet in which the instance is running.</p>
-- @param InstanceType [InstanceType] <p>The instance type.</p>
-- @param NetworkInterfaces [InstanceNetworkInterfaceList] <p>[EC2-VPC] One or more network interfaces for the instance.</p>
-- @param SourceDestCheck [Boolean] <p>Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the instance to perform NAT. For more information, see <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html">NAT Instances</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- @param Placement [Placement] <p>The location where the instance launched, if applicable.</p>
-- @param Hypervisor [HypervisorType] <p>The hypervisor type of the instance.</p>
-- @param InstanceLifecycle [InstanceLifecycleType] <p>Indicates whether this is a Spot instance or a Scheduled Instance.</p>
-- @param BlockDeviceMappings [InstanceBlockDeviceMappingList] <p>Any block device mapping entries for the instance.</p>
-- @param Architecture [ArchitectureValues] <p>The architecture of the image.</p>
-- @param KernelId [String] <p>The kernel associated with this instance, if applicable.</p>
-- @param IamInstanceProfile [IamInstanceProfile] <p>The IAM instance profile associated with the instance, if applicable.</p>
-- @param RootDeviceName [String] <p>The root device name (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p>
-- @param VirtualizationType [VirtualizationType] <p>The virtualization type of the instance.</p>
-- @param RootDeviceType [DeviceType] <p>The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
-- @param Tags [TagList] <p>Any tags assigned to the instance.</p>
-- @param SpotInstanceRequestId [String] <p>If the request is a Spot instance request, the ID of the request.</p>
-- @param AmiLaunchIndex [Integer] <p>The AMI launch index, which can be used to find this instance in the launch group.</p>
function M.Instance(Monitoring, StateReason, PublicDnsName, Platform, State, EbsOptimized, LaunchTime, PublicIpAddress, RamdiskId, PrivateIpAddress, ProductCodes, VpcId, StateTransitionReason, InstanceId, EnaSupport, SriovNetSupport, ImageId, PrivateDnsName, KeyName, SecurityGroups, ClientToken, SubnetId, InstanceType, NetworkInterfaces, SourceDestCheck, Placement, Hypervisor, InstanceLifecycle, BlockDeviceMappings, Architecture, KernelId, IamInstanceProfile, RootDeviceName, VirtualizationType, RootDeviceType, Tags, SpotInstanceRequestId, AmiLaunchIndex, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Instance")
	local t = { 
		["Monitoring"] = Monitoring,
		["StateReason"] = StateReason,
		["PublicDnsName"] = PublicDnsName,
		["Platform"] = Platform,
		["State"] = State,
		["EbsOptimized"] = EbsOptimized,
		["LaunchTime"] = LaunchTime,
		["PublicIpAddress"] = PublicIpAddress,
		["RamdiskId"] = RamdiskId,
		["PrivateIpAddress"] = PrivateIpAddress,
		["ProductCodes"] = ProductCodes,
		["VpcId"] = VpcId,
		["StateTransitionReason"] = StateTransitionReason,
		["InstanceId"] = InstanceId,
		["EnaSupport"] = EnaSupport,
		["SriovNetSupport"] = SriovNetSupport,
		["ImageId"] = ImageId,
		["PrivateDnsName"] = PrivateDnsName,
		["KeyName"] = KeyName,
		["SecurityGroups"] = SecurityGroups,
		["ClientToken"] = ClientToken,
		["SubnetId"] = SubnetId,
		["InstanceType"] = InstanceType,
		["NetworkInterfaces"] = NetworkInterfaces,
		["SourceDestCheck"] = SourceDestCheck,
		["Placement"] = Placement,
		["Hypervisor"] = Hypervisor,
		["InstanceLifecycle"] = InstanceLifecycle,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["Architecture"] = Architecture,
		["KernelId"] = KernelId,
		["IamInstanceProfile"] = IamInstanceProfile,
		["RootDeviceName"] = RootDeviceName,
		["VirtualizationType"] = VirtualizationType,
		["RootDeviceType"] = RootDeviceType,
		["Tags"] = Tags,
		["SpotInstanceRequestId"] = SpotInstanceRequestId,
		["AmiLaunchIndex"] = AmiLaunchIndex,
	}
	M.AssertInstance(t)
	return t
end

local DeleteNetworkInterfaceRequest_keys = { "NetworkInterfaceId" = true, "DryRun" = true, nil }

function M.AssertDeleteNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkInterfaceRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteNetworkInterfaceRequest_keys[k], "DeleteNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkInterfaceRequest
-- <p>Contains the parameters for DeleteNetworkInterface.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: NetworkInterfaceId
function M.DeleteNetworkInterfaceRequest(NetworkInterfaceId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNetworkInterfaceRequest")
	local t = { 
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteNetworkInterfaceRequest(t)
	return t
end

local SpotFleetMonitoring_keys = { "Enabled" = true, nil }

function M.AssertSpotFleetMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetMonitoring to be of type 'table'")
	if struct["Enabled"] then M.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(SpotFleetMonitoring_keys[k], "SpotFleetMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetMonitoring
-- <p>Describes whether monitoring is enabled.</p>
-- @param Enabled [Boolean] <p>Enables monitoring for the instance.</p> <p>Default: <code>false</code> </p>
function M.SpotFleetMonitoring(Enabled, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotFleetMonitoring")
	local t = { 
		["Enabled"] = Enabled,
	}
	M.AssertSpotFleetMonitoring(t)
	return t
end

local RouteTable_keys = { "Associations" = true, "RouteTableId" = true, "VpcId" = true, "PropagatingVgws" = true, "Tags" = true, "Routes" = true, nil }

function M.AssertRouteTable(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RouteTable to be of type 'table'")
	if struct["Associations"] then M.AssertRouteTableAssociationList(struct["Associations"]) end
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["PropagatingVgws"] then M.AssertPropagatingVgwList(struct["PropagatingVgws"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["Routes"] then M.AssertRouteList(struct["Routes"]) end
	for k,_ in pairs(struct) do
		assert(RouteTable_keys[k], "RouteTable contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RouteTable
-- <p>Describes a route table.</p>
-- @param Associations [RouteTableAssociationList] <p>The associations between the route table and one or more subnets.</p>
-- @param RouteTableId [String] <p>The ID of the route table.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param PropagatingVgws [PropagatingVgwList] <p>Any virtual private gateway (VGW) propagating routes.</p>
-- @param Tags [TagList] <p>Any tags assigned to the route table.</p>
-- @param Routes [RouteList] <p>The routes in the route table.</p>
function M.RouteTable(Associations, RouteTableId, VpcId, PropagatingVgws, Tags, Routes, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RouteTable")
	local t = { 
		["Associations"] = Associations,
		["RouteTableId"] = RouteTableId,
		["VpcId"] = VpcId,
		["PropagatingVgws"] = PropagatingVgws,
		["Tags"] = Tags,
		["Routes"] = Routes,
	}
	M.AssertRouteTable(t)
	return t
end

local VpnConnectionOptionsSpecification_keys = { "StaticRoutesOnly" = true, nil }

function M.AssertVpnConnectionOptionsSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnectionOptionsSpecification to be of type 'table'")
	if struct["StaticRoutesOnly"] then M.AssertBoolean(struct["StaticRoutesOnly"]) end
	for k,_ in pairs(struct) do
		assert(VpnConnectionOptionsSpecification_keys[k], "VpnConnectionOptionsSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnectionOptionsSpecification
-- <p>Describes VPN connection options.</p>
-- @param StaticRoutesOnly [Boolean] <p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>
function M.VpnConnectionOptionsSpecification(StaticRoutesOnly, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnConnectionOptionsSpecification")
	local t = { 
		["StaticRoutesOnly"] = StaticRoutesOnly,
	}
	M.AssertVpnConnectionOptionsSpecification(t)
	return t
end

local DescribeNetworkAclsResult_keys = { "NetworkAcls" = true, nil }

function M.AssertDescribeNetworkAclsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkAclsResult to be of type 'table'")
	if struct["NetworkAcls"] then M.AssertNetworkAclList(struct["NetworkAcls"]) end
	for k,_ in pairs(struct) do
		assert(DescribeNetworkAclsResult_keys[k], "DescribeNetworkAclsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkAclsResult
-- <p>Contains the output of DescribeNetworkAcls.</p>
-- @param NetworkAcls [NetworkAclList] <p>Information about one or more network ACLs.</p>
function M.DescribeNetworkAclsResult(NetworkAcls, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkAclsResult")
	local t = { 
		["NetworkAcls"] = NetworkAcls,
	}
	M.AssertDescribeNetworkAclsResult(t)
	return t
end

local CreateTagsRequest_keys = { "DryRun" = true, "Resources" = true, "Tags" = true, nil }

function M.AssertCreateTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateTagsRequest to be of type 'table'")
	assert(struct["Resources"], "Expected key Resources to exist in table")
	assert(struct["Tags"], "Expected key Tags to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Resources"] then M.AssertResourceIdList(struct["Resources"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(CreateTagsRequest_keys[k], "CreateTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateTagsRequest
-- <p>Contains the parameters for CreateTags.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Resources [ResourceIdList] <p>The IDs of one or more resources to tag. For example, ami-1a2b3c4d.</p>
-- @param Tags [TagList] <p>One or more tags. The <code>value</code> parameter is required, but if you don't want the tag to have a value, specify the parameter with no value, and we set the value to an empty string. </p>
-- Required parameter: Resources
-- Required parameter: Tags
function M.CreateTagsRequest(DryRun, Resources, Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateTagsRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Resources"] = Resources,
		["Tags"] = Tags,
	}
	M.AssertCreateTagsRequest(t)
	return t
end

local HostOffering_keys = { "HourlyPrice" = true, "OfferingId" = true, "CurrencyCode" = true, "InstanceFamily" = true, "PaymentOption" = true, "UpfrontPrice" = true, "Duration" = true, nil }

function M.AssertHostOffering(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostOffering to be of type 'table'")
	if struct["HourlyPrice"] then M.AssertString(struct["HourlyPrice"]) end
	if struct["OfferingId"] then M.AssertString(struct["OfferingId"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["InstanceFamily"] then M.AssertString(struct["InstanceFamily"]) end
	if struct["PaymentOption"] then M.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["UpfrontPrice"] then M.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then M.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(HostOffering_keys[k], "HostOffering contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostOffering
-- <p>Details about the Dedicated Host Reservation offering.</p>
-- @param HourlyPrice [String] <p>The hourly price of the offering.</p>
-- @param OfferingId [String] <p>The ID of the offering.</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency of the offering.</p>
-- @param InstanceFamily [String] <p>The instance family of the offering.</p>
-- @param PaymentOption [PaymentOption] <p>The available payment option.</p>
-- @param UpfrontPrice [String] <p>The upfront price of the offering. Does not apply to No Upfront offerings.</p>
-- @param Duration [Integer] <p>The duration of the offering (in seconds).</p>
function M.HostOffering(HourlyPrice, OfferingId, CurrencyCode, InstanceFamily, PaymentOption, UpfrontPrice, Duration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HostOffering")
	local t = { 
		["HourlyPrice"] = HourlyPrice,
		["OfferingId"] = OfferingId,
		["CurrencyCode"] = CurrencyCode,
		["InstanceFamily"] = InstanceFamily,
		["PaymentOption"] = PaymentOption,
		["UpfrontPrice"] = UpfrontPrice,
		["Duration"] = Duration,
	}
	M.AssertHostOffering(t)
	return t
end

local DescribeVpcClassicLinkDnsSupportRequest_keys = { "NextToken" = true, "MaxResults" = true, "VpcIds" = true, nil }

function M.AssertDescribeVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then M.AssertMaxResults(struct["MaxResults"]) end
	if struct["VpcIds"] then M.AssertVpcClassicLinkIdList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcClassicLinkDnsSupportRequest_keys[k], "DescribeVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkDnsSupportRequest
-- <p>Contains the parameters for DescribeVpcClassicLinkDnsSupport.</p>
-- @param NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param MaxResults [MaxResults] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- @param VpcIds [VpcClassicLinkIdList] <p>One or more VPC IDs.</p>
function M.DescribeVpcClassicLinkDnsSupportRequest(NextToken, MaxResults, VpcIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcClassicLinkDnsSupportRequest")
	local t = { 
		["NextToken"] = NextToken,
		["MaxResults"] = MaxResults,
		["VpcIds"] = VpcIds,
	}
	M.AssertDescribeVpcClassicLinkDnsSupportRequest(t)
	return t
end

local DescribeSpotInstanceRequestsRequest_keys = { "SpotInstanceRequestIds" = true, "DryRun" = true, "Filters" = true, nil }

function M.AssertDescribeSpotInstanceRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotInstanceRequestsRequest to be of type 'table'")
	if struct["SpotInstanceRequestIds"] then M.AssertSpotInstanceRequestIdList(struct["SpotInstanceRequestIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotInstanceRequestsRequest_keys[k], "DescribeSpotInstanceRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotInstanceRequestsRequest
-- <p>Contains the parameters for DescribeSpotInstanceRequests.</p>
-- @param SpotInstanceRequestIds [SpotInstanceRequestIdList] <p>One or more Spot instance request IDs.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone-group</code> - The Availability Zone group.</p> </li> <li> <p> <code>create-time</code> - The time stamp when the Spot instance request was created.</p> </li> <li> <p> <code>fault-code</code> - The fault code related to the request.</p> </li> <li> <p> <code>fault-message</code> - The fault message related to the request.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance that fulfilled the request.</p> </li> <li> <p> <code>launch-group</code> - The Spot instance launch group.</p> </li> <li> <p> <code>launch.block-device-mapping.delete-on-termination</code> - Indicates whether the Amazon EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>launch.block-device-mapping.device-name</code> - The device name for the Amazon EBS volume (for example, <code>/dev/sdh</code>).</p> </li> <li> <p> <code>launch.block-device-mapping.snapshot-id</code> - The ID of the snapshot used for the Amazon EBS volume.</p> </li> <li> <p> <code>launch.block-device-mapping.volume-size</code> - The size of the Amazon EBS volume, in GiB.</p> </li> <li> <p> <code>launch.block-device-mapping.volume-type</code> - The type of the Amazon EBS volume: <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code>for Cold HDD, or <code>standard</code> for Magnetic.</p> </li> <li> <p> <code>launch.group-id</code> - The security group for the instance.</p> </li> <li> <p> <code>launch.image-id</code> - The ID of the AMI.</p> </li> <li> <p> <code>launch.instance-type</code> - The type of instance (for example, <code>m3.medium</code>).</p> </li> <li> <p> <code>launch.kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>launch.key-name</code> - The name of the key pair the instance launched with.</p> </li> <li> <p> <code>launch.monitoring-enabled</code> - Whether monitoring is enabled for the Spot instance.</p> </li> <li> <p> <code>launch.ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>network-interface.network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>network-interface.device-index</code> - The index of the device for the network interface attachment on the instance.</p> </li> <li> <p> <code>network-interface.subnet-id</code> - The ID of the subnet for the instance.</p> </li> <li> <p> <code>network-interface.description</code> - A description of the network interface.</p> </li> <li> <p> <code>network-interface.private-ip-address</code> - The primary private IP address of the network interface.</p> </li> <li> <p> <code>network-interface.delete-on-termination</code> - Indicates whether the network interface is deleted when the instance is terminated.</p> </li> <li> <p> <code>network-interface.group-id</code> - The ID of the security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.group-name</code> - The name of the security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.addresses.primary</code> - Indicates whether the IP address is the primary private IP address.</p> </li> <li> <p> <code>product-description</code> - The product description associated with the instance (<code>Linux/UNIX</code> | <code>Windows</code>).</p> </li> <li> <p> <code>spot-instance-request-id</code> - The Spot instance request ID.</p> </li> <li> <p> <code>spot-price</code> - The maximum hourly price for any Spot instance launched to fulfill the request.</p> </li> <li> <p> <code>state</code> - The state of the Spot instance request (<code>open</code> | <code>active</code> | <code>closed</code> | <code>cancelled</code> | <code>failed</code>). Spot bid status information can help you track your Amazon EC2 Spot instance requests. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot Bid Status</a> in the Amazon Elastic Compute Cloud User Guide.</p> </li> <li> <p> <code>status-code</code> - The short code describing the most recent evaluation of your Spot instance request.</p> </li> <li> <p> <code>status-message</code> - The message explaining the status of the Spot instance request.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>type</code> - The type of Spot instance request (<code>one-time</code> | <code>persistent</code>).</p> </li> <li> <p> <code>launched-availability-zone</code> - The Availability Zone in which the bid is launched.</p> </li> <li> <p> <code>valid-from</code> - The start date of the request.</p> </li> <li> <p> <code>valid-until</code> - The end date of the request.</p> </li> </ul>
function M.DescribeSpotInstanceRequestsRequest(SpotInstanceRequestIds, DryRun, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotInstanceRequestsRequest")
	local t = { 
		["SpotInstanceRequestIds"] = SpotInstanceRequestIds,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
	}
	M.AssertDescribeSpotInstanceRequestsRequest(t)
	return t
end

local DeleteRouteTableRequest_keys = { "RouteTableId" = true, "DryRun" = true, nil }

function M.AssertDeleteRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRouteTableRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["RouteTableId"] then M.AssertString(struct["RouteTableId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteRouteTableRequest_keys[k], "DeleteRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRouteTableRequest
-- <p>Contains the parameters for DeleteRouteTable.</p>
-- @param RouteTableId [String] <p>The ID of the route table.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: RouteTableId
function M.DeleteRouteTableRequest(RouteTableId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteRouteTableRequest")
	local t = { 
		["RouteTableId"] = RouteTableId,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteRouteTableRequest(t)
	return t
end

local CreateVpnConnectionRouteRequest_keys = { "VpnConnectionId" = true, "DestinationCidrBlock" = true, nil }

function M.AssertCreateVpnConnectionRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionRouteRequest to be of type 'table'")
	assert(struct["DestinationCidrBlock"], "Expected key DestinationCidrBlock to exist in table")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then M.AssertString(struct["VpnConnectionId"]) end
	if struct["DestinationCidrBlock"] then M.AssertString(struct["DestinationCidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpnConnectionRouteRequest_keys[k], "CreateVpnConnectionRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionRouteRequest
-- <p>Contains the parameters for CreateVpnConnectionRoute.</p>
-- @param VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- @param DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer network.</p>
-- Required parameter: DestinationCidrBlock
-- Required parameter: VpnConnectionId
function M.CreateVpnConnectionRouteRequest(VpnConnectionId, DestinationCidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnConnectionRouteRequest")
	local t = { 
		["VpnConnectionId"] = VpnConnectionId,
		["DestinationCidrBlock"] = DestinationCidrBlock,
	}
	M.AssertCreateVpnConnectionRouteRequest(t)
	return t
end

local CreateVpnGatewayRequest_keys = { "DryRun" = true, "AvailabilityZone" = true, "Type" = true, nil }

function M.AssertCreateVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnGatewayRequest to be of type 'table'")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["Type"] then M.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpnGatewayRequest_keys[k], "CreateVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnGatewayRequest
-- <p>Contains the parameters for CreateVpnGateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone for the virtual private gateway.</p>
-- @param Type [GatewayType] <p>The type of VPN connection this virtual private gateway supports.</p>
-- Required parameter: Type
function M.CreateVpnGatewayRequest(DryRun, AvailabilityZone, Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnGatewayRequest")
	local t = { 
		["DryRun"] = DryRun,
		["AvailabilityZone"] = AvailabilityZone,
		["Type"] = Type,
	}
	M.AssertCreateVpnGatewayRequest(t)
	return t
end

local DescribeVpcPeeringConnectionsResult_keys = { "VpcPeeringConnections" = true, nil }

function M.AssertDescribeVpcPeeringConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcPeeringConnectionsResult to be of type 'table'")
	if struct["VpcPeeringConnections"] then M.AssertVpcPeeringConnectionList(struct["VpcPeeringConnections"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcPeeringConnectionsResult_keys[k], "DescribeVpcPeeringConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcPeeringConnectionsResult
-- <p>Contains the output of DescribeVpcPeeringConnections.</p>
-- @param VpcPeeringConnections [VpcPeeringConnectionList] <p>Information about the VPC peering connections.</p>
function M.DescribeVpcPeeringConnectionsResult(VpcPeeringConnections, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcPeeringConnectionsResult")
	local t = { 
		["VpcPeeringConnections"] = VpcPeeringConnections,
	}
	M.AssertDescribeVpcPeeringConnectionsResult(t)
	return t
end

local CreateDhcpOptionsResult_keys = { "DhcpOptions" = true, nil }

function M.AssertCreateDhcpOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDhcpOptionsResult to be of type 'table'")
	if struct["DhcpOptions"] then M.AssertDhcpOptions(struct["DhcpOptions"]) end
	for k,_ in pairs(struct) do
		assert(CreateDhcpOptionsResult_keys[k], "CreateDhcpOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDhcpOptionsResult
-- <p>Contains the output of CreateDhcpOptions.</p>
-- @param DhcpOptions [DhcpOptions] <p>A set of DHCP options.</p>
function M.CreateDhcpOptionsResult(DhcpOptions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateDhcpOptionsResult")
	local t = { 
		["DhcpOptions"] = DhcpOptions,
	}
	M.AssertCreateDhcpOptionsResult(t)
	return t
end

local DeleteKeyPairRequest_keys = { "KeyName" = true, "DryRun" = true, nil }

function M.AssertDeleteKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteKeyPairRequest_keys[k], "DeleteKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteKeyPairRequest
-- <p>Contains the parameters for DeleteKeyPair.</p>
-- @param KeyName [String] <p>The name of the key pair.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: KeyName
function M.DeleteKeyPairRequest(KeyName, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteKeyPairRequest")
	local t = { 
		["KeyName"] = KeyName,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteKeyPairRequest(t)
	return t
end

local EventInformation_keys = { "InstanceId" = true, "EventSubType" = true, "EventDescription" = true, nil }

function M.AssertEventInformation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EventInformation to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["EventSubType"] then M.AssertString(struct["EventSubType"]) end
	if struct["EventDescription"] then M.AssertString(struct["EventDescription"]) end
	for k,_ in pairs(struct) do
		assert(EventInformation_keys[k], "EventInformation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EventInformation
-- <p>Describes a Spot fleet event.</p>
-- @param InstanceId [String] <p>The ID of the instance. This information is available only for <code>instanceChange</code> events.</p>
-- @param EventSubType [String] <p>The event.</p> <p>The following are the <code>error</code> events.</p> <ul> <li> <p> <code>iamFleetRoleInvalid</code> - The Spot fleet did not have the required permissions either to launch or terminate an instance.</p> </li> <li> <p> <code>launchSpecTemporarilyBlacklisted</code> - The configuration is not valid and several attempts to launch instances have failed. For more information, see the description of the event.</p> </li> <li> <p> <code>spotFleetRequestConfigurationInvalid</code> - The configuration is not valid. For more information, see the description of the event.</p> </li> <li> <p> <code>spotInstanceCountLimitExceeded</code> - You've reached the limit on the number of Spot instances that you can launch.</p> </li> </ul> <p>The following are the <code>fleetRequestChange</code> events.</p> <ul> <li> <p> <code>active</code> - The Spot fleet has been validated and Amazon EC2 is attempting to maintain the target number of running Spot instances.</p> </li> <li> <p> <code>cancelled</code> - The Spot fleet is canceled and has no running Spot instances. The Spot fleet will be deleted two days after its instances were terminated.</p> </li> <li> <p> <code>cancelled_running</code> - The Spot fleet is canceled and will not launch additional Spot instances, but its existing Spot instances continue to run until they are interrupted or terminated.</p> </li> <li> <p> <code>cancelled_terminating</code> - The Spot fleet is canceled and its Spot instances are terminating.</p> </li> <li> <p> <code>expired</code> - The Spot fleet request has expired. A subsequent event indicates that the instances were terminated, if the request was created with <code>TerminateInstancesWithExpiration</code> set.</p> </li> <li> <p> <code>modify_in_progress</code> - A request to modify the Spot fleet request was accepted and is in progress.</p> </li> <li> <p> <code>modify_successful</code> - The Spot fleet request was modified.</p> </li> <li> <p> <code>price_update</code> - The bid price for a launch configuration was adjusted because it was too high. This change is permanent.</p> </li> <li> <p> <code>submitted</code> - The Spot fleet request is being evaluated and Amazon EC2 is preparing to launch the target number of Spot instances.</p> </li> </ul> <p>The following are the <code>instanceChange</code> events.</p> <ul> <li> <p> <code>launched</code> - A bid was fulfilled and a new instance was launched.</p> </li> <li> <p> <code>terminated</code> - An instance was terminated by the user.</p> </li> </ul>
-- @param EventDescription [String] <p>The description of the event.</p>
function M.EventInformation(InstanceId, EventSubType, EventDescription, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EventInformation")
	local t = { 
		["InstanceId"] = InstanceId,
		["EventSubType"] = EventSubType,
		["EventDescription"] = EventDescription,
	}
	M.AssertEventInformation(t)
	return t
end

local TerminateInstancesRequest_keys = { "DryRun" = true, "InstanceIds" = true, nil }

function M.AssertTerminateInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then M.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(TerminateInstancesRequest_keys[k], "TerminateInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateInstancesRequest
-- <p>Contains the parameters for TerminateInstances.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Constraints: Up to 1000 instance IDs. We recommend breaking up this request into smaller batches.</p>
-- Required parameter: InstanceIds
function M.TerminateInstancesRequest(DryRun, InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TerminateInstancesRequest")
	local t = { 
		["DryRun"] = DryRun,
		["InstanceIds"] = InstanceIds,
	}
	M.AssertTerminateInstancesRequest(t)
	return t
end

local CreateVpnConnectionResult_keys = { "VpnConnection" = true, nil }

function M.AssertCreateVpnConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionResult to be of type 'table'")
	if struct["VpnConnection"] then M.AssertVpnConnection(struct["VpnConnection"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpnConnectionResult_keys[k], "CreateVpnConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionResult
-- <p>Contains the output of CreateVpnConnection.</p>
-- @param VpnConnection [VpnConnection] <p>Information about the VPN connection.</p>
function M.CreateVpnConnectionResult(VpnConnection, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnConnectionResult")
	local t = { 
		["VpnConnection"] = VpnConnection,
	}
	M.AssertCreateVpnConnectionResult(t)
	return t
end

local InstanceStatusDetails_keys = { "Status" = true, "ImpairedSince" = true, "Name" = true, nil }

function M.AssertInstanceStatusDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusDetails to be of type 'table'")
	if struct["Status"] then M.AssertStatusType(struct["Status"]) end
	if struct["ImpairedSince"] then M.AssertDateTime(struct["ImpairedSince"]) end
	if struct["Name"] then M.AssertStatusName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(InstanceStatusDetails_keys[k], "InstanceStatusDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusDetails
-- <p>Describes the instance status.</p>
-- @param Status [StatusType] <p>The status.</p>
-- @param ImpairedSince [DateTime] <p>The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.</p>
-- @param Name [StatusName] <p>The type of instance status.</p>
function M.InstanceStatusDetails(Status, ImpairedSince, Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStatusDetails")
	local t = { 
		["Status"] = Status,
		["ImpairedSince"] = ImpairedSince,
		["Name"] = Name,
	}
	M.AssertInstanceStatusDetails(t)
	return t
end

local SlotStartTimeRangeRequest_keys = { "LatestTime" = true, "EarliestTime" = true, nil }

function M.AssertSlotStartTimeRangeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SlotStartTimeRangeRequest to be of type 'table'")
	if struct["LatestTime"] then M.AssertDateTime(struct["LatestTime"]) end
	if struct["EarliestTime"] then M.AssertDateTime(struct["EarliestTime"]) end
	for k,_ in pairs(struct) do
		assert(SlotStartTimeRangeRequest_keys[k], "SlotStartTimeRangeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SlotStartTimeRangeRequest
-- <p>Describes the time period for a Scheduled Instance to start its first schedule.</p>
-- @param LatestTime [DateTime] <p>The latest date and time, in UTC, for the Scheduled Instance to start.</p>
-- @param EarliestTime [DateTime] <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
function M.SlotStartTimeRangeRequest(LatestTime, EarliestTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SlotStartTimeRangeRequest")
	local t = { 
		["LatestTime"] = LatestTime,
		["EarliestTime"] = EarliestTime,
	}
	M.AssertSlotStartTimeRangeRequest(t)
	return t
end

local DescribeRouteTablesResult_keys = { "RouteTables" = true, nil }

function M.AssertDescribeRouteTablesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRouteTablesResult to be of type 'table'")
	if struct["RouteTables"] then M.AssertRouteTableList(struct["RouteTables"]) end
	for k,_ in pairs(struct) do
		assert(DescribeRouteTablesResult_keys[k], "DescribeRouteTablesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRouteTablesResult
-- <p>Contains the output of DescribeRouteTables.</p>
-- @param RouteTables [RouteTableList] <p>Information about one or more route tables.</p>
function M.DescribeRouteTablesResult(RouteTables, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeRouteTablesResult")
	local t = { 
		["RouteTables"] = RouteTables,
	}
	M.AssertDescribeRouteTablesResult(t)
	return t
end

local ReservedInstancesModification_keys = { "Status" = true, "ModificationResults" = true, "EffectiveDate" = true, "CreateDate" = true, "StatusMessage" = true, "ClientToken" = true, "ReservedInstancesModificationId" = true, "ReservedInstancesIds" = true, "UpdateDate" = true, nil }

function M.AssertReservedInstancesModification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesModification to be of type 'table'")
	if struct["Status"] then M.AssertString(struct["Status"]) end
	if struct["ModificationResults"] then M.AssertReservedInstancesModificationResultList(struct["ModificationResults"]) end
	if struct["EffectiveDate"] then M.AssertDateTime(struct["EffectiveDate"]) end
	if struct["CreateDate"] then M.AssertDateTime(struct["CreateDate"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["ReservedInstancesModificationId"] then M.AssertString(struct["ReservedInstancesModificationId"]) end
	if struct["ReservedInstancesIds"] then M.AssertReservedIntancesIds(struct["ReservedInstancesIds"]) end
	if struct["UpdateDate"] then M.AssertDateTime(struct["UpdateDate"]) end
	for k,_ in pairs(struct) do
		assert(ReservedInstancesModification_keys[k], "ReservedInstancesModification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesModification
-- <p>Describes a Reserved Instance modification.</p>
-- @param Status [String] <p>The status of the Reserved Instances modification request.</p>
-- @param ModificationResults [ReservedInstancesModificationResultList] <p>Contains target configurations along with their corresponding new Reserved Instance IDs.</p>
-- @param EffectiveDate [DateTime] <p>The time for the modification to become effective.</p>
-- @param CreateDate [DateTime] <p>The time when the modification request was created.</p>
-- @param StatusMessage [String] <p>The reason for the status.</p>
-- @param ClientToken [String] <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- @param ReservedInstancesModificationId [String] <p>A unique ID for the Reserved Instance modification.</p>
-- @param ReservedInstancesIds [ReservedIntancesIds] <p>The IDs of one or more Reserved Instances.</p>
-- @param UpdateDate [DateTime] <p>The time when the modification request was last updated.</p>
function M.ReservedInstancesModification(Status, ModificationResults, EffectiveDate, CreateDate, StatusMessage, ClientToken, ReservedInstancesModificationId, ReservedInstancesIds, UpdateDate, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesModification")
	local t = { 
		["Status"] = Status,
		["ModificationResults"] = ModificationResults,
		["EffectiveDate"] = EffectiveDate,
		["CreateDate"] = CreateDate,
		["StatusMessage"] = StatusMessage,
		["ClientToken"] = ClientToken,
		["ReservedInstancesModificationId"] = ReservedInstancesModificationId,
		["ReservedInstancesIds"] = ReservedInstancesIds,
		["UpdateDate"] = UpdateDate,
	}
	M.AssertReservedInstancesModification(t)
	return t
end

local DescribeSpotFleetRequestHistoryRequest_keys = { "SpotFleetRequestId" = true, "DryRun" = true, "EventType" = true, "MaxResults" = true, "StartTime" = true, "NextToken" = true, nil }

function M.AssertDescribeSpotFleetRequestHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestHistoryRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["StartTime"], "Expected key StartTime to exist in table")
	if struct["SpotFleetRequestId"] then M.AssertString(struct["SpotFleetRequestId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["EventType"] then M.AssertEventType(struct["EventType"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["StartTime"] then M.AssertDateTime(struct["StartTime"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotFleetRequestHistoryRequest_keys[k], "DescribeSpotFleetRequestHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestHistoryRequest
-- <p>Contains the parameters for DescribeSpotFleetRequestHistory.</p>
-- @param SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param EventType [EventType] <p>The type of events to describe. By default, all events are described.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param StartTime [DateTime] <p>The starting date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @param NextToken [String] <p>The token for the next set of results.</p>
-- Required parameter: SpotFleetRequestId
-- Required parameter: StartTime
function M.DescribeSpotFleetRequestHistoryRequest(SpotFleetRequestId, DryRun, EventType, MaxResults, StartTime, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetRequestHistoryRequest")
	local t = { 
		["SpotFleetRequestId"] = SpotFleetRequestId,
		["DryRun"] = DryRun,
		["EventType"] = EventType,
		["MaxResults"] = MaxResults,
		["StartTime"] = StartTime,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeSpotFleetRequestHistoryRequest(t)
	return t
end

local InstanceIpv6Address_keys = { "Ipv6Address" = true, nil }

function M.AssertInstanceIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then M.AssertString(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(InstanceIpv6Address_keys[k], "InstanceIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceIpv6Address
-- <p>Describes an IPv6 address.</p>
-- @param Ipv6Address [String] <p>The IPv6 address.</p>
function M.InstanceIpv6Address(Ipv6Address, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceIpv6Address")
	local t = { 
		["Ipv6Address"] = Ipv6Address,
	}
	M.AssertInstanceIpv6Address(t)
	return t
end

local Ipv6CidrBlock_keys = { "Ipv6CidrBlock" = true, nil }

function M.AssertIpv6CidrBlock(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Ipv6CidrBlock to be of type 'table'")
	if struct["Ipv6CidrBlock"] then M.AssertString(struct["Ipv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(Ipv6CidrBlock_keys[k], "Ipv6CidrBlock contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Ipv6CidrBlock
-- <p>Describes an IPv6 CIDR block.</p>
-- @param Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
function M.Ipv6CidrBlock(Ipv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Ipv6CidrBlock")
	local t = { 
		["Ipv6CidrBlock"] = Ipv6CidrBlock,
	}
	M.AssertIpv6CidrBlock(t)
	return t
end

local ModifyVpcEndpointRequest_keys = { "DryRun" = true, "AddRouteTableIds" = true, "ResetPolicy" = true, "RemoveRouteTableIds" = true, "PolicyDocument" = true, "VpcEndpointId" = true, nil }

function M.AssertModifyVpcEndpointRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointRequest to be of type 'table'")
	assert(struct["VpcEndpointId"], "Expected key VpcEndpointId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["AddRouteTableIds"] then M.AssertValueStringList(struct["AddRouteTableIds"]) end
	if struct["ResetPolicy"] then M.AssertBoolean(struct["ResetPolicy"]) end
	if struct["RemoveRouteTableIds"] then M.AssertValueStringList(struct["RemoveRouteTableIds"]) end
	if struct["PolicyDocument"] then M.AssertString(struct["PolicyDocument"]) end
	if struct["VpcEndpointId"] then M.AssertString(struct["VpcEndpointId"]) end
	for k,_ in pairs(struct) do
		assert(ModifyVpcEndpointRequest_keys[k], "ModifyVpcEndpointRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointRequest
-- <p>Contains the parameters for ModifyVpcEndpoint.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param AddRouteTableIds [ValueStringList] <p>One or more route tables IDs to associate with the endpoint.</p>
-- @param ResetPolicy [Boolean] <p>Specify <code>true</code> to reset the policy document to the default policy. The default policy allows access to the service.</p>
-- @param RemoveRouteTableIds [ValueStringList] <p>One or more route table IDs to disassociate from the endpoint.</p>
-- @param PolicyDocument [String] <p>A policy document to attach to the endpoint. The policy must be in valid JSON format.</p>
-- @param VpcEndpointId [String] <p>The ID of the endpoint.</p>
-- Required parameter: VpcEndpointId
function M.ModifyVpcEndpointRequest(DryRun, AddRouteTableIds, ResetPolicy, RemoveRouteTableIds, PolicyDocument, VpcEndpointId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcEndpointRequest")
	local t = { 
		["DryRun"] = DryRun,
		["AddRouteTableIds"] = AddRouteTableIds,
		["ResetPolicy"] = ResetPolicy,
		["RemoveRouteTableIds"] = RemoveRouteTableIds,
		["PolicyDocument"] = PolicyDocument,
		["VpcEndpointId"] = VpcEndpointId,
	}
	M.AssertModifyVpcEndpointRequest(t)
	return t
end

local ReservedInstancesListing_keys = { "ReservedInstancesId" = true, "Status" = true, "Tags" = true, "PriceSchedules" = true, "CreateDate" = true, "ClientToken" = true, "ReservedInstancesListingId" = true, "UpdateDate" = true, "InstanceCounts" = true, "StatusMessage" = true, nil }

function M.AssertReservedInstancesListing(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesListing to be of type 'table'")
	if struct["ReservedInstancesId"] then M.AssertString(struct["ReservedInstancesId"]) end
	if struct["Status"] then M.AssertListingStatus(struct["Status"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["PriceSchedules"] then M.AssertPriceScheduleList(struct["PriceSchedules"]) end
	if struct["CreateDate"] then M.AssertDateTime(struct["CreateDate"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	if struct["ReservedInstancesListingId"] then M.AssertString(struct["ReservedInstancesListingId"]) end
	if struct["UpdateDate"] then M.AssertDateTime(struct["UpdateDate"]) end
	if struct["InstanceCounts"] then M.AssertInstanceCountList(struct["InstanceCounts"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(ReservedInstancesListing_keys[k], "ReservedInstancesListing contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesListing
-- <p>Describes a Reserved Instance listing.</p>
-- @param ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- @param Status [ListingStatus] <p>The status of the Reserved Instance listing.</p>
-- @param Tags [TagList] <p>Any tags assigned to the resource.</p>
-- @param PriceSchedules [PriceScheduleList] <p>The price of the Reserved Instance listing.</p>
-- @param CreateDate [DateTime] <p>The time the listing was created.</p>
-- @param ClientToken [String] <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- @param ReservedInstancesListingId [String] <p>The ID of the Reserved Instance listing.</p>
-- @param UpdateDate [DateTime] <p>The last modified timestamp of the listing.</p>
-- @param InstanceCounts [InstanceCountList] <p>The number of instances in this state.</p>
-- @param StatusMessage [String] <p>The reason for the current status of the Reserved Instance listing. The response can be blank.</p>
function M.ReservedInstancesListing(ReservedInstancesId, Status, Tags, PriceSchedules, CreateDate, ClientToken, ReservedInstancesListingId, UpdateDate, InstanceCounts, StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesListing")
	local t = { 
		["ReservedInstancesId"] = ReservedInstancesId,
		["Status"] = Status,
		["Tags"] = Tags,
		["PriceSchedules"] = PriceSchedules,
		["CreateDate"] = CreateDate,
		["ClientToken"] = ClientToken,
		["ReservedInstancesListingId"] = ReservedInstancesListingId,
		["UpdateDate"] = UpdateDate,
		["InstanceCounts"] = InstanceCounts,
		["StatusMessage"] = StatusMessage,
	}
	M.AssertReservedInstancesListing(t)
	return t
end

local Route_keys = { "Origin" = true, "DestinationCidrBlock" = true, "EgressOnlyInternetGatewayId" = true, "DestinationPrefixListId" = true, "InstanceId" = true, "NetworkInterfaceId" = true, "State" = true, "NatGatewayId" = true, "VpcPeeringConnectionId" = true, "GatewayId" = true, "DestinationIpv6CidrBlock" = true, "InstanceOwnerId" = true, nil }

function M.AssertRoute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Route to be of type 'table'")
	if struct["Origin"] then M.AssertRouteOrigin(struct["Origin"]) end
	if struct["DestinationCidrBlock"] then M.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then M.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DestinationPrefixListId"] then M.AssertString(struct["DestinationPrefixListId"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["State"] then M.AssertRouteState(struct["State"]) end
	if struct["NatGatewayId"] then M.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then M.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then M.AssertString(struct["DestinationIpv6CidrBlock"]) end
	if struct["InstanceOwnerId"] then M.AssertString(struct["InstanceOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(Route_keys[k], "Route contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Route
-- <p>Describes a route in a route table.</p>
-- @param Origin [RouteOrigin] <p>Describes how the route was created.</p> <ul> <li> <p> <code>CreateRouteTable</code> - The route was automatically created when the route table was created.</p> </li> <li> <p> <code>CreateRoute</code> - The route was manually added to the route table.</p> </li> <li> <p> <code>EnableVgwRoutePropagation</code> - The route was propagated by route propagation.</p> </li> </ul>
-- @param DestinationCidrBlock [String] <p>The IPv4 CIDR block used for the destination match.</p>
-- @param EgressOnlyInternetGatewayId [String] <p>The ID of the egress-only Internet gateway.</p>
-- @param DestinationPrefixListId [String] <p>The prefix of the AWS service.</p>
-- @param InstanceId [String] <p>The ID of a NAT instance in your VPC.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param State [RouteState] <p>The state of the route. The <code>blackhole</code> state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, or the specified NAT instance has been terminated).</p>
-- @param NatGatewayId [String] <p>The ID of a NAT gateway.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- @param GatewayId [String] <p>The ID of a gateway attached to your VPC.</p>
-- @param DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR block used for the destination match.</p>
-- @param InstanceOwnerId [String] <p>The AWS account ID of the owner of the instance.</p>
function M.Route(Origin, DestinationCidrBlock, EgressOnlyInternetGatewayId, DestinationPrefixListId, InstanceId, NetworkInterfaceId, State, NatGatewayId, VpcPeeringConnectionId, GatewayId, DestinationIpv6CidrBlock, InstanceOwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Route")
	local t = { 
		["Origin"] = Origin,
		["DestinationCidrBlock"] = DestinationCidrBlock,
		["EgressOnlyInternetGatewayId"] = EgressOnlyInternetGatewayId,
		["DestinationPrefixListId"] = DestinationPrefixListId,
		["InstanceId"] = InstanceId,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["State"] = State,
		["NatGatewayId"] = NatGatewayId,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
		["GatewayId"] = GatewayId,
		["DestinationIpv6CidrBlock"] = DestinationIpv6CidrBlock,
		["InstanceOwnerId"] = InstanceOwnerId,
	}
	M.AssertRoute(t)
	return t
end

local ProductCode_keys = { "ProductCodeId" = true, "ProductCodeType" = true, nil }

function M.AssertProductCode(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProductCode to be of type 'table'")
	if struct["ProductCodeId"] then M.AssertString(struct["ProductCodeId"]) end
	if struct["ProductCodeType"] then M.AssertProductCodeValues(struct["ProductCodeType"]) end
	for k,_ in pairs(struct) do
		assert(ProductCode_keys[k], "ProductCode contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProductCode
-- <p>Describes a product code.</p>
-- @param ProductCodeId [String] <p>The product code.</p>
-- @param ProductCodeType [ProductCodeValues] <p>The type of product code.</p>
function M.ProductCode(ProductCodeId, ProductCodeType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ProductCode")
	local t = { 
		["ProductCodeId"] = ProductCodeId,
		["ProductCodeType"] = ProductCodeType,
	}
	M.AssertProductCode(t)
	return t
end

local Ipv6Range_keys = { "CidrIpv6" = true, nil }

function M.AssertIpv6Range(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Ipv6Range to be of type 'table'")
	if struct["CidrIpv6"] then M.AssertString(struct["CidrIpv6"]) end
	for k,_ in pairs(struct) do
		assert(Ipv6Range_keys[k], "Ipv6Range contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Ipv6Range
-- <p>[EC2-VPC only] Describes an IPv6 range.</p>
-- @param CidrIpv6 [String] <p>The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix.</p>
function M.Ipv6Range(CidrIpv6, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Ipv6Range")
	local t = { 
		["CidrIpv6"] = CidrIpv6,
	}
	M.AssertIpv6Range(t)
	return t
end

local AcceptReservedInstancesExchangeQuoteResult_keys = { "ExchangeId" = true, nil }

function M.AssertAcceptReservedInstancesExchangeQuoteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptReservedInstancesExchangeQuoteResult to be of type 'table'")
	if struct["ExchangeId"] then M.AssertString(struct["ExchangeId"]) end
	for k,_ in pairs(struct) do
		assert(AcceptReservedInstancesExchangeQuoteResult_keys[k], "AcceptReservedInstancesExchangeQuoteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptReservedInstancesExchangeQuoteResult
-- <p>The result of the exchange and whether it was <code>successful</code>.</p>
-- @param ExchangeId [String] <p>The ID of the successful exchange.</p>
function M.AcceptReservedInstancesExchangeQuoteResult(ExchangeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AcceptReservedInstancesExchangeQuoteResult")
	local t = { 
		["ExchangeId"] = ExchangeId,
	}
	M.AssertAcceptReservedInstancesExchangeQuoteResult(t)
	return t
end

local AssociateSubnetCidrBlockResult_keys = { "SubnetId" = true, "Ipv6CidrBlockAssociation" = true, nil }

function M.AssertAssociateSubnetCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateSubnetCidrBlockResult to be of type 'table'")
	if struct["SubnetId"] then M.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlockAssociation"] then M.AssertSubnetIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	for k,_ in pairs(struct) do
		assert(AssociateSubnetCidrBlockResult_keys[k], "AssociateSubnetCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateSubnetCidrBlockResult
--  
-- @param SubnetId [String] <p>The ID of the subnet.</p>
-- @param Ipv6CidrBlockAssociation [SubnetIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
function M.AssociateSubnetCidrBlockResult(SubnetId, Ipv6CidrBlockAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateSubnetCidrBlockResult")
	local t = { 
		["SubnetId"] = SubnetId,
		["Ipv6CidrBlockAssociation"] = Ipv6CidrBlockAssociation,
	}
	M.AssertAssociateSubnetCidrBlockResult(t)
	return t
end

local SpotPrice_keys = { "Timestamp" = true, "AvailabilityZone" = true, "InstanceType" = true, "ProductDescription" = true, "SpotPrice" = true, nil }

function M.AssertSpotPrice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotPrice to be of type 'table'")
	if struct["Timestamp"] then M.AssertDateTime(struct["Timestamp"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["ProductDescription"] then M.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["SpotPrice"] then M.AssertString(struct["SpotPrice"]) end
	for k,_ in pairs(struct) do
		assert(SpotPrice_keys[k], "SpotPrice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotPrice
-- <p>Describes the maximum hourly price (bid) for any Spot instance launched to fulfill the request.</p>
-- @param Timestamp [DateTime] <p>The date and time the request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @param AvailabilityZone [String] <p>The Availability Zone.</p>
-- @param InstanceType [InstanceType] <p>The instance type. Note that T2 and HS1 instance types are not supported.</p>
-- @param ProductDescription [RIProductDescription] <p>A general description of the AMI.</p>
-- @param SpotPrice [String] <p>The maximum price (bid) that you are willing to pay for a Spot instance.</p>
function M.SpotPrice(Timestamp, AvailabilityZone, InstanceType, ProductDescription, SpotPrice, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotPrice")
	local t = { 
		["Timestamp"] = Timestamp,
		["AvailabilityZone"] = AvailabilityZone,
		["InstanceType"] = InstanceType,
		["ProductDescription"] = ProductDescription,
		["SpotPrice"] = SpotPrice,
	}
	M.AssertSpotPrice(t)
	return t
end

local PrefixList_keys = { "PrefixListName" = true, "Cidrs" = true, "PrefixListId" = true, nil }

function M.AssertPrefixList(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrefixList to be of type 'table'")
	if struct["PrefixListName"] then M.AssertString(struct["PrefixListName"]) end
	if struct["Cidrs"] then M.AssertValueStringList(struct["Cidrs"]) end
	if struct["PrefixListId"] then M.AssertString(struct["PrefixListId"]) end
	for k,_ in pairs(struct) do
		assert(PrefixList_keys[k], "PrefixList contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrefixList
-- <p>Describes prefixes for AWS services.</p>
-- @param PrefixListName [String] <p>The name of the prefix.</p>
-- @param Cidrs [ValueStringList] <p>The IP address range of the AWS service.</p>
-- @param PrefixListId [String] <p>The ID of the prefix.</p>
function M.PrefixList(PrefixListName, Cidrs, PrefixListId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PrefixList")
	local t = { 
		["PrefixListName"] = PrefixListName,
		["Cidrs"] = Cidrs,
		["PrefixListId"] = PrefixListId,
	}
	M.AssertPrefixList(t)
	return t
end

local DeleteVpcEndpointsRequest_keys = { "VpcEndpointIds" = true, "DryRun" = true, nil }

function M.AssertDeleteVpcEndpointsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointsRequest to be of type 'table'")
	assert(struct["VpcEndpointIds"], "Expected key VpcEndpointIds to exist in table")
	if struct["VpcEndpointIds"] then M.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteVpcEndpointsRequest_keys[k], "DeleteVpcEndpointsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointsRequest
-- <p>Contains the parameters for DeleteVpcEndpoints.</p>
-- @param VpcEndpointIds [ValueStringList] <p>One or more endpoint IDs.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcEndpointIds
function M.DeleteVpcEndpointsRequest(VpcEndpointIds, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcEndpointsRequest")
	local t = { 
		["VpcEndpointIds"] = VpcEndpointIds,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteVpcEndpointsRequest(t)
	return t
end

local Image_keys = { "RootDeviceType" = true, "State" = true, "ImageLocation" = true, "RamdiskId" = true, "Public" = true, "ProductCodes" = true, "Description" = true, "Tags" = true, "EnaSupport" = true, "SriovNetSupport" = true, "ImageId" = true, "KernelId" = true, "Name" = true, "Hypervisor" = true, "BlockDeviceMappings" = true, "Architecture" = true, "ImageOwnerAlias" = true, "StateReason" = true, "RootDeviceName" = true, "ImageType" = true, "VirtualizationType" = true, "Platform" = true, "OwnerId" = true, "CreationDate" = true, nil }

function M.AssertImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Image to be of type 'table'")
	if struct["RootDeviceType"] then M.AssertDeviceType(struct["RootDeviceType"]) end
	if struct["State"] then M.AssertImageState(struct["State"]) end
	if struct["ImageLocation"] then M.AssertString(struct["ImageLocation"]) end
	if struct["RamdiskId"] then M.AssertString(struct["RamdiskId"]) end
	if struct["Public"] then M.AssertBoolean(struct["Public"]) end
	if struct["ProductCodes"] then M.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["EnaSupport"] then M.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then M.AssertString(struct["SriovNetSupport"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["KernelId"] then M.AssertString(struct["KernelId"]) end
	if struct["Name"] then M.AssertString(struct["Name"]) end
	if struct["Hypervisor"] then M.AssertHypervisorType(struct["Hypervisor"]) end
	if struct["BlockDeviceMappings"] then M.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then M.AssertArchitectureValues(struct["Architecture"]) end
	if struct["ImageOwnerAlias"] then M.AssertString(struct["ImageOwnerAlias"]) end
	if struct["StateReason"] then M.AssertStateReason(struct["StateReason"]) end
	if struct["RootDeviceName"] then M.AssertString(struct["RootDeviceName"]) end
	if struct["ImageType"] then M.AssertImageTypeValues(struct["ImageType"]) end
	if struct["VirtualizationType"] then M.AssertVirtualizationType(struct["VirtualizationType"]) end
	if struct["Platform"] then M.AssertPlatformValues(struct["Platform"]) end
	if struct["OwnerId"] then M.AssertString(struct["OwnerId"]) end
	if struct["CreationDate"] then M.AssertString(struct["CreationDate"]) end
	for k,_ in pairs(struct) do
		assert(Image_keys[k], "Image contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Image
-- <p>Describes an image.</p>
-- @param RootDeviceType [DeviceType] <p>The type of root device used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
-- @param State [ImageState] <p>The current state of the AMI. If the state is <code>available</code>, the image is successfully registered and can be used to launch an instance.</p>
-- @param ImageLocation [String] <p>The location of the AMI.</p>
-- @param RamdiskId [String] <p>The RAM disk associated with the image, if any. Only applicable for machine images.</p>
-- @param Public [Boolean] <p>Indicates whether the image has public launch permissions. The value is <code>true</code> if this image has public launch permissions or <code>false</code> if it has only implicit and explicit launch permissions.</p>
-- @param ProductCodes [ProductCodeList] <p>Any product codes associated with the AMI.</p>
-- @param Description [String] <p>The description of the AMI that was provided during image creation.</p>
-- @param Tags [TagList] <p>Any tags assigned to the image.</p>
-- @param EnaSupport [Boolean] <p>Specifies whether enhanced networking with ENA is enabled.</p>
-- @param SriovNetSupport [String] <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- @param ImageId [String] <p>The ID of the AMI.</p>
-- @param KernelId [String] <p>The kernel associated with the image, if any. Only applicable for machine images.</p>
-- @param Name [String] <p>The name of the AMI that was provided during image creation.</p>
-- @param Hypervisor [HypervisorType] <p>The hypervisor type of the image.</p>
-- @param BlockDeviceMappings [BlockDeviceMappingList] <p>Any block device mapping entries.</p>
-- @param Architecture [ArchitectureValues] <p>The architecture of the image.</p>
-- @param ImageOwnerAlias [String] <p>The AWS account alias (for example, <code>amazon</code>, <code>self</code>) or the AWS account ID of the AMI owner.</p>
-- @param StateReason [StateReason] <p>The reason for the state change.</p>
-- @param RootDeviceName [String] <p>The device name of the root device (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p>
-- @param ImageType [ImageTypeValues] <p>The type of image.</p>
-- @param VirtualizationType [VirtualizationType] <p>The type of virtualization of the AMI.</p>
-- @param Platform [PlatformValues] <p>The value is <code>Windows</code> for Windows AMIs; otherwise blank.</p>
-- @param OwnerId [String] <p>The AWS account ID of the image owner.</p>
-- @param CreationDate [String] <p>The date and time the image was created.</p>
function M.Image(RootDeviceType, State, ImageLocation, RamdiskId, Public, ProductCodes, Description, Tags, EnaSupport, SriovNetSupport, ImageId, KernelId, Name, Hypervisor, BlockDeviceMappings, Architecture, ImageOwnerAlias, StateReason, RootDeviceName, ImageType, VirtualizationType, Platform, OwnerId, CreationDate, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Image")
	local t = { 
		["RootDeviceType"] = RootDeviceType,
		["State"] = State,
		["ImageLocation"] = ImageLocation,
		["RamdiskId"] = RamdiskId,
		["Public"] = Public,
		["ProductCodes"] = ProductCodes,
		["Description"] = Description,
		["Tags"] = Tags,
		["EnaSupport"] = EnaSupport,
		["SriovNetSupport"] = SriovNetSupport,
		["ImageId"] = ImageId,
		["KernelId"] = KernelId,
		["Name"] = Name,
		["Hypervisor"] = Hypervisor,
		["BlockDeviceMappings"] = BlockDeviceMappings,
		["Architecture"] = Architecture,
		["ImageOwnerAlias"] = ImageOwnerAlias,
		["StateReason"] = StateReason,
		["RootDeviceName"] = RootDeviceName,
		["ImageType"] = ImageType,
		["VirtualizationType"] = VirtualizationType,
		["Platform"] = Platform,
		["OwnerId"] = OwnerId,
		["CreationDate"] = CreationDate,
	}
	M.AssertImage(t)
	return t
end

local DetachNetworkInterfaceRequest_keys = { "DryRun" = true, "AttachmentId" = true, "Force" = true, nil }

function M.AssertDetachNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachNetworkInterfaceRequest to be of type 'table'")
	assert(struct["AttachmentId"], "Expected key AttachmentId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["AttachmentId"] then M.AssertString(struct["AttachmentId"]) end
	if struct["Force"] then M.AssertBoolean(struct["Force"]) end
	for k,_ in pairs(struct) do
		assert(DetachNetworkInterfaceRequest_keys[k], "DetachNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachNetworkInterfaceRequest
-- <p>Contains the parameters for DetachNetworkInterface.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param AttachmentId [String] <p>The ID of the attachment.</p>
-- @param Force [Boolean] <p>Specifies whether to force a detachment.</p>
-- Required parameter: AttachmentId
function M.DetachNetworkInterfaceRequest(DryRun, AttachmentId, Force, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachNetworkInterfaceRequest")
	local t = { 
		["DryRun"] = DryRun,
		["AttachmentId"] = AttachmentId,
		["Force"] = Force,
	}
	M.AssertDetachNetworkInterfaceRequest(t)
	return t
end

local AttachNetworkInterfaceResult_keys = { "AttachmentId" = true, nil }

function M.AssertAttachNetworkInterfaceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachNetworkInterfaceResult to be of type 'table'")
	if struct["AttachmentId"] then M.AssertString(struct["AttachmentId"]) end
	for k,_ in pairs(struct) do
		assert(AttachNetworkInterfaceResult_keys[k], "AttachNetworkInterfaceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachNetworkInterfaceResult
-- <p>Contains the output of AttachNetworkInterface.</p>
-- @param AttachmentId [String] <p>The ID of the network interface attachment.</p>
function M.AttachNetworkInterfaceResult(AttachmentId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachNetworkInterfaceResult")
	local t = { 
		["AttachmentId"] = AttachmentId,
	}
	M.AssertAttachNetworkInterfaceResult(t)
	return t
end

local DescribeReservedInstancesListingsResult_keys = { "ReservedInstancesListings" = true, nil }

function M.AssertDescribeReservedInstancesListingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesListingsResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then M.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(DescribeReservedInstancesListingsResult_keys[k], "DescribeReservedInstancesListingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesListingsResult
-- <p>Contains the output of DescribeReservedInstancesListings.</p>
-- @param ReservedInstancesListings [ReservedInstancesListingList] <p>Information about the Reserved Instance listing.</p>
function M.DescribeReservedInstancesListingsResult(ReservedInstancesListings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesListingsResult")
	local t = { 
		["ReservedInstancesListings"] = ReservedInstancesListings,
	}
	M.AssertDescribeReservedInstancesListingsResult(t)
	return t
end

local DisassociateIamInstanceProfileRequest_keys = { "AssociationId" = true, nil }

function M.AssertDisassociateIamInstanceProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateIamInstanceProfileRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(DisassociateIamInstanceProfileRequest_keys[k], "DisassociateIamInstanceProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateIamInstanceProfileRequest
--  
-- @param AssociationId [String] <p>The ID of the IAM instance profile association.</p>
-- Required parameter: AssociationId
function M.DisassociateIamInstanceProfileRequest(AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateIamInstanceProfileRequest")
	local t = { 
		["AssociationId"] = AssociationId,
	}
	M.AssertDisassociateIamInstanceProfileRequest(t)
	return t
end

local AllocateAddressRequest_keys = { "Domain" = true, "DryRun" = true, nil }

function M.AssertAllocateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateAddressRequest to be of type 'table'")
	if struct["Domain"] then M.AssertDomainType(struct["Domain"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(AllocateAddressRequest_keys[k], "AllocateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateAddressRequest
-- <p>Contains the parameters for AllocateAddress.</p>
-- @param Domain [DomainType] <p>Set to <code>vpc</code> to allocate the address for use with instances in a VPC.</p> <p>Default: The address is for use with instances in EC2-Classic.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.AllocateAddressRequest(Domain, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AllocateAddressRequest")
	local t = { 
		["Domain"] = Domain,
		["DryRun"] = DryRun,
	}
	M.AssertAllocateAddressRequest(t)
	return t
end

local DescribeIamInstanceProfileAssociationsResult_keys = { "IamInstanceProfileAssociations" = true, "NextToken" = true, nil }

function M.AssertDescribeIamInstanceProfileAssociationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIamInstanceProfileAssociationsResult to be of type 'table'")
	if struct["IamInstanceProfileAssociations"] then M.AssertIamInstanceProfileAssociationSet(struct["IamInstanceProfileAssociations"]) end
	if struct["NextToken"] then M.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeIamInstanceProfileAssociationsResult_keys[k], "DescribeIamInstanceProfileAssociationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIamInstanceProfileAssociationsResult
--  
-- @param IamInstanceProfileAssociations [IamInstanceProfileAssociationSet] <p>Information about one or more IAM instance profile associations.</p>
-- @param NextToken [NextToken] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeIamInstanceProfileAssociationsResult(IamInstanceProfileAssociations, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIamInstanceProfileAssociationsResult")
	local t = { 
		["IamInstanceProfileAssociations"] = IamInstanceProfileAssociations,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeIamInstanceProfileAssociationsResult(t)
	return t
end

local AttributeBooleanValue_keys = { "Value" = true, nil }

function M.AssertAttributeBooleanValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttributeBooleanValue to be of type 'table'")
	if struct["Value"] then M.AssertBoolean(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(AttributeBooleanValue_keys[k], "AttributeBooleanValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttributeBooleanValue
-- <p>Describes a value for a resource attribute that is a Boolean value.</p>
-- @param Value [Boolean] <p>The attribute value. The valid values are <code>true</code> or <code>false</code>.</p>
function M.AttributeBooleanValue(Value, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttributeBooleanValue")
	local t = { 
		["Value"] = Value,
	}
	M.AssertAttributeBooleanValue(t)
	return t
end

local DescribeSnapshotAttributeRequest_keys = { "Attribute" = true, "DryRun" = true, "SnapshotId" = true, nil }

function M.AssertDescribeSnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["Attribute"] then M.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSnapshotAttributeRequest_keys[k], "DescribeSnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotAttributeRequest
-- <p>Contains the parameters for DescribeSnapshotAttribute.</p>
-- @param Attribute [SnapshotAttributeName] <p>The snapshot attribute you would like to view.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- Required parameter: Attribute
-- Required parameter: SnapshotId
function M.DescribeSnapshotAttributeRequest(Attribute, DryRun, SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSnapshotAttributeRequest")
	local t = { 
		["Attribute"] = Attribute,
		["DryRun"] = DryRun,
		["SnapshotId"] = SnapshotId,
	}
	M.AssertDescribeSnapshotAttributeRequest(t)
	return t
end

local DescribeAvailabilityZonesRequest_keys = { "DryRun" = true, "Filters" = true, "ZoneNames" = true, nil }

function M.AssertDescribeAvailabilityZonesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailabilityZonesRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["ZoneNames"] then M.AssertZoneNameStringList(struct["ZoneNames"]) end
	for k,_ in pairs(struct) do
		assert(DescribeAvailabilityZonesRequest_keys[k], "DescribeAvailabilityZonesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailabilityZonesRequest
-- <p>Contains the parameters for DescribeAvailabilityZones.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>message</code> - Information about the Availability Zone.</p> </li> <li> <p> <code>region-name</code> - The name of the region for the Availability Zone (for example, <code>us-east-1</code>).</p> </li> <li> <p> <code>state</code> - The state of the Availability Zone (<code>available</code> | <code>information</code> | <code>impaired</code> | <code>unavailable</code>).</p> </li> <li> <p> <code>zone-name</code> - The name of the Availability Zone (for example, <code>us-east-1a</code>).</p> </li> </ul>
-- @param ZoneNames [ZoneNameStringList] <p>The names of one or more Availability Zones.</p>
function M.DescribeAvailabilityZonesRequest(DryRun, Filters, ZoneNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAvailabilityZonesRequest")
	local t = { 
		["DryRun"] = DryRun,
		["Filters"] = Filters,
		["ZoneNames"] = ZoneNames,
	}
	M.AssertDescribeAvailabilityZonesRequest(t)
	return t
end

local DetachVolumeRequest_keys = { "Device" = true, "InstanceId" = true, "DryRun" = true, "Force" = true, "VolumeId" = true, nil }

function M.AssertDetachVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Device"] then M.AssertString(struct["Device"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Force"] then M.AssertBoolean(struct["Force"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(DetachVolumeRequest_keys[k], "DetachVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachVolumeRequest
-- <p>Contains the parameters for DetachVolume.</p>
-- @param Device [String] <p>The device name.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Force [Boolean] <p>Forces detachment if the previous detachment attempt did not occur cleanly (for example, logging into an instance, unmounting the volume, and detaching normally). This option can lead to data loss or a corrupted file system. Use this option only as a last resort to detach a volume from a failed instance. The instance won't have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures.</p>
-- @param VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.DetachVolumeRequest(Device, InstanceId, DryRun, Force, VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachVolumeRequest")
	local t = { 
		["Device"] = Device,
		["InstanceId"] = InstanceId,
		["DryRun"] = DryRun,
		["Force"] = Force,
		["VolumeId"] = VolumeId,
	}
	M.AssertDetachVolumeRequest(t)
	return t
end

local ResetInstanceAttributeRequest_keys = { "InstanceId" = true, "Attribute" = true, "DryRun" = true, nil }

function M.AssertResetInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetInstanceAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then M.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(ResetInstanceAttributeRequest_keys[k], "ResetInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetInstanceAttributeRequest
-- <p>Contains the parameters for ResetInstanceAttribute.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param Attribute [InstanceAttributeName] <p>The attribute to reset.</p> <important> <p>You can only reset the following attributes: <code>kernel</code> | <code>ramdisk</code> | <code>sourceDestCheck</code>. To change an instance attribute, use <a>ModifyInstanceAttribute</a>.</p> </important>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: Attribute
-- Required parameter: InstanceId
function M.ResetInstanceAttributeRequest(InstanceId, Attribute, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ResetInstanceAttributeRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["Attribute"] = Attribute,
		["DryRun"] = DryRun,
	}
	M.AssertResetInstanceAttributeRequest(t)
	return t
end

local RestoreAddressToClassicRequest_keys = { "PublicIp" = true, "DryRun" = true, nil }

function M.AssertRestoreAddressToClassicRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RestoreAddressToClassicRequest to be of type 'table'")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(RestoreAddressToClassicRequest_keys[k], "RestoreAddressToClassicRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RestoreAddressToClassicRequest
-- <p>Contains the parameters for RestoreAddressToClassic.</p>
-- @param PublicIp [String] <p>The Elastic IP address.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: PublicIp
function M.RestoreAddressToClassicRequest(PublicIp, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RestoreAddressToClassicRequest")
	local t = { 
		["PublicIp"] = PublicIp,
		["DryRun"] = DryRun,
	}
	M.AssertRestoreAddressToClassicRequest(t)
	return t
end

local HistoryRecord_keys = { "EventType" = true, "EventInformation" = true, "Timestamp" = true, nil }

function M.AssertHistoryRecord(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HistoryRecord to be of type 'table'")
	assert(struct["EventInformation"], "Expected key EventInformation to exist in table")
	assert(struct["EventType"], "Expected key EventType to exist in table")
	assert(struct["Timestamp"], "Expected key Timestamp to exist in table")
	if struct["EventType"] then M.AssertEventType(struct["EventType"]) end
	if struct["EventInformation"] then M.AssertEventInformation(struct["EventInformation"]) end
	if struct["Timestamp"] then M.AssertDateTime(struct["Timestamp"]) end
	for k,_ in pairs(struct) do
		assert(HistoryRecord_keys[k], "HistoryRecord contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HistoryRecord
-- <p>Describes an event in the history of the Spot fleet request.</p>
-- @param EventType [EventType] <p>The event type.</p> <ul> <li> <p> <code>error</code> - Indicates an error with the Spot fleet request.</p> </li> <li> <p> <code>fleetRequestChange</code> - Indicates a change in the status or configuration of the Spot fleet request.</p> </li> <li> <p> <code>instanceChange</code> - Indicates that an instance was launched or terminated.</p> </li> </ul>
-- @param EventInformation [EventInformation] <p>Information about the event.</p>
-- @param Timestamp [DateTime] <p>The date and time of the event, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- Required parameter: EventInformation
-- Required parameter: EventType
-- Required parameter: Timestamp
function M.HistoryRecord(EventType, EventInformation, Timestamp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HistoryRecord")
	local t = { 
		["EventType"] = EventType,
		["EventInformation"] = EventInformation,
		["Timestamp"] = Timestamp,
	}
	M.AssertHistoryRecord(t)
	return t
end

local PrivateIpAddressSpecification_keys = { "Primary" = true, "PrivateIpAddress" = true, nil }

function M.AssertPrivateIpAddressSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrivateIpAddressSpecification to be of type 'table'")
	assert(struct["PrivateIpAddress"], "Expected key PrivateIpAddress to exist in table")
	if struct["Primary"] then M.AssertBoolean(struct["Primary"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(PrivateIpAddressSpecification_keys[k], "PrivateIpAddressSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrivateIpAddressSpecification
-- <p>Describes a secondary private IPv4 address for a network interface.</p>
-- @param Primary [Boolean] <p>Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.</p>
-- @param PrivateIpAddress [String] <p>The private IPv4 addresses.</p>
-- Required parameter: PrivateIpAddress
function M.PrivateIpAddressSpecification(Primary, PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PrivateIpAddressSpecification")
	local t = { 
		["Primary"] = Primary,
		["PrivateIpAddress"] = PrivateIpAddress,
	}
	M.AssertPrivateIpAddressSpecification(t)
	return t
end

local AcceptReservedInstancesExchangeQuoteRequest_keys = { "ReservedInstanceIds" = true, "DryRun" = true, "TargetConfigurations" = true, nil }

function M.AssertAcceptReservedInstancesExchangeQuoteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptReservedInstancesExchangeQuoteRequest to be of type 'table'")
	assert(struct["ReservedInstanceIds"], "Expected key ReservedInstanceIds to exist in table")
	if struct["ReservedInstanceIds"] then M.AssertReservedInstanceIdSet(struct["ReservedInstanceIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["TargetConfigurations"] then M.AssertTargetConfigurationRequestSet(struct["TargetConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(AcceptReservedInstancesExchangeQuoteRequest_keys[k], "AcceptReservedInstancesExchangeQuoteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptReservedInstancesExchangeQuoteRequest
-- <p>Contains the parameters for accepting the quote.</p>
-- @param ReservedInstanceIds [ReservedInstanceIdSet] <p>The IDs of the Convertible Reserved Instances to exchange for other Convertible Reserved Instances of the same or higher value.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param TargetConfigurations [TargetConfigurationRequestSet] <p>The configurations of the Convertible Reserved Instance offerings that you are purchasing in this exchange.</p>
-- Required parameter: ReservedInstanceIds
function M.AcceptReservedInstancesExchangeQuoteRequest(ReservedInstanceIds, DryRun, TargetConfigurations, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AcceptReservedInstancesExchangeQuoteRequest")
	local t = { 
		["ReservedInstanceIds"] = ReservedInstanceIds,
		["DryRun"] = DryRun,
		["TargetConfigurations"] = TargetConfigurations,
	}
	M.AssertAcceptReservedInstancesExchangeQuoteRequest(t)
	return t
end

local AttachVpnGatewayRequest_keys = { "VpcId" = true, "DryRun" = true, "VpnGatewayId" = true, nil }

function M.AssertAttachVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVpnGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then M.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(AttachVpnGatewayRequest_keys[k], "AttachVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVpnGatewayRequest
-- <p>Contains the parameters for AttachVpnGateway.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required parameter: VpcId
-- Required parameter: VpnGatewayId
function M.AttachVpnGatewayRequest(VpcId, DryRun, VpnGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachVpnGatewayRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
		["VpnGatewayId"] = VpnGatewayId,
	}
	M.AssertAttachVpnGatewayRequest(t)
	return t
end

local CreateVpcEndpointRequest_keys = { "VpcId" = true, "DryRun" = true, "ServiceName" = true, "PolicyDocument" = true, "RouteTableIds" = true, "ClientToken" = true, nil }

function M.AssertCreateVpcEndpointRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointRequest to be of type 'table'")
	assert(struct["ServiceName"], "Expected key ServiceName to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["ServiceName"] then M.AssertString(struct["ServiceName"]) end
	if struct["PolicyDocument"] then M.AssertString(struct["PolicyDocument"]) end
	if struct["RouteTableIds"] then M.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpcEndpointRequest_keys[k], "CreateVpcEndpointRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointRequest
-- <p>Contains the parameters for CreateVpcEndpoint.</p>
-- @param VpcId [String] <p>The ID of the VPC in which the endpoint will be used.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param ServiceName [String] <p>The AWS service name, in the form <code>com.amazonaws.<i>region</i>.<i>service</i> </code>. To get a list of available services, use the <a>DescribeVpcEndpointServices</a> request.</p>
-- @param PolicyDocument [String] <p>A policy to attach to the endpoint that controls access to the service. The policy must be in valid JSON format. If this parameter is not specified, we attach a default policy that allows full access to the service.</p>
-- @param RouteTableIds [ValueStringList] <p>One or more route table IDs.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required parameter: ServiceName
-- Required parameter: VpcId
function M.CreateVpcEndpointRequest(VpcId, DryRun, ServiceName, PolicyDocument, RouteTableIds, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcEndpointRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
		["ServiceName"] = ServiceName,
		["PolicyDocument"] = PolicyDocument,
		["RouteTableIds"] = RouteTableIds,
		["ClientToken"] = ClientToken,
	}
	M.AssertCreateVpcEndpointRequest(t)
	return t
end

local AssociateAddressRequest_keys = { "DryRun" = true, "InstanceId" = true, "NetworkInterfaceId" = true, "PublicIp" = true, "AllowReassociation" = true, "AllocationId" = true, "PrivateIpAddress" = true, nil }

function M.AssertAssociateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateAddressRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["AllowReassociation"] then M.AssertBoolean(struct["AllowReassociation"]) end
	if struct["AllocationId"] then M.AssertString(struct["AllocationId"]) end
	if struct["PrivateIpAddress"] then M.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(AssociateAddressRequest_keys[k], "AssociateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateAddressRequest
-- <p>Contains the parameters for AssociateAddress.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceId [String] <p>The ID of the instance. This is required for EC2-Classic. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. The operation fails if you specify an instance ID unless exactly one network interface is attached.</p>
-- @param NetworkInterfaceId [String] <p>[EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID.</p>
-- @param PublicIp [String] <p>The Elastic IP address. This is required for EC2-Classic.</p>
-- @param AllowReassociation [Boolean] <p>[EC2-VPC] For a VPC in an EC2-Classic account, specify true to allow an Elastic IP address that is already associated with an instance or network interface to be reassociated with the specified instance or network interface. Otherwise, the operation fails. In a VPC in an EC2-VPC-only account, reassociation is automatic, therefore you can specify false to ensure the operation fails if the Elastic IP address is already associated with another resource.</p>
-- @param AllocationId [String] <p>[EC2-VPC] The allocation ID. This is required for EC2-VPC.</p>
-- @param PrivateIpAddress [String] <p>[EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.</p>
function M.AssociateAddressRequest(DryRun, InstanceId, NetworkInterfaceId, PublicIp, AllowReassociation, AllocationId, PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateAddressRequest")
	local t = { 
		["DryRun"] = DryRun,
		["InstanceId"] = InstanceId,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["PublicIp"] = PublicIp,
		["AllowReassociation"] = AllowReassociation,
		["AllocationId"] = AllocationId,
		["PrivateIpAddress"] = PrivateIpAddress,
	}
	M.AssertAssociateAddressRequest(t)
	return t
end

local DeleteNatGatewayResult_keys = { "NatGatewayId" = true, nil }

function M.AssertDeleteNatGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNatGatewayResult to be of type 'table'")
	if struct["NatGatewayId"] then M.AssertString(struct["NatGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(DeleteNatGatewayResult_keys[k], "DeleteNatGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNatGatewayResult
-- <p>Contains the output of DeleteNatGateway.</p>
-- @param NatGatewayId [String] <p>The ID of the NAT gateway.</p>
function M.DeleteNatGatewayResult(NatGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNatGatewayResult")
	local t = { 
		["NatGatewayId"] = NatGatewayId,
	}
	M.AssertDeleteNatGatewayResult(t)
	return t
end

local ImportImageTask_keys = { "Status" = true, "LicenseType" = true, "Description" = true, "Hypervisor" = true, "ImageId" = true, "Platform" = true, "Architecture" = true, "SnapshotDetails" = true, "Progress" = true, "StatusMessage" = true, "ImportTaskId" = true, nil }

function M.AssertImportImageTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageTask to be of type 'table'")
	if struct["Status"] then M.AssertString(struct["Status"]) end
	if struct["LicenseType"] then M.AssertString(struct["LicenseType"]) end
	if struct["Description"] then M.AssertString(struct["Description"]) end
	if struct["Hypervisor"] then M.AssertString(struct["Hypervisor"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	if struct["Platform"] then M.AssertString(struct["Platform"]) end
	if struct["Architecture"] then M.AssertString(struct["Architecture"]) end
	if struct["SnapshotDetails"] then M.AssertSnapshotDetailList(struct["SnapshotDetails"]) end
	if struct["Progress"] then M.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then M.AssertString(struct["StatusMessage"]) end
	if struct["ImportTaskId"] then M.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(ImportImageTask_keys[k], "ImportImageTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageTask
-- <p>Describes an import image task.</p>
-- @param Status [String] <p>A brief status for the import image task.</p>
-- @param LicenseType [String] <p>The license type of the virtual machine.</p>
-- @param Description [String] <p>A description of the import task.</p>
-- @param Hypervisor [String] <p>The target hypervisor for the import task.</p> <p>Valid values: <code>xen</code> </p>
-- @param ImageId [String] <p>The ID of the Amazon Machine Image (AMI) of the imported virtual machine.</p>
-- @param Platform [String] <p>The description string for the import image task.</p>
-- @param Architecture [String] <p>The architecture of the virtual machine.</p> <p>Valid values: <code>i386</code> | <code>x86_64</code> </p>
-- @param SnapshotDetails [SnapshotDetailList] <p>Information about the snapshots.</p>
-- @param Progress [String] <p>The percentage of progress of the import image task.</p>
-- @param StatusMessage [String] <p>A descriptive status message for the import image task.</p>
-- @param ImportTaskId [String] <p>The ID of the import image task.</p>
function M.ImportImageTask(Status, LicenseType, Description, Hypervisor, ImageId, Platform, Architecture, SnapshotDetails, Progress, StatusMessage, ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportImageTask")
	local t = { 
		["Status"] = Status,
		["LicenseType"] = LicenseType,
		["Description"] = Description,
		["Hypervisor"] = Hypervisor,
		["ImageId"] = ImageId,
		["Platform"] = Platform,
		["Architecture"] = Architecture,
		["SnapshotDetails"] = SnapshotDetails,
		["Progress"] = Progress,
		["StatusMessage"] = StatusMessage,
		["ImportTaskId"] = ImportTaskId,
	}
	M.AssertImportImageTask(t)
	return t
end

local DeregisterImageRequest_keys = { "DryRun" = true, "ImageId" = true, nil }

function M.AssertDeregisterImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterImageRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(DeregisterImageRequest_keys[k], "DeregisterImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterImageRequest
-- <p>Contains the parameters for DeregisterImage.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param ImageId [String] <p>The ID of the AMI.</p>
-- Required parameter: ImageId
function M.DeregisterImageRequest(DryRun, ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeregisterImageRequest")
	local t = { 
		["DryRun"] = DryRun,
		["ImageId"] = ImageId,
	}
	M.AssertDeregisterImageRequest(t)
	return t
end

local CreateInternetGatewayResult_keys = { "InternetGateway" = true, nil }

function M.AssertCreateInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInternetGatewayResult to be of type 'table'")
	if struct["InternetGateway"] then M.AssertInternetGateway(struct["InternetGateway"]) end
	for k,_ in pairs(struct) do
		assert(CreateInternetGatewayResult_keys[k], "CreateInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInternetGatewayResult
-- <p>Contains the output of CreateInternetGateway.</p>
-- @param InternetGateway [InternetGateway] <p>Information about the Internet gateway.</p>
function M.CreateInternetGatewayResult(InternetGateway, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateInternetGatewayResult")
	local t = { 
		["InternetGateway"] = InternetGateway,
	}
	M.AssertCreateInternetGatewayResult(t)
	return t
end

local ReservedInstanceLimitPrice_keys = { "Amount" = true, "CurrencyCode" = true, nil }

function M.AssertReservedInstanceLimitPrice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstanceLimitPrice to be of type 'table'")
	if struct["Amount"] then M.AssertDouble(struct["Amount"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	for k,_ in pairs(struct) do
		assert(ReservedInstanceLimitPrice_keys[k], "ReservedInstanceLimitPrice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstanceLimitPrice
-- <p>Describes the limit price of a Reserved Instance offering.</p>
-- @param Amount [Double] <p>Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>limitPrice</code> amount is specified. At this time, the only supported currency is <code>USD</code>.</p>
function M.ReservedInstanceLimitPrice(Amount, CurrencyCode, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstanceLimitPrice")
	local t = { 
		["Amount"] = Amount,
		["CurrencyCode"] = CurrencyCode,
	}
	M.AssertReservedInstanceLimitPrice(t)
	return t
end

local DescribeInstanceStatusResult_keys = { "InstanceStatuses" = true, "NextToken" = true, nil }

function M.AssertDescribeInstanceStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceStatusResult to be of type 'table'")
	if struct["InstanceStatuses"] then M.AssertInstanceStatusList(struct["InstanceStatuses"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(DescribeInstanceStatusResult_keys[k], "DescribeInstanceStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceStatusResult
-- <p>Contains the output of DescribeInstanceStatus.</p>
-- @param InstanceStatuses [InstanceStatusList] <p>One or more instance status descriptions.</p>
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeInstanceStatusResult(InstanceStatuses, NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstanceStatusResult")
	local t = { 
		["InstanceStatuses"] = InstanceStatuses,
		["NextToken"] = NextToken,
	}
	M.AssertDescribeInstanceStatusResult(t)
	return t
end

local RunScheduledInstancesResult_keys = { "InstanceIdSet" = true, nil }

function M.AssertRunScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunScheduledInstancesResult to be of type 'table'")
	if struct["InstanceIdSet"] then M.AssertInstanceIdSet(struct["InstanceIdSet"]) end
	for k,_ in pairs(struct) do
		assert(RunScheduledInstancesResult_keys[k], "RunScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunScheduledInstancesResult
-- <p>Contains the output of RunScheduledInstances.</p>
-- @param InstanceIdSet [InstanceIdSet] <p>The IDs of the newly launched instances.</p>
function M.RunScheduledInstancesResult(InstanceIdSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RunScheduledInstancesResult")
	local t = { 
		["InstanceIdSet"] = InstanceIdSet,
	}
	M.AssertRunScheduledInstancesResult(t)
	return t
end

local GetConsoleOutputResult_keys = { "InstanceId" = true, "Output" = true, "Timestamp" = true, nil }

function M.AssertGetConsoleOutputResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleOutputResult to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Output"] then M.AssertString(struct["Output"]) end
	if struct["Timestamp"] then M.AssertDateTime(struct["Timestamp"]) end
	for k,_ in pairs(struct) do
		assert(GetConsoleOutputResult_keys[k], "GetConsoleOutputResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleOutputResult
-- <p>Contains the output of GetConsoleOutput.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param Output [String] <p>The console output, Base64-encoded. If using a command line tool, the tool decodes the output for you.</p>
-- @param Timestamp [DateTime] <p>The time the output was last updated.</p>
function M.GetConsoleOutputResult(InstanceId, Output, Timestamp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetConsoleOutputResult")
	local t = { 
		["InstanceId"] = InstanceId,
		["Output"] = Output,
		["Timestamp"] = Timestamp,
	}
	M.AssertGetConsoleOutputResult(t)
	return t
end

local ClassicLinkInstance_keys = { "InstanceId" = true, "VpcId" = true, "Groups" = true, "Tags" = true, nil }

function M.AssertClassicLinkInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLinkInstance to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["Groups"] then M.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(ClassicLinkInstance_keys[k], "ClassicLinkInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLinkInstance
-- <p>Describes a linked EC2-Classic instance.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param Groups [GroupIdentifierList] <p>A list of security groups.</p>
-- @param Tags [TagList] <p>Any tags assigned to the instance.</p>
function M.ClassicLinkInstance(InstanceId, VpcId, Groups, Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ClassicLinkInstance")
	local t = { 
		["InstanceId"] = InstanceId,
		["VpcId"] = VpcId,
		["Groups"] = Groups,
		["Tags"] = Tags,
	}
	M.AssertClassicLinkInstance(t)
	return t
end

local NetworkInterfaceAttachment_keys = { "Status" = true, "DeviceIndex" = true, "AttachTime" = true, "InstanceId" = true, "DeleteOnTermination" = true, "AttachmentId" = true, "InstanceOwnerId" = true, nil }

function M.AssertNetworkInterfaceAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAttachment to be of type 'table'")
	if struct["Status"] then M.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeviceIndex"] then M.AssertInteger(struct["DeviceIndex"]) end
	if struct["AttachTime"] then M.AssertDateTime(struct["AttachTime"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then M.AssertString(struct["AttachmentId"]) end
	if struct["InstanceOwnerId"] then M.AssertString(struct["InstanceOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(NetworkInterfaceAttachment_keys[k], "NetworkInterfaceAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAttachment
-- <p>Describes a network interface attachment.</p>
-- @param Status [AttachmentStatus] <p>The attachment state.</p>
-- @param DeviceIndex [Integer] <p>The device index of the network interface attachment on the instance.</p>
-- @param AttachTime [DateTime] <p>The timestamp indicating when the attachment initiated.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- @param AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- @param InstanceOwnerId [String] <p>The AWS account ID of the owner of the instance.</p>
function M.NetworkInterfaceAttachment(Status, DeviceIndex, AttachTime, InstanceId, DeleteOnTermination, AttachmentId, InstanceOwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfaceAttachment")
	local t = { 
		["Status"] = Status,
		["DeviceIndex"] = DeviceIndex,
		["AttachTime"] = AttachTime,
		["InstanceId"] = InstanceId,
		["DeleteOnTermination"] = DeleteOnTermination,
		["AttachmentId"] = AttachmentId,
		["InstanceOwnerId"] = InstanceOwnerId,
	}
	M.AssertNetworkInterfaceAttachment(t)
	return t
end

local ModifyNetworkInterfaceAttributeRequest_keys = { "SourceDestCheck" = true, "DryRun" = true, "Description" = true, "NetworkInterfaceId" = true, "Attachment" = true, "Groups" = true, nil }

function M.AssertModifyNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["SourceDestCheck"] then M.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then M.AssertAttributeValue(struct["Description"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["Attachment"] then M.AssertNetworkInterfaceAttachmentChanges(struct["Attachment"]) end
	if struct["Groups"] then M.AssertSecurityGroupIdStringList(struct["Groups"]) end
	for k,_ in pairs(struct) do
		assert(ModifyNetworkInterfaceAttributeRequest_keys[k], "ModifyNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for ModifyNetworkInterfaceAttribute.</p>
-- @param SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT. For more information, see <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html">NAT Instances</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Description [AttributeValue] <p>A description for the network interface.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param Attachment [NetworkInterfaceAttachmentChanges] <p>Information about the interface attachment. If modifying the 'delete on termination' attribute, you must specify the ID of the interface attachment.</p>
-- @param Groups [SecurityGroupIdStringList] <p>Changes the security groups for the network interface. The new set of groups you specify replaces the current set. You must specify at least one group, even if it's just the default security group in the VPC. You must specify the ID of the security group, not the name.</p>
-- Required parameter: NetworkInterfaceId
function M.ModifyNetworkInterfaceAttributeRequest(SourceDestCheck, DryRun, Description, NetworkInterfaceId, Attachment, Groups, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyNetworkInterfaceAttributeRequest")
	local t = { 
		["SourceDestCheck"] = SourceDestCheck,
		["DryRun"] = DryRun,
		["Description"] = Description,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["Attachment"] = Attachment,
		["Groups"] = Groups,
	}
	M.AssertModifyNetworkInterfaceAttributeRequest(t)
	return t
end

local InstanceStatus_keys = { "InstanceStatus" = true, "AvailabilityZone" = true, "InstanceId" = true, "InstanceState" = true, "Events" = true, "SystemStatus" = true, nil }

function M.AssertInstanceStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatus to be of type 'table'")
	if struct["InstanceStatus"] then M.AssertInstanceStatusSummary(struct["InstanceStatus"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["InstanceState"] then M.AssertInstanceState(struct["InstanceState"]) end
	if struct["Events"] then M.AssertInstanceStatusEventList(struct["Events"]) end
	if struct["SystemStatus"] then M.AssertInstanceStatusSummary(struct["SystemStatus"]) end
	for k,_ in pairs(struct) do
		assert(InstanceStatus_keys[k], "InstanceStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatus
-- <p>Describes the status of an instance.</p>
-- @param InstanceStatus [InstanceStatusSummary] <p>Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone of the instance.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param InstanceState [InstanceState] <p>The intended state of the instance. <a>DescribeInstanceStatus</a> requires that an instance be in the <code>running</code> state.</p>
-- @param Events [InstanceStatusEventList] <p>Any scheduled events associated with the instance.</p>
-- @param SystemStatus [InstanceStatusSummary] <p>Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.</p>
function M.InstanceStatus(InstanceStatus, AvailabilityZone, InstanceId, InstanceState, Events, SystemStatus, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStatus")
	local t = { 
		["InstanceStatus"] = InstanceStatus,
		["AvailabilityZone"] = AvailabilityZone,
		["InstanceId"] = InstanceId,
		["InstanceState"] = InstanceState,
		["Events"] = Events,
		["SystemStatus"] = SystemStatus,
	}
	M.AssertInstanceStatus(t)
	return t
end

local EgressOnlyInternetGateway_keys = { "EgressOnlyInternetGatewayId" = true, "Attachments" = true, nil }

function M.AssertEgressOnlyInternetGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EgressOnlyInternetGateway to be of type 'table'")
	if struct["EgressOnlyInternetGatewayId"] then M.AssertEgressOnlyInternetGatewayId(struct["EgressOnlyInternetGatewayId"]) end
	if struct["Attachments"] then M.AssertInternetGatewayAttachmentList(struct["Attachments"]) end
	for k,_ in pairs(struct) do
		assert(EgressOnlyInternetGateway_keys[k], "EgressOnlyInternetGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EgressOnlyInternetGateway
-- <p>Describes an egress-only Internet gateway.</p>
-- @param EgressOnlyInternetGatewayId [EgressOnlyInternetGatewayId] <p>The ID of the egress-only Internet gateway.</p>
-- @param Attachments [InternetGatewayAttachmentList] <p>Information about the attachment of the egress-only Internet gateway.</p>
function M.EgressOnlyInternetGateway(EgressOnlyInternetGatewayId, Attachments, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EgressOnlyInternetGateway")
	local t = { 
		["EgressOnlyInternetGatewayId"] = EgressOnlyInternetGatewayId,
		["Attachments"] = Attachments,
	}
	M.AssertEgressOnlyInternetGateway(t)
	return t
end

local UnassignPrivateIpAddressesRequest_keys = { "NetworkInterfaceId" = true, "PrivateIpAddresses" = true, nil }

function M.AssertUnassignPrivateIpAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignPrivateIpAddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	assert(struct["PrivateIpAddresses"], "Expected key PrivateIpAddresses to exist in table")
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PrivateIpAddresses"] then M.AssertPrivateIpAddressStringList(struct["PrivateIpAddresses"]) end
	for k,_ in pairs(struct) do
		assert(UnassignPrivateIpAddressesRequest_keys[k], "UnassignPrivateIpAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignPrivateIpAddressesRequest
-- <p>Contains the parameters for UnassignPrivateIpAddresses.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param PrivateIpAddresses [PrivateIpAddressStringList] <p>The secondary private IP addresses to unassign from the network interface. You can specify this option multiple times to unassign more than one IP address.</p>
-- Required parameter: NetworkInterfaceId
-- Required parameter: PrivateIpAddresses
function M.UnassignPrivateIpAddressesRequest(NetworkInterfaceId, PrivateIpAddresses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnassignPrivateIpAddressesRequest")
	local t = { 
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["PrivateIpAddresses"] = PrivateIpAddresses,
	}
	M.AssertUnassignPrivateIpAddressesRequest(t)
	return t
end

local Filter_keys = { "Values" = true, "Name" = true, nil }

function M.AssertFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Filter to be of type 'table'")
	if struct["Values"] then M.AssertValueStringList(struct["Values"]) end
	if struct["Name"] then M.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(Filter_keys[k], "Filter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Filter
-- <p>A filter name and value pair that is used to return a more specific list of results. Filters can be used to match a set of resources by various criteria, such as tags, attributes, or IDs.</p>
-- @param Values [ValueStringList] <p>One or more filter values. Filter values are case-sensitive.</p>
-- @param Name [String] <p>The name of the filter. Filter names are case-sensitive.</p>
function M.Filter(Values, Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Filter")
	local t = { 
		["Values"] = Values,
		["Name"] = Name,
	}
	M.AssertFilter(t)
	return t
end

local TargetReservationValue_keys = { "TargetConfiguration" = true, "ReservationValue" = true, nil }

function M.AssertTargetReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetReservationValue to be of type 'table'")
	if struct["TargetConfiguration"] then M.AssertTargetConfiguration(struct["TargetConfiguration"]) end
	if struct["ReservationValue"] then M.AssertReservationValue(struct["ReservationValue"]) end
	for k,_ in pairs(struct) do
		assert(TargetReservationValue_keys[k], "TargetReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetReservationValue
-- <p>The total value of the new Convertible Reserved Instances.</p>
-- @param TargetConfiguration [TargetConfiguration] <p>The configuration of the Convertible Reserved Instances that make up the exchange.</p>
-- @param ReservationValue [ReservationValue] <p>The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of the list value, remaining upfront price, and additional upfront cost of the exchange.</p>
function M.TargetReservationValue(TargetConfiguration, ReservationValue, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TargetReservationValue")
	local t = { 
		["TargetConfiguration"] = TargetConfiguration,
		["ReservationValue"] = ReservationValue,
	}
	M.AssertTargetReservationValue(t)
	return t
end

local ModifyIdFormatRequest_keys = { "UseLongIds" = true, "Resource" = true, nil }

function M.AssertModifyIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyIdFormatRequest to be of type 'table'")
	assert(struct["Resource"], "Expected key Resource to exist in table")
	assert(struct["UseLongIds"], "Expected key UseLongIds to exist in table")
	if struct["UseLongIds"] then M.AssertBoolean(struct["UseLongIds"]) end
	if struct["Resource"] then M.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(ModifyIdFormatRequest_keys[k], "ModifyIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyIdFormatRequest
-- <p>Contains the parameters of ModifyIdFormat.</p>
-- @param UseLongIds [Boolean] <p>Indicate whether the resource should use longer IDs (17-character IDs).</p>
-- @param Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- Required parameter: Resource
-- Required parameter: UseLongIds
function M.ModifyIdFormatRequest(UseLongIds, Resource, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyIdFormatRequest")
	local t = { 
		["UseLongIds"] = UseLongIds,
		["Resource"] = Resource,
	}
	M.AssertModifyIdFormatRequest(t)
	return t
end

local DescribeIdentityIdFormatResult_keys = { "Statuses" = true, nil }

function M.AssertDescribeIdentityIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdentityIdFormatResult to be of type 'table'")
	if struct["Statuses"] then M.AssertIdFormatList(struct["Statuses"]) end
	for k,_ in pairs(struct) do
		assert(DescribeIdentityIdFormatResult_keys[k], "DescribeIdentityIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdentityIdFormatResult
-- <p>Contains the output of DescribeIdentityIdFormat.</p>
-- @param Statuses [IdFormatList] <p>Information about the ID format for the resources.</p>
function M.DescribeIdentityIdFormatResult(Statuses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIdentityIdFormatResult")
	local t = { 
		["Statuses"] = Statuses,
	}
	M.AssertDescribeIdentityIdFormatResult(t)
	return t
end

local ImportVolumeResult_keys = { "ConversionTask" = true, nil }

function M.AssertImportVolumeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeResult to be of type 'table'")
	if struct["ConversionTask"] then M.AssertConversionTask(struct["ConversionTask"]) end
	for k,_ in pairs(struct) do
		assert(ImportVolumeResult_keys[k], "ImportVolumeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeResult
-- <p>Contains the output for ImportVolume.</p>
-- @param ConversionTask [ConversionTask] <p>Information about the conversion task.</p>
function M.ImportVolumeResult(ConversionTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportVolumeResult")
	local t = { 
		["ConversionTask"] = ConversionTask,
	}
	M.AssertImportVolumeResult(t)
	return t
end

local DescribeKeyPairsResult_keys = { "KeyPairs" = true, nil }

function M.AssertDescribeKeyPairsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeKeyPairsResult to be of type 'table'")
	if struct["KeyPairs"] then M.AssertKeyPairList(struct["KeyPairs"]) end
	for k,_ in pairs(struct) do
		assert(DescribeKeyPairsResult_keys[k], "DescribeKeyPairsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeKeyPairsResult
-- <p>Contains the output of DescribeKeyPairs.</p>
-- @param KeyPairs [KeyPairList] <p>Information about one or more key pairs.</p>
function M.DescribeKeyPairsResult(KeyPairs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeKeyPairsResult")
	local t = { 
		["KeyPairs"] = KeyPairs,
	}
	M.AssertDescribeKeyPairsResult(t)
	return t
end

local VolumeAttachment_keys = { "AttachTime" = true, "InstanceId" = true, "VolumeId" = true, "State" = true, "DeleteOnTermination" = true, "Device" = true, nil }

function M.AssertVolumeAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeAttachment to be of type 'table'")
	if struct["AttachTime"] then M.AssertDateTime(struct["AttachTime"]) end
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	if struct["State"] then M.AssertVolumeAttachmentState(struct["State"]) end
	if struct["DeleteOnTermination"] then M.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["Device"] then M.AssertString(struct["Device"]) end
	for k,_ in pairs(struct) do
		assert(VolumeAttachment_keys[k], "VolumeAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeAttachment
-- <p>Describes volume attachment details.</p>
-- @param AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param VolumeId [String] <p>The ID of the volume.</p>
-- @param State [VolumeAttachmentState] <p>The attachment state of the volume.</p>
-- @param DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- @param Device [String] <p>The device name.</p>
function M.VolumeAttachment(AttachTime, InstanceId, VolumeId, State, DeleteOnTermination, Device, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeAttachment")
	local t = { 
		["AttachTime"] = AttachTime,
		["InstanceId"] = InstanceId,
		["VolumeId"] = VolumeId,
		["State"] = State,
		["DeleteOnTermination"] = DeleteOnTermination,
		["Device"] = Device,
	}
	M.AssertVolumeAttachment(t)
	return t
end

local DescribeReservedInstancesRequest_keys = { "OfferingType" = true, "OfferingClass" = true, "DryRun" = true, "ReservedInstancesIds" = true, "Filters" = true, nil }

function M.AssertDescribeReservedInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesRequest to be of type 'table'")
	if struct["OfferingType"] then M.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["OfferingClass"] then M.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["ReservedInstancesIds"] then M.AssertReservedInstancesIdStringList(struct["ReservedInstancesIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeReservedInstancesRequest_keys[k], "DescribeReservedInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesRequest
-- <p>Contains the parameters for DescribeReservedInstances.</p>
-- @param OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the <code>Medium Utilization</code> Reserved Instance offering type.</p>
-- @param OfferingClass [OfferingClassType] <p>Describes whether the Reserved Instance is Standard or Convertible.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param ReservedInstancesIds [ReservedInstancesIdStringList] <p>One or more Reserved Instance IDs.</p> <p>Default: Describes all your Reserved Instances, or only those otherwise specified.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be used.</p> </li> <li> <p> <code>duration</code> - The duration of the Reserved Instance (one year or three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p> </li> <li> <p> <code>end</code> - The time when the Reserved Instance expires (for example, 2015-08-07T11:54:42.000Z).</p> </li> <li> <p> <code>fixed-price</code> - The purchase price of the Reserved Instance (for example, 9800.0).</p> </li> <li> <p> <code>instance-type</code> - The instance type that is covered by the reservation.</p> </li> <li> <p> <code>scope</code> - The scope of the Reserved Instance (<code>Region</code> or <code>Availability Zone</code>).</p> </li> <li> <p> <code>product-description</code> - The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Windows</code> | <code>Windows (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> | <code>Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon VPC)</code>).</p> </li> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instance.</p> </li> <li> <p> <code>start</code> - The time at which the Reserved Instance purchase request was placed (for example, 2014-08-07T11:54:42.000Z).</p> </li> <li> <p> <code>state</code> - The state of the Reserved Instance (<code>payment-pending</code> | <code>active</code> | <code>payment-failed</code> | <code>retired</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for example, 0.84).</p> </li> </ul>
function M.DescribeReservedInstancesRequest(OfferingType, OfferingClass, DryRun, ReservedInstancesIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesRequest")
	local t = { 
		["OfferingType"] = OfferingType,
		["OfferingClass"] = OfferingClass,
		["DryRun"] = DryRun,
		["ReservedInstancesIds"] = ReservedInstancesIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeReservedInstancesRequest(t)
	return t
end

local CreateCustomerGatewayRequest_keys = { "PublicIp" = true, "BgpAsn" = true, "DryRun" = true, "Type" = true, nil }

function M.AssertCreateCustomerGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCustomerGatewayRequest to be of type 'table'")
	assert(struct["BgpAsn"], "Expected key BgpAsn to exist in table")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["BgpAsn"] then M.AssertInteger(struct["BgpAsn"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Type"] then M.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(CreateCustomerGatewayRequest_keys[k], "CreateCustomerGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCustomerGatewayRequest
-- <p>Contains the parameters for CreateCustomerGateway.</p>
-- @param PublicIp [String] <p>The Internet-routable IP address for the customer gateway's outside interface. The address must be static.</p>
-- @param BgpAsn [Integer] <p>For devices that support BGP, the customer gateway's BGP ASN.</p> <p>Default: 65000</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Type [GatewayType] <p>The type of VPN connection that this customer gateway supports (<code>ipsec.1</code>).</p>
-- Required parameter: BgpAsn
-- Required parameter: PublicIp
-- Required parameter: Type
function M.CreateCustomerGatewayRequest(PublicIp, BgpAsn, DryRun, Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateCustomerGatewayRequest")
	local t = { 
		["PublicIp"] = PublicIp,
		["BgpAsn"] = BgpAsn,
		["DryRun"] = DryRun,
		["Type"] = Type,
	}
	M.AssertCreateCustomerGatewayRequest(t)
	return t
end

local DeleteSecurityGroupRequest_keys = { "GroupName" = true, "DryRun" = true, "GroupId" = true, nil }

function M.AssertDeleteSecurityGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSecurityGroupRequest to be of type 'table'")
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(DeleteSecurityGroupRequest_keys[k], "DeleteSecurityGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSecurityGroupRequest
-- <p>Contains the parameters for DeleteSecurityGroup.</p>
-- @param GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group. You can specify either the security group name or the security group ID.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param GroupId [String] <p>The ID of the security group. Required for a nondefault VPC.</p>
function M.DeleteSecurityGroupRequest(GroupName, DryRun, GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteSecurityGroupRequest")
	local t = { 
		["GroupName"] = GroupName,
		["DryRun"] = DryRun,
		["GroupId"] = GroupId,
	}
	M.AssertDeleteSecurityGroupRequest(t)
	return t
end

local NatGatewayAddress_keys = { "PublicIp" = true, "NetworkInterfaceId" = true, "AllocationId" = true, "PrivateIp" = true, nil }

function M.AssertNatGatewayAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NatGatewayAddress to be of type 'table'")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AllocationId"] then M.AssertString(struct["AllocationId"]) end
	if struct["PrivateIp"] then M.AssertString(struct["PrivateIp"]) end
	for k,_ in pairs(struct) do
		assert(NatGatewayAddress_keys[k], "NatGatewayAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NatGatewayAddress
-- <p>Describes the IP addresses and network interface associated with a NAT gateway.</p>
-- @param PublicIp [String] <p>The Elastic IP address associated with the NAT gateway.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface associated with the NAT gateway.</p>
-- @param AllocationId [String] <p>The allocation ID of the Elastic IP address that's associated with the NAT gateway.</p>
-- @param PrivateIp [String] <p>The private IP address associated with the Elastic IP address.</p>
function M.NatGatewayAddress(PublicIp, NetworkInterfaceId, AllocationId, PrivateIp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NatGatewayAddress")
	local t = { 
		["PublicIp"] = PublicIp,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["AllocationId"] = AllocationId,
		["PrivateIp"] = PrivateIp,
	}
	M.AssertNatGatewayAddress(t)
	return t
end

local DescribeSnapshotAttributeResult_keys = { "ProductCodes" = true, "CreateVolumePermissions" = true, "SnapshotId" = true, nil }

function M.AssertDescribeSnapshotAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotAttributeResult to be of type 'table'")
	if struct["ProductCodes"] then M.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["CreateVolumePermissions"] then M.AssertCreateVolumePermissionList(struct["CreateVolumePermissions"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSnapshotAttributeResult_keys[k], "DescribeSnapshotAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotAttributeResult
-- <p>Contains the output of DescribeSnapshotAttribute.</p>
-- @param ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- @param CreateVolumePermissions [CreateVolumePermissionList] <p>A list of permissions for creating volumes from the snapshot.</p>
-- @param SnapshotId [String] <p>The ID of the EBS snapshot.</p>
function M.DescribeSnapshotAttributeResult(ProductCodes, CreateVolumePermissions, SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSnapshotAttributeResult")
	local t = { 
		["ProductCodes"] = ProductCodes,
		["CreateVolumePermissions"] = CreateVolumePermissions,
		["SnapshotId"] = SnapshotId,
	}
	M.AssertDescribeSnapshotAttributeResult(t)
	return t
end

local ActiveInstance_keys = { "InstanceId" = true, "InstanceHealth" = true, "InstanceType" = true, "SpotInstanceRequestId" = true, nil }

function M.AssertActiveInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ActiveInstance to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["InstanceHealth"] then M.AssertInstanceHealthStatus(struct["InstanceHealth"]) end
	if struct["InstanceType"] then M.AssertString(struct["InstanceType"]) end
	if struct["SpotInstanceRequestId"] then M.AssertString(struct["SpotInstanceRequestId"]) end
	for k,_ in pairs(struct) do
		assert(ActiveInstance_keys[k], "ActiveInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ActiveInstance
-- <p>Describes a running instance in a Spot fleet.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param InstanceHealth [InstanceHealthStatus] <p>The health status of the instance. If the status of either the instance status check or the system status check is <code>impaired</code>, the health status of the instance is <code>unhealthy</code>. Otherwise, the health status is <code>healthy</code>.</p>
-- @param InstanceType [String] <p>The instance type.</p>
-- @param SpotInstanceRequestId [String] <p>The ID of the Spot instance request.</p>
function M.ActiveInstance(InstanceId, InstanceHealth, InstanceType, SpotInstanceRequestId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ActiveInstance")
	local t = { 
		["InstanceId"] = InstanceId,
		["InstanceHealth"] = InstanceHealth,
		["InstanceType"] = InstanceType,
		["SpotInstanceRequestId"] = SpotInstanceRequestId,
	}
	M.AssertActiveInstance(t)
	return t
end

local ModifyVolumeRequest_keys = { "VolumeType" = true, "Iops" = true, "DryRun" = true, "VolumeId" = true, "Size" = true, nil }

function M.AssertModifyVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["VolumeType"] then M.AssertVolumeType(struct["VolumeType"]) end
	if struct["Iops"] then M.AssertInteger(struct["Iops"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	if struct["Size"] then M.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(ModifyVolumeRequest_keys[k], "ModifyVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeRequest
--  
-- @param VolumeType [VolumeType] <p>Target EBS volume type of the volume to be modified</p> <p> The API does not support modifications for volume type <code>standard</code>. You also cannot change the type of a volume to <code>standard</code>. </p> <p>Default: If no type is specified, the existing type is retained. </p>
-- @param Iops [Integer] <p>Target IOPS rate of the volume to be modified.</p> <p>Only valid for Provisioned IOPS SSD (<code>io1</code>) volumes. For more information about <code>io1</code> IOPS configuration, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops">http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops</a>.</p> <p>Default: If no IOPS value is specified, the existing value is retained. </p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VolumeId [String]  
-- @param Size [Integer] <p>Target size in GiB of the volume to be modified. Target volume size must be greater than or equal to than the existing size of the volume. For information about available EBS volume sizes, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html</a>.</p> <p>Default: If no size is specified, the existing size is retained. </p>
-- Required parameter: VolumeId
function M.ModifyVolumeRequest(VolumeType, Iops, DryRun, VolumeId, Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVolumeRequest")
	local t = { 
		["VolumeType"] = VolumeType,
		["Iops"] = Iops,
		["DryRun"] = DryRun,
		["VolumeId"] = VolumeId,
		["Size"] = Size,
	}
	M.AssertModifyVolumeRequest(t)
	return t
end

local RevokeSecurityGroupIngressRequest_keys = { "DryRun" = true, "GroupName" = true, "CidrIp" = true, "IpPermissions" = true, "FromPort" = true, "SourceSecurityGroupOwnerId" = true, "SourceSecurityGroupName" = true, "ToPort" = true, "IpProtocol" = true, "GroupId" = true, nil }

function M.AssertRevokeSecurityGroupIngressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RevokeSecurityGroupIngressRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["GroupName"] then M.AssertString(struct["GroupName"]) end
	if struct["CidrIp"] then M.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then M.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then M.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then M.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then M.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then M.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then M.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(RevokeSecurityGroupIngressRequest_keys[k], "RevokeSecurityGroupIngressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RevokeSecurityGroupIngressRequest
-- <p>Contains the parameters for RevokeSecurityGroupIngress.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group.</p>
-- @param CidrIp [String] <p>The CIDR IP address range. You can't specify this parameter when specifying a source security group.</p>
-- @param IpPermissions [IpPermissionList] <p>A set of IP permissions. You can't specify a source security group and a CIDR IP address range.</p>
-- @param FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. For the ICMP type number, use <code>-1</code> to specify all ICMP types.</p>
-- @param SourceSecurityGroupOwnerId [String] <p>[EC2-Classic] The AWS account ID of the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
-- @param SourceSecurityGroupName [String] <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. For EC2-VPC, the source security group must be in the same VPC. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
-- @param ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP code number. For the ICMP code number, use <code>-1</code> to specify all ICMP codes for the ICMP type.</p>
-- @param IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). Use <code>-1</code> to specify all.</p>
-- @param GroupId [String] <p>The ID of the security group. Required for a security group in a nondefault VPC.</p>
function M.RevokeSecurityGroupIngressRequest(DryRun, GroupName, CidrIp, IpPermissions, FromPort, SourceSecurityGroupOwnerId, SourceSecurityGroupName, ToPort, IpProtocol, GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RevokeSecurityGroupIngressRequest")
	local t = { 
		["DryRun"] = DryRun,
		["GroupName"] = GroupName,
		["CidrIp"] = CidrIp,
		["IpPermissions"] = IpPermissions,
		["FromPort"] = FromPort,
		["SourceSecurityGroupOwnerId"] = SourceSecurityGroupOwnerId,
		["SourceSecurityGroupName"] = SourceSecurityGroupName,
		["ToPort"] = ToPort,
		["IpProtocol"] = IpProtocol,
		["GroupId"] = GroupId,
	}
	M.AssertRevokeSecurityGroupIngressRequest(t)
	return t
end

local CreateSpotDatafeedSubscriptionResult_keys = { "SpotDatafeedSubscription" = true, nil }

function M.AssertCreateSpotDatafeedSubscriptionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSpotDatafeedSubscriptionResult to be of type 'table'")
	if struct["SpotDatafeedSubscription"] then M.AssertSpotDatafeedSubscription(struct["SpotDatafeedSubscription"]) end
	for k,_ in pairs(struct) do
		assert(CreateSpotDatafeedSubscriptionResult_keys[k], "CreateSpotDatafeedSubscriptionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSpotDatafeedSubscriptionResult
-- <p>Contains the output of CreateSpotDatafeedSubscription.</p>
-- @param SpotDatafeedSubscription [SpotDatafeedSubscription] <p>The Spot instance data feed subscription.</p>
function M.CreateSpotDatafeedSubscriptionResult(SpotDatafeedSubscription, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSpotDatafeedSubscriptionResult")
	local t = { 
		["SpotDatafeedSubscription"] = SpotDatafeedSubscription,
	}
	M.AssertCreateSpotDatafeedSubscriptionResult(t)
	return t
end

local DescribeClassicLinkInstancesRequest_keys = { "MaxResults" = true, "NextToken" = true, "DryRun" = true, "InstanceIds" = true, "Filters" = true, nil }

function M.AssertDescribeClassicLinkInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeClassicLinkInstancesRequest to be of type 'table'")
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then M.AssertInstanceIdStringList(struct["InstanceIds"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeClassicLinkInstancesRequest_keys[k], "DescribeClassicLinkInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeClassicLinkInstancesRequest
-- <p>Contains the parameters for DescribeClassicLinkInstances.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the instance IDs parameter in the same request.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- @param NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceIds [InstanceIdStringList] <p>One or more instance IDs. Must be instances linked to a VPC through ClassicLink.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>group-id</code> - The ID of a VPC security group that's associated with the instance.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC that the instance is linked to.</p> </li> </ul>
function M.DescribeClassicLinkInstancesRequest(MaxResults, NextToken, DryRun, InstanceIds, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeClassicLinkInstancesRequest")
	local t = { 
		["MaxResults"] = MaxResults,
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["InstanceIds"] = InstanceIds,
		["Filters"] = Filters,
	}
	M.AssertDescribeClassicLinkInstancesRequest(t)
	return t
end

local DescribeReservedInstancesOfferingsRequest_keys = { "MaxInstanceCount" = true, "OfferingType" = true, "AvailabilityZone" = true, "DryRun" = true, "ProductDescription" = true, "IncludeMarketplace" = true, "ReservedInstancesOfferingIds" = true, "MaxResults" = true, "InstanceType" = true, "OfferingClass" = true, "Filters" = true, "MinDuration" = true, "InstanceTenancy" = true, "NextToken" = true, "MaxDuration" = true, nil }

function M.AssertDescribeReservedInstancesOfferingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesOfferingsRequest to be of type 'table'")
	if struct["MaxInstanceCount"] then M.AssertInteger(struct["MaxInstanceCount"]) end
	if struct["OfferingType"] then M.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["ProductDescription"] then M.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["IncludeMarketplace"] then M.AssertBoolean(struct["IncludeMarketplace"]) end
	if struct["ReservedInstancesOfferingIds"] then M.AssertReservedInstancesOfferingIdStringList(struct["ReservedInstancesOfferingIds"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["OfferingClass"] then M.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["MinDuration"] then M.AssertLong(struct["MinDuration"]) end
	if struct["InstanceTenancy"] then M.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["MaxDuration"] then M.AssertLong(struct["MaxDuration"]) end
	for k,_ in pairs(struct) do
		assert(DescribeReservedInstancesOfferingsRequest_keys[k], "DescribeReservedInstancesOfferingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesOfferingsRequest
-- <p>Contains the parameters for DescribeReservedInstancesOfferings.</p>
-- @param MaxInstanceCount [Integer] <p>The maximum number of instances to filter when searching for offerings.</p> <p>Default: 20</p>
-- @param OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the <code>Medium Utilization</code> Reserved Instance offering type. </p>
-- @param AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the description are for use with Amazon VPC.</p>
-- @param IncludeMarketplace [Boolean] <p>Include Reserved Instance Marketplace offerings in the response.</p>
-- @param ReservedInstancesOfferingIds [ReservedInstancesOfferingIdStringList] <p>One or more Reserved Instances offering IDs.</p>
-- @param MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. The maximum is 100.</p> <p>Default: 100</p>
-- @param InstanceType [InstanceType] <p>The instance type that the reservation will cover (for example, <code>m1.small</code>). For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param OfferingClass [OfferingClassType] <p>The offering class of the Reserved Instance. Can be <code>standard</code> or <code>convertible</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be used.</p> </li> <li> <p> <code>duration</code> - The duration of the Reserved Instance (for example, one year or three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p> </li> <li> <p> <code>fixed-price</code> - The purchase price of the Reserved Instance (for example, 9800.0).</p> </li> <li> <p> <code>instance-type</code> - The instance type that is covered by the reservation.</p> </li> <li> <p> <code>marketplace</code> - Set to <code>true</code> to show only Reserved Instance Marketplace offerings. When this filter is not used, which is the default behavior, all offerings from both AWS and the Reserved Instance Marketplace are listed.</p> </li> <li> <p> <code>product-description</code> - The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC. (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Windows</code> | <code>Windows (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> | <code> Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon VPC)</code>) </p> </li> <li> <p> <code>reserved-instances-offering-id</code> - The Reserved Instances offering ID.</p> </li> <li> <p> <code>scope</code> - The scope of the Reserved Instance (<code>Availability Zone</code> or <code>Region</code>).</p> </li> <li> <p> <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for example, 0.84).</p> </li> </ul>
-- @param MinDuration [Long] <p>The minimum duration (in seconds) to filter when searching for offerings.</p> <p>Default: 2592000 (1 month)</p>
-- @param InstanceTenancy [Tenancy] <p>The tenancy of the instances covered by the reservation. A Reserved Instance with a tenancy of <code>dedicated</code> is applied to instances that run in a VPC on single-tenant hardware (i.e., Dedicated Instances).</p> <p> <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p> <p>Default: <code>default</code> </p>
-- @param NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param MaxDuration [Long] <p>The maximum duration (in seconds) to filter when searching for offerings.</p> <p>Default: 94608000 (3 years)</p>
function M.DescribeReservedInstancesOfferingsRequest(MaxInstanceCount, OfferingType, AvailabilityZone, DryRun, ProductDescription, IncludeMarketplace, ReservedInstancesOfferingIds, MaxResults, InstanceType, OfferingClass, Filters, MinDuration, InstanceTenancy, NextToken, MaxDuration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesOfferingsRequest")
	local t = { 
		["MaxInstanceCount"] = MaxInstanceCount,
		["OfferingType"] = OfferingType,
		["AvailabilityZone"] = AvailabilityZone,
		["DryRun"] = DryRun,
		["ProductDescription"] = ProductDescription,
		["IncludeMarketplace"] = IncludeMarketplace,
		["ReservedInstancesOfferingIds"] = ReservedInstancesOfferingIds,
		["MaxResults"] = MaxResults,
		["InstanceType"] = InstanceType,
		["OfferingClass"] = OfferingClass,
		["Filters"] = Filters,
		["MinDuration"] = MinDuration,
		["InstanceTenancy"] = InstanceTenancy,
		["NextToken"] = NextToken,
		["MaxDuration"] = MaxDuration,
	}
	M.AssertDescribeReservedInstancesOfferingsRequest(t)
	return t
end

local GetReservedInstancesExchangeQuoteResult_keys = { "CurrencyCode" = true, "ReservedInstanceValueSet" = true, "PaymentDue" = true, "TargetConfigurationValueSet" = true, "IsValidExchange" = true, "ValidationFailureReason" = true, "OutputReservedInstancesWillExpireAt" = true, "ReservedInstanceValueRollup" = true, "TargetConfigurationValueRollup" = true, nil }

function M.AssertGetReservedInstancesExchangeQuoteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetReservedInstancesExchangeQuoteResult to be of type 'table'")
	if struct["CurrencyCode"] then M.AssertString(struct["CurrencyCode"]) end
	if struct["ReservedInstanceValueSet"] then M.AssertReservedInstanceReservationValueSet(struct["ReservedInstanceValueSet"]) end
	if struct["PaymentDue"] then M.AssertString(struct["PaymentDue"]) end
	if struct["TargetConfigurationValueSet"] then M.AssertTargetReservationValueSet(struct["TargetConfigurationValueSet"]) end
	if struct["IsValidExchange"] then M.AssertBoolean(struct["IsValidExchange"]) end
	if struct["ValidationFailureReason"] then M.AssertString(struct["ValidationFailureReason"]) end
	if struct["OutputReservedInstancesWillExpireAt"] then M.AssertDateTime(struct["OutputReservedInstancesWillExpireAt"]) end
	if struct["ReservedInstanceValueRollup"] then M.AssertReservationValue(struct["ReservedInstanceValueRollup"]) end
	if struct["TargetConfigurationValueRollup"] then M.AssertReservationValue(struct["TargetConfigurationValueRollup"]) end
	for k,_ in pairs(struct) do
		assert(GetReservedInstancesExchangeQuoteResult_keys[k], "GetReservedInstancesExchangeQuoteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetReservedInstancesExchangeQuoteResult
-- <p>Contains the output of GetReservedInstancesExchangeQuote.</p>
-- @param CurrencyCode [String] <p>The currency of the transaction.</p>
-- @param ReservedInstanceValueSet [ReservedInstanceReservationValueSet] <p>The configuration of your Convertible Reserved Instances.</p>
-- @param PaymentDue [String] <p>The total true upfront charge for the exchange.</p>
-- @param TargetConfigurationValueSet [TargetReservationValueSet] <p>The values of the target Convertible Reserved Instances.</p>
-- @param IsValidExchange [Boolean] <p>If <code>true</code>, the exchange is valid. If <code>false</code>, the exchange cannot be completed.</p>
-- @param ValidationFailureReason [String] <p>Describes the reason why the exchange cannot be completed.</p>
-- @param OutputReservedInstancesWillExpireAt [DateTime] <p>The new end date of the reservation term.</p>
-- @param ReservedInstanceValueRollup [ReservationValue] <p>The cost associated with the Reserved Instance.</p>
-- @param TargetConfigurationValueRollup [ReservationValue] <p>The cost associated with the Reserved Instance.</p>
function M.GetReservedInstancesExchangeQuoteResult(CurrencyCode, ReservedInstanceValueSet, PaymentDue, TargetConfigurationValueSet, IsValidExchange, ValidationFailureReason, OutputReservedInstancesWillExpireAt, ReservedInstanceValueRollup, TargetConfigurationValueRollup, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetReservedInstancesExchangeQuoteResult")
	local t = { 
		["CurrencyCode"] = CurrencyCode,
		["ReservedInstanceValueSet"] = ReservedInstanceValueSet,
		["PaymentDue"] = PaymentDue,
		["TargetConfigurationValueSet"] = TargetConfigurationValueSet,
		["IsValidExchange"] = IsValidExchange,
		["ValidationFailureReason"] = ValidationFailureReason,
		["OutputReservedInstancesWillExpireAt"] = OutputReservedInstancesWillExpireAt,
		["ReservedInstanceValueRollup"] = ReservedInstanceValueRollup,
		["TargetConfigurationValueRollup"] = TargetConfigurationValueRollup,
	}
	M.AssertGetReservedInstancesExchangeQuoteResult(t)
	return t
end

local CreateImageResult_keys = { "ImageId" = true, nil }

function M.AssertCreateImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateImageResult to be of type 'table'")
	if struct["ImageId"] then M.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(CreateImageResult_keys[k], "CreateImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateImageResult
-- <p>Contains the output of CreateImage.</p>
-- @param ImageId [String] <p>The ID of the new AMI.</p>
function M.CreateImageResult(ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateImageResult")
	local t = { 
		["ImageId"] = ImageId,
	}
	M.AssertCreateImageResult(t)
	return t
end

local DhcpOptions_keys = { "Tags" = true, "DhcpConfigurations" = true, "DhcpOptionsId" = true, nil }

function M.AssertDhcpOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DhcpOptions to be of type 'table'")
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["DhcpConfigurations"] then M.AssertDhcpConfigurationList(struct["DhcpConfigurations"]) end
	if struct["DhcpOptionsId"] then M.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(DhcpOptions_keys[k], "DhcpOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DhcpOptions
-- <p>Describes a set of DHCP options.</p>
-- @param Tags [TagList] <p>Any tags assigned to the DHCP options set.</p>
-- @param DhcpConfigurations [DhcpConfigurationList] <p>One or more DHCP options in the set.</p>
-- @param DhcpOptionsId [String] <p>The ID of the set of DHCP options.</p>
function M.DhcpOptions(Tags, DhcpConfigurations, DhcpOptionsId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DhcpOptions")
	local t = { 
		["Tags"] = Tags,
		["DhcpConfigurations"] = DhcpConfigurations,
		["DhcpOptionsId"] = DhcpOptionsId,
	}
	M.AssertDhcpOptions(t)
	return t
end

local ReservedInstances_keys = { "ReservedInstancesId" = true, "OfferingType" = true, "AvailabilityZone" = true, "End" = true, "ProductDescription" = true, "Tags" = true, "Scope" = true, "UsagePrice" = true, "RecurringCharges" = true, "OfferingClass" = true, "Start" = true, "State" = true, "FixedPrice" = true, "CurrencyCode" = true, "Duration" = true, "InstanceTenancy" = true, "InstanceType" = true, "InstanceCount" = true, nil }

function M.AssertReservedInstances(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstances to be of type 'table'")
	if struct["ReservedInstancesId"] then M.AssertString(struct["ReservedInstancesId"]) end
	if struct["OfferingType"] then M.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["End"] then M.AssertDateTime(struct["End"]) end
	if struct["ProductDescription"] then M.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["Scope"] then M.Assertscope(struct["Scope"]) end
	if struct["UsagePrice"] then M.AssertFloat(struct["UsagePrice"]) end
	if struct["RecurringCharges"] then M.AssertRecurringChargesList(struct["RecurringCharges"]) end
	if struct["OfferingClass"] then M.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Start"] then M.AssertDateTime(struct["Start"]) end
	if struct["State"] then M.AssertReservedInstanceState(struct["State"]) end
	if struct["FixedPrice"] then M.AssertFloat(struct["FixedPrice"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Duration"] then M.AssertLong(struct["Duration"]) end
	if struct["InstanceTenancy"] then M.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(ReservedInstances_keys[k], "ReservedInstances contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstances
-- <p>Describes a Reserved Instance.</p>
-- @param ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- @param OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- @param End [DateTime] <p>The time when the Reserved Instance expires.</p>
-- @param ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description.</p>
-- @param Tags [TagList] <p>Any tags assigned to the resource.</p>
-- @param Scope [scope] <p>The scope of the Reserved Instance.</p>
-- @param UsagePrice [Float] <p>The usage price of the Reserved Instance, per hour.</p>
-- @param RecurringCharges [RecurringChargesList] <p>The recurring charge tag assigned to the resource.</p>
-- @param OfferingClass [OfferingClassType] <p>The offering class of the Reserved Instance.</p>
-- @param Start [DateTime] <p>The date and time the Reserved Instance started.</p>
-- @param State [ReservedInstanceState] <p>The state of the Reserved Instance purchase.</p>
-- @param FixedPrice [Float] <p>The purchase price of the Reserved Instance.</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>
-- @param Duration [Long] <p>The duration of the Reserved Instance, in seconds.</p>
-- @param InstanceTenancy [Tenancy] <p>The tenancy of the instance.</p>
-- @param InstanceType [InstanceType] <p>The instance type on which the Reserved Instance can be used.</p>
-- @param InstanceCount [Integer] <p>The number of reservations purchased.</p>
function M.ReservedInstances(ReservedInstancesId, OfferingType, AvailabilityZone, End, ProductDescription, Tags, Scope, UsagePrice, RecurringCharges, OfferingClass, Start, State, FixedPrice, CurrencyCode, Duration, InstanceTenancy, InstanceType, InstanceCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstances")
	local t = { 
		["ReservedInstancesId"] = ReservedInstancesId,
		["OfferingType"] = OfferingType,
		["AvailabilityZone"] = AvailabilityZone,
		["End"] = End,
		["ProductDescription"] = ProductDescription,
		["Tags"] = Tags,
		["Scope"] = Scope,
		["UsagePrice"] = UsagePrice,
		["RecurringCharges"] = RecurringCharges,
		["OfferingClass"] = OfferingClass,
		["Start"] = Start,
		["State"] = State,
		["FixedPrice"] = FixedPrice,
		["CurrencyCode"] = CurrencyCode,
		["Duration"] = Duration,
		["InstanceTenancy"] = InstanceTenancy,
		["InstanceType"] = InstanceType,
		["InstanceCount"] = InstanceCount,
	}
	M.AssertReservedInstances(t)
	return t
end

local DescribeCustomerGatewaysResult_keys = { "CustomerGateways" = true, nil }

function M.AssertDescribeCustomerGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCustomerGatewaysResult to be of type 'table'")
	if struct["CustomerGateways"] then M.AssertCustomerGatewayList(struct["CustomerGateways"]) end
	for k,_ in pairs(struct) do
		assert(DescribeCustomerGatewaysResult_keys[k], "DescribeCustomerGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCustomerGatewaysResult
-- <p>Contains the output of DescribeCustomerGateways.</p>
-- @param CustomerGateways [CustomerGatewayList] <p>Information about one or more customer gateways.</p>
function M.DescribeCustomerGatewaysResult(CustomerGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeCustomerGatewaysResult")
	local t = { 
		["CustomerGateways"] = CustomerGateways,
	}
	M.AssertDescribeCustomerGatewaysResult(t)
	return t
end

local AvailabilityZoneMessage_keys = { "Message" = true, nil }

function M.AssertAvailabilityZoneMessage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailabilityZoneMessage to be of type 'table'")
	if struct["Message"] then M.AssertString(struct["Message"]) end
	for k,_ in pairs(struct) do
		assert(AvailabilityZoneMessage_keys[k], "AvailabilityZoneMessage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailabilityZoneMessage
-- <p>Describes a message about an Availability Zone.</p>
-- @param Message [String] <p>The message about the Availability Zone.</p>
function M.AvailabilityZoneMessage(Message, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AvailabilityZoneMessage")
	local t = { 
		["Message"] = Message,
	}
	M.AssertAvailabilityZoneMessage(t)
	return t
end

local GetConsoleScreenshotResult_keys = { "InstanceId" = true, "ImageData" = true, nil }

function M.AssertGetConsoleScreenshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleScreenshotResult to be of type 'table'")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["ImageData"] then M.AssertString(struct["ImageData"]) end
	for k,_ in pairs(struct) do
		assert(GetConsoleScreenshotResult_keys[k], "GetConsoleScreenshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleScreenshotResult
-- <p>Contains the output of the request.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param ImageData [String] <p>The data that comprises the image.</p>
function M.GetConsoleScreenshotResult(InstanceId, ImageData, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetConsoleScreenshotResult")
	local t = { 
		["InstanceId"] = InstanceId,
		["ImageData"] = ImageData,
	}
	M.AssertGetConsoleScreenshotResult(t)
	return t
end

local DescribeVpcPeeringConnectionsRequest_keys = { "VpcPeeringConnectionIds" = true, "DryRun" = true, "Filters" = true, nil }

function M.AssertDescribeVpcPeeringConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcPeeringConnectionsRequest to be of type 'table'")
	if struct["VpcPeeringConnectionIds"] then M.AssertValueStringList(struct["VpcPeeringConnectionIds"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcPeeringConnectionsRequest_keys[k], "DescribeVpcPeeringConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcPeeringConnectionsRequest
-- <p>Contains the parameters for DescribeVpcPeeringConnections.</p>
-- @param VpcPeeringConnectionIds [ValueStringList] <p>One or more VPC peering connection IDs.</p> <p>Default: Describes all your VPC peering connections.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>accepter-vpc-info.cidr-block</code> - The IPv4 CIDR block of the peer VPC.</p> </li> <li> <p> <code>accepter-vpc-info.owner-id</code> - The AWS account ID of the owner of the peer VPC.</p> </li> <li> <p> <code>accepter-vpc-info.vpc-id</code> - The ID of the peer VPC.</p> </li> <li> <p> <code>expiration-time</code> - The expiration date and time for the VPC peering connection.</p> </li> <li> <p> <code>requester-vpc-info.cidr-block</code> - The IPv4 CIDR block of the requester's VPC.</p> </li> <li> <p> <code>requester-vpc-info.owner-id</code> - The AWS account ID of the owner of the requester VPC.</p> </li> <li> <p> <code>requester-vpc-info.vpc-id</code> - The ID of the requester VPC.</p> </li> <li> <p> <code>status-code</code> - The status of the VPC peering connection (<code>pending-acceptance</code> | <code>failed</code> | <code>expired</code> | <code>provisioning</code> | <code>active</code> | <code>deleted</code> | <code>rejected</code>).</p> </li> <li> <p> <code>status-message</code> - A message that provides more information about the status of the VPC peering connection, if applicable.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-peering-connection-id</code> - The ID of the VPC peering connection.</p> </li> </ul>
function M.DescribeVpcPeeringConnectionsRequest(VpcPeeringConnectionIds, DryRun, Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcPeeringConnectionsRequest")
	local t = { 
		["VpcPeeringConnectionIds"] = VpcPeeringConnectionIds,
		["DryRun"] = DryRun,
		["Filters"] = Filters,
	}
	M.AssertDescribeVpcPeeringConnectionsRequest(t)
	return t
end

local AuthorizeSecurityGroupEgressRequest_keys = { "DryRun" = true, "CidrIp" = true, "IpPermissions" = true, "FromPort" = true, "SourceSecurityGroupOwnerId" = true, "SourceSecurityGroupName" = true, "ToPort" = true, "IpProtocol" = true, "GroupId" = true, nil }

function M.AssertAuthorizeSecurityGroupEgressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizeSecurityGroupEgressRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["CidrIp"] then M.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then M.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then M.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then M.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then M.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then M.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then M.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then M.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(AuthorizeSecurityGroupEgressRequest_keys[k], "AuthorizeSecurityGroupEgressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizeSecurityGroupEgressRequest
-- <p>Contains the parameters for AuthorizeSecurityGroupEgress.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param CidrIp [String] <p>The CIDR IPv4 address range. We recommend that you specify the CIDR range in a set of IP permissions instead.</p>
-- @param IpPermissions [IpPermissionList] <p>A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.</p>
-- @param FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- @param SourceSecurityGroupOwnerId [String] <p>The AWS account number for a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- @param SourceSecurityGroupName [String] <p>The name of a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- @param ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- @param IpProtocol [String] <p>The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.</p>
-- @param GroupId [String] <p>The ID of the security group.</p>
-- Required parameter: GroupId
function M.AuthorizeSecurityGroupEgressRequest(DryRun, CidrIp, IpPermissions, FromPort, SourceSecurityGroupOwnerId, SourceSecurityGroupName, ToPort, IpProtocol, GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AuthorizeSecurityGroupEgressRequest")
	local t = { 
		["DryRun"] = DryRun,
		["CidrIp"] = CidrIp,
		["IpPermissions"] = IpPermissions,
		["FromPort"] = FromPort,
		["SourceSecurityGroupOwnerId"] = SourceSecurityGroupOwnerId,
		["SourceSecurityGroupName"] = SourceSecurityGroupName,
		["ToPort"] = ToPort,
		["IpProtocol"] = IpProtocol,
		["GroupId"] = GroupId,
	}
	M.AssertAuthorizeSecurityGroupEgressRequest(t)
	return t
end

local DeleteCustomerGatewayRequest_keys = { "CustomerGatewayId" = true, "DryRun" = true, nil }

function M.AssertDeleteCustomerGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteCustomerGatewayRequest to be of type 'table'")
	assert(struct["CustomerGatewayId"], "Expected key CustomerGatewayId to exist in table")
	if struct["CustomerGatewayId"] then M.AssertString(struct["CustomerGatewayId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DeleteCustomerGatewayRequest_keys[k], "DeleteCustomerGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteCustomerGatewayRequest
-- <p>Contains the parameters for DeleteCustomerGateway.</p>
-- @param CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: CustomerGatewayId
function M.DeleteCustomerGatewayRequest(CustomerGatewayId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteCustomerGatewayRequest")
	local t = { 
		["CustomerGatewayId"] = CustomerGatewayId,
		["DryRun"] = DryRun,
	}
	M.AssertDeleteCustomerGatewayRequest(t)
	return t
end

local CreateReservedInstancesListingRequest_keys = { "ReservedInstancesId" = true, "PriceSchedules" = true, "InstanceCount" = true, "ClientToken" = true, nil }

function M.AssertCreateReservedInstancesListingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateReservedInstancesListingRequest to be of type 'table'")
	assert(struct["ClientToken"], "Expected key ClientToken to exist in table")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["PriceSchedules"], "Expected key PriceSchedules to exist in table")
	assert(struct["ReservedInstancesId"], "Expected key ReservedInstancesId to exist in table")
	if struct["ReservedInstancesId"] then M.AssertString(struct["ReservedInstancesId"]) end
	if struct["PriceSchedules"] then M.AssertPriceScheduleSpecificationList(struct["PriceSchedules"]) end
	if struct["InstanceCount"] then M.AssertInteger(struct["InstanceCount"]) end
	if struct["ClientToken"] then M.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(CreateReservedInstancesListingRequest_keys[k], "CreateReservedInstancesListingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateReservedInstancesListingRequest
-- <p>Contains the parameters for CreateReservedInstancesListing.</p>
-- @param ReservedInstancesId [String] <p>The ID of the active Standard Reserved Instance.</p>
-- @param PriceSchedules [PriceScheduleSpecificationList] <p>A list specifying the price of the Standard Reserved Instance for each month remaining in the Reserved Instance term.</p>
-- @param InstanceCount [Integer] <p>The number of instances that are a part of a Reserved Instance account to be listed in the Reserved Instance Marketplace. This number should be less than or equal to the instance count associated with the Reserved Instance ID specified in this call.</p>
-- @param ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required parameter: ClientToken
-- Required parameter: InstanceCount
-- Required parameter: PriceSchedules
-- Required parameter: ReservedInstancesId
function M.CreateReservedInstancesListingRequest(ReservedInstancesId, PriceSchedules, InstanceCount, ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateReservedInstancesListingRequest")
	local t = { 
		["ReservedInstancesId"] = ReservedInstancesId,
		["PriceSchedules"] = PriceSchedules,
		["InstanceCount"] = InstanceCount,
		["ClientToken"] = ClientToken,
	}
	M.AssertCreateReservedInstancesListingRequest(t)
	return t
end

local NetworkInterfaceAssociation_keys = { "PublicIp" = true, "AssociationId" = true, "PublicDnsName" = true, "AllocationId" = true, "IpOwnerId" = true, nil }

function M.AssertNetworkInterfaceAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAssociation to be of type 'table'")
	if struct["PublicIp"] then M.AssertString(struct["PublicIp"]) end
	if struct["AssociationId"] then M.AssertString(struct["AssociationId"]) end
	if struct["PublicDnsName"] then M.AssertString(struct["PublicDnsName"]) end
	if struct["AllocationId"] then M.AssertString(struct["AllocationId"]) end
	if struct["IpOwnerId"] then M.AssertString(struct["IpOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(NetworkInterfaceAssociation_keys[k], "NetworkInterfaceAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAssociation
-- <p>Describes association information for an Elastic IP address (IPv4 only).</p>
-- @param PublicIp [String] <p>The address of the Elastic IP address bound to the network interface.</p>
-- @param AssociationId [String] <p>The association ID.</p>
-- @param PublicDnsName [String] <p>The public DNS name.</p>
-- @param AllocationId [String] <p>The allocation ID.</p>
-- @param IpOwnerId [String] <p>The ID of the Elastic IP address owner.</p>
function M.NetworkInterfaceAssociation(PublicIp, AssociationId, PublicDnsName, AllocationId, IpOwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfaceAssociation")
	local t = { 
		["PublicIp"] = PublicIp,
		["AssociationId"] = AssociationId,
		["PublicDnsName"] = PublicDnsName,
		["AllocationId"] = AllocationId,
		["IpOwnerId"] = IpOwnerId,
	}
	M.AssertNetworkInterfaceAssociation(t)
	return t
end

local ReservedInstancesOffering_keys = { "OfferingClass" = true, "Marketplace" = true, "ProductDescription" = true, "CurrencyCode" = true, "PricingDetails" = true, "UsagePrice" = true, "RecurringCharges" = true, "OfferingType" = true, "AvailabilityZone" = true, "FixedPrice" = true, "Scope" = true, "Duration" = true, "InstanceTenancy" = true, "ReservedInstancesOfferingId" = true, "InstanceType" = true, nil }

function M.AssertReservedInstancesOffering(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesOffering to be of type 'table'")
	if struct["OfferingClass"] then M.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Marketplace"] then M.AssertBoolean(struct["Marketplace"]) end
	if struct["ProductDescription"] then M.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["CurrencyCode"] then M.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["PricingDetails"] then M.AssertPricingDetailsList(struct["PricingDetails"]) end
	if struct["UsagePrice"] then M.AssertFloat(struct["UsagePrice"]) end
	if struct["RecurringCharges"] then M.AssertRecurringChargesList(struct["RecurringCharges"]) end
	if struct["OfferingType"] then M.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["FixedPrice"] then M.AssertFloat(struct["FixedPrice"]) end
	if struct["Scope"] then M.Assertscope(struct["Scope"]) end
	if struct["Duration"] then M.AssertLong(struct["Duration"]) end
	if struct["InstanceTenancy"] then M.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["ReservedInstancesOfferingId"] then M.AssertString(struct["ReservedInstancesOfferingId"]) end
	if struct["InstanceType"] then M.AssertInstanceType(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(ReservedInstancesOffering_keys[k], "ReservedInstancesOffering contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesOffering
-- <p>Describes a Reserved Instance offering.</p>
-- @param OfferingClass [OfferingClassType] <p>If <code>convertible</code> it can be exchanged for Reserved Instances of the same or higher monetary value, with different configurations. If <code>standard</code>, it is not possible to perform an exchange.</p>
-- @param Marketplace [Boolean] <p>Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or AWS. If it's a Reserved Instance Marketplace offering, this is <code>true</code>.</p>
-- @param ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description.</p>
-- @param CurrencyCode [CurrencyCodeValues] <p>The currency of the Reserved Instance offering you are purchasing. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>
-- @param PricingDetails [PricingDetailsList] <p>The pricing details of the Reserved Instance offering.</p>
-- @param UsagePrice [Float] <p>The usage price of the Reserved Instance, per hour.</p>
-- @param RecurringCharges [RecurringChargesList] <p>The recurring charge tag assigned to the resource.</p>
-- @param OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- @param FixedPrice [Float] <p>The purchase price of the Reserved Instance.</p>
-- @param Scope [scope] <p>Whether the Reserved Instance is applied to instances in a region or an Availability Zone.</p>
-- @param Duration [Long] <p>The duration of the Reserved Instance, in seconds.</p>
-- @param InstanceTenancy [Tenancy] <p>The tenancy of the instance.</p>
-- @param ReservedInstancesOfferingId [String] <p>The ID of the Reserved Instance offering. This is the offering ID used in <a>GetReservedInstancesExchangeQuote</a> to confirm that an exchange can be made.</p>
-- @param InstanceType [InstanceType] <p>The instance type on which the Reserved Instance can be used.</p>
function M.ReservedInstancesOffering(OfferingClass, Marketplace, ProductDescription, CurrencyCode, PricingDetails, UsagePrice, RecurringCharges, OfferingType, AvailabilityZone, FixedPrice, Scope, Duration, InstanceTenancy, ReservedInstancesOfferingId, InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesOffering")
	local t = { 
		["OfferingClass"] = OfferingClass,
		["Marketplace"] = Marketplace,
		["ProductDescription"] = ProductDescription,
		["CurrencyCode"] = CurrencyCode,
		["PricingDetails"] = PricingDetails,
		["UsagePrice"] = UsagePrice,
		["RecurringCharges"] = RecurringCharges,
		["OfferingType"] = OfferingType,
		["AvailabilityZone"] = AvailabilityZone,
		["FixedPrice"] = FixedPrice,
		["Scope"] = Scope,
		["Duration"] = Duration,
		["InstanceTenancy"] = InstanceTenancy,
		["ReservedInstancesOfferingId"] = ReservedInstancesOfferingId,
		["InstanceType"] = InstanceType,
	}
	M.AssertReservedInstancesOffering(t)
	return t
end

local IpPermission_keys = { "PrefixListIds" = true, "FromPort" = true, "IpRanges" = true, "ToPort" = true, "IpProtocol" = true, "UserIdGroupPairs" = true, "Ipv6Ranges" = true, nil }

function M.AssertIpPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IpPermission to be of type 'table'")
	if struct["PrefixListIds"] then M.AssertPrefixListIdList(struct["PrefixListIds"]) end
	if struct["FromPort"] then M.AssertInteger(struct["FromPort"]) end
	if struct["IpRanges"] then M.AssertIpRangeList(struct["IpRanges"]) end
	if struct["ToPort"] then M.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then M.AssertString(struct["IpProtocol"]) end
	if struct["UserIdGroupPairs"] then M.AssertUserIdGroupPairList(struct["UserIdGroupPairs"]) end
	if struct["Ipv6Ranges"] then M.AssertIpv6RangeList(struct["Ipv6Ranges"]) end
	for k,_ in pairs(struct) do
		assert(IpPermission_keys[k], "IpPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IpPermission
-- <p>Describes a security group rule.</p>
-- @param PrefixListIds [PrefixListIdList] <p>(Valid for <a>AuthorizeSecurityGroupEgress</a>, <a>RevokeSecurityGroupEgress</a> and <a>DescribeSecurityGroups</a> only) One or more prefix list IDs for an AWS service. In an <a>AuthorizeSecurityGroupEgress</a> request, this is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.</p>
-- @param FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of <code>-1</code> indicates all ICMP/ICMPv6 types.</p>
-- @param IpRanges [IpRangeList] <p>One or more IPv4 ranges.</p>
-- @param ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes for the specified ICMP type.</p>
-- @param IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). </p> <p>[EC2-VPC only] Use <code>-1</code> to specify all protocols. When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>58</code> (ICMPv6) allows traffic on all ports, regardless of any port range you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For <code>58</code> (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed when authorizing rules. </p>
-- @param UserIdGroupPairs [UserIdGroupPairList] <p>One or more security group and AWS account ID pairs.</p>
-- @param Ipv6Ranges [Ipv6RangeList] <p>[EC2-VPC only] One or more IPv6 ranges.</p>
function M.IpPermission(PrefixListIds, FromPort, IpRanges, ToPort, IpProtocol, UserIdGroupPairs, Ipv6Ranges, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IpPermission")
	local t = { 
		["PrefixListIds"] = PrefixListIds,
		["FromPort"] = FromPort,
		["IpRanges"] = IpRanges,
		["ToPort"] = ToPort,
		["IpProtocol"] = IpProtocol,
		["UserIdGroupPairs"] = UserIdGroupPairs,
		["Ipv6Ranges"] = Ipv6Ranges,
	}
	M.AssertIpPermission(t)
	return t
end

local MonitorInstancesRequest_keys = { "DryRun" = true, "InstanceIds" = true, nil }

function M.AssertMonitorInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MonitorInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then M.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(MonitorInstancesRequest_keys[k], "MonitorInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MonitorInstancesRequest
-- <p>Contains the parameters for MonitorInstances.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.MonitorInstancesRequest(DryRun, InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MonitorInstancesRequest")
	local t = { 
		["DryRun"] = DryRun,
		["InstanceIds"] = InstanceIds,
	}
	M.AssertMonitorInstancesRequest(t)
	return t
end

local AcceptVpcPeeringConnectionRequest_keys = { "DryRun" = true, "VpcPeeringConnectionId" = true, nil }

function M.AssertAcceptVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcPeeringConnectionRequest to be of type 'table'")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then M.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(AcceptVpcPeeringConnectionRequest_keys[k], "AcceptVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcPeeringConnectionRequest
-- <p>Contains the parameters for AcceptVpcPeeringConnection.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
function M.AcceptVpcPeeringConnectionRequest(DryRun, VpcPeeringConnectionId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AcceptVpcPeeringConnectionRequest")
	local t = { 
		["DryRun"] = DryRun,
		["VpcPeeringConnectionId"] = VpcPeeringConnectionId,
	}
	M.AssertAcceptVpcPeeringConnectionRequest(t)
	return t
end

local Volume_keys = { "AvailabilityZone" = true, "Attachments" = true, "Tags" = true, "Encrypted" = true, "VolumeType" = true, "VolumeId" = true, "State" = true, "KmsKeyId" = true, "SnapshotId" = true, "Iops" = true, "CreateTime" = true, "Size" = true, nil }

function M.AssertVolume(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Volume to be of type 'table'")
	if struct["AvailabilityZone"] then M.AssertString(struct["AvailabilityZone"]) end
	if struct["Attachments"] then M.AssertVolumeAttachmentList(struct["Attachments"]) end
	if struct["Tags"] then M.AssertTagList(struct["Tags"]) end
	if struct["Encrypted"] then M.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then M.AssertVolumeType(struct["VolumeType"]) end
	if struct["VolumeId"] then M.AssertString(struct["VolumeId"]) end
	if struct["State"] then M.AssertVolumeState(struct["State"]) end
	if struct["KmsKeyId"] then M.AssertString(struct["KmsKeyId"]) end
	if struct["SnapshotId"] then M.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then M.AssertInteger(struct["Iops"]) end
	if struct["CreateTime"] then M.AssertDateTime(struct["CreateTime"]) end
	if struct["Size"] then M.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(Volume_keys[k], "Volume contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Volume
-- <p>Describes a volume.</p>
-- @param AvailabilityZone [String] <p>The Availability Zone for the volume.</p>
-- @param Attachments [VolumeAttachmentList] <p>Information about the volume attachments.</p>
-- @param Tags [TagList] <p>Any tags assigned to the volume.</p>
-- @param Encrypted [Boolean] <p>Indicates whether the volume will be encrypted.</p>
-- @param VolumeType [VolumeType] <p>The volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p>
-- @param VolumeId [String] <p>The ID of the volume.</p>
-- @param State [VolumeState] <p>The volume state.</p>
-- @param KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the volume.</p>
-- @param SnapshotId [String] <p>The snapshot from which the volume was created, if applicable.</p>
-- @param Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For Provisioned IOPS SSD volumes, this represents the number of IOPS that are provisioned for the volume. For General Purpose SSD volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information on General Purpose SSD baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
-- @param CreateTime [DateTime] <p>The time stamp when volume creation was initiated.</p>
-- @param Size [Integer] <p>The size of the volume, in GiBs.</p>
function M.Volume(AvailabilityZone, Attachments, Tags, Encrypted, VolumeType, VolumeId, State, KmsKeyId, SnapshotId, Iops, CreateTime, Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Volume")
	local t = { 
		["AvailabilityZone"] = AvailabilityZone,
		["Attachments"] = Attachments,
		["Tags"] = Tags,
		["Encrypted"] = Encrypted,
		["VolumeType"] = VolumeType,
		["VolumeId"] = VolumeId,
		["State"] = State,
		["KmsKeyId"] = KmsKeyId,
		["SnapshotId"] = SnapshotId,
		["Iops"] = Iops,
		["CreateTime"] = CreateTime,
		["Size"] = Size,
	}
	M.AssertVolume(t)
	return t
end

local CreateVpcResult_keys = { "Vpc" = true, nil }

function M.AssertCreateVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcResult to be of type 'table'")
	if struct["Vpc"] then M.AssertVpc(struct["Vpc"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpcResult_keys[k], "CreateVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcResult
-- <p>Contains the output of CreateVpc.</p>
-- @param Vpc [Vpc] <p>Information about the VPC.</p>
function M.CreateVpcResult(Vpc, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcResult")
	local t = { 
		["Vpc"] = Vpc,
	}
	M.AssertCreateVpcResult(t)
	return t
end

local EnableVpcClassicLinkRequest_keys = { "VpcId" = true, "DryRun" = true, nil }

function M.AssertEnableVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(EnableVpcClassicLinkRequest_keys[k], "EnableVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkRequest
-- <p>Contains the parameters for EnableVpcClassicLink.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.EnableVpcClassicLinkRequest(VpcId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVpcClassicLinkRequest")
	local t = { 
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
	}
	M.AssertEnableVpcClassicLinkRequest(t)
	return t
end

local DescribeVolumeStatusRequest_keys = { "NextToken" = true, "DryRun" = true, "MaxResults" = true, "Filters" = true, "VolumeIds" = true, nil }

function M.AssertDescribeVolumeStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeStatusRequest to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then M.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then M.AssertFilterList(struct["Filters"]) end
	if struct["VolumeIds"] then M.AssertVolumeIdStringList(struct["VolumeIds"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVolumeStatusRequest_keys[k], "DescribeVolumeStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeStatusRequest
-- <p>Contains the parameters for DescribeVolumeStatus.</p>
-- @param NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeVolumeStatus</code> request. When the results of the request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param MaxResults [Integer] <p>The maximum number of volume results returned by <code>DescribeVolumeStatus</code> in paginated output. When this parameter is used, the request only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then <code>DescribeVolumeStatus</code> returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.</p>
-- @param Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>action.code</code> - The action code for the event (for example, <code>enable-volume-io</code>).</p> </li> <li> <p> <code>action.description</code> - A description of the action.</p> </li> <li> <p> <code>action.event-id</code> - The event ID associated with the action.</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>event.description</code> - A description of the event.</p> </li> <li> <p> <code>event.event-id</code> - The event ID.</p> </li> <li> <p> <code>event.event-type</code> - The event type (for <code>io-enabled</code>: <code>passed</code> | <code>failed</code>; for <code>io-performance</code>: <code>io-performance:degraded</code> | <code>io-performance:severely-degraded</code> | <code>io-performance:stalled</code>).</p> </li> <li> <p> <code>event.not-after</code> - The latest end time for the event.</p> </li> <li> <p> <code>event.not-before</code> - The earliest start time for the event.</p> </li> <li> <p> <code>volume-status.details-name</code> - The cause for <code>volume-status.status</code> (<code>io-enabled</code> | <code>io-performance</code>).</p> </li> <li> <p> <code>volume-status.details-status</code> - The status of <code>volume-status.details-name</code> (for <code>io-enabled</code>: <code>passed</code> | <code>failed</code>; for <code>io-performance</code>: <code>normal</code> | <code>degraded</code> | <code>severely-degraded</code> | <code>stalled</code>).</p> </li> <li> <p> <code>volume-status.status</code> - The status of the volume (<code>ok</code> | <code>impaired</code> | <code>warning</code> | <code>insufficient-data</code>).</p> </li> </ul>
-- @param VolumeIds [VolumeIdStringList] <p>One or more volume IDs.</p> <p>Default: Describes all your volumes.</p>
function M.DescribeVolumeStatusRequest(NextToken, DryRun, MaxResults, Filters, VolumeIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumeStatusRequest")
	local t = { 
		["NextToken"] = NextToken,
		["DryRun"] = DryRun,
		["MaxResults"] = MaxResults,
		["Filters"] = Filters,
		["VolumeIds"] = VolumeIds,
	}
	M.AssertDescribeVolumeStatusRequest(t)
	return t
end

local AssignPrivateIpAddressesRequest_keys = { "NetworkInterfaceId" = true, "SecondaryPrivateIpAddressCount" = true, "PrivateIpAddresses" = true, "AllowReassignment" = true, nil }

function M.AssertAssignPrivateIpAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignPrivateIpAddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["SecondaryPrivateIpAddressCount"] then M.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	if struct["PrivateIpAddresses"] then M.AssertPrivateIpAddressStringList(struct["PrivateIpAddresses"]) end
	if struct["AllowReassignment"] then M.AssertBoolean(struct["AllowReassignment"]) end
	for k,_ in pairs(struct) do
		assert(AssignPrivateIpAddressesRequest_keys[k], "AssignPrivateIpAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignPrivateIpAddressesRequest
-- <p>Contains the parameters for AssignPrivateIpAddresses.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary IP addresses to assign to the network interface. You can't specify this parameter when also specifying private IP addresses.</p>
-- @param PrivateIpAddresses [PrivateIpAddressStringList] <p>One or more IP addresses to be assigned as a secondary private IP address to the network interface. You can't specify this parameter when also specifying a number of secondary IP addresses.</p> <p>If you don't specify an IP address, Amazon EC2 automatically selects an IP address within the subnet range.</p>
-- @param AllowReassignment [Boolean] <p>Indicates whether to allow an IP address that is already assigned to another network interface or instance to be reassigned to the specified network interface.</p>
-- Required parameter: NetworkInterfaceId
function M.AssignPrivateIpAddressesRequest(NetworkInterfaceId, SecondaryPrivateIpAddressCount, PrivateIpAddresses, AllowReassignment, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssignPrivateIpAddressesRequest")
	local t = { 
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["SecondaryPrivateIpAddressCount"] = SecondaryPrivateIpAddressCount,
		["PrivateIpAddresses"] = PrivateIpAddresses,
		["AllowReassignment"] = AllowReassignment,
	}
	M.AssertAssignPrivateIpAddressesRequest(t)
	return t
end

local RequestSpotFleetRequest_keys = { "SpotFleetRequestConfig" = true, "DryRun" = true, nil }

function M.AssertRequestSpotFleetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotFleetRequest to be of type 'table'")
	assert(struct["SpotFleetRequestConfig"], "Expected key SpotFleetRequestConfig to exist in table")
	if struct["SpotFleetRequestConfig"] then M.AssertSpotFleetRequestConfigData(struct["SpotFleetRequestConfig"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(RequestSpotFleetRequest_keys[k], "RequestSpotFleetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotFleetRequest
-- <p>Contains the parameters for RequestSpotFleet.</p>
-- @param SpotFleetRequestConfig [SpotFleetRequestConfigData] <p>The configuration for the Spot fleet request.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: SpotFleetRequestConfig
function M.RequestSpotFleetRequest(SpotFleetRequestConfig, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotFleetRequest")
	local t = { 
		["SpotFleetRequestConfig"] = SpotFleetRequestConfig,
		["DryRun"] = DryRun,
	}
	M.AssertRequestSpotFleetRequest(t)
	return t
end

local CreateVpcRequest_keys = { "AmazonProvidedIpv6CidrBlock" = true, "DryRun" = true, "InstanceTenancy" = true, "CidrBlock" = true, nil }

function M.AssertCreateVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcRequest to be of type 'table'")
	assert(struct["CidrBlock"], "Expected key CidrBlock to exist in table")
	if struct["AmazonProvidedIpv6CidrBlock"] then M.AssertBoolean(struct["AmazonProvidedIpv6CidrBlock"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceTenancy"] then M.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["CidrBlock"] then M.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(CreateVpcRequest_keys[k], "CreateVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcRequest
-- <p>Contains the parameters for CreateVpc.</p>
-- @param AmazonProvidedIpv6CidrBlock [Boolean] <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceTenancy [Tenancy] <p>The tenancy options for instances launched into the VPC. For <code>default</code>, instances are launched with shared tenancy by default. You can launch instances with any tenancy into a shared tenancy VPC. For <code>dedicated</code>, instances are launched as dedicated tenancy instances by default. You can only launch instances with a tenancy of <code>dedicated</code> or <code>host</code> into a dedicated tenancy VPC. </p> <p> <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p> <p>Default: <code>default</code> </p>
-- @param CidrBlock [String] <p>The IPv4 network range for the VPC, in CIDR notation. For example, <code>10.0.0.0/16</code>.</p>
-- Required parameter: CidrBlock
function M.CreateVpcRequest(AmazonProvidedIpv6CidrBlock, DryRun, InstanceTenancy, CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcRequest")
	local t = { 
		["AmazonProvidedIpv6CidrBlock"] = AmazonProvidedIpv6CidrBlock,
		["DryRun"] = DryRun,
		["InstanceTenancy"] = InstanceTenancy,
		["CidrBlock"] = CidrBlock,
	}
	M.AssertCreateVpcRequest(t)
	return t
end

local CancelSpotFleetRequestsError_keys = { "Message" = true, "Code" = true, nil }

function M.AssertCancelSpotFleetRequestsError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsError to be of type 'table'")
	assert(struct["Code"], "Expected key Code to exist in table")
	assert(struct["Message"], "Expected key Message to exist in table")
	if struct["Message"] then M.AssertString(struct["Message"]) end
	if struct["Code"] then M.AssertCancelBatchErrorCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(CancelSpotFleetRequestsError_keys[k], "CancelSpotFleetRequestsError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsError
-- <p>Describes a Spot fleet error.</p>
-- @param Message [String] <p>The description for the error code.</p>
-- @param Code [CancelBatchErrorCode] <p>The error code.</p>
-- Required parameter: Code
-- Required parameter: Message
function M.CancelSpotFleetRequestsError(Message, Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsError")
	local t = { 
		["Message"] = Message,
		["Code"] = Code,
	}
	M.AssertCancelSpotFleetRequestsError(t)
	return t
end

local ClassicLinkDnsSupport_keys = { "VpcId" = true, "ClassicLinkDnsSupported" = true, nil }

function M.AssertClassicLinkDnsSupport(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLinkDnsSupport to be of type 'table'")
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["ClassicLinkDnsSupported"] then M.AssertBoolean(struct["ClassicLinkDnsSupported"]) end
	for k,_ in pairs(struct) do
		assert(ClassicLinkDnsSupport_keys[k], "ClassicLinkDnsSupport contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLinkDnsSupport
-- <p>Describes the ClassicLink DNS support status of a VPC.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param ClassicLinkDnsSupported [Boolean] <p>Indicates whether ClassicLink DNS support is enabled for the VPC.</p>
function M.ClassicLinkDnsSupport(VpcId, ClassicLinkDnsSupported, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ClassicLinkDnsSupport")
	local t = { 
		["VpcId"] = VpcId,
		["ClassicLinkDnsSupported"] = ClassicLinkDnsSupported,
	}
	M.AssertClassicLinkDnsSupport(t)
	return t
end

local RebootInstancesRequest_keys = { "DryRun" = true, "InstanceIds" = true, nil }

function M.AssertRebootInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RebootInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then M.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(RebootInstancesRequest_keys[k], "RebootInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RebootInstancesRequest
-- <p>Contains the parameters for RebootInstances.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.RebootInstancesRequest(DryRun, InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RebootInstancesRequest")
	local t = { 
		["DryRun"] = DryRun,
		["InstanceIds"] = InstanceIds,
	}
	M.AssertRebootInstancesRequest(t)
	return t
end

local CreateNetworkAclEntryRequest_keys = { "IcmpTypeCode" = true, "NetworkAclId" = true, "RuleNumber" = true, "DryRun" = true, "Ipv6CidrBlock" = true, "Egress" = true, "RuleAction" = true, "PortRange" = true, "Protocol" = true, "CidrBlock" = true, nil }

function M.AssertCreateNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["Protocol"], "Expected key Protocol to exist in table")
	assert(struct["RuleAction"], "Expected key RuleAction to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["IcmpTypeCode"] then M.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["NetworkAclId"] then M.AssertString(struct["NetworkAclId"]) end
	if struct["RuleNumber"] then M.AssertInteger(struct["RuleNumber"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	if struct["Ipv6CidrBlock"] then M.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then M.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then M.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then M.AssertPortRange(struct["PortRange"]) end
	if struct["Protocol"] then M.AssertString(struct["Protocol"]) end
	if struct["CidrBlock"] then M.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(CreateNetworkAclEntryRequest_keys[k], "CreateNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclEntryRequest
-- <p>Contains the parameters for CreateNetworkAclEntry.</p>
-- @param IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
-- @param NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param RuleNumber [Integer] <p>The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number.</p> <p>Constraints: Positive integer from 1 to 32766. The range 32767 to 65535 is reserved for internal use.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation (for example <code>2001:db8:1234:1a00::/64</code>).</p>
-- @param Egress [Boolean] <p>Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet).</p>
-- @param RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- @param PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
-- @param Protocol [String] <p>The protocol. A value of <code>-1</code> or <code>all</code> means all protocols. If you specify <code>all</code>, <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, or <code>icmp</code>, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
-- @param CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation (for example <code>172.16.0.0/24</code>).</p>
-- Required parameter: Egress
-- Required parameter: NetworkAclId
-- Required parameter: Protocol
-- Required parameter: RuleAction
-- Required parameter: RuleNumber
function M.CreateNetworkAclEntryRequest(IcmpTypeCode, NetworkAclId, RuleNumber, DryRun, Ipv6CidrBlock, Egress, RuleAction, PortRange, Protocol, CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkAclEntryRequest")
	local t = { 
		["IcmpTypeCode"] = IcmpTypeCode,
		["NetworkAclId"] = NetworkAclId,
		["RuleNumber"] = RuleNumber,
		["DryRun"] = DryRun,
		["Ipv6CidrBlock"] = Ipv6CidrBlock,
		["Egress"] = Egress,
		["RuleAction"] = RuleAction,
		["PortRange"] = PortRange,
		["Protocol"] = Protocol,
		["CidrBlock"] = CidrBlock,
	}
	M.AssertCreateNetworkAclEntryRequest(t)
	return t
end

local AttachNetworkInterfaceRequest_keys = { "InstanceId" = true, "DeviceIndex" = true, "NetworkInterfaceId" = true, "DryRun" = true, nil }

function M.AssertAttachNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachNetworkInterfaceRequest to be of type 'table'")
	assert(struct["DeviceIndex"], "Expected key DeviceIndex to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["DeviceIndex"] then M.AssertInteger(struct["DeviceIndex"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(AttachNetworkInterfaceRequest_keys[k], "AttachNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachNetworkInterfaceRequest
-- <p>Contains the parameters for AttachNetworkInterface.</p>
-- @param InstanceId [String] <p>The ID of the instance.</p>
-- @param DeviceIndex [Integer] <p>The index of the device for the network interface attachment.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: DeviceIndex
-- Required parameter: InstanceId
-- Required parameter: NetworkInterfaceId
function M.AttachNetworkInterfaceRequest(InstanceId, DeviceIndex, NetworkInterfaceId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachNetworkInterfaceRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["DeviceIndex"] = DeviceIndex,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["DryRun"] = DryRun,
	}
	M.AssertAttachNetworkInterfaceRequest(t)
	return t
end

local ImportKeyPairResult_keys = { "KeyName" = true, "KeyFingerprint" = true, nil }

function M.AssertImportKeyPairResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportKeyPairResult to be of type 'table'")
	if struct["KeyName"] then M.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then M.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(ImportKeyPairResult_keys[k], "ImportKeyPairResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportKeyPairResult
-- <p>Contains the output of ImportKeyPair.</p>
-- @param KeyName [String] <p>The key pair name you provided.</p>
-- @param KeyFingerprint [String] <p>The MD5 public key fingerprint as specified in section 4 of RFC 4716.</p>
function M.ImportKeyPairResult(KeyName, KeyFingerprint, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportKeyPairResult")
	local t = { 
		["KeyName"] = KeyName,
		["KeyFingerprint"] = KeyFingerprint,
	}
	M.AssertImportKeyPairResult(t)
	return t
end

local DescribeSpotInstanceRequestsResult_keys = { "SpotInstanceRequests" = true, nil }

function M.AssertDescribeSpotInstanceRequestsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotInstanceRequestsResult to be of type 'table'")
	if struct["SpotInstanceRequests"] then M.AssertSpotInstanceRequestList(struct["SpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(DescribeSpotInstanceRequestsResult_keys[k], "DescribeSpotInstanceRequestsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotInstanceRequestsResult
-- <p>Contains the output of DescribeSpotInstanceRequests.</p>
-- @param SpotInstanceRequests [SpotInstanceRequestList] <p>One or more Spot instance requests.</p>
function M.DescribeSpotInstanceRequestsResult(SpotInstanceRequests, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotInstanceRequestsResult")
	local t = { 
		["SpotInstanceRequests"] = SpotInstanceRequests,
	}
	M.AssertDescribeSpotInstanceRequestsResult(t)
	return t
end

local ClientData_keys = { "Comment" = true, "UploadSize" = true, "UploadEnd" = true, "UploadStart" = true, nil }

function M.AssertClientData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClientData to be of type 'table'")
	if struct["Comment"] then M.AssertString(struct["Comment"]) end
	if struct["UploadSize"] then M.AssertDouble(struct["UploadSize"]) end
	if struct["UploadEnd"] then M.AssertDateTime(struct["UploadEnd"]) end
	if struct["UploadStart"] then M.AssertDateTime(struct["UploadStart"]) end
	for k,_ in pairs(struct) do
		assert(ClientData_keys[k], "ClientData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClientData
-- <p>Describes the client-specific data.</p>
-- @param Comment [String] <p>A user-defined comment about the disk upload.</p>
-- @param UploadSize [Double] <p>The size of the uploaded disk image, in GiB.</p>
-- @param UploadEnd [DateTime] <p>The time that the disk upload ends.</p>
-- @param UploadStart [DateTime] <p>The time that the disk upload starts.</p>
function M.ClientData(Comment, UploadSize, UploadEnd, UploadStart, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ClientData")
	local t = { 
		["Comment"] = Comment,
		["UploadSize"] = UploadSize,
		["UploadEnd"] = UploadEnd,
		["UploadStart"] = UploadStart,
	}
	M.AssertClientData(t)
	return t
end

local DescribeNetworkInterfaceAttributeResult_keys = { "SourceDestCheck" = true, "NetworkInterfaceId" = true, "Attachment" = true, "Groups" = true, "Description" = true, nil }

function M.AssertDescribeNetworkInterfaceAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfaceAttributeResult to be of type 'table'")
	if struct["SourceDestCheck"] then M.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["NetworkInterfaceId"] then M.AssertString(struct["NetworkInterfaceId"]) end
	if struct["Attachment"] then M.AssertNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then M.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Description"] then M.AssertAttributeValue(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(DescribeNetworkInterfaceAttributeResult_keys[k], "DescribeNetworkInterfaceAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfaceAttributeResult
-- <p>Contains the output of DescribeNetworkInterfaceAttribute.</p>
-- @param SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled.</p>
-- @param NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param Attachment [NetworkInterfaceAttachment] <p>The attachment (if any) of the network interface.</p>
-- @param Groups [GroupIdentifierList] <p>The security groups associated with the network interface.</p>
-- @param Description [AttributeValue] <p>The description of the network interface.</p>
function M.DescribeNetworkInterfaceAttributeResult(SourceDestCheck, NetworkInterfaceId, Attachment, Groups, Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkInterfaceAttributeResult")
	local t = { 
		["SourceDestCheck"] = SourceDestCheck,
		["NetworkInterfaceId"] = NetworkInterfaceId,
		["Attachment"] = Attachment,
		["Groups"] = Groups,
		["Description"] = Description,
	}
	M.AssertDescribeNetworkInterfaceAttributeResult(t)
	return t
end

local ModifyInstancePlacementRequest_keys = { "InstanceId" = true, "Tenancy" = true, "HostId" = true, "Affinity" = true, nil }

function M.AssertModifyInstancePlacementRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstancePlacementRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then M.AssertString(struct["InstanceId"]) end
	if struct["Tenancy"] then M.AssertHostTenancy(struct["Tenancy"]) end
	if struct["HostId"] then M.AssertString(struct["HostId"]) end
	if struct["Affinity"] then M.AssertAffinity(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(ModifyInstancePlacementRequest_keys[k], "ModifyInstancePlacementRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstancePlacementRequest
-- <p>Contains the parameters for ModifyInstancePlacement.</p>
-- @param InstanceId [String] <p>The ID of the instance that you are modifying.</p>
-- @param Tenancy [HostTenancy] <p>The tenancy of the instance that you are modifying.</p>
-- @param HostId [String] <p>The ID of the Dedicated Host that the instance will have affinity with.</p>
-- @param Affinity [Affinity] <p>The new affinity setting for the instance.</p>
-- Required parameter: InstanceId
function M.ModifyInstancePlacementRequest(InstanceId, Tenancy, HostId, Affinity, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyInstancePlacementRequest")
	local t = { 
		["InstanceId"] = InstanceId,
		["Tenancy"] = Tenancy,
		["HostId"] = HostId,
		["Affinity"] = Affinity,
	}
	M.AssertModifyInstancePlacementRequest(t)
	return t
end

local SpotFleetRequestConfig_keys = { "SpotFleetRequestState" = true, "SpotFleetRequestId" = true, "ActivityStatus" = true, "CreateTime" = true, "SpotFleetRequestConfig" = true, nil }

function M.AssertSpotFleetRequestConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetRequestConfig to be of type 'table'")
	assert(struct["CreateTime"], "Expected key CreateTime to exist in table")
	assert(struct["SpotFleetRequestConfig"], "Expected key SpotFleetRequestConfig to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["SpotFleetRequestState"], "Expected key SpotFleetRequestState to exist in table")
	if struct["SpotFleetRequestState"] then M.AssertBatchState(struct["SpotFleetRequestState"]) end
	if struct["SpotFleetRequestId"] then M.AssertString(struct["SpotFleetRequestId"]) end
	if struct["ActivityStatus"] then M.AssertActivityStatus(struct["ActivityStatus"]) end
	if struct["CreateTime"] then M.AssertDateTime(struct["CreateTime"]) end
	if struct["SpotFleetRequestConfig"] then M.AssertSpotFleetRequestConfigData(struct["SpotFleetRequestConfig"]) end
	for k,_ in pairs(struct) do
		assert(SpotFleetRequestConfig_keys[k], "SpotFleetRequestConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetRequestConfig
-- <p>Describes a Spot fleet request.</p>
-- @param SpotFleetRequestState [BatchState] <p>The state of the Spot fleet request.</p>
-- @param SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param ActivityStatus [ActivityStatus] <p>The progress of the Spot fleet request. If there is an error, the status is <code>error</code>. After all bids are placed, the status is <code>pending_fulfillment</code>. If the size of the fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>. If the size of the fleet is decreased, the status is <code>pending_termination</code> while Spot instances are terminating.</p>
-- @param CreateTime [DateTime] <p>The creation date and time of the request.</p>
-- @param SpotFleetRequestConfig [SpotFleetRequestConfigData] <p>Information about the configuration of the Spot fleet request.</p>
-- Required parameter: CreateTime
-- Required parameter: SpotFleetRequestConfig
-- Required parameter: SpotFleetRequestId
-- Required parameter: SpotFleetRequestState
function M.SpotFleetRequestConfig(SpotFleetRequestState, SpotFleetRequestId, ActivityStatus, CreateTime, SpotFleetRequestConfig, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotFleetRequestConfig")
	local t = { 
		["SpotFleetRequestState"] = SpotFleetRequestState,
		["SpotFleetRequestId"] = SpotFleetRequestId,
		["ActivityStatus"] = ActivityStatus,
		["CreateTime"] = CreateTime,
		["SpotFleetRequestConfig"] = SpotFleetRequestConfig,
	}
	M.AssertSpotFleetRequestConfig(t)
	return t
end

local ExportToS3TaskSpecification_keys = { "S3Bucket" = true, "DiskImageFormat" = true, "S3Prefix" = true, "ContainerFormat" = true, nil }

function M.AssertExportToS3TaskSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportToS3TaskSpecification to be of type 'table'")
	if struct["S3Bucket"] then M.AssertString(struct["S3Bucket"]) end
	if struct["DiskImageFormat"] then M.AssertDiskImageFormat(struct["DiskImageFormat"]) end
	if struct["S3Prefix"] then M.AssertString(struct["S3Prefix"]) end
	if struct["ContainerFormat"] then M.AssertContainerFormat(struct["ContainerFormat"]) end
	for k,_ in pairs(struct) do
		assert(ExportToS3TaskSpecification_keys[k], "ExportToS3TaskSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportToS3TaskSpecification
-- <p>Describes an instance export task.</p>
-- @param S3Bucket [String] <p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>
-- @param DiskImageFormat [DiskImageFormat] <p>The format for the exported image.</p>
-- @param S3Prefix [String] <p>The image is written to a single object in the S3 bucket at the S3 key s3prefix + exportTaskId + '.' + diskImageFormat.</p>
-- @param ContainerFormat [ContainerFormat] <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>
function M.ExportToS3TaskSpecification(S3Bucket, DiskImageFormat, S3Prefix, ContainerFormat, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ExportToS3TaskSpecification")
	local t = { 
		["S3Bucket"] = S3Bucket,
		["DiskImageFormat"] = DiskImageFormat,
		["S3Prefix"] = S3Prefix,
		["ContainerFormat"] = ContainerFormat,
	}
	M.AssertExportToS3TaskSpecification(t)
	return t
end

local DescribeHostReservationOfferingsResult_keys = { "NextToken" = true, "OfferingSet" = true, nil }

function M.AssertDescribeHostReservationOfferingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationOfferingsResult to be of type 'table'")
	if struct["NextToken"] then M.AssertString(struct["NextToken"]) end
	if struct["OfferingSet"] then M.AssertHostOfferingSet(struct["OfferingSet"]) end
	for k,_ in pairs(struct) do
		assert(DescribeHostReservationOfferingsResult_keys[k], "DescribeHostReservationOfferingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationOfferingsResult
--  
-- @param NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param OfferingSet [HostOfferingSet] <p>Information about the offerings.</p>
function M.DescribeHostReservationOfferingsResult(NextToken, OfferingSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostReservationOfferingsResult")
	local t = { 
		["NextToken"] = NextToken,
		["OfferingSet"] = OfferingSet,
	}
	M.AssertDescribeHostReservationOfferingsResult(t)
	return t
end

local DescribeVpcAttributeRequest_keys = { "Attribute" = true, "VpcId" = true, "DryRun" = true, nil }

function M.AssertDescribeVpcAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["Attribute"] then M.AssertVpcAttributeName(struct["Attribute"]) end
	if struct["VpcId"] then M.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then M.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(DescribeVpcAttributeRequest_keys[k], "DescribeVpcAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcAttributeRequest
-- <p>Contains the parameters for DescribeVpcAttribute.</p>
-- @param Attribute [VpcAttributeName] <p>The VPC attribute.</p>
-- @param VpcId [String] <p>The ID of the VPC.</p>
-- @param DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: Attribute
-- Required parameter: VpcId
function M.DescribeVpcAttributeRequest(Attribute, VpcId, DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcAttributeRequest")
	local t = { 
		["Attribute"] = Attribute,
		["VpcId"] = VpcId,
		["DryRun"] = DryRun,
	}
	M.AssertDescribeVpcAttributeRequest(t)
	return t
end

function M.AssertEgressOnlyInternetGatewayId(str)
	assert(str)
	assert(type(str) == "string", "Expected EgressOnlyInternetGatewayId to be of type 'string'")
end

--  
function M.EgressOnlyInternetGatewayId(str)
	M.AssertEgressOnlyInternetGatewayId(str)
	return str
end

function M.AssertIpv6Address(str)
	assert(str)
	assert(type(str) == "string", "Expected Ipv6Address to be of type 'string'")
end

--  
function M.Ipv6Address(str)
	M.AssertIpv6Address(str)
	return str
end

function M.AssertVolumeModificationState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeModificationState to be of type 'string'")
end

--  
function M.VolumeModificationState(str)
	M.AssertVolumeModificationState(str)
	return str
end

function M.AssertVpnState(str)
	assert(str)
	assert(type(str) == "string", "Expected VpnState to be of type 'string'")
end

--  
function M.VpnState(str)
	M.AssertVpnState(str)
	return str
end

function M.AssertSubnetState(str)
	assert(str)
	assert(type(str) == "string", "Expected SubnetState to be of type 'string'")
end

--  
function M.SubnetState(str)
	M.AssertSubnetState(str)
	return str
end

function M.AssertOfferingTypeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected OfferingTypeValues to be of type 'string'")
end

--  
function M.OfferingTypeValues(str)
	M.AssertOfferingTypeValues(str)
	return str
end

function M.AssertState(str)
	assert(str)
	assert(type(str) == "string", "Expected State to be of type 'string'")
end

--  
function M.State(str)
	M.AssertState(str)
	return str
end

function M.AssertSpotInstanceState(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotInstanceState to be of type 'string'")
end

--  
function M.SpotInstanceState(str)
	M.AssertSpotInstanceState(str)
	return str
end

function M.AssertEventCode(str)
	assert(str)
	assert(type(str) == "string", "Expected EventCode to be of type 'string'")
end

--  
function M.EventCode(str)
	M.AssertEventCode(str)
	return str
end

function M.AssertMonitoringState(str)
	assert(str)
	assert(type(str) == "string", "Expected MonitoringState to be of type 'string'")
end

--  
function M.MonitoringState(str)
	M.AssertMonitoringState(str)
	return str
end

function M.AssertVpcState(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcState to be of type 'string'")
end

--  
function M.VpcState(str)
	M.AssertVpcState(str)
	return str
end

function M.AssertSubnetCidrBlockStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected SubnetCidrBlockStateCode to be of type 'string'")
end

--  
function M.SubnetCidrBlockStateCode(str)
	M.AssertSubnetCidrBlockStateCode(str)
	return str
end

function M.AssertRouteState(str)
	assert(str)
	assert(type(str) == "string", "Expected RouteState to be of type 'string'")
end

--  
function M.RouteState(str)
	M.AssertRouteState(str)
	return str
end

function M.AssertVpcCidrBlockStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcCidrBlockStateCode to be of type 'string'")
end

--  
function M.VpcCidrBlockStateCode(str)
	M.AssertVpcCidrBlockStateCode(str)
	return str
end

function M.AssertPlacementGroupState(str)
	assert(str)
	assert(type(str) == "string", "Expected PlacementGroupState to be of type 'string'")
end

--  
function M.PlacementGroupState(str)
	M.AssertPlacementGroupState(str)
	return str
end

function M.AssertPlatformValues(str)
	assert(str)
	assert(type(str) == "string", "Expected PlatformValues to be of type 'string'")
end

--  
function M.PlatformValues(str)
	M.AssertPlatformValues(str)
	return str
end

function M.AssertStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected Status to be of type 'string'")
end

--  
function M.Status(str)
	M.AssertStatus(str)
	return str
end

function M.AssertEventType(str)
	assert(str)
	assert(type(str) == "string", "Expected EventType to be of type 'string'")
end

--  
function M.EventType(str)
	M.AssertEventType(str)
	return str
end

function M.AssertNetworkInterfaceType(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceType to be of type 'string'")
end

--  
function M.NetworkInterfaceType(str)
	M.AssertNetworkInterfaceType(str)
	return str
end

function M.AssertVolumeState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeState to be of type 'string'")
end

--  
function M.VolumeState(str)
	M.AssertVolumeState(str)
	return str
end

function M.Assertscope(str)
	assert(str)
	assert(type(str) == "string", "Expected scope to be of type 'string'")
end

--  
function M.scope(str)
	M.Assertscope(str)
	return str
end

function M.AssertReportStatusType(str)
	assert(str)
	assert(type(str) == "string", "Expected ReportStatusType to be of type 'string'")
end

--  
function M.ReportStatusType(str)
	M.AssertReportStatusType(str)
	return str
end

function M.AssertInstanceLifecycleType(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceLifecycleType to be of type 'string'")
end

--  
function M.InstanceLifecycleType(str)
	M.AssertInstanceLifecycleType(str)
	return str
end

function M.AssertSpotInstanceType(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotInstanceType to be of type 'string'")
end

--  
function M.SpotInstanceType(str)
	M.AssertSpotInstanceType(str)
	return str
end

function M.AssertReservedInstanceState(str)
	assert(str)
	assert(type(str) == "string", "Expected ReservedInstanceState to be of type 'string'")
end

--  
function M.ReservedInstanceState(str)
	M.AssertReservedInstanceState(str)
	return str
end

function M.AssertPlacementStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected PlacementStrategy to be of type 'string'")
end

--  
function M.PlacementStrategy(str)
	M.AssertPlacementStrategy(str)
	return str
end

function M.AssertNextToken(str)
	assert(str)
	assert(type(str) == "string", "Expected NextToken to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.NextToken(str)
	M.AssertNextToken(str)
	return str
end

function M.AssertVpcPeeringConnectionStateReasonCode(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcPeeringConnectionStateReasonCode to be of type 'string'")
end

--  
function M.VpcPeeringConnectionStateReasonCode(str)
	M.AssertVpcPeeringConnectionStateReasonCode(str)
	return str
end

function M.AssertSnapshotState(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotState to be of type 'string'")
end

--  
function M.SnapshotState(str)
	M.AssertSnapshotState(str)
	return str
end

function M.AssertFleetType(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetType to be of type 'string'")
end

--  
function M.FleetType(str)
	M.AssertFleetType(str)
	return str
end

function M.AssertString(str)
	assert(str)
	assert(type(str) == "string", "Expected String to be of type 'string'")
end

--  
function M.String(str)
	M.AssertString(str)
	return str
end

function M.AssertListingStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ListingStatus to be of type 'string'")
end

--  
function M.ListingStatus(str)
	M.AssertListingStatus(str)
	return str
end

function M.AssertSnapshotAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotAttributeName to be of type 'string'")
end

--  
function M.SnapshotAttributeName(str)
	M.AssertSnapshotAttributeName(str)
	return str
end

function M.AssertInstanceHealthStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceHealthStatus to be of type 'string'")
end

--  
function M.InstanceHealthStatus(str)
	M.AssertInstanceHealthStatus(str)
	return str
end

function M.AssertNetworkInterfaceAttribute(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceAttribute to be of type 'string'")
end

--  
function M.NetworkInterfaceAttribute(str)
	M.AssertNetworkInterfaceAttribute(str)
	return str
end

function M.AssertVirtualizationType(str)
	assert(str)
	assert(type(str) == "string", "Expected VirtualizationType to be of type 'string'")
end

--  
function M.VirtualizationType(str)
	M.AssertVirtualizationType(str)
	return str
end

function M.AssertVolumeAttachmentState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeAttachmentState to be of type 'string'")
end

--  
function M.VolumeAttachmentState(str)
	M.AssertVolumeAttachmentState(str)
	return str
end

function M.AssertInstanceType(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceType to be of type 'string'")
end

--  
function M.InstanceType(str)
	M.AssertInstanceType(str)
	return str
end

function M.AssertShutdownBehavior(str)
	assert(str)
	assert(type(str) == "string", "Expected ShutdownBehavior to be of type 'string'")
end

--  
function M.ShutdownBehavior(str)
	M.AssertShutdownBehavior(str)
	return str
end

function M.AssertInstanceAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceAttributeName to be of type 'string'")
end

--  
function M.InstanceAttributeName(str)
	M.AssertInstanceAttributeName(str)
	return str
end

function M.AssertActivityStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ActivityStatus to be of type 'string'")
end

--  
function M.ActivityStatus(str)
	M.AssertActivityStatus(str)
	return str
end

function M.AssertPaymentOption(str)
	assert(str)
	assert(type(str) == "string", "Expected PaymentOption to be of type 'string'")
end

--  
function M.PaymentOption(str)
	M.AssertPaymentOption(str)
	return str
end

function M.AssertVolumeType(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeType to be of type 'string'")
end

--  
function M.VolumeType(str)
	M.AssertVolumeType(str)
	return str
end

function M.AssertCancelBatchErrorCode(str)
	assert(str)
	assert(type(str) == "string", "Expected CancelBatchErrorCode to be of type 'string'")
end

--  
function M.CancelBatchErrorCode(str)
	M.AssertCancelBatchErrorCode(str)
	return str
end

function M.AssertImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageAttributeName to be of type 'string'")
end

--  
function M.ImageAttributeName(str)
	M.AssertImageAttributeName(str)
	return str
end

function M.AssertBundleTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected BundleTaskState to be of type 'string'")
end

--  
function M.BundleTaskState(str)
	M.AssertBundleTaskState(str)
	return str
end

function M.AssertAvailabilityZoneState(str)
	assert(str)
	assert(type(str) == "string", "Expected AvailabilityZoneState to be of type 'string'")
end

--  
function M.AvailabilityZoneState(str)
	M.AssertAvailabilityZoneState(str)
	return str
end

function M.AssertHostTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected HostTenancy to be of type 'string'")
end

--  
function M.HostTenancy(str)
	M.AssertHostTenancy(str)
	return str
end

function M.AssertDomainType(str)
	assert(str)
	assert(type(str) == "string", "Expected DomainType to be of type 'string'")
end

--  
function M.DomainType(str)
	M.AssertDomainType(str)
	return str
end

function M.AssertCancelSpotInstanceRequestState(str)
	assert(str)
	assert(type(str) == "string", "Expected CancelSpotInstanceRequestState to be of type 'string'")
end

--  
function M.CancelSpotInstanceRequestState(str)
	M.AssertCancelSpotInstanceRequestState(str)
	return str
end

function M.AssertArchitectureValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ArchitectureValues to be of type 'string'")
end

--  
function M.ArchitectureValues(str)
	M.AssertArchitectureValues(str)
	return str
end

function M.AssertAllocationState(str)
	assert(str)
	assert(type(str) == "string", "Expected AllocationState to be of type 'string'")
end

--  
function M.AllocationState(str)
	M.AssertAllocationState(str)
	return str
end

function M.AssertIamInstanceProfileAssociationState(str)
	assert(str)
	assert(type(str) == "string", "Expected IamInstanceProfileAssociationState to be of type 'string'")
end

--  
function M.IamInstanceProfileAssociationState(str)
	M.AssertIamInstanceProfileAssociationState(str)
	return str
end

function M.AssertResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceType to be of type 'string'")
end

--  
function M.ResourceType(str)
	M.AssertResourceType(str)
	return str
end

function M.AssertRouteOrigin(str)
	assert(str)
	assert(type(str) == "string", "Expected RouteOrigin to be of type 'string'")
end

--  
function M.RouteOrigin(str)
	M.AssertRouteOrigin(str)
	return str
end

function M.AssertOfferingClassType(str)
	assert(str)
	assert(type(str) == "string", "Expected OfferingClassType to be of type 'string'")
end

--  
function M.OfferingClassType(str)
	M.AssertOfferingClassType(str)
	return str
end

function M.AssertSummaryStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected SummaryStatus to be of type 'string'")
end

--  
function M.SummaryStatus(str)
	M.AssertSummaryStatus(str)
	return str
end

function M.AssertExcessCapacityTerminationPolicy(str)
	assert(str)
	assert(type(str) == "string", "Expected ExcessCapacityTerminationPolicy to be of type 'string'")
end

--  
function M.ExcessCapacityTerminationPolicy(str)
	M.AssertExcessCapacityTerminationPolicy(str)
	return str
end

function M.AssertAccountAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected AccountAttributeName to be of type 'string'")
end

--  
function M.AccountAttributeName(str)
	M.AssertAccountAttributeName(str)
	return str
end

function M.AssertMoveStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected MoveStatus to be of type 'string'")
end

--  
function M.MoveStatus(str)
	M.AssertMoveStatus(str)
	return str
end

function M.AssertVpcAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcAttributeName to be of type 'string'")
end

--  
function M.VpcAttributeName(str)
	M.AssertVpcAttributeName(str)
	return str
end

function M.AssertTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected Tenancy to be of type 'string'")
end

--  
function M.Tenancy(str)
	M.AssertTenancy(str)
	return str
end

function M.AssertVolumeStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeStatusName to be of type 'string'")
end

--  
function M.VolumeStatusName(str)
	M.AssertVolumeStatusName(str)
	return str
end

function M.AssertVolumeStatusInfoStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeStatusInfoStatus to be of type 'string'")
end

--  
function M.VolumeStatusInfoStatus(str)
	M.AssertVolumeStatusInfoStatus(str)
	return str
end

function M.AssertDeviceType(str)
	assert(str)
	assert(type(str) == "string", "Expected DeviceType to be of type 'string'")
end

--  
function M.DeviceType(str)
	M.AssertDeviceType(str)
	return str
end

function M.AssertOperationType(str)
	assert(str)
	assert(type(str) == "string", "Expected OperationType to be of type 'string'")
end

--  
function M.OperationType(str)
	M.AssertOperationType(str)
	return str
end

function M.AssertResetImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ResetImageAttributeName to be of type 'string'")
end

--  
function M.ResetImageAttributeName(str)
	M.AssertResetImageAttributeName(str)
	return str
end

function M.AssertInstanceStateName(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceStateName to be of type 'string'")
end

--  
function M.InstanceStateName(str)
	M.AssertInstanceStateName(str)
	return str
end

function M.AssertDiskImageFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected DiskImageFormat to be of type 'string'")
end

--  
function M.DiskImageFormat(str)
	M.AssertDiskImageFormat(str)
	return str
end

function M.AssertBatchState(str)
	assert(str)
	assert(type(str) == "string", "Expected BatchState to be of type 'string'")
end

--  
function M.BatchState(str)
	M.AssertBatchState(str)
	return str
end

function M.AssertProductCodeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ProductCodeValues to be of type 'string'")
end

--  
function M.ProductCodeValues(str)
	M.AssertProductCodeValues(str)
	return str
end

function M.AssertRuleAction(str)
	assert(str)
	assert(type(str) == "string", "Expected RuleAction to be of type 'string'")
end

--  
function M.RuleAction(str)
	M.AssertRuleAction(str)
	return str
end

function M.AssertHypervisorType(str)
	assert(str)
	assert(type(str) == "string", "Expected HypervisorType to be of type 'string'")
end

--  
function M.HypervisorType(str)
	M.AssertHypervisorType(str)
	return str
end

function M.AssertGatewayType(str)
	assert(str)
	assert(type(str) == "string", "Expected GatewayType to be of type 'string'")
end

--  
function M.GatewayType(str)
	M.AssertGatewayType(str)
	return str
end

function M.AssertCurrencyCodeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected CurrencyCodeValues to be of type 'string'")
end

--  
function M.CurrencyCodeValues(str)
	M.AssertCurrencyCodeValues(str)
	return str
end

function M.AssertStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusName to be of type 'string'")
end

--  
function M.StatusName(str)
	M.AssertStatusName(str)
	return str
end

function M.AssertReservationState(str)
	assert(str)
	assert(type(str) == "string", "Expected ReservationState to be of type 'string'")
end

--  
function M.ReservationState(str)
	M.AssertReservationState(str)
	return str
end

function M.AssertStatusType(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusType to be of type 'string'")
end

--  
function M.StatusType(str)
	M.AssertStatusType(str)
	return str
end

function M.AssertVpnStaticRouteSource(str)
	assert(str)
	assert(type(str) == "string", "Expected VpnStaticRouteSource to be of type 'string'")
end

--  
function M.VpnStaticRouteSource(str)
	M.AssertVpnStaticRouteSource(str)
	return str
end

function M.AssertAllocationStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected AllocationStrategy to be of type 'string'")
end

--  
function M.AllocationStrategy(str)
	M.AssertAllocationStrategy(str)
	return str
end

function M.AssertExportEnvironment(str)
	assert(str)
	assert(type(str) == "string", "Expected ExportEnvironment to be of type 'string'")
end

--  
function M.ExportEnvironment(str)
	M.AssertExportEnvironment(str)
	return str
end

function M.AssertTelemetryStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected TelemetryStatus to be of type 'string'")
end

--  
function M.TelemetryStatus(str)
	M.AssertTelemetryStatus(str)
	return str
end

function M.AssertAttachmentStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected AttachmentStatus to be of type 'string'")
end

--  
function M.AttachmentStatus(str)
	M.AssertAttachmentStatus(str)
	return str
end

function M.AssertRecurringChargeFrequency(str)
	assert(str)
	assert(type(str) == "string", "Expected RecurringChargeFrequency to be of type 'string'")
end

--  
function M.RecurringChargeFrequency(str)
	M.AssertRecurringChargeFrequency(str)
	return str
end

function M.AssertDatafeedSubscriptionState(str)
	assert(str)
	assert(type(str) == "string", "Expected DatafeedSubscriptionState to be of type 'string'")
end

--  
function M.DatafeedSubscriptionState(str)
	M.AssertDatafeedSubscriptionState(str)
	return str
end

function M.AssertVolumeAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeAttributeName to be of type 'string'")
end

--  
function M.VolumeAttributeName(str)
	M.AssertVolumeAttributeName(str)
	return str
end

function M.AssertTrafficType(str)
	assert(str)
	assert(type(str) == "string", "Expected TrafficType to be of type 'string'")
end

--  
function M.TrafficType(str)
	M.AssertTrafficType(str)
	return str
end

function M.AssertContainerFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected ContainerFormat to be of type 'string'")
end

--  
function M.ContainerFormat(str)
	M.AssertContainerFormat(str)
	return str
end

function M.AssertListingState(str)
	assert(str)
	assert(type(str) == "string", "Expected ListingState to be of type 'string'")
end

--  
function M.ListingState(str)
	M.AssertListingState(str)
	return str
end

function M.AssertImageState(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageState to be of type 'string'")
end

--  
function M.ImageState(str)
	M.AssertImageState(str)
	return str
end

function M.AssertImageTypeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageTypeValues to be of type 'string'")
end

--  
function M.ImageTypeValues(str)
	M.AssertImageTypeValues(str)
	return str
end

function M.AssertNatGatewayState(str)
	assert(str)
	assert(type(str) == "string", "Expected NatGatewayState to be of type 'string'")
end

--  
function M.NatGatewayState(str)
	M.AssertNatGatewayState(str)
	return str
end

function M.AssertRIProductDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected RIProductDescription to be of type 'string'")
end

--  
function M.RIProductDescription(str)
	M.AssertRIProductDescription(str)
	return str
end

function M.AssertNetworkInterfaceStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceStatus to be of type 'string'")
end

--  
function M.NetworkInterfaceStatus(str)
	M.AssertNetworkInterfaceStatus(str)
	return str
end

function M.AssertAffinity(str)
	assert(str)
	assert(type(str) == "string", "Expected Affinity to be of type 'string'")
end

--  
function M.Affinity(str)
	M.AssertAffinity(str)
	return str
end

function M.AssertFlowLogsResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected FlowLogsResourceType to be of type 'string'")
end

--  
function M.FlowLogsResourceType(str)
	M.AssertFlowLogsResourceType(str)
	return str
end

function M.AssertPermissionGroup(str)
	assert(str)
	assert(type(str) == "string", "Expected PermissionGroup to be of type 'string'")
end

--  
function M.PermissionGroup(str)
	M.AssertPermissionGroup(str)
	return str
end

function M.AssertExportTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected ExportTaskState to be of type 'string'")
end

--  
function M.ExportTaskState(str)
	M.AssertExportTaskState(str)
	return str
end

function M.AssertFpgaImageStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected FpgaImageStateCode to be of type 'string'")
end

--  
function M.FpgaImageStateCode(str)
	M.AssertFpgaImageStateCode(str)
	return str
end

function M.AssertReportInstanceReasonCodes(str)
	assert(str)
	assert(type(str) == "string", "Expected ReportInstanceReasonCodes to be of type 'string'")
end

--  
function M.ReportInstanceReasonCodes(str)
	M.AssertReportInstanceReasonCodes(str)
	return str
end

function M.AssertConversionTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected ConversionTaskState to be of type 'string'")
end

--  
function M.ConversionTaskState(str)
	M.AssertConversionTaskState(str)
	return str
end

function M.AssertAutoPlacement(str)
	assert(str)
	assert(type(str) == "string", "Expected AutoPlacement to be of type 'string'")
end

--  
function M.AutoPlacement(str)
	M.AssertAutoPlacement(str)
	return str
end

function M.AssertFloat(float)
	assert(float)
	assert(type(float) == "number", "Expected Float to be of type 'number'")
end

function M.Float(float)
	M.AssertFloat(float)
	return float
end

function M.AssertDouble(double)
	assert(double)
	assert(type(double) == "number", "Expected Double to be of type 'number'")
end

function M.Double(double)
	M.AssertDouble(double)
	return double
end

function M.AssertLong(long)
	assert(long)
	assert(type(long) == "number", "Expected Long to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.Long(long)
	M.AssertLong(long)
	return long
end

function M.AssertInteger(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected Integer to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.Integer(integer)
	M.AssertInteger(integer)
	return integer
end

function M.AssertMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 255, "Expected integer to be max 255")
	assert(integer >= 5, "Expected integer to be min 5")
end

function M.MaxResults(integer)
	M.AssertMaxResults(integer)
	return integer
end

function M.AssertBoolean(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Boolean to be of type 'boolean'")
end

function M.Boolean(boolean)
	M.AssertBoolean(boolean)
	return boolean
end

function M.AssertDateTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected DateTime to be of type 'string'")
end

function M.DateTime(timestamp)
	M.AssertDateTime(timestamp)
	return timestamp
end

function M.AssertBlob(blob)
	assert(blob)
	assert(type(string) == "string", "Expected Blob to be of type 'string'")
end

function M.Blob(blob)
	M.AssertBlob(blob)
	return blob
end

function M.AssertOccurrenceDaySet(list)
	assert(list)
	assert(type(list) == "table", "Expected OccurrenceDaySet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInteger(v)
	end
end

--  
-- List of Integer objects
function M.OccurrenceDaySet(list)
	M.AssertOccurrenceDaySet(list)
	return list
end

function M.AssertInstanceStatusEventList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusEventList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceStatusEvent(v)
	end
end

--  
-- List of InstanceStatusEvent objects
function M.InstanceStatusEventList(list)
	M.AssertInstanceStatusEventList(list)
	return list
end

function M.AssertInstanceStatusDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceStatusDetails(v)
	end
end

--  
-- List of InstanceStatusDetails objects
function M.InstanceStatusDetailsList(list)
	M.AssertInstanceStatusDetailsList(list)
	return list
end

function M.AssertAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected AddressList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertAddress(v)
	end
end

--  
-- List of Address objects
function M.AddressList(list)
	M.AssertAddressList(list)
	return list
end

function M.AssertResponseHostIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ResponseHostIdSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResponseHostIdSet(list)
	M.AssertResponseHostIdSet(list)
	return list
end

function M.AssertReservedInstancesModificationResultList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationResultList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReservedInstancesModificationResult(v)
	end
end

--  
-- List of ReservedInstancesModificationResult objects
function M.ReservedInstancesModificationResultList(list)
	M.AssertReservedInstancesModificationResultList(list)
	return list
end

function M.AssertPriceScheduleList(list)
	assert(list)
	assert(type(list) == "table", "Expected PriceScheduleList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertPriceSchedule(v)
	end
end

--  
-- List of PriceSchedule objects
function M.PriceScheduleList(list)
	M.AssertPriceScheduleList(list)
	return list
end

function M.AssertStaleSecurityGroupSet(list)
	assert(list)
	assert(type(list) == "table", "Expected StaleSecurityGroupSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertStaleSecurityGroup(v)
	end
end

--  
-- List of StaleSecurityGroup objects
function M.StaleSecurityGroupSet(list)
	M.AssertStaleSecurityGroupSet(list)
	return list
end

function M.AssertCustomerGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected CustomerGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertCustomerGateway(v)
	end
end

--  
-- List of CustomerGateway objects
function M.CustomerGatewayList(list)
	M.AssertCustomerGatewayList(list)
	return list
end

function M.AssertUserIdGroupPairSet(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdGroupPairSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertUserIdGroupPair(v)
	end
end

--  
-- List of UserIdGroupPair objects
function M.UserIdGroupPairSet(list)
	M.AssertUserIdGroupPairSet(list)
	return list
end

function M.AssertUnsuccessfulItemSet(list)
	assert(list)
	assert(type(list) == "table", "Expected UnsuccessfulItemSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertUnsuccessfulItem(v)
	end
end

--  
-- List of UnsuccessfulItem objects
function M.UnsuccessfulItemSet(list)
	M.AssertUnsuccessfulItemSet(list)
	return list
end

function M.AssertRouteList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertRoute(v)
	end
end

--  
-- List of Route objects
function M.RouteList(list)
	M.AssertRouteList(list)
	return list
end

function M.AssertGroupIds(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIds to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupIds(list)
	M.AssertGroupIds(list)
	return list
end

function M.AssertSubnetIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.SubnetIdStringList(list)
	M.AssertSubnetIdStringList(list)
	return list
end

function M.AssertTagSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertTagSpecification(v)
	end
end

--  
-- List of TagSpecification objects
function M.TagSpecificationList(list)
	M.AssertTagSpecificationList(list)
	return list
end

function M.AssertSubnetList(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertSubnet(v)
	end
end

--  
-- List of Subnet objects
function M.SubnetList(list)
	M.AssertSubnetList(list)
	return list
end

function M.AssertNetworkInterfaceList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertNetworkInterface(v)
	end
end

--  
-- List of NetworkInterface objects
function M.NetworkInterfaceList(list)
	M.AssertNetworkInterfaceList(list)
	return list
end

function M.AssertIpv6RangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6RangeList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertIpv6Range(v)
	end
end

--  
-- List of Ipv6Range objects
function M.Ipv6RangeList(list)
	M.AssertIpv6RangeList(list)
	return list
end

function M.AssertPurchaseSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchaseSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertPurchase(v)
	end
end

--  
-- List of Purchase objects
function M.PurchaseSet(list)
	M.AssertPurchaseSet(list)
	return list
end

function M.AssertImportInstanceVolumeDetailSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportInstanceVolumeDetailSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertImportInstanceVolumeDetailItem(v)
	end
end

--  
-- List of ImportInstanceVolumeDetailItem objects
function M.ImportInstanceVolumeDetailSet(list)
	M.AssertImportInstanceVolumeDetailSet(list)
	return list
end

function M.AssertPlacementGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected PlacementGroupList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertPlacementGroup(v)
	end
end

--  
-- List of PlacementGroup objects
function M.PlacementGroupList(list)
	M.AssertPlacementGroupList(list)
	return list
end

function M.AssertVpcAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVpcAttachment(v)
	end
end

--  
-- List of VpcAttachment objects
function M.VpcAttachmentList(list)
	M.AssertVpcAttachmentList(list)
	return list
end

function M.AssertDiskImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected DiskImageList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertDiskImage(v)
	end
end

--  
-- List of DiskImage objects
function M.DiskImageList(list)
	M.AssertDiskImageList(list)
	return list
end

function M.AssertReservedInstancesModificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReservedInstancesModification(v)
	end
end

--  
-- List of ReservedInstancesModification objects
function M.ReservedInstancesModificationList(list)
	M.AssertReservedInstancesModificationList(list)
	return list
end

function M.AssertSecurityGroupIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.SecurityGroupIdStringList(list)
	M.AssertSecurityGroupIdStringList(list)
	return list
end

function M.AssertRestorableByStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected RestorableByStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.RestorableByStringList(list)
	M.AssertRestorableByStringList(list)
	return list
end

function M.AssertNatGatewayAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected NatGatewayAddressList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertNatGatewayAddress(v)
	end
end

--  
-- List of NatGatewayAddress objects
function M.NatGatewayAddressList(list)
	M.AssertNatGatewayAddressList(list)
	return list
end

function M.AssertCancelSpotFleetRequestsErrorSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelSpotFleetRequestsErrorSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertCancelSpotFleetRequestsErrorItem(v)
	end
end

--  
-- List of CancelSpotFleetRequestsErrorItem objects
function M.CancelSpotFleetRequestsErrorSet(list)
	M.AssertCancelSpotFleetRequestsErrorSet(list)
	return list
end

function M.AssertInstanceIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIpv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceIpv6Address(v)
	end
end

--  
-- List of InstanceIpv6Address objects
function M.InstanceIpv6AddressList(list)
	M.AssertInstanceIpv6AddressList(list)
	return list
end

function M.AssertPropagatingVgwList(list)
	assert(list)
	assert(type(list) == "table", "Expected PropagatingVgwList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertPropagatingVgw(v)
	end
end

--  
-- List of PropagatingVgw objects
function M.PropagatingVgwList(list)
	M.AssertPropagatingVgwList(list)
	return list
end

function M.AssertValueStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ValueStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ValueStringList(list)
	M.AssertValueStringList(list)
	return list
end

function M.AssertBlockDeviceMappingRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected BlockDeviceMappingRequestList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertBlockDeviceMapping(v)
	end
end

--  
-- List of BlockDeviceMapping objects
function M.BlockDeviceMappingRequestList(list)
	M.AssertBlockDeviceMappingRequestList(list)
	return list
end

function M.AssertNewDhcpConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected NewDhcpConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertNewDhcpConfiguration(v)
	end
end

--  
-- List of NewDhcpConfiguration objects
function M.NewDhcpConfigurationList(list)
	M.AssertNewDhcpConfigurationList(list)
	return list
end

function M.AssertVolumeStatusActionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusActionsList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVolumeStatusAction(v)
	end
end

--  
-- List of VolumeStatusAction objects
function M.VolumeStatusActionsList(list)
	M.AssertVolumeStatusActionsList(list)
	return list
end

function M.AssertInternetGatewayAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected InternetGatewayAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInternetGatewayAttachment(v)
	end
end

--  
-- List of InternetGatewayAttachment objects
function M.InternetGatewayAttachmentList(list)
	M.AssertInternetGatewayAttachmentList(list)
	return list
end

function M.AssertInstancePrivateIpAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstancePrivateIpAddressList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstancePrivateIpAddress(v)
	end
end

--  
-- List of InstancePrivateIpAddress objects
function M.InstancePrivateIpAddressList(list)
	M.AssertInstancePrivateIpAddressList(list)
	return list
end

function M.AssertFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected FilterList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertFilter(v)
	end
end

--  
-- List of Filter objects
function M.FilterList(list)
	M.AssertFilterList(list)
	return list
end

function M.AssertInstanceMonitoringList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceMonitoringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceMonitoring(v)
	end
end

--  
-- List of InstanceMonitoring objects
function M.InstanceMonitoringList(list)
	M.AssertInstanceMonitoringList(list)
	return list
end

function M.AssertUnsuccessfulItemList(list)
	assert(list)
	assert(type(list) == "table", "Expected UnsuccessfulItemList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertUnsuccessfulItem(v)
	end
end

--  
-- List of UnsuccessfulItem objects
function M.UnsuccessfulItemList(list)
	M.AssertUnsuccessfulItemList(list)
	return list
end

function M.AssertImportSnapshotTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportSnapshotTaskList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertImportSnapshotTask(v)
	end
end

--  
-- List of ImportSnapshotTask objects
function M.ImportSnapshotTaskList(list)
	M.AssertImportSnapshotTaskList(list)
	return list
end

function M.AssertPurchaseRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchaseRequestSet to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		M.AssertPurchaseRequest(v)
	end
end

--  
-- List of PurchaseRequest objects
function M.PurchaseRequestSet(list)
	M.AssertPurchaseRequestSet(list)
	return list
end

function M.AssertScheduledInstancesBlockDeviceMappingSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesBlockDeviceMappingSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertScheduledInstancesBlockDeviceMapping(v)
	end
end

--  
-- List of ScheduledInstancesBlockDeviceMapping objects
function M.ScheduledInstancesBlockDeviceMappingSet(list)
	M.AssertScheduledInstancesBlockDeviceMappingSet(list)
	return list
end

function M.AssertVpnGatewayIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnGatewayIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpnGatewayIdStringList(list)
	M.AssertVpnGatewayIdStringList(list)
	return list
end

function M.AssertSubnetIpv6CidrBlockAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetIpv6CidrBlockAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertSubnetIpv6CidrBlockAssociation(v)
	end
end

--  
-- List of SubnetIpv6CidrBlockAssociation objects
function M.SubnetIpv6CidrBlockAssociationSet(list)
	M.AssertSubnetIpv6CidrBlockAssociationSet(list)
	return list
end

function M.AssertOwnerStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected OwnerStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.OwnerStringList(list)
	M.AssertOwnerStringList(list)
	return list
end

function M.AssertEgressOnlyInternetGatewayIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected EgressOnlyInternetGatewayIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertEgressOnlyInternetGatewayId(v)
	end
end

--  
-- List of EgressOnlyInternetGatewayId objects
function M.EgressOnlyInternetGatewayIdList(list)
	M.AssertEgressOnlyInternetGatewayIdList(list)
	return list
end

function M.AssertScheduledInstanceIdRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceIdRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ScheduledInstanceIdRequestSet(list)
	M.AssertScheduledInstanceIdRequestSet(list)
	return list
end

function M.AssertInstanceCountList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceCountList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceCount(v)
	end
end

--  
-- List of InstanceCount objects
function M.InstanceCountList(list)
	M.AssertInstanceCountList(list)
	return list
end

function M.AssertImportTaskIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportTaskIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ImportTaskIdList(list)
	M.AssertImportTaskIdList(list)
	return list
end

function M.AssertZoneNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ZoneNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ZoneNameStringList(list)
	M.AssertZoneNameStringList(list)
	return list
end

function M.AssertGroupIdentifierList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIdentifierList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertGroupIdentifier(v)
	end
end

--  
-- List of GroupIdentifier objects
function M.GroupIdentifierList(list)
	M.AssertGroupIdentifierList(list)
	return list
end

function M.AssertBillingProductList(list)
	assert(list)
	assert(type(list) == "table", "Expected BillingProductList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.BillingProductList(list)
	M.AssertBillingProductList(list)
	return list
end

function M.AssertSecurityGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.SecurityGroupStringList(list)
	M.AssertSecurityGroupStringList(list)
	return list
end

function M.AssertLaunchSpecsList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchSpecsList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		M.AssertSpotFleetLaunchSpecification(v)
	end
end

--  
-- List of SpotFleetLaunchSpecification objects
function M.LaunchSpecsList(list)
	M.AssertLaunchSpecsList(list)
	return list
end

function M.AssertSpotInstanceRequestIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotInstanceRequestIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.SpotInstanceRequestIdList(list)
	M.AssertSpotInstanceRequestIdList(list)
	return list
end

function M.AssertVpcEndpointSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcEndpointSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVpcEndpoint(v)
	end
end

--  
-- List of VpcEndpoint objects
function M.VpcEndpointSet(list)
	M.AssertVpcEndpointSet(list)
	return list
end

function M.AssertCancelledSpotInstanceRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelledSpotInstanceRequestList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertCancelledSpotInstanceRequest(v)
	end
end

--  
-- List of CancelledSpotInstanceRequest objects
function M.CancelledSpotInstanceRequestList(list)
	M.AssertCancelledSpotInstanceRequestList(list)
	return list
end

function M.AssertDhcpOptionsIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpOptionsIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.DhcpOptionsIdStringList(list)
	M.AssertDhcpOptionsIdStringList(list)
	return list
end

function M.AssertTagDescriptionList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagDescriptionList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertTagDescription(v)
	end
end

--  
-- List of TagDescription objects
function M.TagDescriptionList(list)
	M.AssertTagDescriptionList(list)
	return list
end

function M.AssertIpRangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected IpRangeList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertIpRange(v)
	end
end

--  
-- List of IpRange objects
function M.IpRangeList(list)
	M.AssertIpRangeList(list)
	return list
end

function M.AssertImageDiskContainerList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageDiskContainerList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertImageDiskContainer(v)
	end
end

--  
-- List of ImageDiskContainer objects
function M.ImageDiskContainerList(list)
	M.AssertImageDiskContainerList(list)
	return list
end

function M.AssertNetworkInterfacePrivateIpAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfacePrivateIpAddressList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertNetworkInterfacePrivateIpAddress(v)
	end
end

--  
-- List of NetworkInterfacePrivateIpAddress objects
function M.NetworkInterfacePrivateIpAddressList(list)
	M.AssertNetworkInterfacePrivateIpAddressList(list)
	return list
end

function M.AssertHostReservationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostReservationSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertHostReservation(v)
	end
end

--  
-- List of HostReservation objects
function M.HostReservationSet(list)
	M.AssertHostReservationSet(list)
	return list
end

function M.AssertNetworkAclEntryList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclEntryList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertNetworkAclEntry(v)
	end
end

--  
-- List of NetworkAclEntry objects
function M.NetworkAclEntryList(list)
	M.AssertNetworkAclEntryList(list)
	return list
end

function M.AssertRequestHostIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected RequestHostIdSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.RequestHostIdSet(list)
	M.AssertRequestHostIdSet(list)
	return list
end

function M.AssertReservedInstancesOfferingList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesOfferingList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReservedInstancesOffering(v)
	end
end

--  
-- List of ReservedInstancesOffering objects
function M.ReservedInstancesOfferingList(list)
	M.AssertReservedInstancesOfferingList(list)
	return list
end

function M.AssertIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.Ipv6AddressList(list)
	M.AssertIpv6AddressList(list)
	return list
end

function M.AssertInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstance(v)
	end
end

--  
-- List of Instance objects
function M.InstanceList(list)
	M.AssertInstanceList(list)
	return list
end

function M.AssertVpcClassicLinkIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcClassicLinkIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpcClassicLinkIdList(list)
	M.AssertVpcClassicLinkIdList(list)
	return list
end

function M.AssertVolumeIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.VolumeIdStringList(list)
	M.AssertVolumeIdStringList(list)
	return list
end

function M.AssertInstanceBlockDeviceMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceBlockDeviceMappingList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceBlockDeviceMapping(v)
	end
end

--  
-- List of InstanceBlockDeviceMapping objects
function M.InstanceBlockDeviceMappingList(list)
	M.AssertInstanceBlockDeviceMappingList(list)
	return list
end

function M.AssertVpnConnectionIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnConnectionIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpnConnectionIdStringList(list)
	M.AssertVpnConnectionIdStringList(list)
	return list
end

function M.AssertUserGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.UserGroupStringList(list)
	M.AssertUserGroupStringList(list)
	return list
end

function M.AssertExportTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExportTaskList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertExportTask(v)
	end
end

--  
-- List of ExportTask objects
function M.ExportTaskList(list)
	M.AssertExportTaskList(list)
	return list
end

function M.AssertVolumeList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVolume(v)
	end
end

--  
-- List of Volume objects
function M.VolumeList(list)
	M.AssertVolumeList(list)
	return list
end

function M.AssertRegionList(list)
	assert(list)
	assert(type(list) == "table", "Expected RegionList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertRegion(v)
	end
end

--  
-- List of Region objects
function M.RegionList(list)
	M.AssertRegionList(list)
	return list
end

function M.AssertVolumeModificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeModificationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVolumeModification(v)
	end
end

--  
-- List of VolumeModification objects
function M.VolumeModificationList(list)
	M.AssertVolumeModificationList(list)
	return list
end

function M.AssertResponseHostIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResponseHostIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResponseHostIdList(list)
	M.AssertResponseHostIdList(list)
	return list
end

function M.AssertVpcPeeringConnectionList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcPeeringConnectionList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVpcPeeringConnection(v)
	end
end

--  
-- List of VpcPeeringConnection objects
function M.VpcPeeringConnectionList(list)
	M.AssertVpcPeeringConnectionList(list)
	return list
end

function M.AssertProductCodeStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductCodeStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ProductCodeStringList(list)
	M.AssertProductCodeStringList(list)
	return list
end

function M.AssertFpgaImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected FpgaImageList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertFpgaImage(v)
	end
end

--  
-- List of FpgaImage objects
function M.FpgaImageList(list)
	M.AssertFpgaImageList(list)
	return list
end

function M.AssertBundleTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected BundleTaskList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertBundleTask(v)
	end
end

--  
-- List of BundleTask objects
function M.BundleTaskList(list)
	M.AssertBundleTaskList(list)
	return list
end

function M.AssertAvailabilityZoneMessageList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailabilityZoneMessageList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertAvailabilityZoneMessage(v)
	end
end

--  
-- List of AvailabilityZoneMessage objects
function M.AvailabilityZoneMessageList(list)
	M.AssertAvailabilityZoneMessageList(list)
	return list
end

function M.AssertPricingDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected PricingDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertPricingDetail(v)
	end
end

--  
-- List of PricingDetail objects
function M.PricingDetailsList(list)
	M.AssertPricingDetailsList(list)
	return list
end

function M.AssertHistoryRecords(list)
	assert(list)
	assert(type(list) == "table", "Expected HistoryRecords to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertHistoryRecord(v)
	end
end

--  
-- List of HistoryRecord objects
function M.HistoryRecords(list)
	M.AssertHistoryRecords(list)
	return list
end

function M.AssertInstanceStateChangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStateChangeList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceStateChange(v)
	end
end

--  
-- List of InstanceStateChange objects
function M.InstanceStateChangeList(list)
	M.AssertInstanceStateChangeList(list)
	return list
end

function M.AssertReservationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReservation(v)
	end
end

--  
-- List of Reservation objects
function M.ReservationList(list)
	M.AssertReservationList(list)
	return list
end

function M.AssertHostList(list)
	assert(list)
	assert(type(list) == "table", "Expected HostList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertHost(v)
	end
end

--  
-- List of Host objects
function M.HostList(list)
	M.AssertHostList(list)
	return list
end

function M.AssertPrivateIpAddressStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.PrivateIpAddressStringList(list)
	M.AssertPrivateIpAddressStringList(list)
	return list
end

function M.AssertNetworkInterfaceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.NetworkInterfaceIdList(list)
	M.AssertNetworkInterfaceIdList(list)
	return list
end

function M.AssertPurchasedScheduledInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchasedScheduledInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertScheduledInstance(v)
	end
end

--  
-- List of ScheduledInstance objects
function M.PurchasedScheduledInstanceSet(list)
	M.AssertPurchasedScheduledInstanceSet(list)
	return list
end

function M.AssertKeyNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected KeyNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.KeyNameStringList(list)
	M.AssertKeyNameStringList(list)
	return list
end

function M.AssertBundleIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected BundleIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.BundleIdStringList(list)
	M.AssertBundleIdStringList(list)
	return list
end

function M.AssertInstanceIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.InstanceIdStringList(list)
	M.AssertInstanceIdStringList(list)
	return list
end

function M.AssertRouteTableList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteTableList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertRouteTable(v)
	end
end

--  
-- List of RouteTable objects
function M.RouteTableList(list)
	M.AssertRouteTableList(list)
	return list
end

function M.AssertIdFormatList(list)
	assert(list)
	assert(type(list) == "table", "Expected IdFormatList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertIdFormat(v)
	end
end

--  
-- List of IdFormat objects
function M.IdFormatList(list)
	M.AssertIdFormatList(list)
	return list
end

function M.AssertRequestHostIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected RequestHostIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.RequestHostIdList(list)
	M.AssertRequestHostIdList(list)
	return list
end

function M.AssertKeyPairList(list)
	assert(list)
	assert(type(list) == "table", "Expected KeyPairList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertKeyPairInfo(v)
	end
end

--  
-- List of KeyPairInfo objects
function M.KeyPairList(list)
	M.AssertKeyPairList(list)
	return list
end

function M.AssertScheduledInstancesSecurityGroupIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesSecurityGroupIdSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ScheduledInstancesSecurityGroupIdSet(list)
	M.AssertScheduledInstancesSecurityGroupIdSet(list)
	return list
end

function M.AssertSnapshotIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.SnapshotIdStringList(list)
	M.AssertSnapshotIdStringList(list)
	return list
end

function M.AssertProductCodeList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductCodeList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertProductCode(v)
	end
end

--  
-- List of ProductCode objects
function M.ProductCodeList(list)
	M.AssertProductCodeList(list)
	return list
end

function M.AssertCancelSpotFleetRequestsSuccessSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelSpotFleetRequestsSuccessSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertCancelSpotFleetRequestsSuccessItem(v)
	end
end

--  
-- List of CancelSpotFleetRequestsSuccessItem objects
function M.CancelSpotFleetRequestsSuccessSet(list)
	M.AssertCancelSpotFleetRequestsSuccessSet(list)
	return list
end

function M.AssertAvailabilityZoneList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailabilityZoneList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertAvailabilityZone(v)
	end
end

--  
-- List of AvailabilityZone objects
function M.AvailabilityZoneList(list)
	M.AssertAvailabilityZoneList(list)
	return list
end

function M.AssertFlowLogSet(list)
	assert(list)
	assert(type(list) == "table", "Expected FlowLogSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertFlowLog(v)
	end
end

--  
-- List of FlowLog objects
function M.FlowLogSet(list)
	M.AssertFlowLogSet(list)
	return list
end

function M.AssertDhcpConfigurationValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpConfigurationValueList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertAttributeValue(v)
	end
end

--  
-- List of AttributeValue objects
function M.DhcpConfigurationValueList(list)
	M.AssertDhcpConfigurationValueList(list)
	return list
end

function M.AssertImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertImage(v)
	end
end

--  
-- List of Image objects
function M.ImageList(list)
	M.AssertImageList(list)
	return list
end

function M.AssertRecurringChargesList(list)
	assert(list)
	assert(type(list) == "table", "Expected RecurringChargesList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertRecurringCharge(v)
	end
end

--  
-- List of RecurringCharge objects
function M.RecurringChargesList(list)
	M.AssertRecurringChargesList(list)
	return list
end

function M.AssertHostReservationIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostReservationIdSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.HostReservationIdSet(list)
	M.AssertHostReservationIdSet(list)
	return list
end

function M.AssertClassicLinkInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected ClassicLinkInstanceList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertClassicLinkInstance(v)
	end
end

--  
-- List of ClassicLinkInstance objects
function M.ClassicLinkInstanceList(list)
	M.AssertClassicLinkInstanceList(list)
	return list
end

function M.AssertVpcClassicLinkList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcClassicLinkList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVpcClassicLink(v)
	end
end

--  
-- List of VpcClassicLink objects
function M.VpcClassicLinkList(list)
	M.AssertVpcClassicLinkList(list)
	return list
end

function M.AssertSpotFleetRequestConfigSet(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotFleetRequestConfigSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertSpotFleetRequestConfig(v)
	end
end

--  
-- List of SpotFleetRequestConfig objects
function M.SpotFleetRequestConfigSet(list)
	M.AssertSpotFleetRequestConfigSet(list)
	return list
end

function M.AssertTargetReservationValueSet(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetReservationValueSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertTargetReservationValue(v)
	end
end

--  
-- List of TargetReservationValue objects
function M.TargetReservationValueSet(list)
	M.AssertTargetReservationValueSet(list)
	return list
end

function M.AssertPrivateIpAddressConfigSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressConfigSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertScheduledInstancesPrivateIpAddressConfig(v)
	end
end

--  
-- List of ScheduledInstancesPrivateIpAddressConfig objects
function M.PrivateIpAddressConfigSet(list)
	M.AssertPrivateIpAddressConfigSet(list)
	return list
end

function M.AssertInstanceTypeList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceTypeList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceType(v)
	end
end

--  
-- List of InstanceType objects
function M.InstanceTypeList(list)
	M.AssertInstanceTypeList(list)
	return list
end

function M.AssertVpnConnectionList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnConnectionList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVpnConnection(v)
	end
end

--  
-- List of VpnConnection objects
function M.VpnConnectionList(list)
	M.AssertVpnConnectionList(list)
	return list
end

function M.AssertDhcpConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertDhcpConfiguration(v)
	end
end

--  
-- List of DhcpConfiguration objects
function M.DhcpConfigurationList(list)
	M.AssertDhcpConfigurationList(list)
	return list
end

function M.AssertNetworkAclAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertNetworkAclAssociation(v)
	end
end

--  
-- List of NetworkAclAssociation objects
function M.NetworkAclAssociationList(list)
	M.AssertNetworkAclAssociationList(list)
	return list
end

function M.AssertScheduledInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertScheduledInstance(v)
	end
end

--  
-- List of ScheduledInstance objects
function M.ScheduledInstanceSet(list)
	M.AssertScheduledInstanceSet(list)
	return list
end

function M.AssertExportTaskIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExportTaskIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ExportTaskIdStringList(list)
	M.AssertExportTaskIdStringList(list)
	return list
end

function M.AssertInstanceIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIdSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.InstanceIdSet(list)
	M.AssertInstanceIdSet(list)
	return list
end

function M.AssertAccountAttributeList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertAccountAttribute(v)
	end
end

--  
-- List of AccountAttribute objects
function M.AccountAttributeList(list)
	M.AssertAccountAttributeList(list)
	return list
end

function M.AssertDescribeConversionTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected DescribeConversionTaskList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertConversionTask(v)
	end
end

--  
-- List of ConversionTask objects
function M.DescribeConversionTaskList(list)
	M.AssertDescribeConversionTaskList(list)
	return list
end

function M.AssertReasonCodesList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReasonCodesList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReportInstanceReasonCodes(v)
	end
end

--  
-- List of ReportInstanceReasonCodes objects
function M.ReasonCodesList(list)
	M.AssertReasonCodesList(list)
	return list
end

function M.AssertAccountAttributeValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeValueList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertAccountAttributeValue(v)
	end
end

--  
-- List of AccountAttributeValue objects
function M.AccountAttributeValueList(list)
	M.AssertAccountAttributeValueList(list)
	return list
end

function M.AssertReservedInstanceIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstanceIdSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstanceIdSet(list)
	M.AssertReservedInstanceIdSet(list)
	return list
end

function M.AssertInstanceNetworkInterfaceList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceNetworkInterfaceList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceNetworkInterface(v)
	end
end

--  
-- List of InstanceNetworkInterface objects
function M.InstanceNetworkInterfaceList(list)
	M.AssertInstanceNetworkInterfaceList(list)
	return list
end

function M.AssertAssociationIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.AssociationIdList(list)
	M.AssertAssociationIdList(list)
	return list
end

function M.AssertDhcpOptionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpOptionsList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertDhcpOptions(v)
	end
end

--  
-- List of DhcpOptions objects
function M.DhcpOptionsList(list)
	M.AssertDhcpOptionsList(list)
	return list
end

function M.AssertAllocationIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AllocationIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.AllocationIdList(list)
	M.AssertAllocationIdList(list)
	return list
end

function M.AssertEgressOnlyInternetGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected EgressOnlyInternetGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertEgressOnlyInternetGateway(v)
	end
end

--  
-- List of EgressOnlyInternetGateway objects
function M.EgressOnlyInternetGatewayList(list)
	M.AssertEgressOnlyInternetGatewayList(list)
	return list
end

function M.AssertExecutableByStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExecutableByStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ExecutableByStringList(list)
	M.AssertExecutableByStringList(list)
	return list
end

function M.AssertRouteTableAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteTableAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertRouteTableAssociation(v)
	end
end

--  
-- List of RouteTableAssociation objects
function M.RouteTableAssociationList(list)
	M.AssertRouteTableAssociationList(list)
	return list
end

function M.AssertImportImageTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportImageTaskList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertImportImageTask(v)
	end
end

--  
-- List of ImportImageTask objects
function M.ImportImageTaskList(list)
	M.AssertImportImageTaskList(list)
	return list
end

function M.AssertInternetGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected InternetGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInternetGateway(v)
	end
end

--  
-- List of InternetGateway objects
function M.InternetGatewayList(list)
	M.AssertInternetGatewayList(list)
	return list
end

function M.AssertPublicIpStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PublicIpStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.PublicIpStringList(list)
	M.AssertPublicIpStringList(list)
	return list
end

function M.AssertScheduledInstancesNetworkInterfaceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesNetworkInterfaceSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertScheduledInstancesNetworkInterface(v)
	end
end

--  
-- List of ScheduledInstancesNetworkInterface objects
function M.ScheduledInstancesNetworkInterfaceSet(list)
	M.AssertScheduledInstancesNetworkInterfaceSet(list)
	return list
end

function M.AssertReservedInstancesConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReservedInstancesConfiguration(v)
	end
end

--  
-- List of ReservedInstancesConfiguration objects
function M.ReservedInstancesConfigurationList(list)
	M.AssertReservedInstancesConfigurationList(list)
	return list
end

function M.AssertSnapshotDetailList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotDetailList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertSnapshotDetail(v)
	end
end

--  
-- List of SnapshotDetail objects
function M.SnapshotDetailList(list)
	M.AssertSnapshotDetailList(list)
	return list
end

function M.AssertNatGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected NatGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertNatGateway(v)
	end
end

--  
-- List of NatGateway objects
function M.NatGatewayList(list)
	M.AssertNatGatewayList(list)
	return list
end

function M.AssertConversionIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ConversionIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ConversionIdStringList(list)
	M.AssertConversionIdStringList(list)
	return list
end

function M.AssertVpnStaticRouteList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnStaticRouteList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVpnStaticRoute(v)
	end
end

--  
-- List of VpnStaticRoute objects
function M.VpnStaticRouteList(list)
	M.AssertVpnStaticRouteList(list)
	return list
end

function M.AssertFpgaImageIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected FpgaImageIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.FpgaImageIdList(list)
	M.AssertFpgaImageIdList(list)
	return list
end

function M.AssertInstanceNetworkInterfaceSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceNetworkInterfaceSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceNetworkInterfaceSpecification(v)
	end
end

--  
-- List of InstanceNetworkInterfaceSpecification objects
function M.InstanceNetworkInterfaceSpecificationList(list)
	M.AssertInstanceNetworkInterfaceSpecificationList(list)
	return list
end

function M.AssertReservedInstancesIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesIdStringList(list)
	M.AssertReservedInstancesIdStringList(list)
	return list
end

function M.AssertInstanceBlockDeviceMappingSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceBlockDeviceMappingSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceBlockDeviceMappingSpecification(v)
	end
end

--  
-- List of InstanceBlockDeviceMappingSpecification objects
function M.InstanceBlockDeviceMappingSpecificationList(list)
	M.AssertInstanceBlockDeviceMappingSpecificationList(list)
	return list
end

function M.AssertReservedInstancesOfferingIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesOfferingIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesOfferingIdStringList(list)
	M.AssertReservedInstancesOfferingIdStringList(list)
	return list
end

function M.AssertTargetConfigurationRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetConfigurationRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertTargetConfigurationRequest(v)
	end
end

--  
-- List of TargetConfigurationRequest objects
function M.TargetConfigurationRequestSet(list)
	M.AssertTargetConfigurationRequestSet(list)
	return list
end

function M.AssertUserIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.UserIdStringList(list)
	M.AssertUserIdStringList(list)
	return list
end

function M.AssertVolumeStatusDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVolumeStatusDetails(v)
	end
end

--  
-- List of VolumeStatusDetails objects
function M.VolumeStatusDetailsList(list)
	M.AssertVolumeStatusDetailsList(list)
	return list
end

function M.AssertLaunchPermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchPermissionList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertLaunchPermission(v)
	end
end

--  
-- List of LaunchPermission objects
function M.LaunchPermissionList(list)
	M.AssertLaunchPermissionList(list)
	return list
end

function M.AssertRegionNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected RegionNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.RegionNameStringList(list)
	M.AssertRegionNameStringList(list)
	return list
end

function M.AssertUserIdGroupPairList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdGroupPairList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertUserIdGroupPair(v)
	end
end

--  
-- List of UserIdGroupPair objects
function M.UserIdGroupPairList(list)
	M.AssertUserIdGroupPairList(list)
	return list
end

function M.AssertVolumeStatusList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVolumeStatusItem(v)
	end
end

--  
-- List of VolumeStatusItem objects
function M.VolumeStatusList(list)
	M.AssertVolumeStatusList(list)
	return list
end

function M.AssertVpcIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpcIdStringList(list)
	M.AssertVpcIdStringList(list)
	return list
end

function M.AssertStaleIpPermissionSet(list)
	assert(list)
	assert(type(list) == "table", "Expected StaleIpPermissionSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertStaleIpPermission(v)
	end
end

--  
-- List of StaleIpPermission objects
function M.StaleIpPermissionSet(list)
	M.AssertStaleIpPermissionSet(list)
	return list
end

function M.AssertResourceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResourceIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResourceIdList(list)
	M.AssertResourceIdList(list)
	return list
end

function M.AssertSecurityGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertSecurityGroup(v)
	end
end

--  
-- List of SecurityGroup objects
function M.SecurityGroupList(list)
	M.AssertSecurityGroupList(list)
	return list
end

function M.AssertSnapshotList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertSnapshot(v)
	end
end

--  
-- List of Snapshot objects
function M.SnapshotList(list)
	M.AssertSnapshotList(list)
	return list
end

function M.AssertPrefixListSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertPrefixList(v)
	end
end

--  
-- List of PrefixList objects
function M.PrefixListSet(list)
	M.AssertPrefixListSet(list)
	return list
end

function M.AssertIpv6CidrBlockSet(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6CidrBlockSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertIpv6CidrBlock(v)
	end
end

--  
-- List of Ipv6CidrBlock objects
function M.Ipv6CidrBlockSet(list)
	M.AssertIpv6CidrBlockSet(list)
	return list
end

function M.AssertPrefixListIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListIdSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.PrefixListIdSet(list)
	M.AssertPrefixListIdSet(list)
	return list
end

function M.AssertCustomerGatewayIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected CustomerGatewayIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.CustomerGatewayIdStringList(list)
	M.AssertCustomerGatewayIdStringList(list)
	return list
end

function M.AssertActiveInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ActiveInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertActiveInstance(v)
	end
end

--  
-- List of ActiveInstance objects
function M.ActiveInstanceSet(list)
	M.AssertActiveInstanceSet(list)
	return list
end

function M.AssertIamInstanceProfileAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected IamInstanceProfileAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertIamInstanceProfileAssociation(v)
	end
end

--  
-- List of IamInstanceProfileAssociation objects
function M.IamInstanceProfileAssociationSet(list)
	M.AssertIamInstanceProfileAssociationSet(list)
	return list
end

function M.AssertIpRanges(list)
	assert(list)
	assert(type(list) == "table", "Expected IpRanges to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.IpRanges(list)
	M.AssertIpRanges(list)
	return list
end

function M.AssertGroupNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupNameStringList(list)
	M.AssertGroupNameStringList(list)
	return list
end

function M.AssertGroupIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupIdStringList(list)
	M.AssertGroupIdStringList(list)
	return list
end

function M.AssertProductDescriptionList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductDescriptionList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ProductDescriptionList(list)
	M.AssertProductDescriptionList(list)
	return list
end

function M.AssertAvailableInstanceCapacityList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailableInstanceCapacityList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceCapacity(v)
	end
end

--  
-- List of InstanceCapacity objects
function M.AvailableInstanceCapacityList(list)
	M.AssertAvailableInstanceCapacityList(list)
	return list
end

function M.AssertReservedIntancesIds(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedIntancesIds to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReservedInstancesId(v)
	end
end

--  
-- List of ReservedInstancesId objects
function M.ReservedIntancesIds(list)
	M.AssertReservedIntancesIds(list)
	return list
end

function M.AssertScheduledInstanceAvailabilitySet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceAvailabilitySet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertScheduledInstanceAvailability(v)
	end
end

--  
-- List of ScheduledInstanceAvailability objects
function M.ScheduledInstanceAvailabilitySet(list)
	M.AssertScheduledInstanceAvailabilitySet(list)
	return list
end

function M.AssertScheduledInstancesIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesIpv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertScheduledInstancesIpv6Address(v)
	end
end

--  
-- List of ScheduledInstancesIpv6Address objects
function M.ScheduledInstancesIpv6AddressList(list)
	M.AssertScheduledInstancesIpv6AddressList(list)
	return list
end

function M.AssertPlacementGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PlacementGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.PlacementGroupStringList(list)
	M.AssertPlacementGroupStringList(list)
	return list
end

function M.AssertAccountAttributeNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertAccountAttributeName(v)
	end
end

--  
-- List of AccountAttributeName objects
function M.AccountAttributeNameStringList(list)
	M.AssertAccountAttributeNameStringList(list)
	return list
end

function M.AssertNetworkInterfaceIpv6AddressesList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceIpv6AddressesList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertNetworkInterfaceIpv6Address(v)
	end
end

--  
-- List of NetworkInterfaceIpv6Address objects
function M.NetworkInterfaceIpv6AddressesList(list)
	M.AssertNetworkInterfaceIpv6AddressesList(list)
	return list
end

function M.AssertPriceScheduleSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected PriceScheduleSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertPriceScheduleSpecification(v)
	end
end

--  
-- List of PriceScheduleSpecification objects
function M.PriceScheduleSpecificationList(list)
	M.AssertPriceScheduleSpecificationList(list)
	return list
end

function M.AssertPrivateIpAddressSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertPrivateIpAddressSpecification(v)
	end
end

--  
-- List of PrivateIpAddressSpecification objects
function M.PrivateIpAddressSpecificationList(list)
	M.AssertPrivateIpAddressSpecificationList(list)
	return list
end

function M.AssertVpcList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVpc(v)
	end
end

--  
-- List of Vpc objects
function M.VpcList(list)
	M.AssertVpcList(list)
	return list
end

function M.AssertImageIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ImageIdStringList(list)
	M.AssertImageIdStringList(list)
	return list
end

function M.AssertBlockDeviceMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected BlockDeviceMappingList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertBlockDeviceMapping(v)
	end
end

--  
-- List of BlockDeviceMapping objects
function M.BlockDeviceMappingList(list)
	M.AssertBlockDeviceMappingList(list)
	return list
end

function M.AssertSpotInstanceRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotInstanceRequestList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertSpotInstanceRequest(v)
	end
end

--  
-- List of SpotInstanceRequest objects
function M.SpotInstanceRequestList(list)
	M.AssertSpotInstanceRequestList(list)
	return list
end

function M.AssertReservedInstancesModificationIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesModificationIdStringList(list)
	M.AssertReservedInstancesModificationIdStringList(list)
	return list
end

function M.AssertClassicLinkDnsSupportList(list)
	assert(list)
	assert(type(list) == "table", "Expected ClassicLinkDnsSupportList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertClassicLinkDnsSupport(v)
	end
end

--  
-- List of ClassicLinkDnsSupport objects
function M.ClassicLinkDnsSupportList(list)
	M.AssertClassicLinkDnsSupportList(list)
	return list
end

function M.AssertHostOfferingSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostOfferingSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertHostOffering(v)
	end
end

--  
-- List of HostOffering objects
function M.HostOfferingSet(list)
	M.AssertHostOfferingSet(list)
	return list
end

function M.AssertMovingAddressStatusSet(list)
	assert(list)
	assert(type(list) == "table", "Expected MovingAddressStatusSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertMovingAddressStatus(v)
	end
end

--  
-- List of MovingAddressStatus objects
function M.MovingAddressStatusSet(list)
	M.AssertMovingAddressStatusSet(list)
	return list
end

function M.AssertInstanceStatusList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInstanceStatus(v)
	end
end

--  
-- List of InstanceStatus objects
function M.InstanceStatusList(list)
	M.AssertInstanceStatusList(list)
	return list
end

function M.AssertSpotPriceHistoryList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotPriceHistoryList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertSpotPrice(v)
	end
end

--  
-- List of SpotPrice objects
function M.SpotPriceHistoryList(list)
	M.AssertSpotPriceHistoryList(list)
	return list
end

function M.AssertCreateVolumePermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected CreateVolumePermissionList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertCreateVolumePermission(v)
	end
end

--  
-- List of CreateVolumePermission objects
function M.CreateVolumePermissionList(list)
	M.AssertCreateVolumePermissionList(list)
	return list
end

function M.AssertNetworkAclList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertNetworkAcl(v)
	end
end

--  
-- List of NetworkAcl objects
function M.NetworkAclList(list)
	M.AssertNetworkAclList(list)
	return list
end

function M.AssertVpnGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVpnGateway(v)
	end
end

--  
-- List of VpnGateway objects
function M.VpnGatewayList(list)
	M.AssertVpnGatewayList(list)
	return list
end

function M.AssertReservedInstanceReservationValueSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstanceReservationValueSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReservedInstanceReservationValue(v)
	end
end

--  
-- List of ReservedInstanceReservationValue objects
function M.ReservedInstanceReservationValueSet(list)
	M.AssertReservedInstanceReservationValueSet(list)
	return list
end

function M.AssertVolumeAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVolumeAttachment(v)
	end
end

--  
-- List of VolumeAttachment objects
function M.VolumeAttachmentList(list)
	M.AssertVolumeAttachmentList(list)
	return list
end

function M.AssertReservedInstancesListingList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesListingList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReservedInstancesListing(v)
	end
end

--  
-- List of ReservedInstancesListing objects
function M.ReservedInstancesListingList(list)
	M.AssertReservedInstancesListingList(list)
	return list
end

function M.AssertPrefixListIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListIdList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertPrefixListId(v)
	end
end

--  
-- List of PrefixListId objects
function M.PrefixListIdList(list)
	M.AssertPrefixListIdList(list)
	return list
end

function M.AssertOccurrenceDayRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected OccurrenceDayRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertInteger(v)
	end
end

--  
-- List of Integer objects
function M.OccurrenceDayRequestSet(list)
	M.AssertOccurrenceDayRequestSet(list)
	return list
end

function M.AssertHostInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected HostInstanceList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertHostInstance(v)
	end
end

--  
-- List of HostInstance objects
function M.HostInstanceList(list)
	M.AssertHostInstanceList(list)
	return list
end

function M.AssertVolumeStatusEventsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusEventsList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVolumeStatusEvent(v)
	end
end

--  
-- List of VolumeStatusEvent objects
function M.VolumeStatusEventsList(list)
	M.AssertVolumeStatusEventsList(list)
	return list
end

function M.AssertIpPermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected IpPermissionList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertIpPermission(v)
	end
end

--  
-- List of IpPermission objects
function M.IpPermissionList(list)
	M.AssertIpPermissionList(list)
	return list
end

function M.AssertSecurityGroupReferences(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupReferences to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertSecurityGroupReference(v)
	end
end

--  
-- List of SecurityGroupReference objects
function M.SecurityGroupReferences(list)
	M.AssertSecurityGroupReferences(list)
	return list
end

function M.AssertVpcIpv6CidrBlockAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcIpv6CidrBlockAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVpcIpv6CidrBlockAssociation(v)
	end
end

--  
-- List of VpcIpv6CidrBlockAssociation objects
function M.VpcIpv6CidrBlockAssociationSet(list)
	M.AssertVpcIpv6CidrBlockAssociationSet(list)
	return list
end

function M.AssertReservedInstancesList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertReservedInstances(v)
	end
end

--  
-- List of ReservedInstances objects
function M.ReservedInstancesList(list)
	M.AssertReservedInstancesList(list)
	return list
end

function M.AssertTagList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertTag(v)
	end
end

--  
-- List of Tag objects
function M.TagList(list)
	M.AssertTagList(list)
	return list
end

function M.AssertVgwTelemetryList(list)
	assert(list)
	assert(type(list) == "table", "Expected VgwTelemetryList to be of type ''table")
	for _,v in ipairs(list) do
		M.AssertVgwTelemetry(v)
	end
end

--  
-- List of VgwTelemetry objects
function M.VgwTelemetryList(list)
	M.AssertVgwTelemetryList(list)
	return list
end


local headers = require "aws-sdk.core.headers"
local content_type = require "aws-sdk.core.content_type"
local scheme_mapper = require "aws-sdk.core.scheme_mapper"
local request_handlers = require "aws-sdk.core.request_handlers"

local uri = ""


local function endpoint_for_region(region, use_dualstack)
	if not use_dualstack then
		if region == "us-east-1" then
			return "ec2.amazonaws.com"
		end
	end
	local ss = { "ec2" }
	if use_dualstack then
		ss[#ss + 1] = "dualstack"
	end
	ss[#ss + 1] = region
	ss[#ss + 1] = "amazonaws.com"
	if region == "cn-north-1" then
		ss[#ss + 1] = "cn"
	end
	return table.concat(ss, ".")
end


function M.init(config)
	assert(config, "You must provide a config table")
	uri = scheme_mapper.from_string(config.scheme) .. "://"
	uri = uri .. config.endpoint_override or endpoint_for_region(config.region, config.use_dualstack)
end


--
-- OPERATIONS
--
--- DeleteTags
-- @param DeleteTagsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteTagsAsync(DeleteTagsRequest, cb)
	assert(DeleteTagsRequest, "You must provide a DeleteTagsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteTags",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteTagsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ResetSnapshotAttribute
-- @param ResetSnapshotAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetSnapshotAttributeAsync(ResetSnapshotAttributeRequest, cb)
	assert(ResetSnapshotAttributeRequest, "You must provide a ResetSnapshotAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ResetSnapshotAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ResetSnapshotAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeCustomerGateways
-- @param DescribeCustomerGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeCustomerGatewaysAsync(DescribeCustomerGatewaysRequest, cb)
	assert(DescribeCustomerGatewaysRequest, "You must provide a DescribeCustomerGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeCustomerGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeCustomerGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- EnableVpcClassicLinkDnsSupport
-- @param EnableVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVpcClassicLinkDnsSupportAsync(EnableVpcClassicLinkDnsSupportRequest, cb)
	assert(EnableVpcClassicLinkDnsSupportRequest, "You must provide a EnableVpcClassicLinkDnsSupportRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".EnableVpcClassicLinkDnsSupport",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", EnableVpcClassicLinkDnsSupportRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeNetworkAcls
-- @param DescribeNetworkAclsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNetworkAclsAsync(DescribeNetworkAclsRequest, cb)
	assert(DescribeNetworkAclsRequest, "You must provide a DescribeNetworkAclsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeNetworkAcls",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeNetworkAclsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeImageAttribute
-- @param DescribeImageAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImageAttributeAsync(DescribeImageAttributeRequest, cb)
	assert(DescribeImageAttributeRequest, "You must provide a DescribeImageAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeImageAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeImageAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CancelConversionTask
-- @param CancelConversionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelConversionTaskAsync(CancelConversionRequest, cb)
	assert(CancelConversionRequest, "You must provide a CancelConversionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelConversionTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelConversionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CancelImportTask
-- @param CancelImportTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelImportTaskAsync(CancelImportTaskRequest, cb)
	assert(CancelImportTaskRequest, "You must provide a CancelImportTaskRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelImportTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelImportTaskRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateVpnConnectionRoute
-- @param CreateVpnConnectionRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpnConnectionRouteAsync(CreateVpnConnectionRouteRequest, cb)
	assert(CreateVpnConnectionRouteRequest, "You must provide a CreateVpnConnectionRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpnConnectionRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpnConnectionRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeRouteTables
-- @param DescribeRouteTablesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeRouteTablesAsync(DescribeRouteTablesRequest, cb)
	assert(DescribeRouteTablesRequest, "You must provide a DescribeRouteTablesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeRouteTables",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeRouteTablesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ResetImageAttribute
-- @param ResetImageAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetImageAttributeAsync(ResetImageAttributeRequest, cb)
	assert(ResetImageAttributeRequest, "You must provide a ResetImageAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ResetImageAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ResetImageAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateRouteTable
-- @param CreateRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateRouteTableAsync(CreateRouteTableRequest, cb)
	assert(CreateRouteTableRequest, "You must provide a CreateRouteTableRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateRouteTableRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ReplaceRouteTableAssociation
-- @param ReplaceRouteTableAssociationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceRouteTableAssociationAsync(ReplaceRouteTableAssociationRequest, cb)
	assert(ReplaceRouteTableAssociationRequest, "You must provide a ReplaceRouteTableAssociationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceRouteTableAssociation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceRouteTableAssociationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateVpcEndpoint
-- @param CreateVpcEndpointRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpcEndpointAsync(CreateVpcEndpointRequest, cb)
	assert(CreateVpcEndpointRequest, "You must provide a CreateVpcEndpointRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpcEndpoint",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpcEndpointRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RegisterImage
-- @param RegisterImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RegisterImageAsync(RegisterImageRequest, cb)
	assert(RegisterImageRequest, "You must provide a RegisterImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RegisterImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RegisterImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AssociateDhcpOptions
-- @param AssociateDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateDhcpOptionsAsync(AssociateDhcpOptionsRequest, cb)
	assert(AssociateDhcpOptionsRequest, "You must provide a AssociateDhcpOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateDhcpOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ImportKeyPair
-- @param ImportKeyPairRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportKeyPairAsync(ImportKeyPairRequest, cb)
	assert(ImportKeyPairRequest, "You must provide a ImportKeyPairRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportKeyPair",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportKeyPairRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeAvailabilityZones
-- @param DescribeAvailabilityZonesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeAvailabilityZonesAsync(DescribeAvailabilityZonesRequest, cb)
	assert(DescribeAvailabilityZonesRequest, "You must provide a DescribeAvailabilityZonesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeAvailabilityZones",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeAvailabilityZonesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RequestSpotInstances
-- @param RequestSpotInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RequestSpotInstancesAsync(RequestSpotInstancesRequest, cb)
	assert(RequestSpotInstancesRequest, "You must provide a RequestSpotInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RequestSpotInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RequestSpotInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVpnGateways
-- @param DescribeVpnGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpnGatewaysAsync(DescribeVpnGatewaysRequest, cb)
	assert(DescribeVpnGatewaysRequest, "You must provide a DescribeVpnGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpnGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpnGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AcceptVpcPeeringConnection
-- @param AcceptVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AcceptVpcPeeringConnectionAsync(AcceptVpcPeeringConnectionRequest, cb)
	assert(AcceptVpcPeeringConnectionRequest, "You must provide a AcceptVpcPeeringConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AcceptVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AcceptVpcPeeringConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeReservedInstancesModifications
-- @param DescribeReservedInstancesModificationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesModificationsAsync(DescribeReservedInstancesModificationsRequest, cb)
	assert(DescribeReservedInstancesModificationsRequest, "You must provide a DescribeReservedInstancesModificationsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesModifications",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeReservedInstancesModificationsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- GetPasswordData
-- @param GetPasswordDataRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetPasswordDataAsync(GetPasswordDataRequest, cb)
	assert(GetPasswordDataRequest, "You must provide a GetPasswordDataRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetPasswordData",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetPasswordDataRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeImportSnapshotTasks
-- @param DescribeImportSnapshotTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImportSnapshotTasksAsync(DescribeImportSnapshotTasksRequest, cb)
	assert(DescribeImportSnapshotTasksRequest, "You must provide a DescribeImportSnapshotTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeImportSnapshotTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeImportSnapshotTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- UnassignIpv6Addresses
-- @param UnassignIpv6AddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.UnassignIpv6AddressesAsync(UnassignIpv6AddressesRequest, cb)
	assert(UnassignIpv6AddressesRequest, "You must provide a UnassignIpv6AddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".UnassignIpv6Addresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", UnassignIpv6AddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteVpnConnection
-- @param DeleteVpnConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpnConnectionAsync(DeleteVpnConnectionRequest, cb)
	assert(DeleteVpnConnectionRequest, "You must provide a DeleteVpnConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpnConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpnConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AttachVpnGateway
-- @param AttachVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachVpnGatewayAsync(AttachVpnGatewayRequest, cb)
	assert(AttachVpnGatewayRequest, "You must provide a AttachVpnGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachVpnGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ImportImage
-- @param ImportImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportImageAsync(ImportImageRequest, cb)
	assert(ImportImageRequest, "You must provide a ImportImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeAddresses
-- @param DescribeAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeAddressesAsync(DescribeAddressesRequest, cb)
	assert(DescribeAddressesRequest, "You must provide a DescribeAddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeAddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DisassociateIamInstanceProfile
-- @param DisassociateIamInstanceProfileRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateIamInstanceProfileAsync(DisassociateIamInstanceProfileRequest, cb)
	assert(DisassociateIamInstanceProfileRequest, "You must provide a DisassociateIamInstanceProfileRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateIamInstanceProfile",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateIamInstanceProfileRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AssociateIamInstanceProfile
-- @param AssociateIamInstanceProfileRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateIamInstanceProfileAsync(AssociateIamInstanceProfileRequest, cb)
	assert(AssociateIamInstanceProfileRequest, "You must provide a AssociateIamInstanceProfileRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateIamInstanceProfile",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateIamInstanceProfileRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- PurchaseHostReservation
-- @param PurchaseHostReservationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.PurchaseHostReservationAsync(PurchaseHostReservationRequest, cb)
	assert(PurchaseHostReservationRequest, "You must provide a PurchaseHostReservationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".PurchaseHostReservation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", PurchaseHostReservationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- BundleInstance
-- @param BundleInstanceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.BundleInstanceAsync(BundleInstanceRequest, cb)
	assert(BundleInstanceRequest, "You must provide a BundleInstanceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".BundleInstance",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", BundleInstanceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeReservedInstances
-- @param DescribeReservedInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesAsync(DescribeReservedInstancesRequest, cb)
	assert(DescribeReservedInstancesRequest, "You must provide a DescribeReservedInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeReservedInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateNetworkAcl
-- @param CreateNetworkAclRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNetworkAclAsync(CreateNetworkAclRequest, cb)
	assert(CreateNetworkAclRequest, "You must provide a CreateNetworkAclRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateNetworkAcl",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateNetworkAclRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateImage
-- @param CreateImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateImageAsync(CreateImageRequest, cb)
	assert(CreateImageRequest, "You must provide a CreateImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyHosts
-- @param ModifyHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyHostsAsync(ModifyHostsRequest, cb)
	assert(ModifyHostsRequest, "You must provide a ModifyHostsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyHostsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RebootInstances
-- @param RebootInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RebootInstancesAsync(RebootInstancesRequest, cb)
	assert(RebootInstancesRequest, "You must provide a RebootInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RebootInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RebootInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVpcEndpoints
-- @param DescribeVpcEndpointsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcEndpointsAsync(DescribeVpcEndpointsRequest, cb)
	assert(DescribeVpcEndpointsRequest, "You must provide a DescribeVpcEndpointsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpoints",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcEndpointsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyIdentityIdFormat
-- @param ModifyIdentityIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyIdentityIdFormatAsync(ModifyIdentityIdFormatRequest, cb)
	assert(ModifyIdentityIdFormatRequest, "You must provide a ModifyIdentityIdFormatRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyIdentityIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyIdentityIdFormatRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSpotFleetRequestHistory
-- @param DescribeSpotFleetRequestHistoryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotFleetRequestHistoryAsync(DescribeSpotFleetRequestHistoryRequest, cb)
	assert(DescribeSpotFleetRequestHistoryRequest, "You must provide a DescribeSpotFleetRequestHistoryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetRequestHistory",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotFleetRequestHistoryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- PurchaseScheduledInstances
-- @param PurchaseScheduledInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.PurchaseScheduledInstancesAsync(PurchaseScheduledInstancesRequest, cb)
	assert(PurchaseScheduledInstancesRequest, "You must provide a PurchaseScheduledInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".PurchaseScheduledInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", PurchaseScheduledInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ReplaceIamInstanceProfileAssociation
-- @param ReplaceIamInstanceProfileAssociationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceIamInstanceProfileAssociationAsync(ReplaceIamInstanceProfileAssociationRequest, cb)
	assert(ReplaceIamInstanceProfileAssociationRequest, "You must provide a ReplaceIamInstanceProfileAssociationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceIamInstanceProfileAssociation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceIamInstanceProfileAssociationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DetachVolume
-- @param DetachVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachVolumeAsync(DetachVolumeRequest, cb)
	assert(DetachVolumeRequest, "You must provide a DetachVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeIamInstanceProfileAssociations
-- @param DescribeIamInstanceProfileAssociationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeIamInstanceProfileAssociationsAsync(DescribeIamInstanceProfileAssociationsRequest, cb)
	assert(DescribeIamInstanceProfileAssociationsRequest, "You must provide a DescribeIamInstanceProfileAssociationsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeIamInstanceProfileAssociations",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeIamInstanceProfileAssociationsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AssignPrivateIpAddresses
-- @param AssignPrivateIpAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssignPrivateIpAddressesAsync(AssignPrivateIpAddressesRequest, cb)
	assert(AssignPrivateIpAddressesRequest, "You must provide a AssignPrivateIpAddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssignPrivateIpAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssignPrivateIpAddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CancelExportTask
-- @param CancelExportTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelExportTaskAsync(CancelExportTaskRequest, cb)
	assert(CancelExportTaskRequest, "You must provide a CancelExportTaskRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelExportTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelExportTaskRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DetachVpnGateway
-- @param DetachVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachVpnGatewayAsync(DetachVpnGatewayRequest, cb)
	assert(DetachVpnGatewayRequest, "You must provide a DetachVpnGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachVpnGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVpcAttribute
-- @param DescribeVpcAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcAttributeAsync(DescribeVpcAttributeRequest, cb)
	assert(DescribeVpcAttributeRequest, "You must provide a DescribeVpcAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CancelBundleTask
-- @param CancelBundleTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelBundleTaskAsync(CancelBundleTaskRequest, cb)
	assert(CancelBundleTaskRequest, "You must provide a CancelBundleTaskRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelBundleTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelBundleTaskRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeNatGateways
-- @param DescribeNatGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNatGatewaysAsync(DescribeNatGatewaysRequest, cb)
	assert(DescribeNatGatewaysRequest, "You must provide a DescribeNatGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeNatGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeNatGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DisassociateSubnetCidrBlock
-- @param DisassociateSubnetCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateSubnetCidrBlockAsync(DisassociateSubnetCidrBlockRequest, cb)
	assert(DisassociateSubnetCidrBlockRequest, "You must provide a DisassociateSubnetCidrBlockRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateSubnetCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateSubnetCidrBlockRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateVpcPeeringConnection
-- @param CreateVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpcPeeringConnectionAsync(CreateVpcPeeringConnectionRequest, cb)
	assert(CreateVpcPeeringConnectionRequest, "You must provide a CreateVpcPeeringConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpcPeeringConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyIdFormat
-- @param ModifyIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyIdFormatAsync(ModifyIdFormatRequest, cb)
	assert(ModifyIdFormatRequest, "You must provide a ModifyIdFormatRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyIdFormatRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSpotFleetRequests
-- @param DescribeSpotFleetRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotFleetRequestsAsync(DescribeSpotFleetRequestsRequest, cb)
	assert(DescribeSpotFleetRequestsRequest, "You must provide a DescribeSpotFleetRequestsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotFleetRequestsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AllocateHosts
-- @param AllocateHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AllocateHostsAsync(AllocateHostsRequest, cb)
	assert(AllocateHostsRequest, "You must provide a AllocateHostsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AllocateHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AllocateHostsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteNetworkAcl
-- @param DeleteNetworkAclRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNetworkAclAsync(DeleteNetworkAclRequest, cb)
	assert(DeleteNetworkAclRequest, "You must provide a DeleteNetworkAclRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteNetworkAcl",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteNetworkAclRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- GetHostReservationPurchasePreview
-- @param GetHostReservationPurchasePreviewRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetHostReservationPurchasePreviewAsync(GetHostReservationPurchasePreviewRequest, cb)
	assert(GetHostReservationPurchasePreviewRequest, "You must provide a GetHostReservationPurchasePreviewRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetHostReservationPurchasePreview",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetHostReservationPurchasePreviewRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CopyImage
-- @param CopyImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CopyImageAsync(CopyImageRequest, cb)
	assert(CopyImageRequest, "You must provide a CopyImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CopyImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CopyImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateSnapshot
-- @param CreateSnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSnapshotAsync(CreateSnapshotRequest, cb)
	assert(CreateSnapshotRequest, "You must provide a CreateSnapshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateSnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateSnapshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateSubnet
-- @param CreateSubnetRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSubnetAsync(CreateSubnetRequest, cb)
	assert(CreateSubnetRequest, "You must provide a CreateSubnetRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateSubnet",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateSubnetRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RequestSpotFleet
-- @param RequestSpotFleetRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RequestSpotFleetAsync(RequestSpotFleetRequest, cb)
	assert(RequestSpotFleetRequest, "You must provide a RequestSpotFleetRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RequestSpotFleet",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RequestSpotFleetRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyImageAttribute
-- @param ModifyImageAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyImageAttributeAsync(ModifyImageAttributeRequest, cb)
	assert(ModifyImageAttributeRequest, "You must provide a ModifyImageAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyImageAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyImageAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AssociateSubnetCidrBlock
-- @param AssociateSubnetCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateSubnetCidrBlockAsync(AssociateSubnetCidrBlockRequest, cb)
	assert(AssociateSubnetCidrBlockRequest, "You must provide a AssociateSubnetCidrBlockRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateSubnetCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateSubnetCidrBlockRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- StartInstances
-- @param StartInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.StartInstancesAsync(StartInstancesRequest, cb)
	assert(StartInstancesRequest, "You must provide a StartInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".StartInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", StartInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSpotInstanceRequests
-- @param DescribeSpotInstanceRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotInstanceRequestsAsync(DescribeSpotInstanceRequestsRequest, cb)
	assert(DescribeSpotInstanceRequestsRequest, "You must provide a DescribeSpotInstanceRequestsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotInstanceRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotInstanceRequestsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DisableVgwRoutePropagation
-- @param DisableVgwRoutePropagationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisableVgwRoutePropagationAsync(DisableVgwRoutePropagationRequest, cb)
	assert(DisableVgwRoutePropagationRequest, "You must provide a DisableVgwRoutePropagationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisableVgwRoutePropagation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisableVgwRoutePropagationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVpcs
-- @param DescribeVpcsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcsAsync(DescribeVpcsRequest, cb)
	assert(DescribeVpcsRequest, "You must provide a DescribeVpcsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DisassociateAddress
-- @param DisassociateAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateAddressAsync(DisassociateAddressRequest, cb)
	assert(DisassociateAddressRequest, "You must provide a DisassociateAddressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateAddressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifySnapshotAttribute
-- @param ModifySnapshotAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifySnapshotAttributeAsync(ModifySnapshotAttributeRequest, cb)
	assert(ModifySnapshotAttributeRequest, "You must provide a ModifySnapshotAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifySnapshotAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifySnapshotAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- MoveAddressToVpc
-- @param MoveAddressToVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.MoveAddressToVpcAsync(MoveAddressToVpcRequest, cb)
	assert(MoveAddressToVpcRequest, "You must provide a MoveAddressToVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".MoveAddressToVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", MoveAddressToVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateVpc
-- @param CreateVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpcAsync(CreateVpcRequest, cb)
	assert(CreateVpcRequest, "You must provide a CreateVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVpcEndpointServices
-- @param DescribeVpcEndpointServicesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcEndpointServicesAsync(DescribeVpcEndpointServicesRequest, cb)
	assert(DescribeVpcEndpointServicesRequest, "You must provide a DescribeVpcEndpointServicesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpointServices",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcEndpointServicesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CancelSpotFleetRequests
-- @param CancelSpotFleetRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelSpotFleetRequestsAsync(CancelSpotFleetRequestsRequest, cb)
	assert(CancelSpotFleetRequestsRequest, "You must provide a CancelSpotFleetRequestsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelSpotFleetRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelSpotFleetRequestsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- UnmonitorInstances
-- @param UnmonitorInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.UnmonitorInstancesAsync(UnmonitorInstancesRequest, cb)
	assert(UnmonitorInstancesRequest, "You must provide a UnmonitorInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".UnmonitorInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", UnmonitorInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteSubnet
-- @param DeleteSubnetRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSubnetAsync(DeleteSubnetRequest, cb)
	assert(DeleteSubnetRequest, "You must provide a DeleteSubnetRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteSubnet",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteSubnetRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreatePlacementGroup
-- @param CreatePlacementGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreatePlacementGroupAsync(CreatePlacementGroupRequest, cb)
	assert(CreatePlacementGroupRequest, "You must provide a CreatePlacementGroupRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreatePlacementGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreatePlacementGroupRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CopySnapshot
-- @param CopySnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CopySnapshotAsync(CopySnapshotRequest, cb)
	assert(CopySnapshotRequest, "You must provide a CopySnapshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CopySnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CopySnapshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DisableVpcClassicLinkDnsSupport
-- @param DisableVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisableVpcClassicLinkDnsSupportAsync(DisableVpcClassicLinkDnsSupportRequest, cb)
	assert(DisableVpcClassicLinkDnsSupportRequest, "You must provide a DisableVpcClassicLinkDnsSupportRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisableVpcClassicLinkDnsSupport",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisableVpcClassicLinkDnsSupportRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeHostReservationOfferings
-- @param DescribeHostReservationOfferingsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeHostReservationOfferingsAsync(DescribeHostReservationOfferingsRequest, cb)
	assert(DescribeHostReservationOfferingsRequest, "You must provide a DescribeHostReservationOfferingsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeHostReservationOfferings",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeHostReservationOfferingsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVolumesModifications
-- @param DescribeVolumesModificationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumesModificationsAsync(DescribeVolumesModificationsRequest, cb)
	assert(DescribeVolumesModificationsRequest, "You must provide a DescribeVolumesModificationsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVolumesModifications",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVolumesModificationsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AssociateVpcCidrBlock
-- @param AssociateVpcCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateVpcCidrBlockAsync(AssociateVpcCidrBlockRequest, cb)
	assert(AssociateVpcCidrBlockRequest, "You must provide a AssociateVpcCidrBlockRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateVpcCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateVpcCidrBlockRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AssociateAddress
-- @param AssociateAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateAddressAsync(AssociateAddressRequest, cb)
	assert(AssociateAddressRequest, "You must provide a AssociateAddressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateAddressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteCustomerGateway
-- @param DeleteCustomerGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteCustomerGatewayAsync(DeleteCustomerGatewayRequest, cb)
	assert(DeleteCustomerGatewayRequest, "You must provide a DeleteCustomerGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteCustomerGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteCustomerGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateInternetGateway
-- @param CreateInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateInternetGatewayAsync(CreateInternetGatewayRequest, cb)
	assert(CreateInternetGatewayRequest, "You must provide a CreateInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AttachClassicLinkVpc
-- @param AttachClassicLinkVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachClassicLinkVpcAsync(AttachClassicLinkVpcRequest, cb)
	assert(AttachClassicLinkVpcRequest, "You must provide a AttachClassicLinkVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachClassicLinkVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachClassicLinkVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSpotPriceHistory
-- @param DescribeSpotPriceHistoryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotPriceHistoryAsync(DescribeSpotPriceHistoryRequest, cb)
	assert(DescribeSpotPriceHistoryRequest, "You must provide a DescribeSpotPriceHistoryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotPriceHistory",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotPriceHistoryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeDhcpOptions
-- @param DescribeDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeDhcpOptionsAsync(DescribeDhcpOptionsRequest, cb)
	assert(DescribeDhcpOptionsRequest, "You must provide a DescribeDhcpOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeDhcpOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteVpcPeeringConnection
-- @param DeleteVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpcPeeringConnectionAsync(DeleteVpcPeeringConnectionRequest, cb)
	assert(DeleteVpcPeeringConnectionRequest, "You must provide a DeleteVpcPeeringConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpcPeeringConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeFlowLogs
-- @param DescribeFlowLogsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeFlowLogsAsync(DescribeFlowLogsRequest, cb)
	assert(DescribeFlowLogsRequest, "You must provide a DescribeFlowLogsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeFlowLogs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeFlowLogsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateNetworkAclEntry
-- @param CreateNetworkAclEntryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNetworkAclEntryAsync(CreateNetworkAclEntryRequest, cb)
	assert(CreateNetworkAclEntryRequest, "You must provide a CreateNetworkAclEntryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateNetworkAclEntry",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateNetworkAclEntryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ReleaseHosts
-- @param ReleaseHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReleaseHostsAsync(ReleaseHostsRequest, cb)
	assert(ReleaseHostsRequest, "You must provide a ReleaseHostsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReleaseHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReleaseHostsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RestoreAddressToClassic
-- @param RestoreAddressToClassicRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RestoreAddressToClassicAsync(RestoreAddressToClassicRequest, cb)
	assert(RestoreAddressToClassicRequest, "You must provide a RestoreAddressToClassicRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RestoreAddressToClassic",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RestoreAddressToClassicRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateNetworkInterface
-- @param CreateNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNetworkInterfaceAsync(CreateNetworkInterfaceRequest, cb)
	assert(CreateNetworkInterfaceRequest, "You must provide a CreateNetworkInterfaceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateNetworkInterfaceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeRegions
-- @param DescribeRegionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeRegionsAsync(DescribeRegionsRequest, cb)
	assert(DescribeRegionsRequest, "You must provide a DescribeRegionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeRegions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeRegionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RevokeSecurityGroupIngress
-- @param RevokeSecurityGroupIngressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RevokeSecurityGroupIngressAsync(RevokeSecurityGroupIngressRequest, cb)
	assert(RevokeSecurityGroupIngressRequest, "You must provide a RevokeSecurityGroupIngressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RevokeSecurityGroupIngress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RevokeSecurityGroupIngressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- UnassignPrivateIpAddresses
-- @param UnassignPrivateIpAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.UnassignPrivateIpAddressesAsync(UnassignPrivateIpAddressesRequest, cb)
	assert(UnassignPrivateIpAddressesRequest, "You must provide a UnassignPrivateIpAddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".UnassignPrivateIpAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", UnassignPrivateIpAddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AttachInternetGateway
-- @param AttachInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachInternetGatewayAsync(AttachInternetGatewayRequest, cb)
	assert(AttachInternetGatewayRequest, "You must provide a AttachInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateInstanceExportTask
-- @param CreateInstanceExportTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateInstanceExportTaskAsync(CreateInstanceExportTaskRequest, cb)
	assert(CreateInstanceExportTaskRequest, "You must provide a CreateInstanceExportTaskRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateInstanceExportTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateInstanceExportTaskRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteDhcpOptions
-- @param DeleteDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteDhcpOptionsAsync(DeleteDhcpOptionsRequest, cb)
	assert(DeleteDhcpOptionsRequest, "You must provide a DeleteDhcpOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteDhcpOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ResetNetworkInterfaceAttribute
-- @param ResetNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetNetworkInterfaceAttributeAsync(ResetNetworkInterfaceAttributeRequest, cb)
	assert(ResetNetworkInterfaceAttributeRequest, "You must provide a ResetNetworkInterfaceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ResetNetworkInterfaceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ResetNetworkInterfaceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyReservedInstances
-- @param ModifyReservedInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyReservedInstancesAsync(ModifyReservedInstancesRequest, cb)
	assert(ModifyReservedInstancesRequest, "You must provide a ModifyReservedInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyReservedInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyReservedInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DetachNetworkInterface
-- @param DetachNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachNetworkInterfaceAsync(DetachNetworkInterfaceRequest, cb)
	assert(DetachNetworkInterfaceRequest, "You must provide a DetachNetworkInterfaceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachNetworkInterfaceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeImportImageTasks
-- @param DescribeImportImageTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImportImageTasksAsync(DescribeImportImageTasksRequest, cb)
	assert(DescribeImportImageTasksRequest, "You must provide a DescribeImportImageTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeImportImageTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeImportImageTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSpotFleetInstances
-- @param DescribeSpotFleetInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotFleetInstancesAsync(DescribeSpotFleetInstancesRequest, cb)
	assert(DescribeSpotFleetInstancesRequest, "You must provide a DescribeSpotFleetInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotFleetInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- EnableVpcClassicLink
-- @param EnableVpcClassicLinkRequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVpcClassicLinkAsync(EnableVpcClassicLinkRequest, cb)
	assert(EnableVpcClassicLinkRequest, "You must provide a EnableVpcClassicLinkRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".EnableVpcClassicLink",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", EnableVpcClassicLinkRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateFlowLogs
-- @param CreateFlowLogsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateFlowLogsAsync(CreateFlowLogsRequest, cb)
	assert(CreateFlowLogsRequest, "You must provide a CreateFlowLogsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateFlowLogs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateFlowLogsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DisassociateVpcCidrBlock
-- @param DisassociateVpcCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateVpcCidrBlockAsync(DisassociateVpcCidrBlockRequest, cb)
	assert(DisassociateVpcCidrBlockRequest, "You must provide a DisassociateVpcCidrBlockRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateVpcCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateVpcCidrBlockRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVolumeStatus
-- @param DescribeVolumeStatusRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumeStatusAsync(DescribeVolumeStatusRequest, cb)
	assert(DescribeVolumeStatusRequest, "You must provide a DescribeVolumeStatusRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVolumeStatus",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVolumeStatusRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeHosts
-- @param DescribeHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeHostsAsync(DescribeHostsRequest, cb)
	assert(DescribeHostsRequest, "You must provide a DescribeHostsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeHostsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVpcPeeringConnections
-- @param DescribeVpcPeeringConnectionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcPeeringConnectionsAsync(DescribeVpcPeeringConnectionsRequest, cb)
	assert(DescribeVpcPeeringConnectionsRequest, "You must provide a DescribeVpcPeeringConnectionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcPeeringConnections",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcPeeringConnectionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVolumes
-- @param DescribeVolumesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumesAsync(DescribeVolumesRequest, cb)
	assert(DescribeVolumesRequest, "You must provide a DescribeVolumesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVolumes",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVolumesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteNetworkInterface
-- @param DeleteNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNetworkInterfaceAsync(DeleteNetworkInterfaceRequest, cb)
	assert(DeleteNetworkInterfaceRequest, "You must provide a DeleteNetworkInterfaceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteNetworkInterfaceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVpnConnections
-- @param DescribeVpnConnectionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpnConnectionsAsync(DescribeVpnConnectionsRequest, cb)
	assert(DescribeVpnConnectionsRequest, "You must provide a DescribeVpnConnectionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpnConnections",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpnConnectionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteVpcEndpoints
-- @param DeleteVpcEndpointsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpcEndpointsAsync(DeleteVpcEndpointsRequest, cb)
	assert(DeleteVpcEndpointsRequest, "You must provide a DeleteVpcEndpointsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpcEndpoints",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpcEndpointsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVolumeAttribute
-- @param DescribeVolumeAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumeAttributeAsync(DescribeVolumeAttributeRequest, cb)
	assert(DescribeVolumeAttributeRequest, "You must provide a DescribeVolumeAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVolumeAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVolumeAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteKeyPair
-- @param DeleteKeyPairRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteKeyPairAsync(DeleteKeyPairRequest, cb)
	assert(DeleteKeyPairRequest, "You must provide a DeleteKeyPairRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteKeyPair",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteKeyPairRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteNatGateway
-- @param DeleteNatGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNatGatewayAsync(DeleteNatGatewayRequest, cb)
	assert(DeleteNatGatewayRequest, "You must provide a DeleteNatGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteNatGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteNatGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyInstancePlacement
-- @param ModifyInstancePlacementRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyInstancePlacementAsync(ModifyInstancePlacementRequest, cb)
	assert(ModifyInstancePlacementRequest, "You must provide a ModifyInstancePlacementRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyInstancePlacement",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyInstancePlacementRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ReplaceNetworkAclEntry
-- @param ReplaceNetworkAclEntryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceNetworkAclEntryAsync(ReplaceNetworkAclEntryRequest, cb)
	assert(ReplaceNetworkAclEntryRequest, "You must provide a ReplaceNetworkAclEntryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceNetworkAclEntry",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceNetworkAclEntryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateEgressOnlyInternetGateway
-- @param CreateEgressOnlyInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateEgressOnlyInternetGatewayAsync(CreateEgressOnlyInternetGatewayRequest, cb)
	assert(CreateEgressOnlyInternetGatewayRequest, "You must provide a CreateEgressOnlyInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateEgressOnlyInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateEgressOnlyInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteInternetGateway
-- @param DeleteInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteInternetGatewayAsync(DeleteInternetGatewayRequest, cb)
	assert(DeleteInternetGatewayRequest, "You must provide a DeleteInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateVolume
-- @param CreateVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVolumeAsync(CreateVolumeRequest, cb)
	assert(CreateVolumeRequest, "You must provide a CreateVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RunInstances
-- @param RunInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RunInstancesAsync(RunInstancesRequest, cb)
	assert(RunInstancesRequest, "You must provide a RunInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RunInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RunInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeScheduledInstances
-- @param DescribeScheduledInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeScheduledInstancesAsync(DescribeScheduledInstancesRequest, cb)
	assert(DescribeScheduledInstancesRequest, "You must provide a DescribeScheduledInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeScheduledInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeScheduledInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteRoute
-- @param DeleteRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteRouteAsync(DeleteRouteRequest, cb)
	assert(DeleteRouteRequest, "You must provide a DeleteRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DisableVpcClassicLink
-- @param DisableVpcClassicLinkRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisableVpcClassicLinkAsync(DisableVpcClassicLinkRequest, cb)
	assert(DisableVpcClassicLinkRequest, "You must provide a DisableVpcClassicLinkRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisableVpcClassicLink",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisableVpcClassicLinkRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AttachNetworkInterface
-- @param AttachNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachNetworkInterfaceAsync(AttachNetworkInterfaceRequest, cb)
	assert(AttachNetworkInterfaceRequest, "You must provide a AttachNetworkInterfaceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachNetworkInterfaceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateNatGateway
-- @param CreateNatGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNatGatewayAsync(CreateNatGatewayRequest, cb)
	assert(CreateNatGatewayRequest, "You must provide a CreateNatGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateNatGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateNatGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteVpnConnectionRoute
-- @param DeleteVpnConnectionRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpnConnectionRouteAsync(DeleteVpnConnectionRouteRequest, cb)
	assert(DeleteVpnConnectionRouteRequest, "You must provide a DeleteVpnConnectionRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpnConnectionRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpnConnectionRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CancelSpotInstanceRequests
-- @param CancelSpotInstanceRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelSpotInstanceRequestsAsync(CancelSpotInstanceRequestsRequest, cb)
	assert(CancelSpotInstanceRequestsRequest, "You must provide a CancelSpotInstanceRequestsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelSpotInstanceRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelSpotInstanceRequestsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateKeyPair
-- @param CreateKeyPairRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateKeyPairAsync(CreateKeyPairRequest, cb)
	assert(CreateKeyPairRequest, "You must provide a CreateKeyPairRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateKeyPair",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateKeyPairRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeNetworkInterfaceAttribute
-- @param DescribeNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNetworkInterfaceAttributeAsync(DescribeNetworkInterfaceAttributeRequest, cb)
	assert(DescribeNetworkInterfaceAttributeRequest, "You must provide a DescribeNetworkInterfaceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeNetworkInterfaceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeNetworkInterfaceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeIdFormat
-- @param DescribeIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeIdFormatAsync(DescribeIdFormatRequest, cb)
	assert(DescribeIdFormatRequest, "You must provide a DescribeIdFormatRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeIdFormatRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteSnapshot
-- @param DeleteSnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSnapshotAsync(DeleteSnapshotRequest, cb)
	assert(DeleteSnapshotRequest, "You must provide a DeleteSnapshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteSnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteSnapshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeMovingAddresses
-- @param DescribeMovingAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeMovingAddressesAsync(DescribeMovingAddressesRequest, cb)
	assert(DescribeMovingAddressesRequest, "You must provide a DescribeMovingAddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeMovingAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeMovingAddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeInstanceAttribute
-- @param DescribeInstanceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInstanceAttributeAsync(DescribeInstanceAttributeRequest, cb)
	assert(DescribeInstanceAttributeRequest, "You must provide a DescribeInstanceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeInstanceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeInstanceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeregisterImage
-- @param DeregisterImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeregisterImageAsync(DeregisterImageRequest, cb)
	assert(DeregisterImageRequest, "You must provide a DeregisterImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeregisterImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeregisterImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteVpnGateway
-- @param DeleteVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpnGatewayAsync(DeleteVpnGatewayRequest, cb)
	assert(DeleteVpnGatewayRequest, "You must provide a DeleteVpnGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpnGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ReportInstanceStatus
-- @param ReportInstanceStatusRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReportInstanceStatusAsync(ReportInstanceStatusRequest, cb)
	assert(ReportInstanceStatusRequest, "You must provide a ReportInstanceStatusRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReportInstanceStatus",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReportInstanceStatusRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CancelReservedInstancesListing
-- @param CancelReservedInstancesListingRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelReservedInstancesListingAsync(CancelReservedInstancesListingRequest, cb)
	assert(CancelReservedInstancesListingRequest, "You must provide a CancelReservedInstancesListingRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelReservedInstancesListing",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelReservedInstancesListingRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribePrefixLists
-- @param DescribePrefixListsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribePrefixListsAsync(DescribePrefixListsRequest, cb)
	assert(DescribePrefixListsRequest, "You must provide a DescribePrefixListsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribePrefixLists",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribePrefixListsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSnapshotAttribute
-- @param DescribeSnapshotAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSnapshotAttributeAsync(DescribeSnapshotAttributeRequest, cb)
	assert(DescribeSnapshotAttributeRequest, "You must provide a DescribeSnapshotAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSnapshotAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSnapshotAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- PurchaseReservedInstancesOffering
-- @param PurchaseReservedInstancesOfferingRequest
-- @param cb Callback function accepting two args: response, error_message
function M.PurchaseReservedInstancesOfferingAsync(PurchaseReservedInstancesOfferingRequest, cb)
	assert(PurchaseReservedInstancesOfferingRequest, "You must provide a PurchaseReservedInstancesOfferingRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".PurchaseReservedInstancesOffering",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", PurchaseReservedInstancesOfferingRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifySubnetAttribute
-- @param ModifySubnetAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifySubnetAttributeAsync(ModifySubnetAttributeRequest, cb)
	assert(ModifySubnetAttributeRequest, "You must provide a ModifySubnetAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifySubnetAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifySubnetAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeNetworkInterfaces
-- @param DescribeNetworkInterfacesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNetworkInterfacesAsync(DescribeNetworkInterfacesRequest, cb)
	assert(DescribeNetworkInterfacesRequest, "You must provide a DescribeNetworkInterfacesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeNetworkInterfaces",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeNetworkInterfacesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ConfirmProductInstance
-- @param ConfirmProductInstanceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ConfirmProductInstanceAsync(ConfirmProductInstanceRequest, cb)
	assert(ConfirmProductInstanceRequest, "You must provide a ConfirmProductInstanceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ConfirmProductInstance",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ConfirmProductInstanceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeExportTasks
-- @param DescribeExportTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeExportTasksAsync(DescribeExportTasksRequest, cb)
	assert(DescribeExportTasksRequest, "You must provide a DescribeExportTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeExportTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeExportTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DetachInternetGateway
-- @param DetachInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachInternetGatewayAsync(DetachInternetGatewayRequest, cb)
	assert(DetachInternetGatewayRequest, "You must provide a DetachInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteNetworkAclEntry
-- @param DeleteNetworkAclEntryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNetworkAclEntryAsync(DeleteNetworkAclEntryRequest, cb)
	assert(DeleteNetworkAclEntryRequest, "You must provide a DeleteNetworkAclEntryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteNetworkAclEntry",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteNetworkAclEntryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateFpgaImage
-- @param CreateFpgaImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateFpgaImageAsync(CreateFpgaImageRequest, cb)
	assert(CreateFpgaImageRequest, "You must provide a CreateFpgaImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateFpgaImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateFpgaImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateCustomerGateway
-- @param CreateCustomerGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateCustomerGatewayAsync(CreateCustomerGatewayRequest, cb)
	assert(CreateCustomerGatewayRequest, "You must provide a CreateCustomerGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateCustomerGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateCustomerGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ResetInstanceAttribute
-- @param ResetInstanceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetInstanceAttributeAsync(ResetInstanceAttributeRequest, cb)
	assert(ResetInstanceAttributeRequest, "You must provide a ResetInstanceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ResetInstanceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ResetInstanceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateSecurityGroup
-- @param CreateSecurityGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSecurityGroupAsync(CreateSecurityGroupRequest, cb)
	assert(CreateSecurityGroupRequest, "You must provide a CreateSecurityGroupRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateSecurityGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateSecurityGroupRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeInternetGateways
-- @param DescribeInternetGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInternetGatewaysAsync(DescribeInternetGatewaysRequest, cb)
	assert(DescribeInternetGatewaysRequest, "You must provide a DescribeInternetGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeInternetGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeInternetGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyNetworkInterfaceAttribute
-- @param ModifyNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyNetworkInterfaceAttributeAsync(ModifyNetworkInterfaceAttributeRequest, cb)
	assert(ModifyNetworkInterfaceAttributeRequest, "You must provide a ModifyNetworkInterfaceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyNetworkInterfaceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyNetworkInterfaceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AttachVolume
-- @param AttachVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachVolumeAsync(AttachVolumeRequest, cb)
	assert(AttachVolumeRequest, "You must provide a AttachVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSnapshots
-- @param DescribeSnapshotsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSnapshotsAsync(DescribeSnapshotsRequest, cb)
	assert(DescribeSnapshotsRequest, "You must provide a DescribeSnapshotsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSnapshots",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSnapshotsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- TerminateInstances
-- @param TerminateInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.TerminateInstancesAsync(TerminateInstancesRequest, cb)
	assert(TerminateInstancesRequest, "You must provide a TerminateInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".TerminateInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", TerminateInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AcceptReservedInstancesExchangeQuote
-- @param AcceptReservedInstancesExchangeQuoteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AcceptReservedInstancesExchangeQuoteAsync(AcceptReservedInstancesExchangeQuoteRequest, cb)
	assert(AcceptReservedInstancesExchangeQuoteRequest, "You must provide a AcceptReservedInstancesExchangeQuoteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AcceptReservedInstancesExchangeQuote",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AcceptReservedInstancesExchangeQuoteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteSpotDatafeedSubscription
-- @param DeleteSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSpotDatafeedSubscriptionAsync(DeleteSpotDatafeedSubscriptionRequest, cb)
	assert(DeleteSpotDatafeedSubscriptionRequest, "You must provide a DeleteSpotDatafeedSubscriptionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteSpotDatafeedSubscription",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteSpotDatafeedSubscriptionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeletePlacementGroup
-- @param DeletePlacementGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeletePlacementGroupAsync(DeletePlacementGroupRequest, cb)
	assert(DeletePlacementGroupRequest, "You must provide a DeletePlacementGroupRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeletePlacementGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeletePlacementGroupRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteRouteTable
-- @param DeleteRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteRouteTableAsync(DeleteRouteTableRequest, cb)
	assert(DeleteRouteTableRequest, "You must provide a DeleteRouteTableRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteRouteTableRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeKeyPairs
-- @param DescribeKeyPairsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeKeyPairsAsync(DescribeKeyPairsRequest, cb)
	assert(DescribeKeyPairsRequest, "You must provide a DescribeKeyPairsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeKeyPairs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeKeyPairsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeStaleSecurityGroups
-- @param DescribeStaleSecurityGroupsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeStaleSecurityGroupsAsync(DescribeStaleSecurityGroupsRequest, cb)
	assert(DescribeStaleSecurityGroupsRequest, "You must provide a DescribeStaleSecurityGroupsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeStaleSecurityGroups",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeStaleSecurityGroupsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeReservedInstancesOfferings
-- @param DescribeReservedInstancesOfferingsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesOfferingsAsync(DescribeReservedInstancesOfferingsRequest, cb)
	assert(DescribeReservedInstancesOfferingsRequest, "You must provide a DescribeReservedInstancesOfferingsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesOfferings",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeReservedInstancesOfferingsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- GetConsoleScreenshot
-- @param GetConsoleScreenshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetConsoleScreenshotAsync(GetConsoleScreenshotRequest, cb)
	assert(GetConsoleScreenshotRequest, "You must provide a GetConsoleScreenshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetConsoleScreenshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetConsoleScreenshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeAccountAttributes
-- @param DescribeAccountAttributesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeAccountAttributesAsync(DescribeAccountAttributesRequest, cb)
	assert(DescribeAccountAttributesRequest, "You must provide a DescribeAccountAttributesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeAccountAttributes",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeAccountAttributesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AssignIpv6Addresses
-- @param AssignIpv6AddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssignIpv6AddressesAsync(AssignIpv6AddressesRequest, cb)
	assert(AssignIpv6AddressesRequest, "You must provide a AssignIpv6AddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssignIpv6Addresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssignIpv6AddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AuthorizeSecurityGroupEgress
-- @param AuthorizeSecurityGroupEgressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AuthorizeSecurityGroupEgressAsync(AuthorizeSecurityGroupEgressRequest, cb)
	assert(AuthorizeSecurityGroupEgressRequest, "You must provide a AuthorizeSecurityGroupEgressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AuthorizeSecurityGroupEgress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AuthorizeSecurityGroupEgressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AllocateAddress
-- @param AllocateAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AllocateAddressAsync(AllocateAddressRequest, cb)
	assert(AllocateAddressRequest, "You must provide a AllocateAddressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AllocateAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AllocateAddressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AuthorizeSecurityGroupIngress
-- @param AuthorizeSecurityGroupIngressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AuthorizeSecurityGroupIngressAsync(AuthorizeSecurityGroupIngressRequest, cb)
	assert(AuthorizeSecurityGroupIngressRequest, "You must provide a AuthorizeSecurityGroupIngressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AuthorizeSecurityGroupIngress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AuthorizeSecurityGroupIngressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateSpotDatafeedSubscription
-- @param CreateSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSpotDatafeedSubscriptionAsync(CreateSpotDatafeedSubscriptionRequest, cb)
	assert(CreateSpotDatafeedSubscriptionRequest, "You must provide a CreateSpotDatafeedSubscriptionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateSpotDatafeedSubscription",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateSpotDatafeedSubscriptionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ImportInstance
-- @param ImportInstanceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportInstanceAsync(ImportInstanceRequest, cb)
	assert(ImportInstanceRequest, "You must provide a ImportInstanceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportInstance",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportInstanceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- StopInstances
-- @param StopInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.StopInstancesAsync(StopInstancesRequest, cb)
	assert(StopInstancesRequest, "You must provide a StopInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".StopInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", StopInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ReleaseAddress
-- @param ReleaseAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReleaseAddressAsync(ReleaseAddressRequest, cb)
	assert(ReleaseAddressRequest, "You must provide a ReleaseAddressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReleaseAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReleaseAddressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeFpgaImages
-- @param DescribeFpgaImagesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeFpgaImagesAsync(DescribeFpgaImagesRequest, cb)
	assert(DescribeFpgaImagesRequest, "You must provide a DescribeFpgaImagesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeFpgaImages",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeFpgaImagesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RejectVpcPeeringConnection
-- @param RejectVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RejectVpcPeeringConnectionAsync(RejectVpcPeeringConnectionRequest, cb)
	assert(RejectVpcPeeringConnectionRequest, "You must provide a RejectVpcPeeringConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RejectVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RejectVpcPeeringConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- MonitorInstances
-- @param MonitorInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.MonitorInstancesAsync(MonitorInstancesRequest, cb)
	assert(MonitorInstancesRequest, "You must provide a MonitorInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".MonitorInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", MonitorInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeImages
-- @param DescribeImagesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImagesAsync(DescribeImagesRequest, cb)
	assert(DescribeImagesRequest, "You must provide a DescribeImagesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeImages",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeImagesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DisassociateRouteTable
-- @param DisassociateRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateRouteTableAsync(DisassociateRouteTableRequest, cb)
	assert(DisassociateRouteTableRequest, "You must provide a DisassociateRouteTableRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateRouteTableRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ReplaceRoute
-- @param ReplaceRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceRouteAsync(ReplaceRouteRequest, cb)
	assert(ReplaceRouteRequest, "You must provide a ReplaceRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- AssociateRouteTable
-- @param AssociateRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateRouteTableAsync(AssociateRouteTableRequest, cb)
	assert(AssociateRouteTableRequest, "You must provide a AssociateRouteTableRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateRouteTableRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteVpc
-- @param DeleteVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpcAsync(DeleteVpcRequest, cb)
	assert(DeleteVpcRequest, "You must provide a DeleteVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSpotDatafeedSubscription
-- @param DescribeSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotDatafeedSubscriptionAsync(DescribeSpotDatafeedSubscriptionRequest, cb)
	assert(DescribeSpotDatafeedSubscriptionRequest, "You must provide a DescribeSpotDatafeedSubscriptionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotDatafeedSubscription",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotDatafeedSubscriptionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribePlacementGroups
-- @param DescribePlacementGroupsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribePlacementGroupsAsync(DescribePlacementGroupsRequest, cb)
	assert(DescribePlacementGroupsRequest, "You must provide a DescribePlacementGroupsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribePlacementGroups",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribePlacementGroupsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeInstances
-- @param DescribeInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInstancesAsync(DescribeInstancesRequest, cb)
	assert(DescribeInstancesRequest, "You must provide a DescribeInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateRoute
-- @param CreateRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateRouteAsync(CreateRouteRequest, cb)
	assert(CreateRouteRequest, "You must provide a CreateRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteEgressOnlyInternetGateway
-- @param DeleteEgressOnlyInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteEgressOnlyInternetGatewayAsync(DeleteEgressOnlyInternetGatewayRequest, cb)
	assert(DeleteEgressOnlyInternetGatewayRequest, "You must provide a DeleteEgressOnlyInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteEgressOnlyInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteEgressOnlyInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSecurityGroups
-- @param DescribeSecurityGroupsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSecurityGroupsAsync(DescribeSecurityGroupsRequest, cb)
	assert(DescribeSecurityGroupsRequest, "You must provide a DescribeSecurityGroupsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSecurityGroups",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSecurityGroupsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateDhcpOptions
-- @param CreateDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateDhcpOptionsAsync(CreateDhcpOptionsRequest, cb)
	assert(CreateDhcpOptionsRequest, "You must provide a CreateDhcpOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateDhcpOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RevokeSecurityGroupEgress
-- @param RevokeSecurityGroupEgressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RevokeSecurityGroupEgressAsync(RevokeSecurityGroupEgressRequest, cb)
	assert(RevokeSecurityGroupEgressRequest, "You must provide a RevokeSecurityGroupEgressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RevokeSecurityGroupEgress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RevokeSecurityGroupEgressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateVpnGateway
-- @param CreateVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpnGatewayAsync(CreateVpnGatewayRequest, cb)
	assert(CreateVpnGatewayRequest, "You must provide a CreateVpnGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpnGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeBundleTasks
-- @param DescribeBundleTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeBundleTasksAsync(DescribeBundleTasksRequest, cb)
	assert(DescribeBundleTasksRequest, "You must provide a DescribeBundleTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeBundleTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeBundleTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeReservedInstancesListings
-- @param DescribeReservedInstancesListingsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesListingsAsync(DescribeReservedInstancesListingsRequest, cb)
	assert(DescribeReservedInstancesListingsRequest, "You must provide a DescribeReservedInstancesListingsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesListings",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeReservedInstancesListingsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- GetReservedInstancesExchangeQuote
-- @param GetReservedInstancesExchangeQuoteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetReservedInstancesExchangeQuoteAsync(GetReservedInstancesExchangeQuoteRequest, cb)
	assert(GetReservedInstancesExchangeQuoteRequest, "You must provide a GetReservedInstancesExchangeQuoteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetReservedInstancesExchangeQuote",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetReservedInstancesExchangeQuoteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeClassicLinkInstances
-- @param DescribeClassicLinkInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeClassicLinkInstancesAsync(DescribeClassicLinkInstancesRequest, cb)
	assert(DescribeClassicLinkInstancesRequest, "You must provide a DescribeClassicLinkInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeClassicLinkInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeClassicLinkInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifySpotFleetRequest
-- @param ModifySpotFleetRequestRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifySpotFleetRequestAsync(ModifySpotFleetRequestRequest, cb)
	assert(ModifySpotFleetRequestRequest, "You must provide a ModifySpotFleetRequestRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifySpotFleetRequest",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifySpotFleetRequestRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteVolume
-- @param DeleteVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVolumeAsync(DeleteVolumeRequest, cb)
	assert(DeleteVolumeRequest, "You must provide a DeleteVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeConversionTasks
-- @param DescribeConversionTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeConversionTasksAsync(DescribeConversionTasksRequest, cb)
	assert(DescribeConversionTasksRequest, "You must provide a DescribeConversionTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeConversionTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeConversionTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVpcClassicLinkDnsSupport
-- @param DescribeVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcClassicLinkDnsSupportAsync(DescribeVpcClassicLinkDnsSupportRequest, cb)
	assert(DescribeVpcClassicLinkDnsSupportRequest, "You must provide a DescribeVpcClassicLinkDnsSupportRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcClassicLinkDnsSupport",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcClassicLinkDnsSupportRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteSecurityGroup
-- @param DeleteSecurityGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSecurityGroupAsync(DeleteSecurityGroupRequest, cb)
	assert(DeleteSecurityGroupRequest, "You must provide a DeleteSecurityGroupRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteSecurityGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteSecurityGroupRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSubnets
-- @param DescribeSubnetsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSubnetsAsync(DescribeSubnetsRequest, cb)
	assert(DescribeSubnetsRequest, "You must provide a DescribeSubnetsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSubnets",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSubnetsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeVpcClassicLink
-- @param DescribeVpcClassicLinkRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcClassicLinkAsync(DescribeVpcClassicLinkRequest, cb)
	assert(DescribeVpcClassicLinkRequest, "You must provide a DescribeVpcClassicLinkRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcClassicLink",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcClassicLinkRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeIdentityIdFormat
-- @param DescribeIdentityIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeIdentityIdFormatAsync(DescribeIdentityIdFormatRequest, cb)
	assert(DescribeIdentityIdFormatRequest, "You must provide a DescribeIdentityIdFormatRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeIdentityIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeIdentityIdFormatRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyVpcPeeringConnectionOptions
-- @param ModifyVpcPeeringConnectionOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVpcPeeringConnectionOptionsAsync(ModifyVpcPeeringConnectionOptionsRequest, cb)
	assert(ModifyVpcPeeringConnectionOptionsRequest, "You must provide a ModifyVpcPeeringConnectionOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVpcPeeringConnectionOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVpcPeeringConnectionOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyVolumeAttribute
-- @param ModifyVolumeAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVolumeAttributeAsync(ModifyVolumeAttributeRequest, cb)
	assert(ModifyVolumeAttributeRequest, "You must provide a ModifyVolumeAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVolumeAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVolumeAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ImportVolume
-- @param ImportVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportVolumeAsync(ImportVolumeRequest, cb)
	assert(ImportVolumeRequest, "You must provide a ImportVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ImportSnapshot
-- @param ImportSnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportSnapshotAsync(ImportSnapshotRequest, cb)
	assert(ImportSnapshotRequest, "You must provide a ImportSnapshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportSnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportSnapshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- GetConsoleOutput
-- @param GetConsoleOutputRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetConsoleOutputAsync(GetConsoleOutputRequest, cb)
	assert(GetConsoleOutputRequest, "You must provide a GetConsoleOutputRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetConsoleOutput",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetConsoleOutputRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeTags
-- @param DescribeTagsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeTagsAsync(DescribeTagsRequest, cb)
	assert(DescribeTagsRequest, "You must provide a DescribeTagsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeTags",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeTagsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- EnableVgwRoutePropagation
-- @param EnableVgwRoutePropagationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVgwRoutePropagationAsync(EnableVgwRoutePropagationRequest, cb)
	assert(EnableVgwRoutePropagationRequest, "You must provide a EnableVgwRoutePropagationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".EnableVgwRoutePropagation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", EnableVgwRoutePropagationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyVpcEndpoint
-- @param ModifyVpcEndpointRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVpcEndpointAsync(ModifyVpcEndpointRequest, cb)
	assert(ModifyVpcEndpointRequest, "You must provide a ModifyVpcEndpointRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVpcEndpoint",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVpcEndpointRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeInstanceStatus
-- @param DescribeInstanceStatusRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInstanceStatusAsync(DescribeInstanceStatusRequest, cb)
	assert(DescribeInstanceStatusRequest, "You must provide a DescribeInstanceStatusRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeInstanceStatus",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeInstanceStatusRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyVpcAttribute
-- @param ModifyVpcAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVpcAttributeAsync(ModifyVpcAttributeRequest, cb)
	assert(ModifyVpcAttributeRequest, "You must provide a ModifyVpcAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVpcAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVpcAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- EnableVolumeIO
-- @param EnableVolumeIORequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVolumeIOAsync(EnableVolumeIORequest, cb)
	assert(EnableVolumeIORequest, "You must provide a EnableVolumeIORequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".EnableVolumeIO",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", EnableVolumeIORequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateTags
-- @param CreateTagsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateTagsAsync(CreateTagsRequest, cb)
	assert(CreateTagsRequest, "You must provide a CreateTagsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateTags",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateTagsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeSecurityGroupReferences
-- @param DescribeSecurityGroupReferencesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSecurityGroupReferencesAsync(DescribeSecurityGroupReferencesRequest, cb)
	assert(DescribeSecurityGroupReferencesRequest, "You must provide a DescribeSecurityGroupReferencesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSecurityGroupReferences",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSecurityGroupReferencesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DeleteFlowLogs
-- @param DeleteFlowLogsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteFlowLogsAsync(DeleteFlowLogsRequest, cb)
	assert(DeleteFlowLogsRequest, "You must provide a DeleteFlowLogsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteFlowLogs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteFlowLogsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ReplaceNetworkAclAssociation
-- @param ReplaceNetworkAclAssociationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceNetworkAclAssociationAsync(ReplaceNetworkAclAssociationRequest, cb)
	assert(ReplaceNetworkAclAssociationRequest, "You must provide a ReplaceNetworkAclAssociationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceNetworkAclAssociation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceNetworkAclAssociationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateVpnConnection
-- @param CreateVpnConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpnConnectionAsync(CreateVpnConnectionRequest, cb)
	assert(CreateVpnConnectionRequest, "You must provide a CreateVpnConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpnConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpnConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DetachClassicLinkVpc
-- @param DetachClassicLinkVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachClassicLinkVpcAsync(DetachClassicLinkVpcRequest, cb)
	assert(DetachClassicLinkVpcRequest, "You must provide a DetachClassicLinkVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachClassicLinkVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachClassicLinkVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- CreateReservedInstancesListing
-- @param CreateReservedInstancesListingRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateReservedInstancesListingAsync(CreateReservedInstancesListingRequest, cb)
	assert(CreateReservedInstancesListingRequest, "You must provide a CreateReservedInstancesListingRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateReservedInstancesListing",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateReservedInstancesListingRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeHostReservations
-- @param DescribeHostReservationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeHostReservationsAsync(DescribeHostReservationsRequest, cb)
	assert(DescribeHostReservationsRequest, "You must provide a DescribeHostReservationsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeHostReservations",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeHostReservationsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeEgressOnlyInternetGateways
-- @param DescribeEgressOnlyInternetGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeEgressOnlyInternetGatewaysAsync(DescribeEgressOnlyInternetGatewaysRequest, cb)
	assert(DescribeEgressOnlyInternetGatewaysRequest, "You must provide a DescribeEgressOnlyInternetGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeEgressOnlyInternetGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeEgressOnlyInternetGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyInstanceAttribute
-- @param ModifyInstanceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyInstanceAttributeAsync(ModifyInstanceAttributeRequest, cb)
	assert(ModifyInstanceAttributeRequest, "You must provide a ModifyInstanceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyInstanceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyInstanceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- ModifyVolume
-- @param ModifyVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVolumeAsync(ModifyVolumeRequest, cb)
	assert(ModifyVolumeRequest, "You must provide a ModifyVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- RunScheduledInstances
-- @param RunScheduledInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RunScheduledInstancesAsync(RunScheduledInstancesRequest, cb)
	assert(RunScheduledInstancesRequest, "You must provide a RunScheduledInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RunScheduledInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RunScheduledInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- DescribeScheduledInstanceAvailability
-- @param DescribeScheduledInstanceAvailabilityRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeScheduledInstanceAvailabilityAsync(DescribeScheduledInstanceAvailabilityRequest, cb)
	assert(DescribeScheduledInstanceAvailabilityRequest, "You must provide a DescribeScheduledInstanceAvailabilityRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeScheduledInstanceAvailability",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeScheduledInstanceAvailabilityRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end


return M

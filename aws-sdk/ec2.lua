--- GENERATED CODE - DO NOT MODIFY
-- Amazon Elastic Compute Cloud (ec2-2016-11-15)

local M = {}

M.metadata = {
	api_version = "2016-11-15",
	json_version = "",
	protocol = "ec2",
	checksum_format = "",
	endpoint_prefix = "ec2",
	service_abbreviation = "Amazon EC2",
	service_full_name = "Amazon Elastic Compute Cloud",
	signature_version = "v4",
	target_prefix = "",
	timestamp_format = "",
	global_endpoint = "",
	uid = "ec2-2016-11-15",
}

local keys = {}
local asserts = {}

keys.NetworkAcl = { ["Associations"] = true, ["NetworkAclId"] = true, ["VpcId"] = true, ["Tags"] = true, ["Entries"] = true, ["IsDefault"] = true, nil }

function asserts.AssertNetworkAcl(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAcl to be of type 'table'")
	if struct["Associations"] then asserts.AssertNetworkAclAssociationList(struct["Associations"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Entries"] then asserts.AssertNetworkAclEntryList(struct["Entries"]) end
	if struct["IsDefault"] then asserts.AssertBoolean(struct["IsDefault"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkAcl[k], "NetworkAcl contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAcl
-- <p>Describes a network ACL.</p>
-- @param _Associations [NetworkAclAssociationList] <p>Any associations between the network ACL and one or more subnets</p>
-- @param _NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param _VpcId [String] <p>The ID of the VPC for the network ACL.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the network ACL.</p>
-- @param _Entries [NetworkAclEntryList] <p>One or more entries (rules) in the network ACL.</p>
-- @param _IsDefault [Boolean] <p>Indicates whether this is the default network ACL for the VPC.</p>
function M.NetworkAcl(_Associations, _NetworkAclId, _VpcId, _Tags, _Entries, _IsDefault, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkAcl")
	local t = { 
		["Associations"] = _Associations,
		["NetworkAclId"] = _NetworkAclId,
		["VpcId"] = _VpcId,
		["Tags"] = _Tags,
		["Entries"] = _Entries,
		["IsDefault"] = _IsDefault,
	}
	asserts.AssertNetworkAcl(t)
	return t
end

keys.CreateSecurityGroupResult = { ["GroupId"] = true, nil }

function asserts.AssertCreateSecurityGroupResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityGroupResult to be of type 'table'")
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSecurityGroupResult[k], "CreateSecurityGroupResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityGroupResult
-- <p>Contains the output of CreateSecurityGroup.</p>
-- @param _GroupId [String] <p>The ID of the security group.</p>
function M.CreateSecurityGroupResult(_GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSecurityGroupResult")
	local t = { 
		["GroupId"] = _GroupId,
	}
	asserts.AssertCreateSecurityGroupResult(t)
	return t
end

keys.CreateFpgaImageResult = { ["FpgaImageId"] = true, ["FpgaImageGlobalId"] = true, nil }

function asserts.AssertCreateFpgaImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFpgaImageResult to be of type 'table'")
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["FpgaImageGlobalId"] then asserts.AssertString(struct["FpgaImageGlobalId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFpgaImageResult[k], "CreateFpgaImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFpgaImageResult
--  
-- @param _FpgaImageId [String] <p>The FPGA image identifier (AFI ID).</p>
-- @param _FpgaImageGlobalId [String] <p>The global FPGA image identifier (AGFI ID).</p>
function M.CreateFpgaImageResult(_FpgaImageId, _FpgaImageGlobalId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateFpgaImageResult")
	local t = { 
		["FpgaImageId"] = _FpgaImageId,
		["FpgaImageGlobalId"] = _FpgaImageGlobalId,
	}
	asserts.AssertCreateFpgaImageResult(t)
	return t
end

keys.VpcCidrBlockState = { ["State"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertVpcCidrBlockState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcCidrBlockState to be of type 'table'")
	if struct["State"] then asserts.AssertVpcCidrBlockStateCode(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcCidrBlockState[k], "VpcCidrBlockState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcCidrBlockState
-- <p>Describes the state of a CIDR block.</p>
-- @param _State [VpcCidrBlockStateCode] <p>The state of the CIDR block.</p>
-- @param _StatusMessage [String] <p>A message about the status of the CIDR block, if applicable.</p>
function M.VpcCidrBlockState(_State, _StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcCidrBlockState")
	local t = { 
		["State"] = _State,
		["StatusMessage"] = _StatusMessage,
	}
	asserts.AssertVpcCidrBlockState(t)
	return t
end

keys.InstanceBlockDeviceMapping = { ["DeviceName"] = true, ["Ebs"] = true, nil }

function asserts.AssertInstanceBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceBlockDeviceMapping to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["Ebs"] then asserts.AssertEbsInstanceBlockDevice(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceBlockDeviceMapping[k], "InstanceBlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceBlockDeviceMapping
-- <p>Describes a block device mapping.</p>
-- @param _DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param _Ebs [EbsInstanceBlockDevice] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
function M.InstanceBlockDeviceMapping(_DeviceName, _Ebs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceBlockDeviceMapping")
	local t = { 
		["DeviceName"] = _DeviceName,
		["Ebs"] = _Ebs,
	}
	asserts.AssertInstanceBlockDeviceMapping(t)
	return t
end

keys.ImportInstanceTaskDetails = { ["InstanceId"] = true, ["Platform"] = true, ["Description"] = true, ["Volumes"] = true, nil }

function asserts.AssertImportInstanceTaskDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceTaskDetails to be of type 'table'")
	assert(struct["Volumes"], "Expected key Volumes to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Volumes"] then asserts.AssertImportInstanceVolumeDetailSet(struct["Volumes"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceTaskDetails[k], "ImportInstanceTaskDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceTaskDetails
-- <p>Describes an import instance task.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _Platform [PlatformValues] <p>The instance operating system.</p>
-- @param _Description [String] <p>A description of the task.</p>
-- @param _Volumes [ImportInstanceVolumeDetailSet] <p>One or more volumes.</p>
-- Required parameter: Volumes
function M.ImportInstanceTaskDetails(_InstanceId, _Platform, _Description, _Volumes, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceTaskDetails")
	local t = { 
		["InstanceId"] = _InstanceId,
		["Platform"] = _Platform,
		["Description"] = _Description,
		["Volumes"] = _Volumes,
	}
	asserts.AssertImportInstanceTaskDetails(t)
	return t
end

keys.DescribeVpnConnectionsResult = { ["VpnConnections"] = true, nil }

function asserts.AssertDescribeVpnConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnConnectionsResult to be of type 'table'")
	if struct["VpnConnections"] then asserts.AssertVpnConnectionList(struct["VpnConnections"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnConnectionsResult[k], "DescribeVpnConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnConnectionsResult
-- <p>Contains the output of DescribeVpnConnections.</p>
-- @param _VpnConnections [VpnConnectionList] <p>Information about one or more VPN connections.</p>
function M.DescribeVpnConnectionsResult(_VpnConnections, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpnConnectionsResult")
	local t = { 
		["VpnConnections"] = _VpnConnections,
	}
	asserts.AssertDescribeVpnConnectionsResult(t)
	return t
end

keys.ReservedInstancesConfiguration = { ["Platform"] = true, ["AvailabilityZone"] = true, ["Scope"] = true, ["InstanceType"] = true, ["InstanceCount"] = true, nil }

function asserts.AssertReservedInstancesConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesConfiguration to be of type 'table'")
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Scope"] then asserts.Assertscope(struct["Scope"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesConfiguration[k], "ReservedInstancesConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesConfiguration
-- <p>Describes the configuration settings for the modified Reserved Instances.</p>
-- @param _Platform [String] <p>The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone for the modified Reserved Instances.</p>
-- @param _Scope [scope] <p>Whether the Reserved Instance is applied to instances in a region or instances in a specific Availability Zone.</p>
-- @param _InstanceType [InstanceType] <p>The instance type for the modified Reserved Instances.</p>
-- @param _InstanceCount [Integer] <p>The number of modified Reserved Instances.</p>
function M.ReservedInstancesConfiguration(_Platform, _AvailabilityZone, _Scope, _InstanceType, _InstanceCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesConfiguration")
	local t = { 
		["Platform"] = _Platform,
		["AvailabilityZone"] = _AvailabilityZone,
		["Scope"] = _Scope,
		["InstanceType"] = _InstanceType,
		["InstanceCount"] = _InstanceCount,
	}
	asserts.AssertReservedInstancesConfiguration(t)
	return t
end

keys.CreateVpcPeeringConnectionRequest = { ["VpcId"] = true, ["PeerOwnerId"] = true, ["PeerVpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcPeeringConnectionRequest to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PeerOwnerId"] then asserts.AssertString(struct["PeerOwnerId"]) end
	if struct["PeerVpcId"] then asserts.AssertString(struct["PeerVpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcPeeringConnectionRequest[k], "CreateVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcPeeringConnectionRequest
-- <p>Contains the parameters for CreateVpcPeeringConnection.</p>
-- @param _VpcId [String] <p>The ID of the requester VPC.</p>
-- @param _PeerOwnerId [String] <p>The AWS account ID of the owner of the peer VPC.</p> <p>Default: Your AWS account ID</p>
-- @param _PeerVpcId [String] <p>The ID of the VPC with which you are creating the VPC peering connection.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.CreateVpcPeeringConnectionRequest(_VpcId, _PeerOwnerId, _PeerVpcId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcPeeringConnectionRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["PeerOwnerId"] = _PeerOwnerId,
		["PeerVpcId"] = _PeerVpcId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertCreateVpcPeeringConnectionRequest(t)
	return t
end

keys.DeleteVpnConnectionRouteRequest = { ["VpnConnectionId"] = true, ["DestinationCidrBlock"] = true, nil }

function asserts.AssertDeleteVpnConnectionRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnConnectionRouteRequest to be of type 'table'")
	assert(struct["DestinationCidrBlock"], "Expected key DestinationCidrBlock to exist in table")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpnConnectionRouteRequest[k], "DeleteVpnConnectionRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnConnectionRouteRequest
-- <p>Contains the parameters for DeleteVpnConnectionRoute.</p>
-- @param _VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- @param _DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer network.</p>
-- Required parameter: DestinationCidrBlock
-- Required parameter: VpnConnectionId
function M.DeleteVpnConnectionRouteRequest(_VpnConnectionId, _DestinationCidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpnConnectionRouteRequest")
	local t = { 
		["VpnConnectionId"] = _VpnConnectionId,
		["DestinationCidrBlock"] = _DestinationCidrBlock,
	}
	asserts.AssertDeleteVpnConnectionRouteRequest(t)
	return t
end

keys.ScheduledInstancesNetworkInterface = { ["PrivateIpAddressConfigs"] = true, ["DeviceIndex"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["SubnetId"] = true, ["DeleteOnTermination"] = true, ["PrivateIpAddress"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, ["AssociatePublicIpAddress"] = true, ["SecondaryPrivateIpAddressCount"] = true, nil }

function asserts.AssertScheduledInstancesNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesNetworkInterface to be of type 'table'")
	if struct["PrivateIpAddressConfigs"] then asserts.AssertPrivateIpAddressConfigSet(struct["PrivateIpAddressConfigs"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then asserts.AssertScheduledInstancesSecurityGroupIdSet(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertScheduledInstancesIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then asserts.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesNetworkInterface[k], "ScheduledInstancesNetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesNetworkInterface
-- <p>Describes a network interface for a Scheduled Instance.</p>
-- @param _PrivateIpAddressConfigs [PrivateIpAddressConfigSet] <p>The private IPv4 addresses.</p>
-- @param _DeviceIndex [Integer] <p>The index of the device for the network interface attachment.</p>
-- @param _Description [String] <p>The description.</p>
-- @param _Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.</p>
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _DeleteOnTermination [Boolean] <p>Indicates whether to delete the interface when the instance is terminated.</p>
-- @param _PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- @param _Groups [ScheduledInstancesSecurityGroupIdSet] <p>The IDs of one or more security groups.</p>
-- @param _Ipv6Addresses [ScheduledInstancesIpv6AddressList] <p>One or more specific IPv6 addresses from the subnet range.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _AssociatePublicIpAddress [Boolean] <p>Indicates whether to assign a public IPv4 address to instances launched in a VPC. The public IPv4 address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>
-- @param _SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses.</p>
function M.ScheduledInstancesNetworkInterface(_PrivateIpAddressConfigs, _DeviceIndex, _Description, _Ipv6AddressCount, _SubnetId, _DeleteOnTermination, _PrivateIpAddress, _Groups, _Ipv6Addresses, _NetworkInterfaceId, _AssociatePublicIpAddress, _SecondaryPrivateIpAddressCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesNetworkInterface")
	local t = { 
		["PrivateIpAddressConfigs"] = _PrivateIpAddressConfigs,
		["DeviceIndex"] = _DeviceIndex,
		["Description"] = _Description,
		["Ipv6AddressCount"] = _Ipv6AddressCount,
		["SubnetId"] = _SubnetId,
		["DeleteOnTermination"] = _DeleteOnTermination,
		["PrivateIpAddress"] = _PrivateIpAddress,
		["Groups"] = _Groups,
		["Ipv6Addresses"] = _Ipv6Addresses,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["AssociatePublicIpAddress"] = _AssociatePublicIpAddress,
		["SecondaryPrivateIpAddressCount"] = _SecondaryPrivateIpAddressCount,
	}
	asserts.AssertScheduledInstancesNetworkInterface(t)
	return t
end

keys.GetPasswordDataRequest = { ["InstanceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertGetPasswordDataRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPasswordDataRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPasswordDataRequest[k], "GetPasswordDataRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPasswordDataRequest
-- <p>Contains the parameters for GetPasswordData.</p>
-- @param _InstanceId [String] <p>The ID of the Windows instance.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
function M.GetPasswordDataRequest(_InstanceId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetPasswordDataRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertGetPasswordDataRequest(t)
	return t
end

keys.DescribeImagesResult = { ["Images"] = true, nil }

function asserts.AssertDescribeImagesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImagesResult to be of type 'table'")
	if struct["Images"] then asserts.AssertImageList(struct["Images"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImagesResult[k], "DescribeImagesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImagesResult
-- <p>Contains the output of DescribeImages.</p>
-- @param _Images [ImageList] <p>Information about one or more images.</p>
function M.DescribeImagesResult(_Images, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImagesResult")
	local t = { 
		["Images"] = _Images,
	}
	asserts.AssertDescribeImagesResult(t)
	return t
end

keys.PurchaseScheduledInstancesResult = { ["ScheduledInstanceSet"] = true, nil }

function asserts.AssertPurchaseScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseScheduledInstancesResult to be of type 'table'")
	if struct["ScheduledInstanceSet"] then asserts.AssertPurchasedScheduledInstanceSet(struct["ScheduledInstanceSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseScheduledInstancesResult[k], "PurchaseScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseScheduledInstancesResult
-- <p>Contains the output of PurchaseScheduledInstances.</p>
-- @param _ScheduledInstanceSet [PurchasedScheduledInstanceSet] <p>Information about the Scheduled Instances.</p>
function M.PurchaseScheduledInstancesResult(_ScheduledInstanceSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseScheduledInstancesResult")
	local t = { 
		["ScheduledInstanceSet"] = _ScheduledInstanceSet,
	}
	asserts.AssertPurchaseScheduledInstancesResult(t)
	return t
end

keys.Host = { ["HostId"] = true, ["HostProperties"] = true, ["State"] = true, ["Instances"] = true, ["HostReservationId"] = true, ["AvailabilityZone"] = true, ["AvailableCapacity"] = true, ["ClientToken"] = true, ["AutoPlacement"] = true, nil }

function asserts.AssertHost(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Host to be of type 'table'")
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["HostProperties"] then asserts.AssertHostProperties(struct["HostProperties"]) end
	if struct["State"] then asserts.AssertAllocationState(struct["State"]) end
	if struct["Instances"] then asserts.AssertHostInstanceList(struct["Instances"]) end
	if struct["HostReservationId"] then asserts.AssertString(struct["HostReservationId"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["AvailableCapacity"] then asserts.AssertAvailableCapacity(struct["AvailableCapacity"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["AutoPlacement"] then asserts.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(keys.Host[k], "Host contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Host
-- <p>Describes the properties of the Dedicated Host.</p>
-- @param _HostId [String] <p>The ID of the Dedicated Host.</p>
-- @param _HostProperties [HostProperties] <p>The hardware specifications of the Dedicated Host.</p>
-- @param _State [AllocationState] <p>The Dedicated Host's state.</p>
-- @param _Instances [HostInstanceList] <p>The IDs and instance type that are currently running on the Dedicated Host.</p>
-- @param _HostReservationId [String] <p>The reservation ID of the Dedicated Host. This returns a <code>null</code> response if the Dedicated Host doesn't have an associated reservation.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone of the Dedicated Host.</p>
-- @param _AvailableCapacity [AvailableCapacity] <p>The number of new instances that can be launched onto the Dedicated Host.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. </p>
-- @param _AutoPlacement [AutoPlacement] <p>Whether auto-placement is on or off.</p>
function M.Host(_HostId, _HostProperties, _State, _Instances, _HostReservationId, _AvailabilityZone, _AvailableCapacity, _ClientToken, _AutoPlacement, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Host")
	local t = { 
		["HostId"] = _HostId,
		["HostProperties"] = _HostProperties,
		["State"] = _State,
		["Instances"] = _Instances,
		["HostReservationId"] = _HostReservationId,
		["AvailabilityZone"] = _AvailabilityZone,
		["AvailableCapacity"] = _AvailableCapacity,
		["ClientToken"] = _ClientToken,
		["AutoPlacement"] = _AutoPlacement,
	}
	asserts.AssertHost(t)
	return t
end

keys.CancelReservedInstancesListingRequest = { ["ReservedInstancesListingId"] = true, nil }

function asserts.AssertCancelReservedInstancesListingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelReservedInstancesListingRequest to be of type 'table'")
	assert(struct["ReservedInstancesListingId"], "Expected key ReservedInstancesListingId to exist in table")
	if struct["ReservedInstancesListingId"] then asserts.AssertString(struct["ReservedInstancesListingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelReservedInstancesListingRequest[k], "CancelReservedInstancesListingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelReservedInstancesListingRequest
-- <p>Contains the parameters for CancelReservedInstancesListing.</p>
-- @param _ReservedInstancesListingId [String] <p>The ID of the Reserved Instance listing.</p>
-- Required parameter: ReservedInstancesListingId
function M.CancelReservedInstancesListingRequest(_ReservedInstancesListingId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelReservedInstancesListingRequest")
	local t = { 
		["ReservedInstancesListingId"] = _ReservedInstancesListingId,
	}
	asserts.AssertCancelReservedInstancesListingRequest(t)
	return t
end

keys.CreateSubnetResult = { ["Subnet"] = true, nil }

function asserts.AssertCreateSubnetResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSubnetResult to be of type 'table'")
	if struct["Subnet"] then asserts.AssertSubnet(struct["Subnet"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSubnetResult[k], "CreateSubnetResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSubnetResult
-- <p>Contains the output of CreateSubnet.</p>
-- @param _Subnet [Subnet] <p>Information about the subnet.</p>
function M.CreateSubnetResult(_Subnet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSubnetResult")
	local t = { 
		["Subnet"] = _Subnet,
	}
	asserts.AssertCreateSubnetResult(t)
	return t
end

keys.DescribeTagsRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeTagsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeTagsRequest[k], "DescribeTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeTagsRequest
-- <p>Contains the parameters for DescribeTags.</p>
-- @param _NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>key</code> - The tag key.</p> </li> <li> <p> <code>resource-id</code> - The resource ID.</p> </li> <li> <p> <code>resource-type</code> - The resource type (<code>customer-gateway</code> | <code>dhcp-options</code> | <code>image</code> | <code>instance</code> | <code>internet-gateway</code> | <code>network-acl</code> | <code>network-interface</code> | <code>reserved-instances</code> | <code>route-table</code> | <code>security-group</code> | <code>snapshot</code> | <code>spot-instances-request</code> | <code>subnet</code> | <code>volume</code> | <code>vpc</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>).</p> </li> <li> <p> <code>value</code> - The tag value.</p> </li> </ul>
function M.DescribeTagsRequest(_NextToken, _DryRun, _MaxResults, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeTagsRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeTagsRequest(t)
	return t
end

keys.InstancePrivateIpAddress = { ["PrivateDnsName"] = true, ["PrivateIpAddress"] = true, ["Primary"] = true, ["Association"] = true, nil }

function asserts.AssertInstancePrivateIpAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstancePrivateIpAddress to be of type 'table'")
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["Association"] then asserts.AssertInstanceNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstancePrivateIpAddress[k], "InstancePrivateIpAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstancePrivateIpAddress
-- <p>Describes a private IPv4 address.</p>
-- @param _PrivateDnsName [String] <p>The private IPv4 DNS name.</p>
-- @param _PrivateIpAddress [String] <p>The private IPv4 address of the network interface.</p>
-- @param _Primary [Boolean] <p>Indicates whether this IPv4 address is the primary private IP address of the network interface.</p>
-- @param _Association [InstanceNetworkInterfaceAssociation] <p>The association information for an Elastic IP address for the network interface.</p>
function M.InstancePrivateIpAddress(_PrivateDnsName, _PrivateIpAddress, _Primary, _Association, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstancePrivateIpAddress")
	local t = { 
		["PrivateDnsName"] = _PrivateDnsName,
		["PrivateIpAddress"] = _PrivateIpAddress,
		["Primary"] = _Primary,
		["Association"] = _Association,
	}
	asserts.AssertInstancePrivateIpAddress(t)
	return t
end

keys.CreateInstanceExportTaskRequest = { ["InstanceId"] = true, ["TargetEnvironment"] = true, ["Description"] = true, ["ExportToS3Task"] = true, nil }

function asserts.AssertCreateInstanceExportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInstanceExportTaskRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["TargetEnvironment"] then asserts.AssertExportEnvironment(struct["TargetEnvironment"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ExportToS3Task"] then asserts.AssertExportToS3TaskSpecification(struct["ExportToS3Task"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInstanceExportTaskRequest[k], "CreateInstanceExportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInstanceExportTaskRequest
-- <p>Contains the parameters for CreateInstanceExportTask.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _TargetEnvironment [ExportEnvironment] <p>The target virtualization environment.</p>
-- @param _Description [String] <p>A description for the conversion task or the resource being exported. The maximum length is 255 bytes.</p>
-- @param _ExportToS3Task [ExportToS3TaskSpecification] <p>The format and location for an instance export task.</p>
-- Required parameter: InstanceId
function M.CreateInstanceExportTaskRequest(_InstanceId, _TargetEnvironment, _Description, _ExportToS3Task, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateInstanceExportTaskRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["TargetEnvironment"] = _TargetEnvironment,
		["Description"] = _Description,
		["ExportToS3Task"] = _ExportToS3Task,
	}
	asserts.AssertCreateInstanceExportTaskRequest(t)
	return t
end

keys.CreateInstanceExportTaskResult = { ["ExportTask"] = true, nil }

function asserts.AssertCreateInstanceExportTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInstanceExportTaskResult to be of type 'table'")
	if struct["ExportTask"] then asserts.AssertExportTask(struct["ExportTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInstanceExportTaskResult[k], "CreateInstanceExportTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInstanceExportTaskResult
-- <p>Contains the output for CreateInstanceExportTask.</p>
-- @param _ExportTask [ExportTask] <p>Information about the instance export task.</p>
function M.CreateInstanceExportTaskResult(_ExportTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateInstanceExportTaskResult")
	local t = { 
		["ExportTask"] = _ExportTask,
	}
	asserts.AssertCreateInstanceExportTaskResult(t)
	return t
end

keys.RejectVpcPeeringConnectionRequest = { ["DryRun"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertRejectVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcPeeringConnectionRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RejectVpcPeeringConnectionRequest[k], "RejectVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcPeeringConnectionRequest
-- <p>Contains the parameters for RejectVpcPeeringConnection.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required parameter: VpcPeeringConnectionId
function M.RejectVpcPeeringConnectionRequest(_DryRun, _VpcPeeringConnectionId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RejectVpcPeeringConnectionRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
	}
	asserts.AssertRejectVpcPeeringConnectionRequest(t)
	return t
end

keys.CopyImageResult = { ["ImageId"] = true, nil }

function asserts.AssertCopyImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyImageResult to be of type 'table'")
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopyImageResult[k], "CopyImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyImageResult
-- <p>Contains the output of CopyImage.</p>
-- @param _ImageId [String] <p>The ID of the new AMI.</p>
function M.CopyImageResult(_ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CopyImageResult")
	local t = { 
		["ImageId"] = _ImageId,
	}
	asserts.AssertCopyImageResult(t)
	return t
end

keys.Region = { ["Endpoint"] = true, ["RegionName"] = true, nil }

function asserts.AssertRegion(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Region to be of type 'table'")
	if struct["Endpoint"] then asserts.AssertString(struct["Endpoint"]) end
	if struct["RegionName"] then asserts.AssertString(struct["RegionName"]) end
	for k,_ in pairs(struct) do
		assert(keys.Region[k], "Region contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Region
-- <p>Describes a region.</p>
-- @param _Endpoint [String] <p>The region service endpoint.</p>
-- @param _RegionName [String] <p>The name of the region.</p>
function M.Region(_Endpoint, _RegionName, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Region")
	local t = { 
		["Endpoint"] = _Endpoint,
		["RegionName"] = _RegionName,
	}
	asserts.AssertRegion(t)
	return t
end

keys.AllocateHostsRequest = { ["ClientToken"] = true, ["Quantity"] = true, ["AvailabilityZone"] = true, ["InstanceType"] = true, ["AutoPlacement"] = true, nil }

function asserts.AssertAllocateHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateHostsRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["InstanceType"], "Expected key InstanceType to exist in table")
	assert(struct["Quantity"], "Expected key Quantity to exist in table")
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["Quantity"] then asserts.AssertInteger(struct["Quantity"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["AutoPlacement"] then asserts.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateHostsRequest[k], "AllocateHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateHostsRequest
-- <p>Contains the parameters for AllocateHosts.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. </p>
-- @param _Quantity [Integer] <p>The number of Dedicated Hosts you want to allocate to your account with these parameters.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone for the Dedicated Hosts.</p>
-- @param _InstanceType [String] <p>Specify the instance type that you want your Dedicated Hosts to be configured for. When you specify the instance type, that is the only instance type that you can launch onto that host.</p>
-- @param _AutoPlacement [AutoPlacement] <p>This is enabled by default. This property allows instances to be automatically placed onto available Dedicated Hosts, when you are launching instances without specifying a host ID.</p> <p>Default: Enabled</p>
-- Required parameter: AvailabilityZone
-- Required parameter: InstanceType
-- Required parameter: Quantity
function M.AllocateHostsRequest(_ClientToken, _Quantity, _AvailabilityZone, _InstanceType, _AutoPlacement, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AllocateHostsRequest")
	local t = { 
		["ClientToken"] = _ClientToken,
		["Quantity"] = _Quantity,
		["AvailabilityZone"] = _AvailabilityZone,
		["InstanceType"] = _InstanceType,
		["AutoPlacement"] = _AutoPlacement,
	}
	asserts.AssertAllocateHostsRequest(t)
	return t
end

keys.DescribeSpotFleetRequestHistoryResponse = { ["HistoryRecords"] = true, ["SpotFleetRequestId"] = true, ["NextToken"] = true, ["LastEvaluatedTime"] = true, ["StartTime"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestHistoryResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestHistoryResponse to be of type 'table'")
	assert(struct["HistoryRecords"], "Expected key HistoryRecords to exist in table")
	assert(struct["LastEvaluatedTime"], "Expected key LastEvaluatedTime to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["StartTime"], "Expected key StartTime to exist in table")
	if struct["HistoryRecords"] then asserts.AssertHistoryRecords(struct["HistoryRecords"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["LastEvaluatedTime"] then asserts.AssertDateTime(struct["LastEvaluatedTime"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestHistoryResponse[k], "DescribeSpotFleetRequestHistoryResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestHistoryResponse
-- <p>Contains the output of DescribeSpotFleetRequestHistory.</p>
-- @param _HistoryRecords [HistoryRecords] <p>Information about the events in the history of the Spot fleet request.</p>
-- @param _SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param _NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _LastEvaluatedTime [DateTime] <p>The last date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). All records up to this time were retrieved.</p> <p>If <code>nextToken</code> indicates that there are more results, this value is not present.</p>
-- @param _StartTime [DateTime] <p>The starting date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- Required parameter: HistoryRecords
-- Required parameter: LastEvaluatedTime
-- Required parameter: SpotFleetRequestId
-- Required parameter: StartTime
function M.DescribeSpotFleetRequestHistoryResponse(_HistoryRecords, _SpotFleetRequestId, _NextToken, _LastEvaluatedTime, _StartTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetRequestHistoryResponse")
	local t = { 
		["HistoryRecords"] = _HistoryRecords,
		["SpotFleetRequestId"] = _SpotFleetRequestId,
		["NextToken"] = _NextToken,
		["LastEvaluatedTime"] = _LastEvaluatedTime,
		["StartTime"] = _StartTime,
	}
	asserts.AssertDescribeSpotFleetRequestHistoryResponse(t)
	return t
end

keys.PurchaseReservedInstancesOfferingRequest = { ["ReservedInstancesOfferingId"] = true, ["InstanceCount"] = true, ["DryRun"] = true, ["LimitPrice"] = true, nil }

function asserts.AssertPurchaseReservedInstancesOfferingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseReservedInstancesOfferingRequest to be of type 'table'")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["ReservedInstancesOfferingId"], "Expected key ReservedInstancesOfferingId to exist in table")
	if struct["ReservedInstancesOfferingId"] then asserts.AssertString(struct["ReservedInstancesOfferingId"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["LimitPrice"] then asserts.AssertReservedInstanceLimitPrice(struct["LimitPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseReservedInstancesOfferingRequest[k], "PurchaseReservedInstancesOfferingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseReservedInstancesOfferingRequest
-- <p>Contains the parameters for PurchaseReservedInstancesOffering.</p>
-- @param _ReservedInstancesOfferingId [String] <p>The ID of the Reserved Instance offering to purchase.</p>
-- @param _InstanceCount [Integer] <p>The number of Reserved Instances to purchase.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _LimitPrice [ReservedInstanceLimitPrice] <p>Specified for Reserved Instance Marketplace offerings to limit the total order and ensure that the Reserved Instances are not purchased at unexpected prices.</p>
-- Required parameter: InstanceCount
-- Required parameter: ReservedInstancesOfferingId
function M.PurchaseReservedInstancesOfferingRequest(_ReservedInstancesOfferingId, _InstanceCount, _DryRun, _LimitPrice, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseReservedInstancesOfferingRequest")
	local t = { 
		["ReservedInstancesOfferingId"] = _ReservedInstancesOfferingId,
		["InstanceCount"] = _InstanceCount,
		["DryRun"] = _DryRun,
		["LimitPrice"] = _LimitPrice,
	}
	asserts.AssertPurchaseReservedInstancesOfferingRequest(t)
	return t
end

keys.FlowLog = { ["ResourceId"] = true, ["CreationTime"] = true, ["LogGroupName"] = true, ["TrafficType"] = true, ["FlowLogStatus"] = true, ["FlowLogId"] = true, ["DeliverLogsPermissionArn"] = true, ["DeliverLogsStatus"] = true, ["DeliverLogsErrorMessage"] = true, nil }

function asserts.AssertFlowLog(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FlowLog to be of type 'table'")
	if struct["ResourceId"] then asserts.AssertString(struct["ResourceId"]) end
	if struct["CreationTime"] then asserts.AssertDateTime(struct["CreationTime"]) end
	if struct["LogGroupName"] then asserts.AssertString(struct["LogGroupName"]) end
	if struct["TrafficType"] then asserts.AssertTrafficType(struct["TrafficType"]) end
	if struct["FlowLogStatus"] then asserts.AssertString(struct["FlowLogStatus"]) end
	if struct["FlowLogId"] then asserts.AssertString(struct["FlowLogId"]) end
	if struct["DeliverLogsPermissionArn"] then asserts.AssertString(struct["DeliverLogsPermissionArn"]) end
	if struct["DeliverLogsStatus"] then asserts.AssertString(struct["DeliverLogsStatus"]) end
	if struct["DeliverLogsErrorMessage"] then asserts.AssertString(struct["DeliverLogsErrorMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.FlowLog[k], "FlowLog contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FlowLog
-- <p>Describes a flow log.</p>
-- @param _ResourceId [String] <p>The ID of the resource on which the flow log was created.</p>
-- @param _CreationTime [DateTime] <p>The date and time the flow log was created.</p>
-- @param _LogGroupName [String] <p>The name of the flow log group.</p>
-- @param _TrafficType [TrafficType] <p>The type of traffic captured for the flow log.</p>
-- @param _FlowLogStatus [String] <p>The status of the flow log (<code>ACTIVE</code>).</p>
-- @param _FlowLogId [String] <p>The flow log ID.</p>
-- @param _DeliverLogsPermissionArn [String] <p>The ARN of the IAM role that posts logs to CloudWatch Logs.</p>
-- @param _DeliverLogsStatus [String] <p>The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p>
-- @param _DeliverLogsErrorMessage [String] <p>Information about the error that occurred. <code>Rate limited</code> indicates that CloudWatch logs throttling has been applied for one or more network interfaces, or that you've reached the limit on the number of CloudWatch Logs log groups that you can create. <code>Access error</code> indicates that the IAM role associated with the flow log does not have sufficient permissions to publish to CloudWatch Logs. <code>Unknown error</code> indicates an internal error.</p>
function M.FlowLog(_ResourceId, _CreationTime, _LogGroupName, _TrafficType, _FlowLogStatus, _FlowLogId, _DeliverLogsPermissionArn, _DeliverLogsStatus, _DeliverLogsErrorMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating FlowLog")
	local t = { 
		["ResourceId"] = _ResourceId,
		["CreationTime"] = _CreationTime,
		["LogGroupName"] = _LogGroupName,
		["TrafficType"] = _TrafficType,
		["FlowLogStatus"] = _FlowLogStatus,
		["FlowLogId"] = _FlowLogId,
		["DeliverLogsPermissionArn"] = _DeliverLogsPermissionArn,
		["DeliverLogsStatus"] = _DeliverLogsStatus,
		["DeliverLogsErrorMessage"] = _DeliverLogsErrorMessage,
	}
	asserts.AssertFlowLog(t)
	return t
end

keys.RequestSpotInstancesRequest = { ["InstanceCount"] = true, ["DryRun"] = true, ["LaunchGroup"] = true, ["BlockDurationMinutes"] = true, ["LaunchSpecification"] = true, ["AvailabilityZoneGroup"] = true, ["ClientToken"] = true, ["ValidUntil"] = true, ["ValidFrom"] = true, ["Type"] = true, ["SpotPrice"] = true, nil }

function asserts.AssertRequestSpotInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotInstancesRequest to be of type 'table'")
	assert(struct["SpotPrice"], "Expected key SpotPrice to exist in table")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["LaunchGroup"] then asserts.AssertString(struct["LaunchGroup"]) end
	if struct["BlockDurationMinutes"] then asserts.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["LaunchSpecification"] then asserts.AssertRequestSpotLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["AvailabilityZoneGroup"] then asserts.AssertString(struct["AvailabilityZoneGroup"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["Type"] then asserts.AssertSpotInstanceType(struct["Type"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotInstancesRequest[k], "RequestSpotInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotInstancesRequest
-- <p>Contains the parameters for RequestSpotInstances.</p>
-- @param _InstanceCount [Integer] <p>The maximum number of Spot instances to launch.</p> <p>Default: 1</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _LaunchGroup [String] <p>The instance launch group. Launch groups are Spot instances that launch together and terminate together.</p> <p>Default: Instances are launched and terminated individually</p>
-- @param _BlockDurationMinutes [Integer] <p>The required duration for the Spot instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p> <p>The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.</p> <p>Note that you can't specify an Availability Zone group or a launch group if you specify a duration.</p>
-- @param _LaunchSpecification [RequestSpotLaunchSpecification] <p>The launch specification.</p>
-- @param _AvailabilityZoneGroup [String] <p>The user-specified name for a logical grouping of bids.</p> <p>When you specify an Availability Zone group in a Spot Instance request, all Spot instances in the request are launched in the same Availability Zone. Instance proximity is maintained with this parameter, but the choice of Availability Zone is not. The group applies only to bids for Spot Instances of the same instance type. Any additional Spot instance requests that are specified with the same Availability Zone group name are launched in that same Availability Zone, as long as at least one instance from the group is still active.</p> <p>If there is no active instance running in the Availability Zone group that you specify for a new Spot instance request (all instances are terminated, the bid is expired, or the bid falls below current market), then Amazon EC2 launches the instance in any Availability Zone where the constraint can be met. Consequently, the subsequent set of Spot instances could be placed in a different zone from the original request, even if you specified the same Availability Zone group.</p> <p>Default: Instances are launched in any available Availability Zone.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param _ValidUntil [DateTime] <p>The end date of the request. If this is a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached.</p> <p>Default: The request is effective indefinitely.</p>
-- @param _ValidFrom [DateTime] <p>The start date of the request. If this is a one-time request, the request becomes active at this date and time and remains active until all instances launch, the request expires, or the request is canceled. If the request is persistent, the request becomes active at this date and time and remains active until it expires or is canceled.</p> <p>Default: The request is effective indefinitely.</p>
-- @param _Type [SpotInstanceType] <p>The Spot instance request type.</p> <p>Default: <code>one-time</code> </p>
-- @param _SpotPrice [String] <p>The maximum hourly price (bid) for any Spot instance launched to fulfill the request.</p>
-- Required parameter: SpotPrice
function M.RequestSpotInstancesRequest(_InstanceCount, _DryRun, _LaunchGroup, _BlockDurationMinutes, _LaunchSpecification, _AvailabilityZoneGroup, _ClientToken, _ValidUntil, _ValidFrom, _Type, _SpotPrice, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotInstancesRequest")
	local t = { 
		["InstanceCount"] = _InstanceCount,
		["DryRun"] = _DryRun,
		["LaunchGroup"] = _LaunchGroup,
		["BlockDurationMinutes"] = _BlockDurationMinutes,
		["LaunchSpecification"] = _LaunchSpecification,
		["AvailabilityZoneGroup"] = _AvailabilityZoneGroup,
		["ClientToken"] = _ClientToken,
		["ValidUntil"] = _ValidUntil,
		["ValidFrom"] = _ValidFrom,
		["Type"] = _Type,
		["SpotPrice"] = _SpotPrice,
	}
	asserts.AssertRequestSpotInstancesRequest(t)
	return t
end

keys.DisableVpcClassicLinkDnsSupportRequest = { ["VpcId"] = true, nil }

function asserts.AssertDisableVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkDnsSupportRequest[k], "DisableVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkDnsSupportRequest
-- <p>Contains the parameters for DisableVpcClassicLinkDnsSupport.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
function M.DisableVpcClassicLinkDnsSupportRequest(_VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVpcClassicLinkDnsSupportRequest")
	local t = { 
		["VpcId"] = _VpcId,
	}
	asserts.AssertDisableVpcClassicLinkDnsSupportRequest(t)
	return t
end

keys.BlobAttributeValue = { ["Value"] = true, nil }

function asserts.AssertBlobAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BlobAttributeValue to be of type 'table'")
	if struct["Value"] then asserts.AssertBlob(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(keys.BlobAttributeValue[k], "BlobAttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BlobAttributeValue
--  
-- @param _Value [Blob] 
function M.BlobAttributeValue(_Value, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BlobAttributeValue")
	local t = { 
		["Value"] = _Value,
	}
	asserts.AssertBlobAttributeValue(t)
	return t
end

keys.CancelSpotInstanceRequestsRequest = { ["SpotInstanceRequestIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertCancelSpotInstanceRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotInstanceRequestsRequest to be of type 'table'")
	assert(struct["SpotInstanceRequestIds"], "Expected key SpotInstanceRequestIds to exist in table")
	if struct["SpotInstanceRequestIds"] then asserts.AssertSpotInstanceRequestIdList(struct["SpotInstanceRequestIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotInstanceRequestsRequest[k], "CancelSpotInstanceRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotInstanceRequestsRequest
-- <p>Contains the parameters for CancelSpotInstanceRequests.</p>
-- @param _SpotInstanceRequestIds [SpotInstanceRequestIdList] <p>One or more Spot instance request IDs.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: SpotInstanceRequestIds
function M.CancelSpotInstanceRequestsRequest(_SpotInstanceRequestIds, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotInstanceRequestsRequest")
	local t = { 
		["SpotInstanceRequestIds"] = _SpotInstanceRequestIds,
		["DryRun"] = _DryRun,
	}
	asserts.AssertCancelSpotInstanceRequestsRequest(t)
	return t
end

keys.DeleteSnapshotRequest = { ["SnapshotId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSnapshotRequest to be of type 'table'")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSnapshotRequest[k], "DeleteSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSnapshotRequest
-- <p>Contains the parameters for DeleteSnapshot.</p>
-- @param _SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: SnapshotId
function M.DeleteSnapshotRequest(_SnapshotId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteSnapshotRequest")
	local t = { 
		["SnapshotId"] = _SnapshotId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteSnapshotRequest(t)
	return t
end

keys.DetachClassicLinkVpcRequest = { ["InstanceId"] = true, ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDetachClassicLinkVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachClassicLinkVpcRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachClassicLinkVpcRequest[k], "DetachClassicLinkVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachClassicLinkVpcRequest
-- <p>Contains the parameters for DetachClassicLinkVpc.</p>
-- @param _InstanceId [String] <p>The ID of the instance to unlink from the VPC.</p>
-- @param _VpcId [String] <p>The ID of the VPC to which the instance is linked.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
-- Required parameter: VpcId
function M.DetachClassicLinkVpcRequest(_InstanceId, _VpcId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachClassicLinkVpcRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDetachClassicLinkVpcRequest(t)
	return t
end

keys.SnapshotTaskDetail = { ["Status"] = true, ["Description"] = true, ["Format"] = true, ["Url"] = true, ["DiskImageSize"] = true, ["SnapshotId"] = true, ["Progress"] = true, ["StatusMessage"] = true, ["UserBucket"] = true, nil }

function asserts.AssertSnapshotTaskDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotTaskDetail to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["DiskImageSize"] then asserts.AssertDouble(struct["DiskImageSize"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["UserBucket"] then asserts.AssertUserBucketDetails(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnapshotTaskDetail[k], "SnapshotTaskDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotTaskDetail
-- <p>Details about the import snapshot task.</p>
-- @param _Status [String] <p>A brief status for the import snapshot task.</p>
-- @param _Description [String] <p>The description of the snapshot.</p>
-- @param _Format [String] <p>The format of the disk image from which the snapshot is created.</p>
-- @param _Url [String] <p>The URL of the disk image from which the snapshot is created.</p>
-- @param _DiskImageSize [Double] <p>The size of the disk in the snapshot, in GiB.</p>
-- @param _SnapshotId [String] <p>The snapshot ID of the disk being imported.</p>
-- @param _Progress [String] <p>The percentage of completion for the import snapshot task.</p>
-- @param _StatusMessage [String] <p>A detailed status message for the import snapshot task.</p>
-- @param _UserBucket [UserBucketDetails] <p>The S3 bucket for the disk image.</p>
function M.SnapshotTaskDetail(_Status, _Description, _Format, _Url, _DiskImageSize, _SnapshotId, _Progress, _StatusMessage, _UserBucket, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SnapshotTaskDetail")
	local t = { 
		["Status"] = _Status,
		["Description"] = _Description,
		["Format"] = _Format,
		["Url"] = _Url,
		["DiskImageSize"] = _DiskImageSize,
		["SnapshotId"] = _SnapshotId,
		["Progress"] = _Progress,
		["StatusMessage"] = _StatusMessage,
		["UserBucket"] = _UserBucket,
	}
	asserts.AssertSnapshotTaskDetail(t)
	return t
end

keys.Tag = { ["Value"] = true, ["Key"] = true, nil }

function asserts.AssertTag(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Tag to be of type 'table'")
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.Tag[k], "Tag contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Tag
-- <p>Describes a tag.</p>
-- @param _Value [String] <p>The value of the tag.</p> <p>Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.</p>
-- @param _Key [String] <p>The key of the tag.</p> <p>Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with <code>aws:</code> </p>
function M.Tag(_Value, _Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Tag")
	local t = { 
		["Value"] = _Value,
		["Key"] = _Key,
	}
	asserts.AssertTag(t)
	return t
end

keys.ScheduledInstancesPlacement = { ["GroupName"] = true, ["AvailabilityZone"] = true, nil }

function asserts.AssertScheduledInstancesPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesPlacement to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesPlacement[k], "ScheduledInstancesPlacement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesPlacement
-- <p>Describes the placement for a Scheduled Instance.</p>
-- @param _GroupName [String] <p>The name of the placement group.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone.</p>
function M.ScheduledInstancesPlacement(_GroupName, _AvailabilityZone, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesPlacement")
	local t = { 
		["GroupName"] = _GroupName,
		["AvailabilityZone"] = _AvailabilityZone,
	}
	asserts.AssertScheduledInstancesPlacement(t)
	return t
end

keys.DescribeFpgaImagesResult = { ["FpgaImages"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFpgaImagesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImagesResult to be of type 'table'")
	if struct["FpgaImages"] then asserts.AssertFpgaImageList(struct["FpgaImages"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFpgaImagesResult[k], "DescribeFpgaImagesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImagesResult
--  
-- @param _FpgaImages [FpgaImageList] <p>Information about one or more FPGA images.</p>
-- @param _NextToken [NextToken] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeFpgaImagesResult(_FpgaImages, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeFpgaImagesResult")
	local t = { 
		["FpgaImages"] = _FpgaImages,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeFpgaImagesResult(t)
	return t
end

keys.ModifyInstancePlacementResult = { ["Return"] = true, nil }

function asserts.AssertModifyInstancePlacementResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstancePlacementResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstancePlacementResult[k], "ModifyInstancePlacementResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstancePlacementResult
-- <p>Contains the output of ModifyInstancePlacement.</p>
-- @param _Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
function M.ModifyInstancePlacementResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyInstancePlacementResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertModifyInstancePlacementResult(t)
	return t
end

keys.DescribeSecurityGroupReferencesResult = { ["SecurityGroupReferenceSet"] = true, nil }

function asserts.AssertDescribeSecurityGroupReferencesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupReferencesResult to be of type 'table'")
	if struct["SecurityGroupReferenceSet"] then asserts.AssertSecurityGroupReferences(struct["SecurityGroupReferenceSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupReferencesResult[k], "DescribeSecurityGroupReferencesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupReferencesResult
--  
-- @param _SecurityGroupReferenceSet [SecurityGroupReferences] <p>Information about the VPCs with the referencing security groups.</p>
function M.DescribeSecurityGroupReferencesResult(_SecurityGroupReferenceSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSecurityGroupReferencesResult")
	local t = { 
		["SecurityGroupReferenceSet"] = _SecurityGroupReferenceSet,
	}
	asserts.AssertDescribeSecurityGroupReferencesResult(t)
	return t
end

keys.DescribeDhcpOptionsRequest = { ["DhcpOptionsIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDhcpOptionsRequest to be of type 'table'")
	if struct["DhcpOptionsIds"] then asserts.AssertDhcpOptionsIdStringList(struct["DhcpOptionsIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDhcpOptionsRequest[k], "DescribeDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDhcpOptionsRequest
-- <p>Contains the parameters for DescribeDhcpOptions.</p>
-- @param _DhcpOptionsIds [DhcpOptionsIdStringList] <p>The IDs of one or more DHCP options sets.</p> <p>Default: Describes all your DHCP options sets.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>dhcp-options-id</code> - The ID of a set of DHCP options.</p> </li> <li> <p> <code>key</code> - The key for one of the options (for example, <code>domain-name</code>).</p> </li> <li> <p> <code>value</code> - The value for one of the options.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
function M.DescribeDhcpOptionsRequest(_DhcpOptionsIds, _DryRun, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeDhcpOptionsRequest")
	local t = { 
		["DhcpOptionsIds"] = _DhcpOptionsIds,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeDhcpOptionsRequest(t)
	return t
end

keys.ScheduledInstanceRecurrence = { ["OccurrenceDaySet"] = true, ["Interval"] = true, ["Frequency"] = true, ["OccurrenceRelativeToEnd"] = true, ["OccurrenceUnit"] = true, nil }

function asserts.AssertScheduledInstanceRecurrence(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceRecurrence to be of type 'table'")
	if struct["OccurrenceDaySet"] then asserts.AssertOccurrenceDaySet(struct["OccurrenceDaySet"]) end
	if struct["Interval"] then asserts.AssertInteger(struct["Interval"]) end
	if struct["Frequency"] then asserts.AssertString(struct["Frequency"]) end
	if struct["OccurrenceRelativeToEnd"] then asserts.AssertBoolean(struct["OccurrenceRelativeToEnd"]) end
	if struct["OccurrenceUnit"] then asserts.AssertString(struct["OccurrenceUnit"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstanceRecurrence[k], "ScheduledInstanceRecurrence contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceRecurrence
-- <p>Describes the recurring schedule for a Scheduled Instance.</p>
-- @param _OccurrenceDaySet [OccurrenceDaySet] <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday).</p>
-- @param _Interval [Integer] <p>The interval quantity. The interval unit depends on the value of <code>frequency</code>. For example, every 2 weeks or every 2 months.</p>
-- @param _Frequency [String] <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
-- @param _OccurrenceRelativeToEnd [Boolean] <p>Indicates whether the occurrence is relative to the end of the specified week or month.</p>
-- @param _OccurrenceUnit [String] <p>The unit for <code>occurrenceDaySet</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>).</p>
function M.ScheduledInstanceRecurrence(_OccurrenceDaySet, _Interval, _Frequency, _OccurrenceRelativeToEnd, _OccurrenceUnit, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstanceRecurrence")
	local t = { 
		["OccurrenceDaySet"] = _OccurrenceDaySet,
		["Interval"] = _Interval,
		["Frequency"] = _Frequency,
		["OccurrenceRelativeToEnd"] = _OccurrenceRelativeToEnd,
		["OccurrenceUnit"] = _OccurrenceUnit,
	}
	asserts.AssertScheduledInstanceRecurrence(t)
	return t
end

keys.DescribeSecurityGroupsResult = { ["SecurityGroups"] = true, nil }

function asserts.AssertDescribeSecurityGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupsResult to be of type 'table'")
	if struct["SecurityGroups"] then asserts.AssertSecurityGroupList(struct["SecurityGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupsResult[k], "DescribeSecurityGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupsResult
-- <p>Contains the output of DescribeSecurityGroups.</p>
-- @param _SecurityGroups [SecurityGroupList] <p>Information about one or more security groups.</p>
function M.DescribeSecurityGroupsResult(_SecurityGroups, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSecurityGroupsResult")
	local t = { 
		["SecurityGroups"] = _SecurityGroups,
	}
	asserts.AssertDescribeSecurityGroupsResult(t)
	return t
end

keys.CancelExportTaskRequest = { ["ExportTaskId"] = true, nil }

function asserts.AssertCancelExportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelExportTaskRequest to be of type 'table'")
	assert(struct["ExportTaskId"], "Expected key ExportTaskId to exist in table")
	if struct["ExportTaskId"] then asserts.AssertString(struct["ExportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelExportTaskRequest[k], "CancelExportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelExportTaskRequest
-- <p>Contains the parameters for CancelExportTask.</p>
-- @param _ExportTaskId [String] <p>The ID of the export task. This is the ID returned by <code>CreateInstanceExportTask</code>.</p>
-- Required parameter: ExportTaskId
function M.CancelExportTaskRequest(_ExportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelExportTaskRequest")
	local t = { 
		["ExportTaskId"] = _ExportTaskId,
	}
	asserts.AssertCancelExportTaskRequest(t)
	return t
end

keys.ModifyReservedInstancesResult = { ["ReservedInstancesModificationId"] = true, nil }

function asserts.AssertModifyReservedInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyReservedInstancesResult to be of type 'table'")
	if struct["ReservedInstancesModificationId"] then asserts.AssertString(struct["ReservedInstancesModificationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyReservedInstancesResult[k], "ModifyReservedInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyReservedInstancesResult
-- <p>Contains the output of ModifyReservedInstances.</p>
-- @param _ReservedInstancesModificationId [String] <p>The ID for the modification.</p>
function M.ModifyReservedInstancesResult(_ReservedInstancesModificationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyReservedInstancesResult")
	local t = { 
		["ReservedInstancesModificationId"] = _ReservedInstancesModificationId,
	}
	asserts.AssertModifyReservedInstancesResult(t)
	return t
end

keys.DeleteDhcpOptionsRequest = { ["DryRun"] = true, ["DhcpOptionsId"] = true, nil }

function asserts.AssertDeleteDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpOptionsId"], "Expected key DhcpOptionsId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteDhcpOptionsRequest[k], "DeleteDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteDhcpOptionsRequest
-- <p>Contains the parameters for DeleteDhcpOptions.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _DhcpOptionsId [String] <p>The ID of the DHCP options set.</p>
-- Required parameter: DhcpOptionsId
function M.DeleteDhcpOptionsRequest(_DryRun, _DhcpOptionsId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteDhcpOptionsRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["DhcpOptionsId"] = _DhcpOptionsId,
	}
	asserts.AssertDeleteDhcpOptionsRequest(t)
	return t
end

keys.CreateEgressOnlyInternetGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateEgressOnlyInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateEgressOnlyInternetGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateEgressOnlyInternetGatewayRequest[k], "CreateEgressOnlyInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateEgressOnlyInternetGatewayRequest
--  
-- @param _VpcId [String] <p>The ID of the VPC for which to create the egress-only Internet gateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required parameter: VpcId
function M.CreateEgressOnlyInternetGatewayRequest(_VpcId, _DryRun, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateEgressOnlyInternetGatewayRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertCreateEgressOnlyInternetGatewayRequest(t)
	return t
end

keys.DescribeInstancesResult = { ["Reservations"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancesResult to be of type 'table'")
	if struct["Reservations"] then asserts.AssertReservationList(struct["Reservations"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancesResult[k], "DescribeInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancesResult
-- <p>Contains the output of DescribeInstances.</p>
-- @param _Reservations [ReservationList] <p>Zero or more reservations.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeInstancesResult(_Reservations, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstancesResult")
	local t = { 
		["Reservations"] = _Reservations,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeInstancesResult(t)
	return t
end

keys.SnapshotDetail = { ["Status"] = true, ["DeviceName"] = true, ["Description"] = true, ["Format"] = true, ["Url"] = true, ["DiskImageSize"] = true, ["Progress"] = true, ["SnapshotId"] = true, ["StatusMessage"] = true, ["UserBucket"] = true, nil }

function asserts.AssertSnapshotDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotDetail to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["DiskImageSize"] then asserts.AssertDouble(struct["DiskImageSize"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["UserBucket"] then asserts.AssertUserBucketDetails(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnapshotDetail[k], "SnapshotDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotDetail
-- <p>Describes the snapshot created from the imported disk.</p>
-- @param _Status [String] <p>A brief status of the snapshot creation.</p>
-- @param _DeviceName [String] <p>The block device mapping for the snapshot.</p>
-- @param _Description [String] <p>A description for the snapshot.</p>
-- @param _Format [String] <p>The format of the disk image from which the snapshot is created.</p>
-- @param _Url [String] <p>The URL used to access the disk image.</p>
-- @param _DiskImageSize [Double] <p>The size of the disk in the snapshot, in GiB.</p>
-- @param _Progress [String] <p>The percentage of progress for the task.</p>
-- @param _SnapshotId [String] <p>The snapshot ID of the disk being imported.</p>
-- @param _StatusMessage [String] <p>A detailed status message for the snapshot creation.</p>
-- @param _UserBucket [UserBucketDetails] <p>The S3 bucket for the disk image.</p>
function M.SnapshotDetail(_Status, _DeviceName, _Description, _Format, _Url, _DiskImageSize, _Progress, _SnapshotId, _StatusMessage, _UserBucket, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SnapshotDetail")
	local t = { 
		["Status"] = _Status,
		["DeviceName"] = _DeviceName,
		["Description"] = _Description,
		["Format"] = _Format,
		["Url"] = _Url,
		["DiskImageSize"] = _DiskImageSize,
		["Progress"] = _Progress,
		["SnapshotId"] = _SnapshotId,
		["StatusMessage"] = _StatusMessage,
		["UserBucket"] = _UserBucket,
	}
	asserts.AssertSnapshotDetail(t)
	return t
end

keys.RequestSpotFleetResponse = { ["SpotFleetRequestId"] = true, nil }

function asserts.AssertRequestSpotFleetResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotFleetResponse to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotFleetResponse[k], "RequestSpotFleetResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotFleetResponse
-- <p>Contains the output of RequestSpotFleet.</p>
-- @param _SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- Required parameter: SpotFleetRequestId
function M.RequestSpotFleetResponse(_SpotFleetRequestId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotFleetResponse")
	local t = { 
		["SpotFleetRequestId"] = _SpotFleetRequestId,
	}
	asserts.AssertRequestSpotFleetResponse(t)
	return t
end

keys.AssociateRouteTableRequest = { ["SubnetId"] = true, ["RouteTableId"] = true, ["DryRun"] = true, nil }

function asserts.AssertAssociateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateRouteTableRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateRouteTableRequest[k], "AssociateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateRouteTableRequest
-- <p>Contains the parameters for AssociateRouteTable.</p>
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _RouteTableId [String] <p>The ID of the route table.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: RouteTableId
-- Required parameter: SubnetId
function M.AssociateRouteTableRequest(_SubnetId, _RouteTableId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateRouteTableRequest")
	local t = { 
		["SubnetId"] = _SubnetId,
		["RouteTableId"] = _RouteTableId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertAssociateRouteTableRequest(t)
	return t
end

keys.HostReservation = { ["Count"] = true, ["End"] = true, ["HourlyPrice"] = true, ["InstanceFamily"] = true, ["CurrencyCode"] = true, ["OfferingId"] = true, ["PaymentOption"] = true, ["State"] = true, ["HostIdSet"] = true, ["Start"] = true, ["HostReservationId"] = true, ["UpfrontPrice"] = true, ["Duration"] = true, nil }

function asserts.AssertHostReservation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostReservation to be of type 'table'")
	if struct["Count"] then asserts.AssertInteger(struct["Count"]) end
	if struct["End"] then asserts.AssertDateTime(struct["End"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["InstanceFamily"] then asserts.AssertString(struct["InstanceFamily"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["PaymentOption"] then asserts.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["State"] then asserts.AssertReservationState(struct["State"]) end
	if struct["HostIdSet"] then asserts.AssertResponseHostIdSet(struct["HostIdSet"]) end
	if struct["Start"] then asserts.AssertDateTime(struct["Start"]) end
	if struct["HostReservationId"] then asserts.AssertString(struct["HostReservationId"]) end
	if struct["UpfrontPrice"] then asserts.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then asserts.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostReservation[k], "HostReservation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostReservation
-- <p>Details about the Dedicated Host Reservation and associated Dedicated Hosts.</p>
-- @param _Count [Integer] <p>The number of Dedicated Hosts the reservation is associated with.</p>
-- @param _End [DateTime] <p>The date and time that the reservation ends.</p>
-- @param _HourlyPrice [String] <p>The hourly price of the reservation.</p>
-- @param _InstanceFamily [String] <p>The instance family of the Dedicated Host Reservation. The instance family on the Dedicated Host must be the same in order for it to benefit from the reservation.</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>upfrontPrice</code> and <code>hourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param _OfferingId [String] <p>The ID of the reservation. This remains the same regardless of which Dedicated Hosts are associated with it.</p>
-- @param _PaymentOption [PaymentOption] <p>The payment option selected for this reservation.</p>
-- @param _State [ReservationState] <p>The state of the reservation.</p>
-- @param _HostIdSet [ResponseHostIdSet] <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
-- @param _Start [DateTime] <p>The date and time that the reservation started.</p>
-- @param _HostReservationId [String] <p>The ID of the reservation that specifies the associated Dedicated Hosts.</p>
-- @param _UpfrontPrice [String] <p>The upfront price of the reservation.</p>
-- @param _Duration [Integer] <p>The length of the reservation's term, specified in seconds. Can be <code>31536000 (1 year)</code> | <code>94608000 (3 years)</code>.</p>
function M.HostReservation(_Count, _End, _HourlyPrice, _InstanceFamily, _CurrencyCode, _OfferingId, _PaymentOption, _State, _HostIdSet, _Start, _HostReservationId, _UpfrontPrice, _Duration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HostReservation")
	local t = { 
		["Count"] = _Count,
		["End"] = _End,
		["HourlyPrice"] = _HourlyPrice,
		["InstanceFamily"] = _InstanceFamily,
		["CurrencyCode"] = _CurrencyCode,
		["OfferingId"] = _OfferingId,
		["PaymentOption"] = _PaymentOption,
		["State"] = _State,
		["HostIdSet"] = _HostIdSet,
		["Start"] = _Start,
		["HostReservationId"] = _HostReservationId,
		["UpfrontPrice"] = _UpfrontPrice,
		["Duration"] = _Duration,
	}
	asserts.AssertHostReservation(t)
	return t
end

keys.ResetNetworkInterfaceAttributeRequest = { ["NetworkInterfaceId"] = true, ["DryRun"] = true, ["SourceDestCheck"] = true, nil }

function asserts.AssertResetNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SourceDestCheck"] then asserts.AssertString(struct["SourceDestCheck"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetNetworkInterfaceAttributeRequest[k], "ResetNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for ResetNetworkInterfaceAttribute.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _SourceDestCheck [String] <p>The source/destination checking attribute. Resets the value to <code>true</code>.</p>
-- Required parameter: NetworkInterfaceId
function M.ResetNetworkInterfaceAttributeRequest(_NetworkInterfaceId, _DryRun, _SourceDestCheck, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ResetNetworkInterfaceAttributeRequest")
	local t = { 
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["DryRun"] = _DryRun,
		["SourceDestCheck"] = _SourceDestCheck,
	}
	asserts.AssertResetNetworkInterfaceAttributeRequest(t)
	return t
end

keys.NetworkInterfacePrivateIpAddress = { ["PrivateDnsName"] = true, ["PrivateIpAddress"] = true, ["Primary"] = true, ["Association"] = true, nil }

function asserts.AssertNetworkInterfacePrivateIpAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfacePrivateIpAddress to be of type 'table'")
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["Association"] then asserts.AssertNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfacePrivateIpAddress[k], "NetworkInterfacePrivateIpAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfacePrivateIpAddress
-- <p>Describes the private IPv4 address of a network interface.</p>
-- @param _PrivateDnsName [String] <p>The private DNS name.</p>
-- @param _PrivateIpAddress [String] <p>The private IPv4 address.</p>
-- @param _Primary [Boolean] <p>Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.</p>
-- @param _Association [NetworkInterfaceAssociation] <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
function M.NetworkInterfacePrivateIpAddress(_PrivateDnsName, _PrivateIpAddress, _Primary, _Association, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfacePrivateIpAddress")
	local t = { 
		["PrivateDnsName"] = _PrivateDnsName,
		["PrivateIpAddress"] = _PrivateIpAddress,
		["Primary"] = _Primary,
		["Association"] = _Association,
	}
	asserts.AssertNetworkInterfacePrivateIpAddress(t)
	return t
end

keys.DescribeFlowLogsRequest = { ["Filter"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["FlowLogIds"] = true, nil }

function asserts.AssertDescribeFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFlowLogsRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["FlowLogIds"] then asserts.AssertValueStringList(struct["FlowLogIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFlowLogsRequest[k], "DescribeFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFlowLogsRequest
-- <p>Contains the parameters for DescribeFlowLogs.</p>
-- @param _Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>deliver-log-status</code> - The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p> </li> <li> <p> <code>flow-log-id</code> - The ID of the flow log.</p> </li> <li> <p> <code>log-group-name</code> - The name of the log group.</p> </li> <li> <p> <code>resource-id</code> - The ID of the VPC, subnet, or network interface.</p> </li> <li> <p> <code>traffic-type</code> - The type of traffic (<code>ACCEPT</code> | <code>REJECT</code> | <code>ALL</code>)</p> </li> </ul>
-- @param _NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the flow log IDs parameter in the same request.</p>
-- @param _FlowLogIds [ValueStringList] <p>One or more flow log IDs.</p>
function M.DescribeFlowLogsRequest(_Filter, _NextToken, _MaxResults, _FlowLogIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeFlowLogsRequest")
	local t = { 
		["Filter"] = _Filter,
		["NextToken"] = _NextToken,
		["MaxResults"] = _MaxResults,
		["FlowLogIds"] = _FlowLogIds,
	}
	asserts.AssertDescribeFlowLogsRequest(t)
	return t
end

keys.SpotInstanceStatus = { ["Message"] = true, ["Code"] = true, ["UpdateTime"] = true, nil }

function asserts.AssertSpotInstanceStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceStatus to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	if struct["UpdateTime"] then asserts.AssertDateTime(struct["UpdateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotInstanceStatus[k], "SpotInstanceStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceStatus
-- <p>Describes the status of a Spot instance request.</p>
-- @param _Message [String] <p>The description for the status code.</p>
-- @param _Code [String] <p>The status code. For a list of status codes, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html#spot-instance-bid-status-understand">Spot Bid Status Codes</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param _UpdateTime [DateTime] <p>The date and time of the most recent status update, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
function M.SpotInstanceStatus(_Message, _Code, _UpdateTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotInstanceStatus")
	local t = { 
		["Message"] = _Message,
		["Code"] = _Code,
		["UpdateTime"] = _UpdateTime,
	}
	asserts.AssertSpotInstanceStatus(t)
	return t
end

keys.CreateFpgaImageRequest = { ["DryRun"] = true, ["Name"] = true, ["LogsStorageLocation"] = true, ["InputStorageLocation"] = true, ["ClientToken"] = true, ["Description"] = true, nil }

function asserts.AssertCreateFpgaImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFpgaImageRequest to be of type 'table'")
	assert(struct["InputStorageLocation"], "Expected key InputStorageLocation to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["LogsStorageLocation"] then asserts.AssertStorageLocation(struct["LogsStorageLocation"]) end
	if struct["InputStorageLocation"] then asserts.AssertStorageLocation(struct["InputStorageLocation"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFpgaImageRequest[k], "CreateFpgaImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFpgaImageRequest
--  
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Name [String] <p>A name for the AFI.</p>
-- @param _LogsStorageLocation [StorageLocation] <p>The location in Amazon S3 for the output logs.</p>
-- @param _InputStorageLocation [StorageLocation] <p>The location of the encrypted design checkpoint in Amazon S3. The input must be a tarball.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- @param _Description [String] <p>A description for the AFI.</p>
-- Required parameter: InputStorageLocation
function M.CreateFpgaImageRequest(_DryRun, _Name, _LogsStorageLocation, _InputStorageLocation, _ClientToken, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateFpgaImageRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Name"] = _Name,
		["LogsStorageLocation"] = _LogsStorageLocation,
		["InputStorageLocation"] = _InputStorageLocation,
		["ClientToken"] = _ClientToken,
		["Description"] = _Description,
	}
	asserts.AssertCreateFpgaImageRequest(t)
	return t
end

keys.LaunchPermission = { ["UserId"] = true, ["Group"] = true, nil }

function asserts.AssertLaunchPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchPermission to be of type 'table'")
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["Group"] then asserts.AssertPermissionGroup(struct["Group"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchPermission[k], "LaunchPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchPermission
-- <p>Describes a launch permission.</p>
-- @param _UserId [String] <p>The AWS account ID.</p>
-- @param _Group [PermissionGroup] <p>The name of the group.</p>
function M.LaunchPermission(_UserId, _Group, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating LaunchPermission")
	local t = { 
		["UserId"] = _UserId,
		["Group"] = _Group,
	}
	asserts.AssertLaunchPermission(t)
	return t
end

keys.DescribeInstanceStatusRequest = { ["DryRun"] = true, ["IncludeAllInstances"] = true, ["MaxResults"] = true, ["Filters"] = true, ["NextToken"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertDescribeInstanceStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceStatusRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["IncludeAllInstances"] then asserts.AssertBoolean(struct["IncludeAllInstances"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceStatusRequest[k], "DescribeInstanceStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceStatusRequest
-- <p>Contains the parameters for DescribeInstanceStatus.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _IncludeAllInstances [Boolean] <p>When <code>true</code>, includes the health status for all instances. When <code>false</code>, includes the health status for running instances only.</p> <p>Default: <code>false</code> </p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter in the same call.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>event.code</code> - The code for the scheduled event (<code>instance-reboot</code> | <code>system-reboot</code> | <code>system-maintenance</code> | <code>instance-retirement</code> | <code>instance-stop</code>).</p> </li> <li> <p> <code>event.description</code> - A description of the event.</p> </li> <li> <p> <code>event.not-after</code> - The latest end time for the scheduled event (for example, <code>2014-09-15T17:15:20.000Z</code>).</p> </li> <li> <p> <code>event.not-before</code> - The earliest start time for the scheduled event (for example, <code>2014-09-15T17:15:20.000Z</code>).</p> </li> <li> <p> <code>instance-state-code</code> - The code for the instance state, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).</p> </li> <li> <p> <code>instance-state-name</code> - The state of the instance (<code>pending</code> | <code>running</code> | <code>shutting-down</code> | <code>terminated</code> | <code>stopping</code> | <code>stopped</code>).</p> </li> <li> <p> <code>instance-status.reachability</code> - Filters on instance status where the name is <code>reachability</code> (<code>passed</code> | <code>failed</code> | <code>initializing</code> | <code>insufficient-data</code>).</p> </li> <li> <p> <code>instance-status.status</code> - The status of the instance (<code>ok</code> | <code>impaired</code> | <code>initializing</code> | <code>insufficient-data</code> | <code>not-applicable</code>).</p> </li> <li> <p> <code>system-status.reachability</code> - Filters on system status where the name is <code>reachability</code> (<code>passed</code> | <code>failed</code> | <code>initializing</code> | <code>insufficient-data</code>).</p> </li> <li> <p> <code>system-status.status</code> - The system status of the instance (<code>ok</code> | <code>impaired</code> | <code>initializing</code> | <code>insufficient-data</code> | <code>not-applicable</code>).</p> </li> </ul>
-- @param _NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param _InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Default: Describes all your instances.</p> <p>Constraints: Maximum 100 explicitly specified instance IDs.</p>
function M.DescribeInstanceStatusRequest(_DryRun, _IncludeAllInstances, _MaxResults, _Filters, _NextToken, _InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstanceStatusRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["IncludeAllInstances"] = _IncludeAllInstances,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
		["NextToken"] = _NextToken,
		["InstanceIds"] = _InstanceIds,
	}
	asserts.AssertDescribeInstanceStatusRequest(t)
	return t
end

keys.ImportSnapshotTask = { ["SnapshotTaskDetail"] = true, ["Description"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportSnapshotTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotTask to be of type 'table'")
	if struct["SnapshotTaskDetail"] then asserts.AssertSnapshotTaskDetail(struct["SnapshotTaskDetail"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportSnapshotTask[k], "ImportSnapshotTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotTask
-- <p>Describes an import snapshot task.</p>
-- @param _SnapshotTaskDetail [SnapshotTaskDetail] <p>Describes an import snapshot task.</p>
-- @param _Description [String] <p>A description of the import snapshot task.</p>
-- @param _ImportTaskId [String] <p>The ID of the import snapshot task.</p>
function M.ImportSnapshotTask(_SnapshotTaskDetail, _Description, _ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportSnapshotTask")
	local t = { 
		["SnapshotTaskDetail"] = _SnapshotTaskDetail,
		["Description"] = _Description,
		["ImportTaskId"] = _ImportTaskId,
	}
	asserts.AssertImportSnapshotTask(t)
	return t
end

keys.GetHostReservationPurchasePreviewResult = { ["TotalHourlyPrice"] = true, ["Purchase"] = true, ["CurrencyCode"] = true, ["TotalUpfrontPrice"] = true, nil }

function asserts.AssertGetHostReservationPurchasePreviewResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetHostReservationPurchasePreviewResult to be of type 'table'")
	if struct["TotalHourlyPrice"] then asserts.AssertString(struct["TotalHourlyPrice"]) end
	if struct["Purchase"] then asserts.AssertPurchaseSet(struct["Purchase"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["TotalUpfrontPrice"] then asserts.AssertString(struct["TotalUpfrontPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetHostReservationPurchasePreviewResult[k], "GetHostReservationPurchasePreviewResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetHostReservationPurchasePreviewResult
--  
-- @param _TotalHourlyPrice [String] <p>The potential total hourly price of the reservation per hour.</p>
-- @param _Purchase [PurchaseSet] <p>The purchase information of the Dedicated Host Reservation and the Dedicated Hosts associated with it.</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param _TotalUpfrontPrice [String] <p>The potential total upfront price. This is billed immediately.</p>
function M.GetHostReservationPurchasePreviewResult(_TotalHourlyPrice, _Purchase, _CurrencyCode, _TotalUpfrontPrice, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetHostReservationPurchasePreviewResult")
	local t = { 
		["TotalHourlyPrice"] = _TotalHourlyPrice,
		["Purchase"] = _Purchase,
		["CurrencyCode"] = _CurrencyCode,
		["TotalUpfrontPrice"] = _TotalUpfrontPrice,
	}
	asserts.AssertGetHostReservationPurchasePreviewResult(t)
	return t
end

keys.UnsuccessfulItem = { ["ResourceId"] = true, ["Error"] = true, nil }

function asserts.AssertUnsuccessfulItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulItem to be of type 'table'")
	assert(struct["Error"], "Expected key Error to exist in table")
	if struct["ResourceId"] then asserts.AssertString(struct["ResourceId"]) end
	if struct["Error"] then asserts.AssertUnsuccessfulItemError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnsuccessfulItem[k], "UnsuccessfulItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulItem
-- <p>Information about items that were not successfully processed in a batch call.</p>
-- @param _ResourceId [String] <p>The ID of the resource.</p>
-- @param _Error [UnsuccessfulItemError] <p>Information about the error.</p>
-- Required parameter: Error
function M.UnsuccessfulItem(_ResourceId, _Error, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnsuccessfulItem")
	local t = { 
		["ResourceId"] = _ResourceId,
		["Error"] = _Error,
	}
	asserts.AssertUnsuccessfulItem(t)
	return t
end

keys.PeeringConnectionOptionsRequest = { ["AllowEgressFromLocalVpcToRemoteClassicLink"] = true, ["AllowDnsResolutionFromRemoteVpc"] = true, ["AllowEgressFromLocalClassicLinkToRemoteVpc"] = true, nil }

function asserts.AssertPeeringConnectionOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PeeringConnectionOptionsRequest to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then asserts.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then asserts.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then asserts.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.PeeringConnectionOptionsRequest[k], "PeeringConnectionOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PeeringConnectionOptionsRequest
-- <p>The VPC peering connection options.</p>
-- @param _AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.</p>
-- @param _AllowDnsResolutionFromRemoteVpc [Boolean] <p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>
-- @param _AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.</p>
function M.PeeringConnectionOptionsRequest(_AllowEgressFromLocalVpcToRemoteClassicLink, _AllowDnsResolutionFromRemoteVpc, _AllowEgressFromLocalClassicLinkToRemoteVpc, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PeeringConnectionOptionsRequest")
	local t = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = _AllowEgressFromLocalVpcToRemoteClassicLink,
		["AllowDnsResolutionFromRemoteVpc"] = _AllowDnsResolutionFromRemoteVpc,
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = _AllowEgressFromLocalClassicLinkToRemoteVpc,
	}
	asserts.AssertPeeringConnectionOptionsRequest(t)
	return t
end

keys.DescribeInstanceAttributeRequest = { ["InstanceId"] = true, ["Attribute"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then asserts.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceAttributeRequest[k], "DescribeInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceAttributeRequest
-- <p>Contains the parameters for DescribeInstanceAttribute.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _Attribute [InstanceAttributeName] <p>The instance attribute.</p> <p>Note: The <code>enaSupport</code> attribute is not supported at this time.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: Attribute
-- Required parameter: InstanceId
function M.DescribeInstanceAttributeRequest(_InstanceId, _Attribute, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstanceAttributeRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["Attribute"] = _Attribute,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDescribeInstanceAttributeRequest(t)
	return t
end

keys.DiskImageDetail = { ["Bytes"] = true, ["ImportManifestUrl"] = true, ["Format"] = true, nil }

function asserts.AssertDiskImageDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageDetail to be of type 'table'")
	assert(struct["Bytes"], "Expected key Bytes to exist in table")
	assert(struct["Format"], "Expected key Format to exist in table")
	assert(struct["ImportManifestUrl"], "Expected key ImportManifestUrl to exist in table")
	if struct["Bytes"] then asserts.AssertLong(struct["Bytes"]) end
	if struct["ImportManifestUrl"] then asserts.AssertString(struct["ImportManifestUrl"]) end
	if struct["Format"] then asserts.AssertDiskImageFormat(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImageDetail[k], "DiskImageDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageDetail
-- <p>Describes a disk image.</p>
-- @param _Bytes [Long] <p>The size of the disk image, in GiB.</p>
-- @param _ImportManifestUrl [String] <p>A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
-- @param _Format [DiskImageFormat] <p>The disk image format.</p>
-- Required parameter: Bytes
-- Required parameter: Format
-- Required parameter: ImportManifestUrl
function M.DiskImageDetail(_Bytes, _ImportManifestUrl, _Format, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DiskImageDetail")
	local t = { 
		["Bytes"] = _Bytes,
		["ImportManifestUrl"] = _ImportManifestUrl,
		["Format"] = _Format,
	}
	asserts.AssertDiskImageDetail(t)
	return t
end

keys.AvailabilityZone = { ["State"] = true, ["ZoneName"] = true, ["Messages"] = true, ["RegionName"] = true, nil }

function asserts.AssertAvailabilityZone(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailabilityZone to be of type 'table'")
	if struct["State"] then asserts.AssertAvailabilityZoneState(struct["State"]) end
	if struct["ZoneName"] then asserts.AssertString(struct["ZoneName"]) end
	if struct["Messages"] then asserts.AssertAvailabilityZoneMessageList(struct["Messages"]) end
	if struct["RegionName"] then asserts.AssertString(struct["RegionName"]) end
	for k,_ in pairs(struct) do
		assert(keys.AvailabilityZone[k], "AvailabilityZone contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailabilityZone
-- <p>Describes an Availability Zone.</p>
-- @param _State [AvailabilityZoneState] <p>The state of the Availability Zone.</p>
-- @param _ZoneName [String] <p>The name of the Availability Zone.</p>
-- @param _Messages [AvailabilityZoneMessageList] <p>Any messages about the Availability Zone.</p>
-- @param _RegionName [String] <p>The name of the region.</p>
function M.AvailabilityZone(_State, _ZoneName, _Messages, _RegionName, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AvailabilityZone")
	local t = { 
		["State"] = _State,
		["ZoneName"] = _ZoneName,
		["Messages"] = _Messages,
		["RegionName"] = _RegionName,
	}
	asserts.AssertAvailabilityZone(t)
	return t
end

keys.DescribeNetworkInterfacesRequest = { ["NetworkInterfaceIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeNetworkInterfacesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacesRequest to be of type 'table'")
	if struct["NetworkInterfaceIds"] then asserts.AssertNetworkInterfaceIdList(struct["NetworkInterfaceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfacesRequest[k], "DescribeNetworkInterfacesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacesRequest
-- <p>Contains the parameters for DescribeNetworkInterfaces.</p>
-- @param _NetworkInterfaceIds [NetworkInterfaceIdList] <p>One or more network interface IDs.</p> <p>Default: Describes all your network interfaces.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>addresses.private-ip-address</code> - The private IPv4 addresses associated with the network interface.</p> </li> <li> <p> <code>addresses.primary</code> - Whether the private IPv4 address is the primary IP address associated with the network interface. </p> </li> <li> <p> <code>addresses.association.public-ip</code> - The association ID returned when the network interface was associated with the Elastic IP address (IPv4).</p> </li> <li> <p> <code>addresses.association.owner-id</code> - The owner ID of the addresses associated with the network interface.</p> </li> <li> <p> <code>association.association-id</code> - The association ID returned when the network interface was associated with an IPv4 address.</p> </li> <li> <p> <code>association.allocation-id</code> - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.</p> </li> <li> <p> <code>association.ip-owner-id</code> - The owner of the Elastic IP address (IPv4) associated with the network interface.</p> </li> <li> <p> <code>association.public-ip</code> - The address of the Elastic IP address (IPv4) bound to the network interface.</p> </li> <li> <p> <code>association.public-dns-name</code> - The public DNS name for the network interface (IPv4).</p> </li> <li> <p> <code>attachment.attachment-id</code> - The ID of the interface attachment.</p> </li> <li> <p> <code>attachment.attach.time</code> - The time that the network interface was attached to an instance.</p> </li> <li> <p> <code>attachment.delete-on-termination</code> - Indicates whether the attachment is deleted when an instance is terminated.</p> </li> <li> <p> <code>attachment.device-index</code> - The device index to which the network interface is attached.</p> </li> <li> <p> <code>attachment.instance-id</code> - The ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>attachment.instance-owner-id</code> - The owner ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>attachment.nat-gateway-id</code> - The ID of the NAT gateway to which the network interface is attached.</p> </li> <li> <p> <code>attachment.status</code> - The status of the attachment (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the network interface.</p> </li> <li> <p> <code>description</code> - The description of the network interface.</p> </li> <li> <p> <code>group-id</code> - The ID of a security group associated with the network interface.</p> </li> <li> <p> <code>group-name</code> - The name of a security group associated with the network interface.</p> </li> <li> <p> <code>ipv6-addresses.ipv6-address</code> - An IPv6 address associated with the network interface.</p> </li> <li> <p> <code>mac-address</code> - The MAC address of the network interface.</p> </li> <li> <p> <code>network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the network interface owner.</p> </li> <li> <p> <code>private-ip-address</code> - The private IPv4 address or addresses of the network interface.</p> </li> <li> <p> <code>private-dns-name</code> - The private DNS name of the network interface (IPv4).</p> </li> <li> <p> <code>requester-id</code> - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>requester-managed</code> - Indicates whether the network interface is being managed by an AWS service (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>source-desk-check</code> - Indicates whether the network interface performs source/destination checking. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the network interface to perform network address translation (NAT) in your VPC. </p> </li> <li> <p> <code>status</code> - The status of the network interface. If the network interface is not attached to an instance, the status is <code>available</code>; if a network interface is attached to an instance the status is <code>in-use</code>.</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet for the network interface.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the network interface.</p> </li> </ul>
function M.DescribeNetworkInterfacesRequest(_NetworkInterfaceIds, _DryRun, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkInterfacesRequest")
	local t = { 
		["NetworkInterfaceIds"] = _NetworkInterfaceIds,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeNetworkInterfacesRequest(t)
	return t
end

keys.GroupIdentifier = { ["GroupName"] = true, ["GroupId"] = true, nil }

function asserts.AssertGroupIdentifier(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GroupIdentifier to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GroupIdentifier[k], "GroupIdentifier contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GroupIdentifier
-- <p>Describes a security group.</p>
-- @param _GroupName [String] <p>The name of the security group.</p>
-- @param _GroupId [String] <p>The ID of the security group.</p>
function M.GroupIdentifier(_GroupName, _GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GroupIdentifier")
	local t = { 
		["GroupName"] = _GroupName,
		["GroupId"] = _GroupId,
	}
	asserts.AssertGroupIdentifier(t)
	return t
end

keys.RunScheduledInstancesRequest = { ["ScheduledInstanceId"] = true, ["LaunchSpecification"] = true, ["InstanceCount"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertRunScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunScheduledInstancesRequest to be of type 'table'")
	assert(struct["LaunchSpecification"], "Expected key LaunchSpecification to exist in table")
	assert(struct["ScheduledInstanceId"], "Expected key ScheduledInstanceId to exist in table")
	if struct["ScheduledInstanceId"] then asserts.AssertString(struct["ScheduledInstanceId"]) end
	if struct["LaunchSpecification"] then asserts.AssertScheduledInstancesLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunScheduledInstancesRequest[k], "RunScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunScheduledInstancesRequest
-- <p>Contains the parameters for RunScheduledInstances.</p>
-- @param _ScheduledInstanceId [String] <p>The Scheduled Instance ID.</p>
-- @param _LaunchSpecification [ScheduledInstancesLaunchSpecification] <p>The launch specification. You must match the instance type, Availability Zone, network, and platform of the schedule that you purchased.</p>
-- @param _InstanceCount [Integer] <p>The number of instances.</p> <p>Default: 1</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required parameter: LaunchSpecification
-- Required parameter: ScheduledInstanceId
function M.RunScheduledInstancesRequest(_ScheduledInstanceId, _LaunchSpecification, _InstanceCount, _DryRun, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RunScheduledInstancesRequest")
	local t = { 
		["ScheduledInstanceId"] = _ScheduledInstanceId,
		["LaunchSpecification"] = _LaunchSpecification,
		["InstanceCount"] = _InstanceCount,
		["DryRun"] = _DryRun,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertRunScheduledInstancesRequest(t)
	return t
end

keys.DiskImageDescription = { ["Checksum"] = true, ["Size"] = true, ["ImportManifestUrl"] = true, ["Format"] = true, nil }

function asserts.AssertDiskImageDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageDescription to be of type 'table'")
	assert(struct["Format"], "Expected key Format to exist in table")
	assert(struct["ImportManifestUrl"], "Expected key ImportManifestUrl to exist in table")
	assert(struct["Size"], "Expected key Size to exist in table")
	if struct["Checksum"] then asserts.AssertString(struct["Checksum"]) end
	if struct["Size"] then asserts.AssertLong(struct["Size"]) end
	if struct["ImportManifestUrl"] then asserts.AssertString(struct["ImportManifestUrl"]) end
	if struct["Format"] then asserts.AssertDiskImageFormat(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImageDescription[k], "DiskImageDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageDescription
-- <p>Describes a disk image.</p>
-- @param _Checksum [String] <p>The checksum computed for the disk image.</p>
-- @param _Size [Long] <p>The size of the disk image, in GiB.</p>
-- @param _ImportManifestUrl [String] <p>A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
-- @param _Format [DiskImageFormat] <p>The disk image format.</p>
-- Required parameter: Format
-- Required parameter: ImportManifestUrl
-- Required parameter: Size
function M.DiskImageDescription(_Checksum, _Size, _ImportManifestUrl, _Format, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DiskImageDescription")
	local t = { 
		["Checksum"] = _Checksum,
		["Size"] = _Size,
		["ImportManifestUrl"] = _ImportManifestUrl,
		["Format"] = _Format,
	}
	asserts.AssertDiskImageDescription(t)
	return t
end

keys.RouteTableAssociation = { ["SubnetId"] = true, ["RouteTableAssociationId"] = true, ["Main"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertRouteTableAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RouteTableAssociation to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["RouteTableAssociationId"] then asserts.AssertString(struct["RouteTableAssociationId"]) end
	if struct["Main"] then asserts.AssertBoolean(struct["Main"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RouteTableAssociation[k], "RouteTableAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RouteTableAssociation
-- <p>Describes an association between a route table and a subnet.</p>
-- @param _SubnetId [String] <p>The ID of the subnet. A subnet ID is not returned for an implicit association.</p>
-- @param _RouteTableAssociationId [String] <p>The ID of the association between a route table and a subnet.</p>
-- @param _Main [Boolean] <p>Indicates whether this is the main route table.</p>
-- @param _RouteTableId [String] <p>The ID of the route table.</p>
function M.RouteTableAssociation(_SubnetId, _RouteTableAssociationId, _Main, _RouteTableId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RouteTableAssociation")
	local t = { 
		["SubnetId"] = _SubnetId,
		["RouteTableAssociationId"] = _RouteTableAssociationId,
		["Main"] = _Main,
		["RouteTableId"] = _RouteTableId,
	}
	asserts.AssertRouteTableAssociation(t)
	return t
end

keys.CancelImportTaskRequest = { ["DryRun"] = true, ["CancelReason"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertCancelImportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelImportTaskRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["CancelReason"] then asserts.AssertString(struct["CancelReason"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelImportTaskRequest[k], "CancelImportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelImportTaskRequest
-- <p>Contains the parameters for CancelImportTask.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _CancelReason [String] <p>The reason for canceling the task.</p>
-- @param _ImportTaskId [String] <p>The ID of the import image or import snapshot task to be canceled.</p>
function M.CancelImportTaskRequest(_DryRun, _CancelReason, _ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelImportTaskRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["CancelReason"] = _CancelReason,
		["ImportTaskId"] = _ImportTaskId,
	}
	asserts.AssertCancelImportTaskRequest(t)
	return t
end

keys.ImportInstanceRequest = { ["Platform"] = true, ["DiskImages"] = true, ["DryRun"] = true, ["Description"] = true, ["LaunchSpecification"] = true, nil }

function asserts.AssertImportInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceRequest to be of type 'table'")
	assert(struct["Platform"], "Expected key Platform to exist in table")
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["DiskImages"] then asserts.AssertDiskImageList(struct["DiskImages"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["LaunchSpecification"] then asserts.AssertImportInstanceLaunchSpecification(struct["LaunchSpecification"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceRequest[k], "ImportInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceRequest
-- <p>Contains the parameters for ImportInstance.</p>
-- @param _Platform [PlatformValues] <p>The instance operating system.</p>
-- @param _DiskImages [DiskImageList] <p>The disk image.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>A description for the instance being imported.</p>
-- @param _LaunchSpecification [ImportInstanceLaunchSpecification] <p>The launch specification.</p>
-- Required parameter: Platform
function M.ImportInstanceRequest(_Platform, _DiskImages, _DryRun, _Description, _LaunchSpecification, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceRequest")
	local t = { 
		["Platform"] = _Platform,
		["DiskImages"] = _DiskImages,
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["LaunchSpecification"] = _LaunchSpecification,
	}
	asserts.AssertImportInstanceRequest(t)
	return t
end

keys.SubnetCidrBlockState = { ["State"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertSubnetCidrBlockState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SubnetCidrBlockState to be of type 'table'")
	if struct["State"] then asserts.AssertSubnetCidrBlockStateCode(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.SubnetCidrBlockState[k], "SubnetCidrBlockState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SubnetCidrBlockState
-- <p>Describes the state of a CIDR block.</p>
-- @param _State [SubnetCidrBlockStateCode] <p>The state of a CIDR block.</p>
-- @param _StatusMessage [String] <p>A message about the status of the CIDR block, if applicable.</p>
function M.SubnetCidrBlockState(_State, _StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SubnetCidrBlockState")
	local t = { 
		["State"] = _State,
		["StatusMessage"] = _StatusMessage,
	}
	asserts.AssertSubnetCidrBlockState(t)
	return t
end

keys.CreateVolumeRequest = { ["AvailabilityZone"] = true, ["DryRun"] = true, ["TagSpecifications"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["KmsKeyId"] = true, ["SnapshotId"] = true, ["Iops"] = true, ["Size"] = true, nil }

function asserts.AssertCreateVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumeRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["Size"] then asserts.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVolumeRequest[k], "CreateVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumeRequest
-- <p>Contains the parameters for CreateVolume.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone in which to create the volume. Use <a>DescribeAvailabilityZones</a> to list the Availability Zones that are currently available to you.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _TagSpecifications [TagSpecificationList] <p>The tags to apply to the volume during creation.</p>
-- @param _Encrypted [Boolean] <p>Specifies whether the volume should be encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption. Volumes that are created from encrypted snapshots are automatically encrypted. There is no way to create an encrypted volume from an unencrypted snapshot or vice versa. If your AMI uses encrypted volumes, you can only launch it on supported instance types. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param _VolumeType [VolumeType] <p>The volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p> <p>Default: <code>standard</code> </p>
-- @param _KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set.</p>
-- @param _SnapshotId [String] <p>The snapshot from which to create the volume.</p>
-- @param _Iops [Integer] <p>Only valid for Provisioned IOPS SSD volumes. The number of I/O operations per second (IOPS) to provision for the volume, with a maximum ratio of 50 IOPS/GiB.</p> <p>Constraint: Range is 100 to 20000 for Provisioned IOPS SSD volumes </p>
-- @param _Size [Integer] <p>The size of the volume, in GiBs.</p> <p>Constraints: 1-16384 for <code>gp2</code>, 4-16384 for <code>io1</code>, 500-16384 for <code>st1</code>, 500-16384 for <code>sc1</code>, and 1-1024 for <code>standard</code>. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- Required parameter: AvailabilityZone
function M.CreateVolumeRequest(_AvailabilityZone, _DryRun, _TagSpecifications, _Encrypted, _VolumeType, _KmsKeyId, _SnapshotId, _Iops, _Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVolumeRequest")
	local t = { 
		["AvailabilityZone"] = _AvailabilityZone,
		["DryRun"] = _DryRun,
		["TagSpecifications"] = _TagSpecifications,
		["Encrypted"] = _Encrypted,
		["VolumeType"] = _VolumeType,
		["KmsKeyId"] = _KmsKeyId,
		["SnapshotId"] = _SnapshotId,
		["Iops"] = _Iops,
		["Size"] = _Size,
	}
	asserts.AssertCreateVolumeRequest(t)
	return t
end

keys.DescribeHostsResult = { ["NextToken"] = true, ["Hosts"] = true, nil }

function asserts.AssertDescribeHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Hosts"] then asserts.AssertHostList(struct["Hosts"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostsResult[k], "DescribeHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostsResult
-- <p>Contains the output of DescribeHosts.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _Hosts [HostList] <p>Information about the Dedicated Hosts.</p>
function M.DescribeHostsResult(_NextToken, _Hosts, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostsResult")
	local t = { 
		["NextToken"] = _NextToken,
		["Hosts"] = _Hosts,
	}
	asserts.AssertDescribeHostsResult(t)
	return t
end

keys.DescribeVolumesResult = { ["NextToken"] = true, ["Volumes"] = true, nil }

function asserts.AssertDescribeVolumesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Volumes"] then asserts.AssertVolumeList(struct["Volumes"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesResult[k], "DescribeVolumesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesResult
-- <p>Contains the output of DescribeVolumes.</p>
-- @param _NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeVolumes</code> request. When the results of a <code>DescribeVolumes</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _Volumes [VolumeList] <p>Information about the volumes.</p>
function M.DescribeVolumesResult(_NextToken, _Volumes, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumesResult")
	local t = { 
		["NextToken"] = _NextToken,
		["Volumes"] = _Volumes,
	}
	asserts.AssertDescribeVolumesResult(t)
	return t
end

keys.DescribeNatGatewaysRequest = { ["Filter"] = true, ["NextToken"] = true, ["NatGatewayIds"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeNatGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNatGatewaysRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["NatGatewayIds"] then asserts.AssertValueStringList(struct["NatGatewayIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNatGatewaysRequest[k], "DescribeNatGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNatGatewaysRequest
-- <p>Contains the parameters for DescribeNatGateways.</p>
-- @param _Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>nat-gateway-id</code> - The ID of the NAT gateway.</p> </li> <li> <p> <code>state</code> - The state of the NAT gateway (<code>pending</code> | <code>failed</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet in which the NAT gateway resides.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC in which the NAT gateway resides.</p> </li> </ul>
-- @param _NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param _NatGatewayIds [ValueStringList] <p>One or more NAT gateway IDs.</p>
-- @param _MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value specified is greater than 1000, we return only 1000 items.</p>
function M.DescribeNatGatewaysRequest(_Filter, _NextToken, _NatGatewayIds, _MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNatGatewaysRequest")
	local t = { 
		["Filter"] = _Filter,
		["NextToken"] = _NextToken,
		["NatGatewayIds"] = _NatGatewayIds,
		["MaxResults"] = _MaxResults,
	}
	asserts.AssertDescribeNatGatewaysRequest(t)
	return t
end

keys.DetachInternetGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertDetachInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachInternetGatewayRequest[k], "DetachInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachInternetGatewayRequest
-- <p>Contains the parameters for DetachInternetGateway.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- Required parameter: InternetGatewayId
-- Required parameter: VpcId
function M.DetachInternetGatewayRequest(_VpcId, _DryRun, _InternetGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachInternetGatewayRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
		["InternetGatewayId"] = _InternetGatewayId,
	}
	asserts.AssertDetachInternetGatewayRequest(t)
	return t
end

keys.ScheduledInstancesEbs = { ["VolumeSize"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["DeleteOnTermination"] = true, ["SnapshotId"] = true, ["Iops"] = true, nil }

function asserts.AssertScheduledInstancesEbs(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesEbs to be of type 'table'")
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertString(struct["VolumeType"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesEbs[k], "ScheduledInstancesEbs contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesEbs
-- <p>Describes an EBS volume for a Scheduled Instance.</p>
-- @param _VolumeSize [Integer] <p>The size of the volume, in GiB.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- @param _Encrypted [Boolean] <p>Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.</p>
-- @param _VolumeType [String] <p>The volume type. <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, Throughput Optimized HDD for <code>st1</code>, Cold HDD for <code>sc1</code>, or <code>standard</code> for Magnetic.</p> <p>Default: <code>standard</code> </p>
-- @param _DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- @param _SnapshotId [String] <p>The ID of the snapshot.</p>
-- @param _Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about <code>gp2</code> baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for <code>io1</code> volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code>volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
function M.ScheduledInstancesEbs(_VolumeSize, _Encrypted, _VolumeType, _DeleteOnTermination, _SnapshotId, _Iops, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesEbs")
	local t = { 
		["VolumeSize"] = _VolumeSize,
		["Encrypted"] = _Encrypted,
		["VolumeType"] = _VolumeType,
		["DeleteOnTermination"] = _DeleteOnTermination,
		["SnapshotId"] = _SnapshotId,
		["Iops"] = _Iops,
	}
	asserts.AssertScheduledInstancesEbs(t)
	return t
end

keys.CreateImageRequest = { ["DryRun"] = true, ["Description"] = true, ["InstanceId"] = true, ["BlockDeviceMappings"] = true, ["NoReboot"] = true, ["Name"] = true, nil }

function asserts.AssertCreateImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateImageRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["NoReboot"] then asserts.AssertBoolean(struct["NoReboot"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateImageRequest[k], "CreateImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateImageRequest
-- <p>Contains the parameters for CreateImage.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>A description for the new image.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _BlockDeviceMappings [BlockDeviceMappingRequestList] <p>Information about one or more block device mappings.</p>
-- @param _NoReboot [Boolean] <p>By default, Amazon EC2 attempts to shut down and reboot the instance before creating the image. If the 'No Reboot' option is set, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed.</p>
-- @param _Name [String] <p>A name for the new image.</p> <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
-- Required parameter: InstanceId
-- Required parameter: Name
function M.CreateImageRequest(_DryRun, _Description, _InstanceId, _BlockDeviceMappings, _NoReboot, _Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateImageRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["InstanceId"] = _InstanceId,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["NoReboot"] = _NoReboot,
		["Name"] = _Name,
	}
	asserts.AssertCreateImageRequest(t)
	return t
end

keys.DisableVpcClassicLinkDnsSupportResult = { ["Return"] = true, nil }

function asserts.AssertDisableVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkDnsSupportResult[k], "DisableVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkDnsSupportResult
-- <p>Contains the output of DisableVpcClassicLinkDnsSupport.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DisableVpcClassicLinkDnsSupportResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVpcClassicLinkDnsSupportResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertDisableVpcClassicLinkDnsSupportResult(t)
	return t
end

keys.DescribePrefixListsResult = { ["NextToken"] = true, ["PrefixLists"] = true, nil }

function asserts.AssertDescribePrefixListsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrefixListsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["PrefixLists"] then asserts.AssertPrefixListSet(struct["PrefixLists"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePrefixListsResult[k], "DescribePrefixListsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrefixListsResult
-- <p>Contains the output of DescribePrefixLists.</p>
-- @param _NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @param _PrefixLists [PrefixListSet] <p>All available prefix lists.</p>
function M.DescribePrefixListsResult(_NextToken, _PrefixLists, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribePrefixListsResult")
	local t = { 
		["NextToken"] = _NextToken,
		["PrefixLists"] = _PrefixLists,
	}
	asserts.AssertDescribePrefixListsResult(t)
	return t
end

keys.DescribeMovingAddressesResult = { ["MovingAddressStatuses"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeMovingAddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMovingAddressesResult to be of type 'table'")
	if struct["MovingAddressStatuses"] then asserts.AssertMovingAddressStatusSet(struct["MovingAddressStatuses"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMovingAddressesResult[k], "DescribeMovingAddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMovingAddressesResult
-- <p>Contains the output of DescribeMovingAddresses.</p>
-- @param _MovingAddressStatuses [MovingAddressStatusSet] <p>The status for each Elastic IP address.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeMovingAddressesResult(_MovingAddressStatuses, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeMovingAddressesResult")
	local t = { 
		["MovingAddressStatuses"] = _MovingAddressStatuses,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeMovingAddressesResult(t)
	return t
end

keys.VolumeModification = { ["TargetSize"] = true, ["TargetVolumeType"] = true, ["ModificationState"] = true, ["VolumeId"] = true, ["TargetIops"] = true, ["OriginalSize"] = true, ["StartTime"] = true, ["Progress"] = true, ["OriginalVolumeType"] = true, ["OriginalIops"] = true, ["EndTime"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertVolumeModification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeModification to be of type 'table'")
	if struct["TargetSize"] then asserts.AssertInteger(struct["TargetSize"]) end
	if struct["TargetVolumeType"] then asserts.AssertVolumeType(struct["TargetVolumeType"]) end
	if struct["ModificationState"] then asserts.AssertVolumeModificationState(struct["ModificationState"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["TargetIops"] then asserts.AssertInteger(struct["TargetIops"]) end
	if struct["OriginalSize"] then asserts.AssertInteger(struct["OriginalSize"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["Progress"] then asserts.AssertLong(struct["Progress"]) end
	if struct["OriginalVolumeType"] then asserts.AssertVolumeType(struct["OriginalVolumeType"]) end
	if struct["OriginalIops"] then asserts.AssertInteger(struct["OriginalIops"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeModification[k], "VolumeModification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeModification
-- <p>Describes the modification status of an EBS volume.</p> <p>If the volume has never been modified, some element values will be null.</p>
-- @param _TargetSize [Integer] <p>Target size of the volume being modified.</p>
-- @param _TargetVolumeType [VolumeType] <p>Target EBS volume type of the volume being modified.</p>
-- @param _ModificationState [VolumeModificationState] <p>Current state of modification. Modification state is null for unmodified volumes. </p>
-- @param _VolumeId [String] <p>ID of the volume being modified.</p>
-- @param _TargetIops [Integer] <p>Target IOPS rate of the volume being modified.</p>
-- @param _OriginalSize [Integer] <p>Original size of the volume being modified.</p>
-- @param _StartTime [DateTime] <p>Modification start time </p>
-- @param _Progress [Long] <p>Modification progress from 0 to 100%.</p>
-- @param _OriginalVolumeType [VolumeType] <p>Original EBS volume type of the volume being modified.</p>
-- @param _OriginalIops [Integer] <p>Original IOPS rate of the volume being modified.</p>
-- @param _EndTime [DateTime] <p>Modification completion or failure time.</p>
-- @param _StatusMessage [String] <p>Generic status message on modification progress or failure.</p>
function M.VolumeModification(_TargetSize, _TargetVolumeType, _ModificationState, _VolumeId, _TargetIops, _OriginalSize, _StartTime, _Progress, _OriginalVolumeType, _OriginalIops, _EndTime, _StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeModification")
	local t = { 
		["TargetSize"] = _TargetSize,
		["TargetVolumeType"] = _TargetVolumeType,
		["ModificationState"] = _ModificationState,
		["VolumeId"] = _VolumeId,
		["TargetIops"] = _TargetIops,
		["OriginalSize"] = _OriginalSize,
		["StartTime"] = _StartTime,
		["Progress"] = _Progress,
		["OriginalVolumeType"] = _OriginalVolumeType,
		["OriginalIops"] = _OriginalIops,
		["EndTime"] = _EndTime,
		["StatusMessage"] = _StatusMessage,
	}
	asserts.AssertVolumeModification(t)
	return t
end

keys.ModifySnapshotAttributeRequest = { ["DryRun"] = true, ["Attribute"] = true, ["UserIds"] = true, ["GroupNames"] = true, ["CreateVolumePermission"] = true, ["OperationType"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertModifySnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySnapshotAttributeRequest to be of type 'table'")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Attribute"] then asserts.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["UserIds"] then asserts.AssertUserIdStringList(struct["UserIds"]) end
	if struct["GroupNames"] then asserts.AssertGroupNameStringList(struct["GroupNames"]) end
	if struct["CreateVolumePermission"] then asserts.AssertCreateVolumePermissionModifications(struct["CreateVolumePermission"]) end
	if struct["OperationType"] then asserts.AssertOperationType(struct["OperationType"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySnapshotAttributeRequest[k], "ModifySnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySnapshotAttributeRequest
-- <p>Contains the parameters for ModifySnapshotAttribute.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Attribute [SnapshotAttributeName] <p>The snapshot attribute to modify.</p> <note> <p>Only volume creation permissions may be modified at the customer level.</p> </note>
-- @param _UserIds [UserIdStringList] <p>The account ID to modify for the snapshot.</p>
-- @param _GroupNames [GroupNameStringList] <p>The group to modify for the snapshot.</p>
-- @param _CreateVolumePermission [CreateVolumePermissionModifications] <p>A JSON representation of the snapshot attribute modification.</p>
-- @param _OperationType [OperationType] <p>The type of operation to perform to the attribute.</p>
-- @param _SnapshotId [String] <p>The ID of the snapshot.</p>
-- Required parameter: SnapshotId
function M.ModifySnapshotAttributeRequest(_DryRun, _Attribute, _UserIds, _GroupNames, _CreateVolumePermission, _OperationType, _SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifySnapshotAttributeRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Attribute"] = _Attribute,
		["UserIds"] = _UserIds,
		["GroupNames"] = _GroupNames,
		["CreateVolumePermission"] = _CreateVolumePermission,
		["OperationType"] = _OperationType,
		["SnapshotId"] = _SnapshotId,
	}
	asserts.AssertModifySnapshotAttributeRequest(t)
	return t
end

keys.DescribeAddressesResult = { ["Addresses"] = true, nil }

function asserts.AssertDescribeAddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAddressesResult to be of type 'table'")
	if struct["Addresses"] then asserts.AssertAddressList(struct["Addresses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAddressesResult[k], "DescribeAddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAddressesResult
-- <p>Contains the output of DescribeAddresses.</p>
-- @param _Addresses [AddressList] <p>Information about one or more Elastic IP addresses.</p>
function M.DescribeAddressesResult(_Addresses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAddressesResult")
	local t = { 
		["Addresses"] = _Addresses,
	}
	asserts.AssertDescribeAddressesResult(t)
	return t
end

keys.RunInstancesMonitoringEnabled = { ["Enabled"] = true, nil }

function asserts.AssertRunInstancesMonitoringEnabled(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunInstancesMonitoringEnabled to be of type 'table'")
	assert(struct["Enabled"], "Expected key Enabled to exist in table")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunInstancesMonitoringEnabled[k], "RunInstancesMonitoringEnabled contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunInstancesMonitoringEnabled
-- <p>Describes the monitoring of an instance.</p>
-- @param _Enabled [Boolean] <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
-- Required parameter: Enabled
function M.RunInstancesMonitoringEnabled(_Enabled, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RunInstancesMonitoringEnabled")
	local t = { 
		["Enabled"] = _Enabled,
	}
	asserts.AssertRunInstancesMonitoringEnabled(t)
	return t
end

keys.HostProperties = { ["Cores"] = true, ["TotalVCpus"] = true, ["InstanceType"] = true, ["Sockets"] = true, nil }

function asserts.AssertHostProperties(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostProperties to be of type 'table'")
	if struct["Cores"] then asserts.AssertInteger(struct["Cores"]) end
	if struct["TotalVCpus"] then asserts.AssertInteger(struct["TotalVCpus"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["Sockets"] then asserts.AssertInteger(struct["Sockets"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostProperties[k], "HostProperties contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostProperties
-- <p>Describes properties of a Dedicated Host.</p>
-- @param _Cores [Integer] <p>The number of cores on the Dedicated Host.</p>
-- @param _TotalVCpus [Integer] <p>The number of vCPUs on the Dedicated Host.</p>
-- @param _InstanceType [String] <p>The instance type size that the Dedicated Host supports (for example, <code>m3.medium</code>).</p>
-- @param _Sockets [Integer] <p>The number of sockets on the Dedicated Host.</p>
function M.HostProperties(_Cores, _TotalVCpus, _InstanceType, _Sockets, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HostProperties")
	local t = { 
		["Cores"] = _Cores,
		["TotalVCpus"] = _TotalVCpus,
		["InstanceType"] = _InstanceType,
		["Sockets"] = _Sockets,
	}
	asserts.AssertHostProperties(t)
	return t
end

keys.InstanceStatusSummary = { ["Status"] = true, ["Details"] = true, nil }

function asserts.AssertInstanceStatusSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusSummary to be of type 'table'")
	if struct["Status"] then asserts.AssertSummaryStatus(struct["Status"]) end
	if struct["Details"] then asserts.AssertInstanceStatusDetailsList(struct["Details"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatusSummary[k], "InstanceStatusSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusSummary
-- <p>Describes the status of an instance.</p>
-- @param _Status [SummaryStatus] <p>The status.</p>
-- @param _Details [InstanceStatusDetailsList] <p>The system instance health or application instance health.</p>
function M.InstanceStatusSummary(_Status, _Details, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStatusSummary")
	local t = { 
		["Status"] = _Status,
		["Details"] = _Details,
	}
	asserts.AssertInstanceStatusSummary(t)
	return t
end

keys.DescribeVpcsRequest = { ["DryRun"] = true, ["Filters"] = true, ["VpcIds"] = true, nil }

function asserts.AssertDescribeVpcsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["VpcIds"] then asserts.AssertVpcIdStringList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcsRequest[k], "DescribeVpcsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcsRequest
-- <p>Contains the parameters for DescribeVpcs.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>cidr</code> - The IPv4 CIDR block of the VPC. The CIDR block you specify must exactly match the VPC's CIDR block for information to be returned for the VPC. Must contain the slash followed by one or two digits (for example, <code>/28</code>).</p> </li> <li> <p> <code>dhcp-options-id</code> - The ID of a set of DHCP options.</p> </li> <li> <p> <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>ipv6-cidr-block-association.association-id</code> - The association ID for an IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>isDefault</code> - Indicates whether the VPC is the default VPC.</p> </li> <li> <p> <code>state</code> - The state of the VPC (<code>pending</code> | <code>available</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC.</p> </li> </ul>
-- @param _VpcIds [VpcIdStringList] <p>One or more VPC IDs.</p> <p>Default: Describes all your VPCs.</p>
function M.DescribeVpcsRequest(_DryRun, _Filters, _VpcIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcsRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
		["VpcIds"] = _VpcIds,
	}
	asserts.AssertDescribeVpcsRequest(t)
	return t
end

keys.SubnetIpv6CidrBlockAssociation = { ["Ipv6CidrBlock"] = true, ["AssociationId"] = true, ["Ipv6CidrBlockState"] = true, nil }

function asserts.AssertSubnetIpv6CidrBlockAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SubnetIpv6CidrBlockAssociation to be of type 'table'")
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["Ipv6CidrBlockState"] then asserts.AssertSubnetCidrBlockState(struct["Ipv6CidrBlockState"]) end
	for k,_ in pairs(struct) do
		assert(keys.SubnetIpv6CidrBlockAssociation[k], "SubnetIpv6CidrBlockAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SubnetIpv6CidrBlockAssociation
-- <p>Describes an IPv6 CIDR block associated with a subnet.</p>
-- @param _Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- @param _AssociationId [String] <p>The association ID for the CIDR block.</p>
-- @param _Ipv6CidrBlockState [SubnetCidrBlockState] <p>Information about the state of the CIDR block.</p>
function M.SubnetIpv6CidrBlockAssociation(_Ipv6CidrBlock, _AssociationId, _Ipv6CidrBlockState, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SubnetIpv6CidrBlockAssociation")
	local t = { 
		["Ipv6CidrBlock"] = _Ipv6CidrBlock,
		["AssociationId"] = _AssociationId,
		["Ipv6CidrBlockState"] = _Ipv6CidrBlockState,
	}
	asserts.AssertSubnetIpv6CidrBlockAssociation(t)
	return t
end

keys.CreateRouteTableResult = { ["RouteTable"] = true, nil }

function asserts.AssertCreateRouteTableResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteTableResult to be of type 'table'")
	if struct["RouteTable"] then asserts.AssertRouteTable(struct["RouteTable"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteTableResult[k], "CreateRouteTableResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteTableResult
-- <p>Contains the output of CreateRouteTable.</p>
-- @param _RouteTable [RouteTable] <p>Information about the route table.</p>
function M.CreateRouteTableResult(_RouteTable, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateRouteTableResult")
	local t = { 
		["RouteTable"] = _RouteTable,
	}
	asserts.AssertCreateRouteTableResult(t)
	return t
end

keys.ModifyVpcEndpointResult = { ["Return"] = true, nil }

function asserts.AssertModifyVpcEndpointResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointResult[k], "ModifyVpcEndpointResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointResult
-- <p>Contains the output of ModifyVpcEndpoint.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.ModifyVpcEndpointResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcEndpointResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertModifyVpcEndpointResult(t)
	return t
end

keys.DescribeTagsResult = { ["NextToken"] = true, ["Tags"] = true, nil }

function asserts.AssertDescribeTagsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeTagsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Tags"] then asserts.AssertTagDescriptionList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeTagsResult[k], "DescribeTagsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeTagsResult
-- <p>Contains the output of DescribeTags.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return..</p>
-- @param _Tags [TagDescriptionList] <p>A list of tags.</p>
function M.DescribeTagsResult(_NextToken, _Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeTagsResult")
	local t = { 
		["NextToken"] = _NextToken,
		["Tags"] = _Tags,
	}
	asserts.AssertDescribeTagsResult(t)
	return t
end

keys.DeleteVpcPeeringConnectionResult = { ["Return"] = true, nil }

function asserts.AssertDeleteVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcPeeringConnectionResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcPeeringConnectionResult[k], "DeleteVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcPeeringConnectionResult
-- <p>Contains the output of DeleteVpcPeeringConnection.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DeleteVpcPeeringConnectionResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcPeeringConnectionResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertDeleteVpcPeeringConnectionResult(t)
	return t
end

keys.BlockDeviceMapping = { ["DeviceName"] = true, ["VirtualName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BlockDeviceMapping to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertEbsBlockDevice(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.BlockDeviceMapping[k], "BlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BlockDeviceMapping
-- <p>Describes a block device mapping.</p>
-- @param _DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param _VirtualName [String] <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
-- @param _NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- @param _Ebs [EbsBlockDevice] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
function M.BlockDeviceMapping(_DeviceName, _VirtualName, _NoDevice, _Ebs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BlockDeviceMapping")
	local t = { 
		["DeviceName"] = _DeviceName,
		["VirtualName"] = _VirtualName,
		["NoDevice"] = _NoDevice,
		["Ebs"] = _Ebs,
	}
	asserts.AssertBlockDeviceMapping(t)
	return t
end

keys.ImportInstanceResult = { ["ConversionTask"] = true, nil }

function asserts.AssertImportInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceResult to be of type 'table'")
	if struct["ConversionTask"] then asserts.AssertConversionTask(struct["ConversionTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceResult[k], "ImportInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceResult
-- <p>Contains the output for ImportInstance.</p>
-- @param _ConversionTask [ConversionTask] <p>Information about the conversion task.</p>
function M.ImportInstanceResult(_ConversionTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceResult")
	local t = { 
		["ConversionTask"] = _ConversionTask,
	}
	asserts.AssertImportInstanceResult(t)
	return t
end

keys.AssociateRouteTableResult = { ["AssociationId"] = true, nil }

function asserts.AssertAssociateRouteTableResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateRouteTableResult to be of type 'table'")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateRouteTableResult[k], "AssociateRouteTableResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateRouteTableResult
-- <p>Contains the output of AssociateRouteTable.</p>
-- @param _AssociationId [String] <p>The route table association ID (needed to disassociate the route table).</p>
function M.AssociateRouteTableResult(_AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateRouteTableResult")
	local t = { 
		["AssociationId"] = _AssociationId,
	}
	asserts.AssertAssociateRouteTableResult(t)
	return t
end

keys.DiskImageVolumeDescription = { ["Id"] = true, ["Size"] = true, nil }

function asserts.AssertDiskImageVolumeDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageVolumeDescription to be of type 'table'")
	assert(struct["Id"], "Expected key Id to exist in table")
	if struct["Id"] then asserts.AssertString(struct["Id"]) end
	if struct["Size"] then asserts.AssertLong(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImageVolumeDescription[k], "DiskImageVolumeDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageVolumeDescription
-- <p>Describes a disk image volume.</p>
-- @param _Id [String] <p>The volume identifier.</p>
-- @param _Size [Long] <p>The size of the volume, in GiB.</p>
-- Required parameter: Id
function M.DiskImageVolumeDescription(_Id, _Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DiskImageVolumeDescription")
	local t = { 
		["Id"] = _Id,
		["Size"] = _Size,
	}
	asserts.AssertDiskImageVolumeDescription(t)
	return t
end

keys.VpcAttachment = { ["State"] = true, ["VpcId"] = true, nil }

function asserts.AssertVpcAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcAttachment to be of type 'table'")
	if struct["State"] then asserts.AssertAttachmentStatus(struct["State"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcAttachment[k], "VpcAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcAttachment
-- <p>Describes an attachment between a virtual private gateway and a VPC.</p>
-- @param _State [AttachmentStatus] <p>The current state of the attachment.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
function M.VpcAttachment(_State, _VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcAttachment")
	local t = { 
		["State"] = _State,
		["VpcId"] = _VpcId,
	}
	asserts.AssertVpcAttachment(t)
	return t
end

keys.Snapshot = { ["OwnerAlias"] = true, ["DataEncryptionKeyId"] = true, ["Description"] = true, ["VolumeSize"] = true, ["Tags"] = true, ["Encrypted"] = true, ["SnapshotId"] = true, ["VolumeId"] = true, ["StateMessage"] = true, ["State"] = true, ["KmsKeyId"] = true, ["StartTime"] = true, ["OwnerId"] = true, ["Progress"] = true, nil }

function asserts.AssertSnapshot(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Snapshot to be of type 'table'")
	if struct["OwnerAlias"] then asserts.AssertString(struct["OwnerAlias"]) end
	if struct["DataEncryptionKeyId"] then asserts.AssertString(struct["DataEncryptionKeyId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["StateMessage"] then asserts.AssertString(struct["StateMessage"]) end
	if struct["State"] then asserts.AssertSnapshotState(struct["State"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	for k,_ in pairs(struct) do
		assert(keys.Snapshot[k], "Snapshot contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Snapshot
-- <p>Describes a snapshot.</p>
-- @param _OwnerAlias [String] <p> Value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console. </p>
-- @param _DataEncryptionKeyId [String] <p>The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by the <a>DescribeSnapshots</a> API operation.</p>
-- @param _Description [String] <p>The description for the snapshot.</p>
-- @param _VolumeSize [Integer] <p>The size of the volume, in GiB.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the snapshot.</p>
-- @param _Encrypted [Boolean] <p>Indicates whether the snapshot is encrypted.</p>
-- @param _SnapshotId [String] <p>The ID of the snapshot. Each snapshot receives a unique identifier when it is created.</p>
-- @param _VolumeId [String] <p>The ID of the volume that was used to create the snapshot. Snapshots created by the <a>CopySnapshot</a> action have an arbitrary volume ID that should not be used for any purpose.</p>
-- @param _StateMessage [String] <p>Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper AWS Key Management Service (AWS KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by the <a>DescribeSnapshots</a> API operation.</p>
-- @param _State [SnapshotState] <p>The snapshot state.</p>
-- @param _KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the parent volume.</p>
-- @param _StartTime [DateTime] <p>The time stamp when the snapshot was initiated.</p>
-- @param _OwnerId [String] <p>The AWS account ID of the EBS snapshot owner.</p>
-- @param _Progress [String] <p>The progress of the snapshot, as a percentage.</p>
function M.Snapshot(_OwnerAlias, _DataEncryptionKeyId, _Description, _VolumeSize, _Tags, _Encrypted, _SnapshotId, _VolumeId, _StateMessage, _State, _KmsKeyId, _StartTime, _OwnerId, _Progress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Snapshot")
	local t = { 
		["OwnerAlias"] = _OwnerAlias,
		["DataEncryptionKeyId"] = _DataEncryptionKeyId,
		["Description"] = _Description,
		["VolumeSize"] = _VolumeSize,
		["Tags"] = _Tags,
		["Encrypted"] = _Encrypted,
		["SnapshotId"] = _SnapshotId,
		["VolumeId"] = _VolumeId,
		["StateMessage"] = _StateMessage,
		["State"] = _State,
		["KmsKeyId"] = _KmsKeyId,
		["StartTime"] = _StartTime,
		["OwnerId"] = _OwnerId,
		["Progress"] = _Progress,
	}
	asserts.AssertSnapshot(t)
	return t
end

keys.DescribeVpcsResult = { ["Vpcs"] = true, nil }

function asserts.AssertDescribeVpcsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcsResult to be of type 'table'")
	if struct["Vpcs"] then asserts.AssertVpcList(struct["Vpcs"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcsResult[k], "DescribeVpcsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcsResult
-- <p>Contains the output of DescribeVpcs.</p>
-- @param _Vpcs [VpcList] <p>Information about one or more VPCs.</p>
function M.DescribeVpcsResult(_Vpcs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcsResult")
	local t = { 
		["Vpcs"] = _Vpcs,
	}
	asserts.AssertDescribeVpcsResult(t)
	return t
end

keys.CancelSpotFleetRequestsErrorItem = { ["SpotFleetRequestId"] = true, ["Error"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsErrorItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsErrorItem to be of type 'table'")
	assert(struct["Error"], "Expected key Error to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["Error"] then asserts.AssertCancelSpotFleetRequestsError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsErrorItem[k], "CancelSpotFleetRequestsErrorItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsErrorItem
-- <p>Describes a Spot fleet request that was not successfully canceled.</p>
-- @param _SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param _Error [CancelSpotFleetRequestsError] <p>The error.</p>
-- Required parameter: Error
-- Required parameter: SpotFleetRequestId
function M.CancelSpotFleetRequestsErrorItem(_SpotFleetRequestId, _Error, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsErrorItem")
	local t = { 
		["SpotFleetRequestId"] = _SpotFleetRequestId,
		["Error"] = _Error,
	}
	asserts.AssertCancelSpotFleetRequestsErrorItem(t)
	return t
end

keys.DeleteRouteRequest = { ["DestinationCidrBlock"] = true, ["DryRun"] = true, ["DestinationIpv6CidrBlock"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertDeleteRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteRouteRequest[k], "DeleteRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRouteRequest
-- <p>Contains the parameters for DeleteRoute.</p>
-- @param _DestinationCidrBlock [String] <p>The IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
-- @param _RouteTableId [String] <p>The ID of the route table.</p>
-- Required parameter: RouteTableId
function M.DeleteRouteRequest(_DestinationCidrBlock, _DryRun, _DestinationIpv6CidrBlock, _RouteTableId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteRouteRequest")
	local t = { 
		["DestinationCidrBlock"] = _DestinationCidrBlock,
		["DryRun"] = _DryRun,
		["DestinationIpv6CidrBlock"] = _DestinationIpv6CidrBlock,
		["RouteTableId"] = _RouteTableId,
	}
	asserts.AssertDeleteRouteRequest(t)
	return t
end

keys.ReplaceRouteRequest = { ["DestinationCidrBlock"] = true, ["EgressOnlyInternetGatewayId"] = true, ["DryRun"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["RouteTableId"] = true, ["NatGatewayId"] = true, ["VpcPeeringConnectionId"] = true, ["GatewayId"] = true, ["DestinationIpv6CidrBlock"] = true, nil }

function asserts.AssertReplaceRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceRouteRequest[k], "ReplaceRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteRequest
-- <p>Contains the parameters for ReplaceRoute.</p>
-- @param _DestinationCidrBlock [String] <p>The IPv4 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.</p>
-- @param _EgressOnlyInternetGatewayId [String] <p>[IPv6 traffic only] The ID of an egress-only Internet gateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceId [String] <p>The ID of a NAT instance in your VPC.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of a network interface.</p>
-- @param _RouteTableId [String] <p>The ID of the route table.</p>
-- @param _NatGatewayId [String] <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of a VPC peering connection.</p>
-- @param _GatewayId [String] <p>The ID of an Internet gateway or virtual private gateway.</p>
-- @param _DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.</p>
-- Required parameter: RouteTableId
function M.ReplaceRouteRequest(_DestinationCidrBlock, _EgressOnlyInternetGatewayId, _DryRun, _InstanceId, _NetworkInterfaceId, _RouteTableId, _NatGatewayId, _VpcPeeringConnectionId, _GatewayId, _DestinationIpv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceRouteRequest")
	local t = { 
		["DestinationCidrBlock"] = _DestinationCidrBlock,
		["EgressOnlyInternetGatewayId"] = _EgressOnlyInternetGatewayId,
		["DryRun"] = _DryRun,
		["InstanceId"] = _InstanceId,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["RouteTableId"] = _RouteTableId,
		["NatGatewayId"] = _NatGatewayId,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
		["GatewayId"] = _GatewayId,
		["DestinationIpv6CidrBlock"] = _DestinationIpv6CidrBlock,
	}
	asserts.AssertReplaceRouteRequest(t)
	return t
end

keys.SecurityGroupReference = { ["ReferencingVpcId"] = true, ["GroupId"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertSecurityGroupReference(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityGroupReference to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	assert(struct["ReferencingVpcId"], "Expected key ReferencingVpcId to exist in table")
	if struct["ReferencingVpcId"] then asserts.AssertString(struct["ReferencingVpcId"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityGroupReference[k], "SecurityGroupReference contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityGroupReference
-- <p>Describes a VPC with a security group that references your security group.</p>
-- @param _ReferencingVpcId [String] <p>The ID of the VPC with the referencing security group.</p>
-- @param _GroupId [String] <p>The ID of your security group.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required parameter: GroupId
-- Required parameter: ReferencingVpcId
function M.SecurityGroupReference(_ReferencingVpcId, _GroupId, _VpcPeeringConnectionId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SecurityGroupReference")
	local t = { 
		["ReferencingVpcId"] = _ReferencingVpcId,
		["GroupId"] = _GroupId,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
	}
	asserts.AssertSecurityGroupReference(t)
	return t
end

keys.DescribeConversionTasksResult = { ["ConversionTasks"] = true, nil }

function asserts.AssertDescribeConversionTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeConversionTasksResult to be of type 'table'")
	if struct["ConversionTasks"] then asserts.AssertDescribeConversionTaskList(struct["ConversionTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeConversionTasksResult[k], "DescribeConversionTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeConversionTasksResult
-- <p>Contains the output for DescribeConversionTasks.</p>
-- @param _ConversionTasks [DescribeConversionTaskList] <p>Information about the conversion tasks.</p>
function M.DescribeConversionTasksResult(_ConversionTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeConversionTasksResult")
	local t = { 
		["ConversionTasks"] = _ConversionTasks,
	}
	asserts.AssertDescribeConversionTasksResult(t)
	return t
end

keys.CreateSnapshotRequest = { ["DryRun"] = true, ["Description"] = true, ["VolumeId"] = true, nil }

function asserts.AssertCreateSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSnapshotRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSnapshotRequest[k], "CreateSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSnapshotRequest
-- <p>Contains the parameters for CreateSnapshot.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>A description for the snapshot.</p>
-- @param _VolumeId [String] <p>The ID of the EBS volume.</p>
-- Required parameter: VolumeId
function M.CreateSnapshotRequest(_DryRun, _Description, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSnapshotRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertCreateSnapshotRequest(t)
	return t
end

keys.AssociateSubnetCidrBlockRequest = { ["SubnetId"] = true, ["Ipv6CidrBlock"] = true, nil }

function asserts.AssertAssociateSubnetCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateSubnetCidrBlockRequest to be of type 'table'")
	assert(struct["Ipv6CidrBlock"], "Expected key Ipv6CidrBlock to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateSubnetCidrBlockRequest[k], "AssociateSubnetCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateSubnetCidrBlockRequest
--  
-- @param _SubnetId [String] <p>The ID of your subnet.</p>
-- @param _Ipv6CidrBlock [String] <p>The IPv6 CIDR block for your subnet. The subnet must have a /64 prefix length.</p>
-- Required parameter: Ipv6CidrBlock
-- Required parameter: SubnetId
function M.AssociateSubnetCidrBlockRequest(_SubnetId, _Ipv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateSubnetCidrBlockRequest")
	local t = { 
		["SubnetId"] = _SubnetId,
		["Ipv6CidrBlock"] = _Ipv6CidrBlock,
	}
	asserts.AssertAssociateSubnetCidrBlockRequest(t)
	return t
end

keys.ImageAttribute = { ["ProductCodes"] = true, ["Description"] = true, ["LaunchPermissions"] = true, ["SriovNetSupport"] = true, ["ImageId"] = true, ["BlockDeviceMappings"] = true, ["KernelId"] = true, ["RamdiskId"] = true, nil }

function asserts.AssertImageAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImageAttribute to be of type 'table'")
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	if struct["LaunchPermissions"] then asserts.AssertLaunchPermissionList(struct["LaunchPermissions"]) end
	if struct["SriovNetSupport"] then asserts.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then asserts.AssertAttributeValue(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertAttributeValue(struct["RamdiskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImageAttribute[k], "ImageAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImageAttribute
-- <p>Describes an image attribute.</p>
-- @param _ProductCodes [ProductCodeList] <p>One or more product codes.</p>
-- @param _Description [AttributeValue] <p>A description for the AMI.</p>
-- @param _LaunchPermissions [LaunchPermissionList] <p>One or more launch permissions.</p>
-- @param _SriovNetSupport [AttributeValue] <p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- @param _ImageId [String] <p>The ID of the AMI.</p>
-- @param _BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p>
-- @param _KernelId [AttributeValue] <p>The kernel ID.</p>
-- @param _RamdiskId [AttributeValue] <p>The RAM disk ID.</p>
function M.ImageAttribute(_ProductCodes, _Description, _LaunchPermissions, _SriovNetSupport, _ImageId, _BlockDeviceMappings, _KernelId, _RamdiskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImageAttribute")
	local t = { 
		["ProductCodes"] = _ProductCodes,
		["Description"] = _Description,
		["LaunchPermissions"] = _LaunchPermissions,
		["SriovNetSupport"] = _SriovNetSupport,
		["ImageId"] = _ImageId,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["KernelId"] = _KernelId,
		["RamdiskId"] = _RamdiskId,
	}
	asserts.AssertImageAttribute(t)
	return t
end

keys.DeleteEgressOnlyInternetGatewayRequest = { ["EgressOnlyInternetGatewayId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteEgressOnlyInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteEgressOnlyInternetGatewayRequest to be of type 'table'")
	assert(struct["EgressOnlyInternetGatewayId"], "Expected key EgressOnlyInternetGatewayId to exist in table")
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertEgressOnlyInternetGatewayId(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteEgressOnlyInternetGatewayRequest[k], "DeleteEgressOnlyInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteEgressOnlyInternetGatewayRequest
--  
-- @param _EgressOnlyInternetGatewayId [EgressOnlyInternetGatewayId] <p>The ID of the egress-only Internet gateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: EgressOnlyInternetGatewayId
function M.DeleteEgressOnlyInternetGatewayRequest(_EgressOnlyInternetGatewayId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteEgressOnlyInternetGatewayRequest")
	local t = { 
		["EgressOnlyInternetGatewayId"] = _EgressOnlyInternetGatewayId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteEgressOnlyInternetGatewayRequest(t)
	return t
end

keys.DescribeVolumesRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["VolumeIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVolumesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeIds"] then asserts.AssertVolumeIdStringList(struct["VolumeIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesRequest[k], "DescribeVolumesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesRequest
-- <p>Contains the parameters for DescribeVolumes.</p>
-- @param _MaxResults [Integer] <p>The maximum number of volume results returned by <code>DescribeVolumes</code> in paginated output. When this parameter is used, <code>DescribeVolumes</code> only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>DescribeVolumes</code> request with the returned <code>NextToken</code> value. This value can be between 5 and 500; if <code>MaxResults</code> is given a value larger than 500, only 500 results are returned. If this parameter is not used, then <code>DescribeVolumes</code> returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.</p>
-- @param _NextToken [String] <p>The <code>NextToken</code> value returned from a previous paginated <code>DescribeVolumes</code> request where <code>MaxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>NextToken</code> value. This value is <code>null</code> when there are no more results to return.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VolumeIds [VolumeIdStringList] <p>One or more volume IDs.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.attach-time</code> - The time stamp when the attachment initiated.</p> </li> <li> <p> <code>attachment.delete-on-termination</code> - Whether the volume is deleted on instance termination.</p> </li> <li> <p> <code>attachment.device</code> - The device name that is exposed to the instance (for example, <code>/dev/sda1</code>).</p> </li> <li> <p> <code>attachment.instance-id</code> - The ID of the instance the volume is attached to.</p> </li> <li> <p> <code>attachment.status</code> - The attachment state (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone in which the volume was created.</p> </li> <li> <p> <code>create-time</code> - The time stamp when the volume was created.</p> </li> <li> <p> <code>encrypted</code> - The encryption status of the volume.</p> </li> <li> <p> <code>size</code> - The size of the volume, in GiB.</p> </li> <li> <p> <code>snapshot-id</code> - The snapshot from which the volume was created.</p> </li> <li> <p> <code>status</code> - The status of the volume (<code>creating</code> | <code>available</code> | <code>in-use</code> | <code>deleting</code> | <code>deleted</code> | <code>error</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>volume-id</code> - The volume ID.</p> </li> <li> <p> <code>volume-type</code> - The Amazon EBS volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p> </li> </ul>
function M.DescribeVolumesRequest(_MaxResults, _NextToken, _DryRun, _VolumeIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumesRequest")
	local t = { 
		["MaxResults"] = _MaxResults,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["VolumeIds"] = _VolumeIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeVolumesRequest(t)
	return t
end

keys.DescribeHostsRequest = { ["Filter"] = true, ["HostIds"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostsRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["HostIds"] then asserts.AssertRequestHostIdList(struct["HostIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostsRequest[k], "DescribeHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostsRequest
-- <p>Contains the parameters for DescribeHosts.</p>
-- @param _Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-type</code> - The instance type size that the Dedicated Host is configured to support.</p> </li> <li> <p> <code>auto-placement</code> - Whether auto-placement is enabled or disabled (<code>on</code> | <code>off</code>).</p> </li> <li> <p> <code>host-reservation-id</code> - The ID of the reservation assigned to this host.</p> </li> <li> <p> <code>client-token</code> - The idempotency token you provided when you launched the instance</p> </li> <li> <p> <code>state</code>- The allocation state of the Dedicated Host (<code>available</code> | <code>under-assessment</code> | <code>permanent-failure</code> | <code>released</code> | <code>released-permanent-failure</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the host.</p> </li> </ul>
-- @param _HostIds [RequestHostIdList] <p>The IDs of the Dedicated Hosts. The IDs are used for targeted instance launches.</p>
-- @param _NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500; if <code>maxResults</code> is given a larger value than 500, you will receive an error. You cannot specify this parameter and the host IDs parameter in the same request.</p>
function M.DescribeHostsRequest(_Filter, _HostIds, _NextToken, _MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostsRequest")
	local t = { 
		["Filter"] = _Filter,
		["HostIds"] = _HostIds,
		["NextToken"] = _NextToken,
		["MaxResults"] = _MaxResults,
	}
	asserts.AssertDescribeHostsRequest(t)
	return t
end

keys.DescribeImportImageTasksResult = { ["NextToken"] = true, ["ImportImageTasks"] = true, nil }

function asserts.AssertDescribeImportImageTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportImageTasksResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ImportImageTasks"] then asserts.AssertImportImageTaskList(struct["ImportImageTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportImageTasksResult[k], "DescribeImportImageTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportImageTasksResult
-- <p>Contains the output for DescribeImportImageTasks.</p>
-- @param _NextToken [String] <p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _ImportImageTasks [ImportImageTaskList] <p>A list of zero or more import image tasks that are currently active or were completed or canceled in the previous 7 days.</p>
function M.DescribeImportImageTasksResult(_NextToken, _ImportImageTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImportImageTasksResult")
	local t = { 
		["NextToken"] = _NextToken,
		["ImportImageTasks"] = _ImportImageTasks,
	}
	asserts.AssertDescribeImportImageTasksResult(t)
	return t
end

keys.CreatePlacementGroupRequest = { ["GroupName"] = true, ["DryRun"] = true, ["Strategy"] = true, nil }

function asserts.AssertCreatePlacementGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePlacementGroupRequest to be of type 'table'")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	assert(struct["Strategy"], "Expected key Strategy to exist in table")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Strategy"] then asserts.AssertPlacementStrategy(struct["Strategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreatePlacementGroupRequest[k], "CreatePlacementGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePlacementGroupRequest
-- <p>Contains the parameters for CreatePlacementGroup.</p>
-- @param _GroupName [String] <p>A name for the placement group.</p> <p>Constraints: Up to 255 ASCII characters</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Strategy [PlacementStrategy] <p>The placement strategy.</p>
-- Required parameter: GroupName
-- Required parameter: Strategy
function M.CreatePlacementGroupRequest(_GroupName, _DryRun, _Strategy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreatePlacementGroupRequest")
	local t = { 
		["GroupName"] = _GroupName,
		["DryRun"] = _DryRun,
		["Strategy"] = _Strategy,
	}
	asserts.AssertCreatePlacementGroupRequest(t)
	return t
end

keys.DisassociateIamInstanceProfileResult = { ["IamInstanceProfileAssociation"] = true, nil }

function asserts.AssertDisassociateIamInstanceProfileResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateIamInstanceProfileResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then asserts.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateIamInstanceProfileResult[k], "DisassociateIamInstanceProfileResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateIamInstanceProfileResult
--  
-- @param _IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
function M.DisassociateIamInstanceProfileResult(_IamInstanceProfileAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateIamInstanceProfileResult")
	local t = { 
		["IamInstanceProfileAssociation"] = _IamInstanceProfileAssociation,
	}
	asserts.AssertDisassociateIamInstanceProfileResult(t)
	return t
end

keys.AssignIpv6AddressesResult = { ["AssignedIpv6Addresses"] = true, ["NetworkInterfaceId"] = true, nil }

function asserts.AssertAssignIpv6AddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignIpv6AddressesResult to be of type 'table'")
	if struct["AssignedIpv6Addresses"] then asserts.AssertIpv6AddressList(struct["AssignedIpv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssignIpv6AddressesResult[k], "AssignIpv6AddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignIpv6AddressesResult
--  
-- @param _AssignedIpv6Addresses [Ipv6AddressList] <p>The IPv6 addresses assigned to the network interface.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
function M.AssignIpv6AddressesResult(_AssignedIpv6Addresses, _NetworkInterfaceId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssignIpv6AddressesResult")
	local t = { 
		["AssignedIpv6Addresses"] = _AssignedIpv6Addresses,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
	}
	asserts.AssertAssignIpv6AddressesResult(t)
	return t
end

keys.StaleSecurityGroup = { ["VpcId"] = true, ["StaleIpPermissionsEgress"] = true, ["GroupName"] = true, ["StaleIpPermissions"] = true, ["GroupId"] = true, ["Description"] = true, nil }

function asserts.AssertStaleSecurityGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StaleSecurityGroup to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["StaleIpPermissionsEgress"] then asserts.AssertStaleIpPermissionSet(struct["StaleIpPermissionsEgress"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["StaleIpPermissions"] then asserts.AssertStaleIpPermissionSet(struct["StaleIpPermissions"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.StaleSecurityGroup[k], "StaleSecurityGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StaleSecurityGroup
-- <p>Describes a stale security group (a security group that contains stale rules).</p>
-- @param _VpcId [String] <p>The ID of the VPC for the security group.</p>
-- @param _StaleIpPermissionsEgress [StaleIpPermissionSet] <p>Information about the stale outbound rules in the security group.</p>
-- @param _GroupName [String] <p>The name of the security group.</p>
-- @param _StaleIpPermissions [StaleIpPermissionSet] <p>Information about the stale inbound rules in the security group.</p>
-- @param _GroupId [String] <p>The ID of the security group.</p>
-- @param _Description [String] <p>The description of the security group.</p>
-- Required parameter: GroupId
function M.StaleSecurityGroup(_VpcId, _StaleIpPermissionsEgress, _GroupName, _StaleIpPermissions, _GroupId, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StaleSecurityGroup")
	local t = { 
		["VpcId"] = _VpcId,
		["StaleIpPermissionsEgress"] = _StaleIpPermissionsEgress,
		["GroupName"] = _GroupName,
		["StaleIpPermissions"] = _StaleIpPermissions,
		["GroupId"] = _GroupId,
		["Description"] = _Description,
	}
	asserts.AssertStaleSecurityGroup(t)
	return t
end

keys.IamInstanceProfileSpecification = { ["Name"] = true, ["Arn"] = true, nil }

function asserts.AssertIamInstanceProfileSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfileSpecification to be of type 'table'")
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.IamInstanceProfileSpecification[k], "IamInstanceProfileSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfileSpecification
-- <p>Describes an IAM instance profile.</p>
-- @param _Name [String] <p>The name of the instance profile.</p>
-- @param _Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
function M.IamInstanceProfileSpecification(_Name, _Arn, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IamInstanceProfileSpecification")
	local t = { 
		["Name"] = _Name,
		["Arn"] = _Arn,
	}
	asserts.AssertIamInstanceProfileSpecification(t)
	return t
end

keys.DescribeVolumeAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDescribeVolumeAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeAttributeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Attribute"] then asserts.AssertVolumeAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeAttributeRequest[k], "DescribeVolumeAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeAttributeRequest
-- <p>Contains the parameters for DescribeVolumeAttribute.</p>
-- @param _Attribute [VolumeAttributeName] <p>The attribute of the volume. This parameter is required.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.DescribeVolumeAttributeRequest(_Attribute, _DryRun, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumeAttributeRequest")
	local t = { 
		["Attribute"] = _Attribute,
		["DryRun"] = _DryRun,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertDescribeVolumeAttributeRequest(t)
	return t
end

keys.DescribeSecurityGroupsRequest = { ["GroupNames"] = true, ["DryRun"] = true, ["GroupIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeSecurityGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupsRequest to be of type 'table'")
	if struct["GroupNames"] then asserts.AssertGroupNameStringList(struct["GroupNames"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupIds"] then asserts.AssertGroupIdStringList(struct["GroupIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupsRequest[k], "DescribeSecurityGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupsRequest
-- <p>Contains the parameters for DescribeSecurityGroups.</p>
-- @param _GroupNames [GroupNameStringList] <p>[EC2-Classic and default VPC only] One or more security group names. You can specify either the security group name or the security group ID. For security groups in a nondefault VPC, use the <code>group-name</code> filter to describe security groups by name.</p> <p>Default: Describes all your security groups.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _GroupIds [GroupIdStringList] <p>One or more security group IDs. Required for security groups in a nondefault VPC.</p> <p>Default: Describes all your security groups.</p>
-- @param _Filters [FilterList] <p>One or more filters. If using multiple filters for rules, the results include security groups for which any combination of rules - not necessarily a single rule - match all filters.</p> <ul> <li> <p> <code>description</code> - The description of the security group.</p> </li> <li> <p> <code>egress.ip-permission.prefix-list-id</code> - The ID (prefix) of the AWS service to which the security group allows access.</p> </li> <li> <p> <code>group-id</code> - The ID of the security group. </p> </li> <li> <p> <code>group-name</code> - The name of the security group.</p> </li> <li> <p> <code>ip-permission.cidr</code> - An IPv4 CIDR range that has been granted permission in a security group rule.</p> </li> <li> <p> <code>ip-permission.from-port</code> - The start of port range for the TCP and UDP protocols, or an ICMP type number.</p> </li> <li> <p> <code>ip-permission.group-id</code> - The ID of a security group that has been granted permission.</p> </li> <li> <p> <code>ip-permission.group-name</code> - The name of a security group that has been granted permission.</p> </li> <li> <p> <code>ip-permission.ipv6-cidr</code> - An IPv6 CIDR range that has been granted permission in a security group rule.</p> </li> <li> <p> <code>ip-permission.protocol</code> - The IP protocol for the permission (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p> </li> <li> <p> <code>ip-permission.to-port</code> - The end of port range for the TCP and UDP protocols, or an ICMP code.</p> </li> <li> <p> <code>ip-permission.user-id</code> - The ID of an AWS account that has been granted permission.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the owner of the security group.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the security group.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the security group.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC specified when the security group was created.</p> </li> </ul>
function M.DescribeSecurityGroupsRequest(_GroupNames, _DryRun, _GroupIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSecurityGroupsRequest")
	local t = { 
		["GroupNames"] = _GroupNames,
		["DryRun"] = _DryRun,
		["GroupIds"] = _GroupIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeSecurityGroupsRequest(t)
	return t
end

keys.NetworkAclEntry = { ["IcmpTypeCode"] = true, ["RuleNumber"] = true, ["Protocol"] = true, ["Ipv6CidrBlock"] = true, ["Egress"] = true, ["RuleAction"] = true, ["PortRange"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertNetworkAclEntry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAclEntry to be of type 'table'")
	if struct["IcmpTypeCode"] then asserts.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	if struct["Protocol"] then asserts.AssertString(struct["Protocol"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then asserts.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then asserts.AssertPortRange(struct["PortRange"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkAclEntry[k], "NetworkAclEntry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAclEntry
-- <p>Describes an entry in a network ACL.</p>
-- @param _IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP type and code.</p>
-- @param _RuleNumber [Integer] <p>The rule number for the entry. ACL entries are processed in ascending order by rule number.</p>
-- @param _Protocol [String] <p>The protocol. A value of <code>-1</code> means all protocols.</p>
-- @param _Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
-- @param _Egress [Boolean] <p>Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).</p>
-- @param _RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- @param _PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
-- @param _CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
function M.NetworkAclEntry(_IcmpTypeCode, _RuleNumber, _Protocol, _Ipv6CidrBlock, _Egress, _RuleAction, _PortRange, _CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkAclEntry")
	local t = { 
		["IcmpTypeCode"] = _IcmpTypeCode,
		["RuleNumber"] = _RuleNumber,
		["Protocol"] = _Protocol,
		["Ipv6CidrBlock"] = _Ipv6CidrBlock,
		["Egress"] = _Egress,
		["RuleAction"] = _RuleAction,
		["PortRange"] = _PortRange,
		["CidrBlock"] = _CidrBlock,
	}
	asserts.AssertNetworkAclEntry(t)
	return t
end

keys.UserBucketDetails = { ["S3Bucket"] = true, ["S3Key"] = true, nil }

function asserts.AssertUserBucketDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserBucketDetails to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then asserts.AssertString(struct["S3Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserBucketDetails[k], "UserBucketDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserBucketDetails
-- <p>Describes the S3 bucket for the disk image.</p>
-- @param _S3Bucket [String] <p>The S3 bucket from which the disk image was created.</p>
-- @param _S3Key [String] <p>The file name of the disk image.</p>
function M.UserBucketDetails(_S3Bucket, _S3Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UserBucketDetails")
	local t = { 
		["S3Bucket"] = _S3Bucket,
		["S3Key"] = _S3Key,
	}
	asserts.AssertUserBucketDetails(t)
	return t
end

keys.CancelImportTaskResult = { ["State"] = true, ["PreviousState"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertCancelImportTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelImportTaskResult to be of type 'table'")
	if struct["State"] then asserts.AssertString(struct["State"]) end
	if struct["PreviousState"] then asserts.AssertString(struct["PreviousState"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelImportTaskResult[k], "CancelImportTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelImportTaskResult
-- <p>Contains the output for CancelImportTask.</p>
-- @param _State [String] <p>The current state of the task being canceled.</p>
-- @param _PreviousState [String] <p>The current state of the task being canceled.</p>
-- @param _ImportTaskId [String] <p>The ID of the task being canceled.</p>
function M.CancelImportTaskResult(_State, _PreviousState, _ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelImportTaskResult")
	local t = { 
		["State"] = _State,
		["PreviousState"] = _PreviousState,
		["ImportTaskId"] = _ImportTaskId,
	}
	asserts.AssertCancelImportTaskResult(t)
	return t
end

keys.RegisterImageResult = { ["ImageId"] = true, nil }

function asserts.AssertRegisterImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterImageResult to be of type 'table'")
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterImageResult[k], "RegisterImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterImageResult
-- <p>Contains the output of RegisterImage.</p>
-- @param _ImageId [String] <p>The ID of the newly registered AMI.</p>
function M.RegisterImageResult(_ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RegisterImageResult")
	local t = { 
		["ImageId"] = _ImageId,
	}
	asserts.AssertRegisterImageResult(t)
	return t
end

keys.CreateNetworkAclResult = { ["NetworkAcl"] = true, nil }

function asserts.AssertCreateNetworkAclResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclResult to be of type 'table'")
	if struct["NetworkAcl"] then asserts.AssertNetworkAcl(struct["NetworkAcl"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkAclResult[k], "CreateNetworkAclResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclResult
-- <p>Contains the output of CreateNetworkAcl.</p>
-- @param _NetworkAcl [NetworkAcl] <p>Information about the network ACL.</p>
function M.CreateNetworkAclResult(_NetworkAcl, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkAclResult")
	local t = { 
		["NetworkAcl"] = _NetworkAcl,
	}
	asserts.AssertCreateNetworkAclResult(t)
	return t
end

keys.DescribeVolumeStatusResult = { ["NextToken"] = true, ["VolumeStatuses"] = true, nil }

function asserts.AssertDescribeVolumeStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeStatusResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["VolumeStatuses"] then asserts.AssertVolumeStatusList(struct["VolumeStatuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeStatusResult[k], "DescribeVolumeStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeStatusResult
-- <p>Contains the output of DescribeVolumeStatus.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _VolumeStatuses [VolumeStatusList] <p>A list of volumes.</p>
function M.DescribeVolumeStatusResult(_NextToken, _VolumeStatuses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumeStatusResult")
	local t = { 
		["NextToken"] = _NextToken,
		["VolumeStatuses"] = _VolumeStatuses,
	}
	asserts.AssertDescribeVolumeStatusResult(t)
	return t
end

keys.ModifyVolumeResult = { ["VolumeModification"] = true, nil }

function asserts.AssertModifyVolumeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeResult to be of type 'table'")
	if struct["VolumeModification"] then asserts.AssertVolumeModification(struct["VolumeModification"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVolumeResult[k], "ModifyVolumeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeResult
--  
-- @param _VolumeModification [VolumeModification] <p>A <a>VolumeModification</a> object.</p>
function M.ModifyVolumeResult(_VolumeModification, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVolumeResult")
	local t = { 
		["VolumeModification"] = _VolumeModification,
	}
	asserts.AssertModifyVolumeResult(t)
	return t
end

keys.CancelConversionRequest = { ["ConversionTaskId"] = true, ["ReasonMessage"] = true, ["DryRun"] = true, nil }

function asserts.AssertCancelConversionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelConversionRequest to be of type 'table'")
	assert(struct["ConversionTaskId"], "Expected key ConversionTaskId to exist in table")
	if struct["ConversionTaskId"] then asserts.AssertString(struct["ConversionTaskId"]) end
	if struct["ReasonMessage"] then asserts.AssertString(struct["ReasonMessage"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelConversionRequest[k], "CancelConversionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelConversionRequest
-- <p>Contains the parameters for CancelConversionTask.</p>
-- @param _ConversionTaskId [String] <p>The ID of the conversion task.</p>
-- @param _ReasonMessage [String] <p>The reason for canceling the conversion task.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: ConversionTaskId
function M.CancelConversionRequest(_ConversionTaskId, _ReasonMessage, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelConversionRequest")
	local t = { 
		["ConversionTaskId"] = _ConversionTaskId,
		["ReasonMessage"] = _ReasonMessage,
		["DryRun"] = _DryRun,
	}
	asserts.AssertCancelConversionRequest(t)
	return t
end

keys.ConfirmProductInstanceResult = { ["OwnerId"] = true, ["Return"] = true, nil }

function asserts.AssertConfirmProductInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConfirmProductInstanceResult to be of type 'table'")
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConfirmProductInstanceResult[k], "ConfirmProductInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConfirmProductInstanceResult
-- <p>Contains the output of ConfirmProductInstance.</p>
-- @param _OwnerId [String] <p>The AWS account ID of the instance owner. This is only present if the product code is attached to the instance.</p>
-- @param _Return [Boolean] <p>The return value of the request. Returns <code>true</code> if the specified product code is owned by the requester and associated with the specified instance.</p>
function M.ConfirmProductInstanceResult(_OwnerId, _Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ConfirmProductInstanceResult")
	local t = { 
		["OwnerId"] = _OwnerId,
		["Return"] = _Return,
	}
	asserts.AssertConfirmProductInstanceResult(t)
	return t
end

keys.CreateReservedInstancesListingResult = { ["ReservedInstancesListings"] = true, nil }

function asserts.AssertCreateReservedInstancesListingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateReservedInstancesListingResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then asserts.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateReservedInstancesListingResult[k], "CreateReservedInstancesListingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateReservedInstancesListingResult
-- <p>Contains the output of CreateReservedInstancesListing.</p>
-- @param _ReservedInstancesListings [ReservedInstancesListingList] <p>Information about the Standard Reserved Instance listing.</p>
function M.CreateReservedInstancesListingResult(_ReservedInstancesListings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateReservedInstancesListingResult")
	local t = { 
		["ReservedInstancesListings"] = _ReservedInstancesListings,
	}
	asserts.AssertCreateReservedInstancesListingResult(t)
	return t
end

keys.ReplaceNetworkAclEntryRequest = { ["IcmpTypeCode"] = true, ["NetworkAclId"] = true, ["RuleNumber"] = true, ["DryRun"] = true, ["Ipv6CidrBlock"] = true, ["Egress"] = true, ["RuleAction"] = true, ["PortRange"] = true, ["Protocol"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertReplaceNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["Protocol"], "Expected key Protocol to exist in table")
	assert(struct["RuleAction"], "Expected key RuleAction to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["IcmpTypeCode"] then asserts.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then asserts.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then asserts.AssertPortRange(struct["PortRange"]) end
	if struct["Protocol"] then asserts.AssertString(struct["Protocol"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceNetworkAclEntryRequest[k], "ReplaceNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclEntryRequest
-- <p>Contains the parameters for ReplaceNetworkAclEntry.</p>
-- @param _IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP (1) protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
-- @param _NetworkAclId [String] <p>The ID of the ACL.</p>
-- @param _RuleNumber [Integer] <p>The rule number of the entry to replace.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation (for example <code>2001:bd8:1234:1a00::/64</code>).</p>
-- @param _Egress [Boolean] <p>Indicates whether to replace the egress rule.</p> <p>Default: If no value is specified, we replace the ingress rule.</p>
-- @param _RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- @param _PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to. Required if specifying TCP (6) or UDP (17) for the protocol.</p>
-- @param _Protocol [String] <p>The IP protocol. You can specify <code>all</code> or <code>-1</code> to mean all protocols. If you specify <code>all</code>, <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, or <code>icmp</code>, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
-- @param _CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation (for example <code>172.16.0.0/24</code>).</p>
-- Required parameter: Egress
-- Required parameter: NetworkAclId
-- Required parameter: Protocol
-- Required parameter: RuleAction
-- Required parameter: RuleNumber
function M.ReplaceNetworkAclEntryRequest(_IcmpTypeCode, _NetworkAclId, _RuleNumber, _DryRun, _Ipv6CidrBlock, _Egress, _RuleAction, _PortRange, _Protocol, _CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceNetworkAclEntryRequest")
	local t = { 
		["IcmpTypeCode"] = _IcmpTypeCode,
		["NetworkAclId"] = _NetworkAclId,
		["RuleNumber"] = _RuleNumber,
		["DryRun"] = _DryRun,
		["Ipv6CidrBlock"] = _Ipv6CidrBlock,
		["Egress"] = _Egress,
		["RuleAction"] = _RuleAction,
		["PortRange"] = _PortRange,
		["Protocol"] = _Protocol,
		["CidrBlock"] = _CidrBlock,
	}
	asserts.AssertReplaceNetworkAclEntryRequest(t)
	return t
end

keys.ImportSnapshotRequest = { ["DryRun"] = true, ["Description"] = true, ["ClientData"] = true, ["ClientToken"] = true, ["RoleName"] = true, ["DiskContainer"] = true, nil }

function asserts.AssertImportSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ClientData"] then asserts.AssertClientData(struct["ClientData"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["RoleName"] then asserts.AssertString(struct["RoleName"]) end
	if struct["DiskContainer"] then asserts.AssertSnapshotDiskContainer(struct["DiskContainer"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportSnapshotRequest[k], "ImportSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotRequest
-- <p>Contains the parameters for ImportSnapshot.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>The description string for the import snapshot task.</p>
-- @param _ClientData [ClientData] <p>The client-specific data.</p>
-- @param _ClientToken [String] <p>Token to enable idempotency for VM import requests.</p>
-- @param _RoleName [String] <p>The name of the role to use when not using the default role, 'vmimport'.</p>
-- @param _DiskContainer [SnapshotDiskContainer] <p>Information about the disk container.</p>
function M.ImportSnapshotRequest(_DryRun, _Description, _ClientData, _ClientToken, _RoleName, _DiskContainer, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportSnapshotRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["ClientData"] = _ClientData,
		["ClientToken"] = _ClientToken,
		["RoleName"] = _RoleName,
		["DiskContainer"] = _DiskContainer,
	}
	asserts.AssertImportSnapshotRequest(t)
	return t
end

keys.PortRange = { ["To"] = true, ["From"] = true, nil }

function asserts.AssertPortRange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PortRange to be of type 'table'")
	if struct["To"] then asserts.AssertInteger(struct["To"]) end
	if struct["From"] then asserts.AssertInteger(struct["From"]) end
	for k,_ in pairs(struct) do
		assert(keys.PortRange[k], "PortRange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PortRange
-- <p>Describes a range of ports.</p>
-- @param _To [Integer] <p>The last port in the range.</p>
-- @param _From [Integer] <p>The first port in the range.</p>
function M.PortRange(_To, _From, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PortRange")
	local t = { 
		["To"] = _To,
		["From"] = _From,
	}
	asserts.AssertPortRange(t)
	return t
end

keys.Reservation = { ["Instances"] = true, ["ReservationId"] = true, ["RequesterId"] = true, ["Groups"] = true, ["OwnerId"] = true, nil }

function asserts.AssertReservation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Reservation to be of type 'table'")
	if struct["Instances"] then asserts.AssertInstanceList(struct["Instances"]) end
	if struct["ReservationId"] then asserts.AssertString(struct["ReservationId"]) end
	if struct["RequesterId"] then asserts.AssertString(struct["RequesterId"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.Reservation[k], "Reservation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Reservation
-- <p>Describes a reservation.</p>
-- @param _Instances [InstanceList] <p>One or more instances.</p>
-- @param _ReservationId [String] <p>The ID of the reservation.</p>
-- @param _RequesterId [String] <p>The ID of the requester that launched the instances on your behalf (for example, AWS Management Console or Auto Scaling).</p>
-- @param _Groups [GroupIdentifierList] <p>[EC2-Classic only] One or more security groups.</p>
-- @param _OwnerId [String] <p>The ID of the AWS account that owns the reservation.</p>
function M.Reservation(_Instances, _ReservationId, _RequesterId, _Groups, _OwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Reservation")
	local t = { 
		["Instances"] = _Instances,
		["ReservationId"] = _ReservationId,
		["RequesterId"] = _RequesterId,
		["Groups"] = _Groups,
		["OwnerId"] = _OwnerId,
	}
	asserts.AssertReservation(t)
	return t
end

keys.DescribeConversionTasksRequest = { ["ConversionTaskIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeConversionTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeConversionTasksRequest to be of type 'table'")
	if struct["ConversionTaskIds"] then asserts.AssertConversionIdStringList(struct["ConversionTaskIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeConversionTasksRequest[k], "DescribeConversionTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeConversionTasksRequest
-- <p>Contains the parameters for DescribeConversionTasks.</p>
-- @param _ConversionTaskIds [ConversionIdStringList] <p>One or more conversion task IDs.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.DescribeConversionTasksRequest(_ConversionTaskIds, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeConversionTasksRequest")
	local t = { 
		["ConversionTaskIds"] = _ConversionTaskIds,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDescribeConversionTasksRequest(t)
	return t
end

keys.DescribeImagesRequest = { ["Owners"] = true, ["ImageIds"] = true, ["DryRun"] = true, ["Filters"] = true, ["ExecutableUsers"] = true, nil }

function asserts.AssertDescribeImagesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImagesRequest to be of type 'table'")
	if struct["Owners"] then asserts.AssertOwnerStringList(struct["Owners"]) end
	if struct["ImageIds"] then asserts.AssertImageIdStringList(struct["ImageIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ExecutableUsers"] then asserts.AssertExecutableByStringList(struct["ExecutableUsers"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImagesRequest[k], "DescribeImagesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImagesRequest
-- <p>Contains the parameters for DescribeImages.</p>
-- @param _Owners [OwnerStringList] <p>Filters the images by the owner. Specify an AWS account ID, <code>self</code> (owner is the sender of the request), or an AWS owner alias (valid values are <code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>). Omitting this option returns all images for which you have launch permissions, regardless of ownership.</p>
-- @param _ImageIds [ImageIdStringList] <p>One or more image IDs.</p> <p>Default: Describes all images available to you.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>architecture</code> - The image architecture (<code>i386</code> | <code>x86_64</code>).</p> </li> <li> <p> <code>block-device-mapping.delete-on-termination</code> - A Boolean value that indicates whether the Amazon EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>block-device-mapping.device-name</code> - The device name for the EBS volume (for example, <code>/dev/sdh</code>).</p> </li> <li> <p> <code>block-device-mapping.snapshot-id</code> - The ID of the snapshot used for the EBS volume.</p> </li> <li> <p> <code>block-device-mapping.volume-size</code> - The volume size of the EBS volume, in GiB.</p> </li> <li> <p> <code>block-device-mapping.volume-type</code> - The volume type of the EBS volume (<code>gp2</code> | <code>io1</code> | <code>st1 </code>| <code>sc1</code> | <code>standard</code>).</p> </li> <li> <p> <code>description</code> - The description of the image (provided during image creation).</p> </li> <li> <p> <code>ena-support</code> - A Boolean that indicates whether enhanced networking with ENA is enabled.</p> </li> <li> <p> <code>hypervisor</code> - The hypervisor type (<code>ovm</code> | <code>xen</code>).</p> </li> <li> <p> <code>image-id</code> - The ID of the image.</p> </li> <li> <p> <code>image-type</code> - The image type (<code>machine</code> | <code>kernel</code> | <code>ramdisk</code>).</p> </li> <li> <p> <code>is-public</code> - A Boolean that indicates whether the image is public.</p> </li> <li> <p> <code>kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>manifest-location</code> - The location of the image manifest.</p> </li> <li> <p> <code>name</code> - The name of the AMI (provided during image creation).</p> </li> <li> <p> <code>owner-alias</code> - String value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the image owner.</p> </li> <li> <p> <code>platform</code> - The platform. To only list Windows-based AMIs, use <code>windows</code>.</p> </li> <li> <p> <code>product-code</code> - The product code.</p> </li> <li> <p> <code>product-code.type</code> - The type of the product code (<code>devpay</code> | <code>marketplace</code>).</p> </li> <li> <p> <code>ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>root-device-name</code> - The name of the root device volume (for example, <code>/dev/sda1</code>).</p> </li> <li> <p> <code>root-device-type</code> - The type of the root device volume (<code>ebs</code> | <code>instance-store</code>).</p> </li> <li> <p> <code>state</code> - The state of the image (<code>available</code> | <code>pending</code> | <code>failed</code>).</p> </li> <li> <p> <code>state-reason-code</code> - The reason code for the state change.</p> </li> <li> <p> <code>state-reason-message</code> - The message for the state change.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>virtualization-type</code> - The virtualization type (<code>paravirtual</code> | <code>hvm</code>).</p> </li> </ul>
-- @param _ExecutableUsers [ExecutableByStringList] <p>Scopes the images by users with explicit launch permissions. Specify an AWS account ID, <code>self</code> (the sender of the request), or <code>all</code> (public AMIs).</p>
function M.DescribeImagesRequest(_Owners, _ImageIds, _DryRun, _Filters, _ExecutableUsers, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImagesRequest")
	local t = { 
		["Owners"] = _Owners,
		["ImageIds"] = _ImageIds,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
		["ExecutableUsers"] = _ExecutableUsers,
	}
	asserts.AssertDescribeImagesRequest(t)
	return t
end

keys.TagSpecification = { ["ResourceType"] = true, ["Tags"] = true, nil }

function asserts.AssertTagSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TagSpecification to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.TagSpecification[k], "TagSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TagSpecification
-- <p>The tags to apply to a resource when the resource is being created.</p>
-- @param _ResourceType [ResourceType] <p>The type of resource to tag. Currently, the resource types that support tagging on creation are <code>instance</code> and <code>volume</code>. </p>
-- @param _Tags [TagList] <p>The tags to apply to the resource.</p>
function M.TagSpecification(_ResourceType, _Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TagSpecification")
	local t = { 
		["ResourceType"] = _ResourceType,
		["Tags"] = _Tags,
	}
	asserts.AssertTagSpecification(t)
	return t
end

keys.DescribeIdentityIdFormatRequest = { ["PrincipalArn"] = true, ["Resource"] = true, nil }

function asserts.AssertDescribeIdentityIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdentityIdFormatRequest to be of type 'table'")
	assert(struct["PrincipalArn"], "Expected key PrincipalArn to exist in table")
	if struct["PrincipalArn"] then asserts.AssertString(struct["PrincipalArn"]) end
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdentityIdFormatRequest[k], "DescribeIdentityIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdentityIdFormatRequest
-- <p>Contains the parameters for DescribeIdentityIdFormat.</p>
-- @param _PrincipalArn [String] <p>The ARN of the principal, which can be an IAM role, IAM user, or the root user.</p>
-- @param _Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- Required parameter: PrincipalArn
function M.DescribeIdentityIdFormatRequest(_PrincipalArn, _Resource, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIdentityIdFormatRequest")
	local t = { 
		["PrincipalArn"] = _PrincipalArn,
		["Resource"] = _Resource,
	}
	asserts.AssertDescribeIdentityIdFormatRequest(t)
	return t
end

keys.DescribeFpgaImagesRequest = { ["Owners"] = true, ["DryRun"] = true, ["FpgaImageIds"] = true, ["MaxResults"] = true, ["Filters"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFpgaImagesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImagesRequest to be of type 'table'")
	if struct["Owners"] then asserts.AssertOwnerStringList(struct["Owners"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["FpgaImageIds"] then asserts.AssertFpgaImageIdList(struct["FpgaImageIds"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFpgaImagesRequest[k], "DescribeFpgaImagesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImagesRequest
--  
-- @param _Owners [OwnerStringList] <p>Filters the AFI by owner. Specify an AWS account ID, <code>self</code> (owner is the sender of the request), or an AWS owner alias (valid values are <code>amazon</code> | <code>aws-marketplace</code>).</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _FpgaImageIds [FpgaImageIdList] <p>One or more AFI IDs.</p>
-- @param _MaxResults [MaxResults] <p>The maximum number of results to return in a single call.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>create-time</code> - The creation time of the AFI.</p> </li> <li> <p> <code>fpga-image-id</code> - The FPGA image identifier (AFI ID).</p> </li> <li> <p> <code>fpga-image-global-id</code> - The global FPGA image identifier (AGFI ID).</p> </li> <li> <p> <code>name</code> - The name of the AFI.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the AFI owner.</p> </li> <li> <p> <code>product-code</code> - The product code.</p> </li> <li> <p> <code>shell-version</code> - The version of the AWS Shell that was used to create the bitstream.</p> </li> <li> <p> <code>state</code> - The state of the AFI (<code>pending</code> | <code>failed</code> | <code>available</code> | <code>unavailable</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>update-time</code> - The time of the most recent update.</p> </li> </ul>
-- @param _NextToken [NextToken] <p>The token to retrieve the next page of results.</p>
function M.DescribeFpgaImagesRequest(_Owners, _DryRun, _FpgaImageIds, _MaxResults, _Filters, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeFpgaImagesRequest")
	local t = { 
		["Owners"] = _Owners,
		["DryRun"] = _DryRun,
		["FpgaImageIds"] = _FpgaImageIds,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeFpgaImagesRequest(t)
	return t
end

keys.NetworkInterface = { ["Status"] = true, ["MacAddress"] = true, ["SourceDestCheck"] = true, ["AvailabilityZone"] = true, ["Description"] = true, ["NetworkInterfaceId"] = true, ["VpcId"] = true, ["PrivateIpAddresses"] = true, ["RequesterManaged"] = true, ["PrivateDnsName"] = true, ["RequesterId"] = true, ["InterfaceType"] = true, ["Attachment"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["OwnerId"] = true, ["PrivateIpAddress"] = true, ["SubnetId"] = true, ["TagSet"] = true, ["Association"] = true, nil }

function asserts.AssertNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterface to be of type 'table'")
	if struct["Status"] then asserts.AssertNetworkInterfaceStatus(struct["Status"]) end
	if struct["MacAddress"] then asserts.AssertString(struct["MacAddress"]) end
	if struct["SourceDestCheck"] then asserts.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertNetworkInterfacePrivateIpAddressList(struct["PrivateIpAddresses"]) end
	if struct["RequesterManaged"] then asserts.AssertBoolean(struct["RequesterManaged"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["RequesterId"] then asserts.AssertString(struct["RequesterId"]) end
	if struct["InterfaceType"] then asserts.AssertNetworkInterfaceType(struct["InterfaceType"]) end
	if struct["Attachment"] then asserts.AssertNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertNetworkInterfaceIpv6AddressesList(struct["Ipv6Addresses"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["TagSet"] then asserts.AssertTagList(struct["TagSet"]) end
	if struct["Association"] then asserts.AssertNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterface[k], "NetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterface
-- <p>Describes a network interface.</p>
-- @param _Status [NetworkInterfaceStatus] <p>The status of the network interface.</p>
-- @param _MacAddress [String] <p>The MAC address.</p>
-- @param _SourceDestCheck [Boolean] <p>Indicates whether traffic to or from the instance is validated.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone.</p>
-- @param _Description [String] <p>A description.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _PrivateIpAddresses [NetworkInterfacePrivateIpAddressList] <p>The private IPv4 addresses associated with the network interface.</p>
-- @param _RequesterManaged [Boolean] <p>Indicates whether the network interface is being managed by AWS.</p>
-- @param _PrivateDnsName [String] <p>The private DNS name.</p>
-- @param _RequesterId [String] <p>The ID of the entity that launched the instance on your behalf (for example, AWS Management Console or Auto Scaling).</p>
-- @param _InterfaceType [NetworkInterfaceType] <p>The type of interface.</p>
-- @param _Attachment [NetworkInterfaceAttachment] <p>The network interface attachment.</p>
-- @param _Groups [GroupIdentifierList] <p>Any security groups for the network interface.</p>
-- @param _Ipv6Addresses [NetworkInterfaceIpv6AddressesList] <p>The IPv6 addresses associated with the network interface.</p>
-- @param _OwnerId [String] <p>The AWS account ID of the owner of the network interface.</p>
-- @param _PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _TagSet [TagList] <p>Any tags assigned to the network interface.</p>
-- @param _Association [NetworkInterfaceAssociation] <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
function M.NetworkInterface(_Status, _MacAddress, _SourceDestCheck, _AvailabilityZone, _Description, _NetworkInterfaceId, _VpcId, _PrivateIpAddresses, _RequesterManaged, _PrivateDnsName, _RequesterId, _InterfaceType, _Attachment, _Groups, _Ipv6Addresses, _OwnerId, _PrivateIpAddress, _SubnetId, _TagSet, _Association, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterface")
	local t = { 
		["Status"] = _Status,
		["MacAddress"] = _MacAddress,
		["SourceDestCheck"] = _SourceDestCheck,
		["AvailabilityZone"] = _AvailabilityZone,
		["Description"] = _Description,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["VpcId"] = _VpcId,
		["PrivateIpAddresses"] = _PrivateIpAddresses,
		["RequesterManaged"] = _RequesterManaged,
		["PrivateDnsName"] = _PrivateDnsName,
		["RequesterId"] = _RequesterId,
		["InterfaceType"] = _InterfaceType,
		["Attachment"] = _Attachment,
		["Groups"] = _Groups,
		["Ipv6Addresses"] = _Ipv6Addresses,
		["OwnerId"] = _OwnerId,
		["PrivateIpAddress"] = _PrivateIpAddress,
		["SubnetId"] = _SubnetId,
		["TagSet"] = _TagSet,
		["Association"] = _Association,
	}
	asserts.AssertNetworkInterface(t)
	return t
end

keys.KeyPair = { ["KeyMaterial"] = true, ["KeyName"] = true, ["KeyFingerprint"] = true, nil }

function asserts.AssertKeyPair(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KeyPair to be of type 'table'")
	if struct["KeyMaterial"] then asserts.AssertString(struct["KeyMaterial"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then asserts.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(keys.KeyPair[k], "KeyPair contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KeyPair
-- <p>Describes a key pair.</p>
-- @param _KeyMaterial [String] <p>An unencrypted PEM encoded RSA private key.</p>
-- @param _KeyName [String] <p>The name of the key pair.</p>
-- @param _KeyFingerprint [String] <p>The SHA-1 digest of the DER encoded private key.</p>
function M.KeyPair(_KeyMaterial, _KeyName, _KeyFingerprint, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating KeyPair")
	local t = { 
		["KeyMaterial"] = _KeyMaterial,
		["KeyName"] = _KeyName,
		["KeyFingerprint"] = _KeyFingerprint,
	}
	asserts.AssertKeyPair(t)
	return t
end

keys.PropagatingVgw = { ["GatewayId"] = true, nil }

function asserts.AssertPropagatingVgw(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PropagatingVgw to be of type 'table'")
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PropagatingVgw[k], "PropagatingVgw contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PropagatingVgw
-- <p>Describes a virtual private gateway propagating route.</p>
-- @param _GatewayId [String] <p>The ID of the virtual private gateway (VGW).</p>
function M.PropagatingVgw(_GatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PropagatingVgw")
	local t = { 
		["GatewayId"] = _GatewayId,
	}
	asserts.AssertPropagatingVgw(t)
	return t
end

keys.DescribePrefixListsRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["PrefixListIds"] = true, nil }

function asserts.AssertDescribePrefixListsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrefixListsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["PrefixListIds"] then asserts.AssertValueStringList(struct["PrefixListIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePrefixListsRequest[k], "DescribePrefixListsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrefixListsRequest
-- <p>Contains the parameters for DescribePrefixLists.</p>
-- @param _NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value specified is greater than 1000, we return only 1000 items.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>prefix-list-id</code>: The ID of a prefix list.</p> </li> <li> <p> <code>prefix-list-name</code>: The name of a prefix list.</p> </li> </ul>
-- @param _PrefixListIds [ValueStringList] <p>One or more prefix list IDs.</p>
function M.DescribePrefixListsRequest(_NextToken, _DryRun, _MaxResults, _Filters, _PrefixListIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribePrefixListsRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
		["PrefixListIds"] = _PrefixListIds,
	}
	asserts.AssertDescribePrefixListsRequest(t)
	return t
end

keys.PriceSchedule = { ["Active"] = true, ["CurrencyCode"] = true, ["Term"] = true, ["Price"] = true, nil }

function asserts.AssertPriceSchedule(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PriceSchedule to be of type 'table'")
	if struct["Active"] then asserts.AssertBoolean(struct["Active"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Term"] then asserts.AssertLong(struct["Term"]) end
	if struct["Price"] then asserts.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(keys.PriceSchedule[k], "PriceSchedule contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PriceSchedule
-- <p>Describes the price for a Reserved Instance.</p>
-- @param _Active [Boolean] <p>The current price schedule, as determined by the term remaining for the Reserved Instance in the listing.</p> <p>A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>
-- @param _Term [Long] <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
-- @param _Price [Double] <p>The fixed price for the term.</p>
function M.PriceSchedule(_Active, _CurrencyCode, _Term, _Price, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PriceSchedule")
	local t = { 
		["Active"] = _Active,
		["CurrencyCode"] = _CurrencyCode,
		["Term"] = _Term,
		["Price"] = _Price,
	}
	asserts.AssertPriceSchedule(t)
	return t
end

keys.InstanceNetworkInterfaceSpecification = { ["DeviceIndex"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["PrivateIpAddresses"] = true, ["SubnetId"] = true, ["DeleteOnTermination"] = true, ["PrivateIpAddress"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, ["AssociatePublicIpAddress"] = true, ["SecondaryPrivateIpAddressCount"] = true, nil }

function asserts.AssertInstanceNetworkInterfaceSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceSpecification to be of type 'table'")
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then asserts.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterfaceSpecification[k], "InstanceNetworkInterfaceSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceSpecification
-- <p>Describes a network interface.</p>
-- @param _DeviceIndex [Integer] <p>The index of the device on the instance for the network interface attachment. If you are specifying a network interface in a <a>RunInstances</a> request, you must provide the device index.</p>
-- @param _Description [String] <p>The description of the network interface. Applies only if creating a network interface when launching an instance.</p>
-- @param _Ipv6AddressCount [Integer] <p>A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.</p>
-- @param _PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- @param _SubnetId [String] <p>The ID of the subnet associated with the network string. Applies only if creating a network interface when launching an instance.</p>
-- @param _DeleteOnTermination [Boolean] <p>If set to <code>true</code>, the interface is deleted when the instance is terminated. You can specify <code>true</code> only if creating a new network interface when launching an instance.</p>
-- @param _PrivateIpAddress [String] <p>The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- @param _Groups [SecurityGroupIdStringList] <p>The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.</p>
-- @param _Ipv6Addresses [InstanceIpv6AddressList] <p>One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _AssociatePublicIpAddress [Boolean] <p>Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>
-- @param _SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
function M.InstanceNetworkInterfaceSpecification(_DeviceIndex, _Description, _Ipv6AddressCount, _PrivateIpAddresses, _SubnetId, _DeleteOnTermination, _PrivateIpAddress, _Groups, _Ipv6Addresses, _NetworkInterfaceId, _AssociatePublicIpAddress, _SecondaryPrivateIpAddressCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceNetworkInterfaceSpecification")
	local t = { 
		["DeviceIndex"] = _DeviceIndex,
		["Description"] = _Description,
		["Ipv6AddressCount"] = _Ipv6AddressCount,
		["PrivateIpAddresses"] = _PrivateIpAddresses,
		["SubnetId"] = _SubnetId,
		["DeleteOnTermination"] = _DeleteOnTermination,
		["PrivateIpAddress"] = _PrivateIpAddress,
		["Groups"] = _Groups,
		["Ipv6Addresses"] = _Ipv6Addresses,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["AssociatePublicIpAddress"] = _AssociatePublicIpAddress,
		["SecondaryPrivateIpAddressCount"] = _SecondaryPrivateIpAddressCount,
	}
	asserts.AssertInstanceNetworkInterfaceSpecification(t)
	return t
end

keys.ReplaceNetworkAclAssociationResult = { ["NewAssociationId"] = true, nil }

function asserts.AssertReplaceNetworkAclAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclAssociationResult to be of type 'table'")
	if struct["NewAssociationId"] then asserts.AssertString(struct["NewAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceNetworkAclAssociationResult[k], "ReplaceNetworkAclAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclAssociationResult
-- <p>Contains the output of ReplaceNetworkAclAssociation.</p>
-- @param _NewAssociationId [String] <p>The ID of the new association.</p>
function M.ReplaceNetworkAclAssociationResult(_NewAssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceNetworkAclAssociationResult")
	local t = { 
		["NewAssociationId"] = _NewAssociationId,
	}
	asserts.AssertReplaceNetworkAclAssociationResult(t)
	return t
end

keys.UnsuccessfulItemError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertUnsuccessfulItemError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulItemError to be of type 'table'")
	assert(struct["Code"], "Expected key Code to exist in table")
	assert(struct["Message"], "Expected key Message to exist in table")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnsuccessfulItemError[k], "UnsuccessfulItemError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulItemError
-- <p>Information about the error that occurred. For more information about errors, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html">Error Codes</a>.</p>
-- @param _Message [String] <p>The error message accompanying the error code.</p>
-- @param _Code [String] <p>The error code.</p>
-- Required parameter: Code
-- Required parameter: Message
function M.UnsuccessfulItemError(_Message, _Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnsuccessfulItemError")
	local t = { 
		["Message"] = _Message,
		["Code"] = _Code,
	}
	asserts.AssertUnsuccessfulItemError(t)
	return t
end

keys.ReplaceRouteTableAssociationResult = { ["NewAssociationId"] = true, nil }

function asserts.AssertReplaceRouteTableAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteTableAssociationResult to be of type 'table'")
	if struct["NewAssociationId"] then asserts.AssertString(struct["NewAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceRouteTableAssociationResult[k], "ReplaceRouteTableAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteTableAssociationResult
-- <p>Contains the output of ReplaceRouteTableAssociation.</p>
-- @param _NewAssociationId [String] <p>The ID of the new association.</p>
function M.ReplaceRouteTableAssociationResult(_NewAssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceRouteTableAssociationResult")
	local t = { 
		["NewAssociationId"] = _NewAssociationId,
	}
	asserts.AssertReplaceRouteTableAssociationResult(t)
	return t
end

keys.AllocateHostsResult = { ["HostIds"] = true, nil }

function asserts.AssertAllocateHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateHostsResult to be of type 'table'")
	if struct["HostIds"] then asserts.AssertResponseHostIdList(struct["HostIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateHostsResult[k], "AllocateHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateHostsResult
-- <p>Contains the output of AllocateHosts.</p>
-- @param _HostIds [ResponseHostIdList] <p>The ID of the allocated Dedicated Host. This is used when you want to launch an instance onto a specific host.</p>
function M.AllocateHostsResult(_HostIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AllocateHostsResult")
	local t = { 
		["HostIds"] = _HostIds,
	}
	asserts.AssertAllocateHostsResult(t)
	return t
end

keys.CreateCustomerGatewayResult = { ["CustomerGateway"] = true, nil }

function asserts.AssertCreateCustomerGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCustomerGatewayResult to be of type 'table'")
	if struct["CustomerGateway"] then asserts.AssertCustomerGateway(struct["CustomerGateway"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCustomerGatewayResult[k], "CreateCustomerGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCustomerGatewayResult
-- <p>Contains the output of CreateCustomerGateway.</p>
-- @param _CustomerGateway [CustomerGateway] <p>Information about the customer gateway.</p>
function M.CreateCustomerGatewayResult(_CustomerGateway, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateCustomerGatewayResult")
	local t = { 
		["CustomerGateway"] = _CustomerGateway,
	}
	asserts.AssertCreateCustomerGatewayResult(t)
	return t
end

keys.DescribeVpcClassicLinkRequest = { ["DryRun"] = true, ["Filters"] = true, ["VpcIds"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["VpcIds"] then asserts.AssertVpcClassicLinkIdList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkRequest[k], "DescribeVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkRequest
-- <p>Contains the parameters for DescribeVpcClassicLink.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>is-classic-link-enabled</code> - Whether the VPC is enabled for ClassicLink (<code>true</code> | <code>false</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
-- @param _VpcIds [VpcClassicLinkIdList] <p>One or more VPCs for which you want to describe the ClassicLink status.</p>
function M.DescribeVpcClassicLinkRequest(_DryRun, _Filters, _VpcIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcClassicLinkRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
		["VpcIds"] = _VpcIds,
	}
	asserts.AssertDescribeVpcClassicLinkRequest(t)
	return t
end

keys.ModifySpotFleetRequestResponse = { ["Return"] = true, nil }

function asserts.AssertModifySpotFleetRequestResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySpotFleetRequestResponse to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySpotFleetRequestResponse[k], "ModifySpotFleetRequestResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySpotFleetRequestResponse
-- <p>Contains the output of ModifySpotFleetRequest.</p>
-- @param _Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
function M.ModifySpotFleetRequestResponse(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifySpotFleetRequestResponse")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertModifySpotFleetRequestResponse(t)
	return t
end

keys.ModifySpotFleetRequestRequest = { ["TargetCapacity"] = true, ["SpotFleetRequestId"] = true, ["ExcessCapacityTerminationPolicy"] = true, nil }

function asserts.AssertModifySpotFleetRequestRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySpotFleetRequestRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["TargetCapacity"] then asserts.AssertInteger(struct["TargetCapacity"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["ExcessCapacityTerminationPolicy"] then asserts.AssertExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySpotFleetRequestRequest[k], "ModifySpotFleetRequestRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySpotFleetRequestRequest
-- <p>Contains the parameters for ModifySpotFleetRequest.</p>
-- @param _TargetCapacity [Integer] <p>The size of the fleet.</p>
-- @param _SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param _ExcessCapacityTerminationPolicy [ExcessCapacityTerminationPolicy] <p>Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.</p>
-- Required parameter: SpotFleetRequestId
function M.ModifySpotFleetRequestRequest(_TargetCapacity, _SpotFleetRequestId, _ExcessCapacityTerminationPolicy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifySpotFleetRequestRequest")
	local t = { 
		["TargetCapacity"] = _TargetCapacity,
		["SpotFleetRequestId"] = _SpotFleetRequestId,
		["ExcessCapacityTerminationPolicy"] = _ExcessCapacityTerminationPolicy,
	}
	asserts.AssertModifySpotFleetRequestRequest(t)
	return t
end

keys.Subnet = { ["AvailabilityZone"] = true, ["Tags"] = true, ["AvailableIpAddressCount"] = true, ["DefaultForAz"] = true, ["Ipv6CidrBlockAssociationSet"] = true, ["VpcId"] = true, ["State"] = true, ["MapPublicIpOnLaunch"] = true, ["SubnetId"] = true, ["CidrBlock"] = true, ["AssignIpv6AddressOnCreation"] = true, nil }

function asserts.AssertSubnet(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Subnet to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["AvailableIpAddressCount"] then asserts.AssertInteger(struct["AvailableIpAddressCount"]) end
	if struct["DefaultForAz"] then asserts.AssertBoolean(struct["DefaultForAz"]) end
	if struct["Ipv6CidrBlockAssociationSet"] then asserts.AssertSubnetIpv6CidrBlockAssociationSet(struct["Ipv6CidrBlockAssociationSet"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["State"] then asserts.AssertSubnetState(struct["State"]) end
	if struct["MapPublicIpOnLaunch"] then asserts.AssertBoolean(struct["MapPublicIpOnLaunch"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["AssignIpv6AddressOnCreation"] then asserts.AssertBoolean(struct["AssignIpv6AddressOnCreation"]) end
	for k,_ in pairs(struct) do
		assert(keys.Subnet[k], "Subnet contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Subnet
-- <p>Describes a subnet.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone of the subnet.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the subnet.</p>
-- @param _AvailableIpAddressCount [Integer] <p>The number of unused private IPv4 addresses in the subnet. Note that the IPv4 addresses for any stopped instances are considered unavailable.</p>
-- @param _DefaultForAz [Boolean] <p>Indicates whether this is the default subnet for the Availability Zone.</p>
-- @param _Ipv6CidrBlockAssociationSet [SubnetIpv6CidrBlockAssociationSet] <p>Information about the IPv6 CIDR blocks associated with the subnet.</p>
-- @param _VpcId [String] <p>The ID of the VPC the subnet is in.</p>
-- @param _State [SubnetState] <p>The current state of the subnet.</p>
-- @param _MapPublicIpOnLaunch [Boolean] <p>Indicates whether instances launched in this subnet receive a public IPv4 address.</p>
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _CidrBlock [String] <p>The IPv4 CIDR block assigned to the subnet.</p>
-- @param _AssignIpv6AddressOnCreation [Boolean] <p>Indicates whether a network interface created in this subnet (including a network interface created by <a>RunInstances</a>) receives an IPv6 address.</p>
function M.Subnet(_AvailabilityZone, _Tags, _AvailableIpAddressCount, _DefaultForAz, _Ipv6CidrBlockAssociationSet, _VpcId, _State, _MapPublicIpOnLaunch, _SubnetId, _CidrBlock, _AssignIpv6AddressOnCreation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Subnet")
	local t = { 
		["AvailabilityZone"] = _AvailabilityZone,
		["Tags"] = _Tags,
		["AvailableIpAddressCount"] = _AvailableIpAddressCount,
		["DefaultForAz"] = _DefaultForAz,
		["Ipv6CidrBlockAssociationSet"] = _Ipv6CidrBlockAssociationSet,
		["VpcId"] = _VpcId,
		["State"] = _State,
		["MapPublicIpOnLaunch"] = _MapPublicIpOnLaunch,
		["SubnetId"] = _SubnetId,
		["CidrBlock"] = _CidrBlock,
		["AssignIpv6AddressOnCreation"] = _AssignIpv6AddressOnCreation,
	}
	asserts.AssertSubnet(t)
	return t
end

keys.DisableVgwRoutePropagationRequest = { ["GatewayId"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertDisableVgwRoutePropagationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVgwRoutePropagationRequest to be of type 'table'")
	assert(struct["GatewayId"], "Expected key GatewayId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVgwRoutePropagationRequest[k], "DisableVgwRoutePropagationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVgwRoutePropagationRequest
-- <p>Contains the parameters for DisableVgwRoutePropagation.</p>
-- @param _GatewayId [String] <p>The ID of the virtual private gateway.</p>
-- @param _RouteTableId [String] <p>The ID of the route table.</p>
-- Required parameter: GatewayId
-- Required parameter: RouteTableId
function M.DisableVgwRoutePropagationRequest(_GatewayId, _RouteTableId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVgwRoutePropagationRequest")
	local t = { 
		["GatewayId"] = _GatewayId,
		["RouteTableId"] = _RouteTableId,
	}
	asserts.AssertDisableVgwRoutePropagationRequest(t)
	return t
end

keys.DescribeHostReservationsResult = { ["NextToken"] = true, ["HostReservationSet"] = true, nil }

function asserts.AssertDescribeHostReservationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["HostReservationSet"] then asserts.AssertHostReservationSet(struct["HostReservationSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationsResult[k], "DescribeHostReservationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationsResult
--  
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _HostReservationSet [HostReservationSet] <p>Details about the reservation's configuration.</p>
function M.DescribeHostReservationsResult(_NextToken, _HostReservationSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostReservationsResult")
	local t = { 
		["NextToken"] = _NextToken,
		["HostReservationSet"] = _HostReservationSet,
	}
	asserts.AssertDescribeHostReservationsResult(t)
	return t
end

keys.CancelSpotInstanceRequestsResult = { ["CancelledSpotInstanceRequests"] = true, nil }

function asserts.AssertCancelSpotInstanceRequestsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotInstanceRequestsResult to be of type 'table'")
	if struct["CancelledSpotInstanceRequests"] then asserts.AssertCancelledSpotInstanceRequestList(struct["CancelledSpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotInstanceRequestsResult[k], "CancelSpotInstanceRequestsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotInstanceRequestsResult
-- <p>Contains the output of CancelSpotInstanceRequests.</p>
-- @param _CancelledSpotInstanceRequests [CancelledSpotInstanceRequestList] <p>One or more Spot instance requests.</p>
function M.CancelSpotInstanceRequestsResult(_CancelledSpotInstanceRequests, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotInstanceRequestsResult")
	local t = { 
		["CancelledSpotInstanceRequests"] = _CancelledSpotInstanceRequests,
	}
	asserts.AssertCancelSpotInstanceRequestsResult(t)
	return t
end

keys.RunInstancesRequest = { ["DryRun"] = true, ["TagSpecifications"] = true, ["MinCount"] = true, ["EbsOptimized"] = true, ["RamdiskId"] = true, ["Monitoring"] = true, ["PrivateIpAddress"] = true, ["ImageId"] = true, ["KeyName"] = true, ["SecurityGroups"] = true, ["ClientToken"] = true, ["SubnetId"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, ["AdditionalInfo"] = true, ["Placement"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["SecurityGroupIds"] = true, ["BlockDeviceMappings"] = true, ["KernelId"] = true, ["IamInstanceProfile"] = true, ["UserData"] = true, ["Ipv6AddressCount"] = true, ["MaxCount"] = true, ["Ipv6Addresses"] = true, ["DisableApiTermination"] = true, nil }

function asserts.AssertRunInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunInstancesRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	assert(struct["MaxCount"], "Expected key MaxCount to exist in table")
	assert(struct["MinCount"], "Expected key MinCount to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["MinCount"] then asserts.AssertInteger(struct["MinCount"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["Monitoring"] then asserts.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then asserts.AssertSecurityGroupStringList(struct["SecurityGroups"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	if struct["AdditionalInfo"] then asserts.AssertString(struct["AdditionalInfo"]) end
	if struct["Placement"] then asserts.AssertPlacement(struct["Placement"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["SecurityGroupIds"] then asserts.AssertSecurityGroupIdStringList(struct["SecurityGroupIds"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["MaxCount"] then asserts.AssertInteger(struct["MaxCount"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["DisableApiTermination"] then asserts.AssertBoolean(struct["DisableApiTermination"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunInstancesRequest[k], "RunInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunInstancesRequest
-- <p>Contains the parameters for RunInstances.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _TagSpecifications [TagSpecificationList] <p>The tags to apply to the resources during launch. You can tag instances and volumes. The specified tags are applied to all instances or volumes that are created during launch.</p>
-- @param _MinCount [Integer] <p>The minimum number of instances to launch. If you specify a minimum that is more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches no instances.</p> <p>Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I run in Amazon EC2</a> in the Amazon EC2 General FAQ.</p>
-- @param _EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param _RamdiskId [String] <p>The ID of the RAM disk.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- @param _Monitoring [RunInstancesMonitoringEnabled] <p>The monitoring for the instance.</p>
-- @param _PrivateIpAddress [String] <p>[EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.</p> <p>Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.</p>
-- @param _ImageId [String] <p>The ID of the AMI, which you can get by calling <a>DescribeImages</a>.</p>
-- @param _KeyName [String] <p>The name of the key pair. You can create a key pair using <a>CreateKeyPair</a> or <a>ImportKeyPair</a>.</p> <important> <p>If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.</p> </important>
-- @param _SecurityGroups [SecurityGroupStringList] <p>[EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead.</p> <p>Default: Amazon EC2 uses the default security group.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p> <p>Constraints: Maximum 64 ASCII characters</p>
-- @param _SubnetId [String] <p>[EC2-VPC] The ID of the subnet to launch the instance into.</p>
-- @param _InstanceType [InstanceType] <p>The instance type. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Default: <code>m1.small</code> </p>
-- @param _NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces.</p>
-- @param _AdditionalInfo [String] <p>Reserved.</p>
-- @param _Placement [Placement] <p>The placement for the instance.</p>
-- @param _InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p> <p>Default: <code>stop</code> </p>
-- @param _SecurityGroupIds [SecurityGroupIdStringList] <p>One or more security group IDs. You can create a security group using <a>CreateSecurityGroup</a>.</p> <p>Default: Amazon EC2 uses the default security group.</p>
-- @param _BlockDeviceMappings [BlockDeviceMappingRequestList] <p>The block device mapping.</p> <important> <p>Supplying both a snapshot ID and an encryption value as arguments for block-device mapping results in an error. This is because only blank volumes can be encrypted on start, and these are not created from a snapshot. If a snapshot is the basis for the volume, it contains data by definition and its encryption status cannot be changed using this action.</p> </important>
-- @param _KernelId [String] <p>The ID of the kernel.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- @param _IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- @param _UserData [String] <p>The user data to make available to the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html">Running Commands on Your Linux Instance at Launch</a> (Linux) and <a href="http://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data">Adding User Data</a> (Windows). If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param _Ipv6AddressCount [Integer] <p>[EC2-VPC] A number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.</p>
-- @param _MaxCount [Integer] <p>The maximum number of instances to launch. If you specify more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches the largest possible number of instances above <code>MinCount</code>.</p> <p>Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I run in Amazon EC2</a> in the Amazon EC2 FAQ.</p>
-- @param _Ipv6Addresses [InstanceIpv6AddressList] <p>[EC2-VPC] Specify one or more IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.</p>
-- @param _DisableApiTermination [Boolean] <p>If you set this parameter to <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute to <code>false</code> after launch, use <a>ModifyInstanceAttribute</a>. Alternatively, if you set <code>InstanceInitiatedShutdownBehavior</code> to <code>terminate</code>, you can terminate the instance by running the shutdown command from the instance.</p> <p>Default: <code>false</code> </p>
-- Required parameter: ImageId
-- Required parameter: MaxCount
-- Required parameter: MinCount
function M.RunInstancesRequest(_DryRun, _TagSpecifications, _MinCount, _EbsOptimized, _RamdiskId, _Monitoring, _PrivateIpAddress, _ImageId, _KeyName, _SecurityGroups, _ClientToken, _SubnetId, _InstanceType, _NetworkInterfaces, _AdditionalInfo, _Placement, _InstanceInitiatedShutdownBehavior, _SecurityGroupIds, _BlockDeviceMappings, _KernelId, _IamInstanceProfile, _UserData, _Ipv6AddressCount, _MaxCount, _Ipv6Addresses, _DisableApiTermination, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RunInstancesRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["TagSpecifications"] = _TagSpecifications,
		["MinCount"] = _MinCount,
		["EbsOptimized"] = _EbsOptimized,
		["RamdiskId"] = _RamdiskId,
		["Monitoring"] = _Monitoring,
		["PrivateIpAddress"] = _PrivateIpAddress,
		["ImageId"] = _ImageId,
		["KeyName"] = _KeyName,
		["SecurityGroups"] = _SecurityGroups,
		["ClientToken"] = _ClientToken,
		["SubnetId"] = _SubnetId,
		["InstanceType"] = _InstanceType,
		["NetworkInterfaces"] = _NetworkInterfaces,
		["AdditionalInfo"] = _AdditionalInfo,
		["Placement"] = _Placement,
		["InstanceInitiatedShutdownBehavior"] = _InstanceInitiatedShutdownBehavior,
		["SecurityGroupIds"] = _SecurityGroupIds,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["KernelId"] = _KernelId,
		["IamInstanceProfile"] = _IamInstanceProfile,
		["UserData"] = _UserData,
		["Ipv6AddressCount"] = _Ipv6AddressCount,
		["MaxCount"] = _MaxCount,
		["Ipv6Addresses"] = _Ipv6Addresses,
		["DisableApiTermination"] = _DisableApiTermination,
	}
	asserts.AssertRunInstancesRequest(t)
	return t
end

keys.CreateVpnConnectionRequest = { ["CustomerGatewayId"] = true, ["DryRun"] = true, ["Type"] = true, ["VpnGatewayId"] = true, ["Options"] = true, nil }

function asserts.AssertCreateVpnConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionRequest to be of type 'table'")
	assert(struct["CustomerGatewayId"], "Expected key CustomerGatewayId to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Type"] then asserts.AssertString(struct["Type"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	if struct["Options"] then asserts.AssertVpnConnectionOptionsSpecification(struct["Options"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnConnectionRequest[k], "CreateVpnConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionRequest
-- <p>Contains the parameters for CreateVpnConnection.</p>
-- @param _CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Type [String] <p>The type of VPN connection (<code>ipsec.1</code>).</p>
-- @param _VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- @param _Options [VpnConnectionOptionsSpecification] <p>Indicates whether the VPN connection requires static routes. If you are creating a VPN connection for a device that does not support BGP, you must specify <code>true</code>.</p> <p>Default: <code>false</code> </p>
-- Required parameter: CustomerGatewayId
-- Required parameter: Type
-- Required parameter: VpnGatewayId
function M.CreateVpnConnectionRequest(_CustomerGatewayId, _DryRun, _Type, _VpnGatewayId, _Options, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnConnectionRequest")
	local t = { 
		["CustomerGatewayId"] = _CustomerGatewayId,
		["DryRun"] = _DryRun,
		["Type"] = _Type,
		["VpnGatewayId"] = _VpnGatewayId,
		["Options"] = _Options,
	}
	asserts.AssertCreateVpnConnectionRequest(t)
	return t
end

keys.VpcIpv6CidrBlockAssociation = { ["Ipv6CidrBlock"] = true, ["AssociationId"] = true, ["Ipv6CidrBlockState"] = true, nil }

function asserts.AssertVpcIpv6CidrBlockAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcIpv6CidrBlockAssociation to be of type 'table'")
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["Ipv6CidrBlockState"] then asserts.AssertVpcCidrBlockState(struct["Ipv6CidrBlockState"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcIpv6CidrBlockAssociation[k], "VpcIpv6CidrBlockAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcIpv6CidrBlockAssociation
-- <p>Describes an IPv6 CIDR block associated with a VPC.</p>
-- @param _Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- @param _AssociationId [String] <p>The association ID for the IPv6 CIDR block.</p>
-- @param _Ipv6CidrBlockState [VpcCidrBlockState] <p>Information about the state of the CIDR block.</p>
function M.VpcIpv6CidrBlockAssociation(_Ipv6CidrBlock, _AssociationId, _Ipv6CidrBlockState, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcIpv6CidrBlockAssociation")
	local t = { 
		["Ipv6CidrBlock"] = _Ipv6CidrBlock,
		["AssociationId"] = _AssociationId,
		["Ipv6CidrBlockState"] = _Ipv6CidrBlockState,
	}
	asserts.AssertVpcIpv6CidrBlockAssociation(t)
	return t
end

keys.DescribeSpotFleetInstancesResponse = { ["ActiveInstances"] = true, ["SpotFleetRequestId"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSpotFleetInstancesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetInstancesResponse to be of type 'table'")
	assert(struct["ActiveInstances"], "Expected key ActiveInstances to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["ActiveInstances"] then asserts.AssertActiveInstanceSet(struct["ActiveInstances"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetInstancesResponse[k], "DescribeSpotFleetInstancesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetInstancesResponse
-- <p>Contains the output of DescribeSpotFleetInstances.</p>
-- @param _ActiveInstances [ActiveInstanceSet] <p>The running instances. Note that this list is refreshed periodically and might be out of date.</p>
-- @param _SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param _NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- Required parameter: ActiveInstances
-- Required parameter: SpotFleetRequestId
function M.DescribeSpotFleetInstancesResponse(_ActiveInstances, _SpotFleetRequestId, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetInstancesResponse")
	local t = { 
		["ActiveInstances"] = _ActiveInstances,
		["SpotFleetRequestId"] = _SpotFleetRequestId,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeSpotFleetInstancesResponse(t)
	return t
end

keys.VpnConnection = { ["VpnConnectionId"] = true, ["Tags"] = true, ["CustomerGatewayConfiguration"] = true, ["Routes"] = true, ["State"] = true, ["VpnGatewayId"] = true, ["CustomerGatewayId"] = true, ["Type"] = true, ["Options"] = true, ["VgwTelemetry"] = true, nil }

function asserts.AssertVpnConnection(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnection to be of type 'table'")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["CustomerGatewayConfiguration"] then asserts.AssertString(struct["CustomerGatewayConfiguration"]) end
	if struct["Routes"] then asserts.AssertVpnStaticRouteList(struct["Routes"]) end
	if struct["State"] then asserts.AssertVpnState(struct["State"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	if struct["Options"] then asserts.AssertVpnConnectionOptions(struct["Options"]) end
	if struct["VgwTelemetry"] then asserts.AssertVgwTelemetryList(struct["VgwTelemetry"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnConnection[k], "VpnConnection contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnection
-- <p>Describes a VPN connection.</p>
-- @param _VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the VPN connection.</p>
-- @param _CustomerGatewayConfiguration [String] <p>The configuration information for the VPN connection's customer gateway (in the native XML format). This element is always present in the <a>CreateVpnConnection</a> response; however, it's present in the <a>DescribeVpnConnections</a> response only if the VPN connection is in the <code>pending</code> or <code>available</code> state.</p>
-- @param _Routes [VpnStaticRouteList] <p>The static routes associated with the VPN connection.</p>
-- @param _State [VpnState] <p>The current state of the VPN connection.</p>
-- @param _VpnGatewayId [String] <p>The ID of the virtual private gateway at the AWS side of the VPN connection.</p>
-- @param _CustomerGatewayId [String] <p>The ID of the customer gateway at your end of the VPN connection.</p>
-- @param _Type [GatewayType] <p>The type of VPN connection.</p>
-- @param _Options [VpnConnectionOptions] <p>The VPN connection options.</p>
-- @param _VgwTelemetry [VgwTelemetryList] <p>Information about the VPN tunnel.</p>
function M.VpnConnection(_VpnConnectionId, _Tags, _CustomerGatewayConfiguration, _Routes, _State, _VpnGatewayId, _CustomerGatewayId, _Type, _Options, _VgwTelemetry, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnConnection")
	local t = { 
		["VpnConnectionId"] = _VpnConnectionId,
		["Tags"] = _Tags,
		["CustomerGatewayConfiguration"] = _CustomerGatewayConfiguration,
		["Routes"] = _Routes,
		["State"] = _State,
		["VpnGatewayId"] = _VpnGatewayId,
		["CustomerGatewayId"] = _CustomerGatewayId,
		["Type"] = _Type,
		["Options"] = _Options,
		["VgwTelemetry"] = _VgwTelemetry,
	}
	asserts.AssertVpnConnection(t)
	return t
end

keys.ScheduledInstancesPrivateIpAddressConfig = { ["Primary"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertScheduledInstancesPrivateIpAddressConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesPrivateIpAddressConfig to be of type 'table'")
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesPrivateIpAddressConfig[k], "ScheduledInstancesPrivateIpAddressConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesPrivateIpAddressConfig
-- <p>Describes a private IPv4 address for a Scheduled Instance.</p>
-- @param _Primary [Boolean] <p>Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.</p>
-- @param _PrivateIpAddress [String] <p>The IPv4 address.</p>
function M.ScheduledInstancesPrivateIpAddressConfig(_Primary, _PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesPrivateIpAddressConfig")
	local t = { 
		["Primary"] = _Primary,
		["PrivateIpAddress"] = _PrivateIpAddress,
	}
	asserts.AssertScheduledInstancesPrivateIpAddressConfig(t)
	return t
end

keys.DescribeSubnetsResult = { ["Subnets"] = true, nil }

function asserts.AssertDescribeSubnetsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSubnetsResult to be of type 'table'")
	if struct["Subnets"] then asserts.AssertSubnetList(struct["Subnets"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSubnetsResult[k], "DescribeSubnetsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSubnetsResult
-- <p>Contains the output of DescribeSubnets.</p>
-- @param _Subnets [SubnetList] <p>Information about one or more subnets.</p>
function M.DescribeSubnetsResult(_Subnets, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSubnetsResult")
	local t = { 
		["Subnets"] = _Subnets,
	}
	asserts.AssertDescribeSubnetsResult(t)
	return t
end

keys.DisableVpcClassicLinkResult = { ["Return"] = true, nil }

function asserts.AssertDisableVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkResult[k], "DisableVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkResult
-- <p>Contains the output of DisableVpcClassicLink.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DisableVpcClassicLinkResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVpcClassicLinkResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertDisableVpcClassicLinkResult(t)
	return t
end

keys.AcceptVpcPeeringConnectionResult = { ["VpcPeeringConnection"] = true, nil }

function asserts.AssertAcceptVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcPeeringConnectionResult to be of type 'table'")
	if struct["VpcPeeringConnection"] then asserts.AssertVpcPeeringConnection(struct["VpcPeeringConnection"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptVpcPeeringConnectionResult[k], "AcceptVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcPeeringConnectionResult
-- <p>Contains the output of AcceptVpcPeeringConnection.</p>
-- @param _VpcPeeringConnection [VpcPeeringConnection] <p>Information about the VPC peering connection.</p>
function M.AcceptVpcPeeringConnectionResult(_VpcPeeringConnection, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AcceptVpcPeeringConnectionResult")
	local t = { 
		["VpcPeeringConnection"] = _VpcPeeringConnection,
	}
	asserts.AssertAcceptVpcPeeringConnectionResult(t)
	return t
end

keys.ModifyReservedInstancesRequest = { ["TargetConfigurations"] = true, ["ReservedInstancesIds"] = true, ["ClientToken"] = true, nil }

function asserts.AssertModifyReservedInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyReservedInstancesRequest to be of type 'table'")
	assert(struct["ReservedInstancesIds"], "Expected key ReservedInstancesIds to exist in table")
	assert(struct["TargetConfigurations"], "Expected key TargetConfigurations to exist in table")
	if struct["TargetConfigurations"] then asserts.AssertReservedInstancesConfigurationList(struct["TargetConfigurations"]) end
	if struct["ReservedInstancesIds"] then asserts.AssertReservedInstancesIdStringList(struct["ReservedInstancesIds"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyReservedInstancesRequest[k], "ModifyReservedInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyReservedInstancesRequest
-- <p>Contains the parameters for ModifyReservedInstances.</p>
-- @param _TargetConfigurations [ReservedInstancesConfigurationList] <p>The configuration settings for the Reserved Instances to modify.</p>
-- @param _ReservedInstancesIds [ReservedInstancesIdStringList] <p>The IDs of the Reserved Instances to modify.</p>
-- @param _ClientToken [String] <p>A unique, case-sensitive token you provide to ensure idempotency of your modification request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required parameter: ReservedInstancesIds
-- Required parameter: TargetConfigurations
function M.ModifyReservedInstancesRequest(_TargetConfigurations, _ReservedInstancesIds, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyReservedInstancesRequest")
	local t = { 
		["TargetConfigurations"] = _TargetConfigurations,
		["ReservedInstancesIds"] = _ReservedInstancesIds,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertModifyReservedInstancesRequest(t)
	return t
end

keys.ReservedInstanceReservationValue = { ["ReservedInstanceId"] = true, ["ReservationValue"] = true, nil }

function asserts.AssertReservedInstanceReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstanceReservationValue to be of type 'table'")
	if struct["ReservedInstanceId"] then asserts.AssertString(struct["ReservedInstanceId"]) end
	if struct["ReservationValue"] then asserts.AssertReservationValue(struct["ReservationValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstanceReservationValue[k], "ReservedInstanceReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstanceReservationValue
-- <p>The total value of the Convertible Reserved Instance.</p>
-- @param _ReservedInstanceId [String] <p>The ID of the Convertible Reserved Instance that you are exchanging.</p>
-- @param _ReservationValue [ReservationValue] <p>The total value of the Convertible Reserved Instance that you are exchanging.</p>
function M.ReservedInstanceReservationValue(_ReservedInstanceId, _ReservationValue, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstanceReservationValue")
	local t = { 
		["ReservedInstanceId"] = _ReservedInstanceId,
		["ReservationValue"] = _ReservationValue,
	}
	asserts.AssertReservedInstanceReservationValue(t)
	return t
end

keys.CreateVolumePermission = { ["UserId"] = true, ["Group"] = true, nil }

function asserts.AssertCreateVolumePermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumePermission to be of type 'table'")
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["Group"] then asserts.AssertPermissionGroup(struct["Group"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVolumePermission[k], "CreateVolumePermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumePermission
-- <p>Describes the user or group to be added or removed from the permissions for a volume.</p>
-- @param _UserId [String] <p>The specific AWS account ID that is to be added or removed from a volume's list of create volume permissions.</p>
-- @param _Group [PermissionGroup] <p>The specific group that is to be added or removed from a volume's list of create volume permissions.</p>
function M.CreateVolumePermission(_UserId, _Group, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVolumePermission")
	local t = { 
		["UserId"] = _UserId,
		["Group"] = _Group,
	}
	asserts.AssertCreateVolumePermission(t)
	return t
end

keys.DescribeSpotFleetRequestsRequest = { ["SpotFleetRequestIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestsRequest to be of type 'table'")
	if struct["SpotFleetRequestIds"] then asserts.AssertValueStringList(struct["SpotFleetRequestIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestsRequest[k], "DescribeSpotFleetRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestsRequest
-- <p>Contains the parameters for DescribeSpotFleetRequests.</p>
-- @param _SpotFleetRequestIds [ValueStringList] <p>The IDs of the Spot fleet requests.</p>
-- @param _NextToken [String] <p>The token for the next set of results.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
function M.DescribeSpotFleetRequestsRequest(_SpotFleetRequestIds, _NextToken, _DryRun, _MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetRequestsRequest")
	local t = { 
		["SpotFleetRequestIds"] = _SpotFleetRequestIds,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
	}
	asserts.AssertDescribeSpotFleetRequestsRequest(t)
	return t
end

keys.GetConsoleOutputRequest = { ["InstanceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertGetConsoleOutputRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleOutputRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleOutputRequest[k], "GetConsoleOutputRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleOutputRequest
-- <p>Contains the parameters for GetConsoleOutput.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
function M.GetConsoleOutputRequest(_InstanceId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetConsoleOutputRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertGetConsoleOutputRequest(t)
	return t
end

keys.DescribeFlowLogsResult = { ["FlowLogs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFlowLogsResult to be of type 'table'")
	if struct["FlowLogs"] then asserts.AssertFlowLogSet(struct["FlowLogs"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFlowLogsResult[k], "DescribeFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFlowLogsResult
-- <p>Contains the output of DescribeFlowLogs.</p>
-- @param _FlowLogs [FlowLogSet] <p>Information about the flow logs.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeFlowLogsResult(_FlowLogs, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeFlowLogsResult")
	local t = { 
		["FlowLogs"] = _FlowLogs,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeFlowLogsResult(t)
	return t
end

keys.VolumeStatusInfo = { ["Status"] = true, ["Details"] = true, nil }

function asserts.AssertVolumeStatusInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusInfo to be of type 'table'")
	if struct["Status"] then asserts.AssertVolumeStatusInfoStatus(struct["Status"]) end
	if struct["Details"] then asserts.AssertVolumeStatusDetailsList(struct["Details"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusInfo[k], "VolumeStatusInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusInfo
-- <p>Describes the status of a volume.</p>
-- @param _Status [VolumeStatusInfoStatus] <p>The status of the volume.</p>
-- @param _Details [VolumeStatusDetailsList] <p>The details of the volume status.</p>
function M.VolumeStatusInfo(_Status, _Details, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusInfo")
	local t = { 
		["Status"] = _Status,
		["Details"] = _Details,
	}
	asserts.AssertVolumeStatusInfo(t)
	return t
end

keys.Purchase = { ["HourlyPrice"] = true, ["InstanceFamily"] = true, ["CurrencyCode"] = true, ["PaymentOption"] = true, ["HostIdSet"] = true, ["HostReservationId"] = true, ["UpfrontPrice"] = true, ["Duration"] = true, nil }

function asserts.AssertPurchase(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Purchase to be of type 'table'")
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["InstanceFamily"] then asserts.AssertString(struct["InstanceFamily"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["PaymentOption"] then asserts.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["HostIdSet"] then asserts.AssertResponseHostIdSet(struct["HostIdSet"]) end
	if struct["HostReservationId"] then asserts.AssertString(struct["HostReservationId"]) end
	if struct["UpfrontPrice"] then asserts.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then asserts.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(keys.Purchase[k], "Purchase contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Purchase
-- <p>Describes the result of the purchase.</p>
-- @param _HourlyPrice [String] <p>The hourly price of the reservation per hour.</p>
-- @param _InstanceFamily [String] <p>The instance family on the Dedicated Host that the reservation can be associated with.</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>UpfrontPrice</code> and <code>HourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param _PaymentOption [PaymentOption] <p>The payment option for the reservation.</p>
-- @param _HostIdSet [ResponseHostIdSet] <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
-- @param _HostReservationId [String] <p>The ID of the reservation.</p>
-- @param _UpfrontPrice [String] <p>The upfront price of the reservation.</p>
-- @param _Duration [Integer] <p>The duration of the reservation's term in seconds.</p>
function M.Purchase(_HourlyPrice, _InstanceFamily, _CurrencyCode, _PaymentOption, _HostIdSet, _HostReservationId, _UpfrontPrice, _Duration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Purchase")
	local t = { 
		["HourlyPrice"] = _HourlyPrice,
		["InstanceFamily"] = _InstanceFamily,
		["CurrencyCode"] = _CurrencyCode,
		["PaymentOption"] = _PaymentOption,
		["HostIdSet"] = _HostIdSet,
		["HostReservationId"] = _HostReservationId,
		["UpfrontPrice"] = _UpfrontPrice,
		["Duration"] = _Duration,
	}
	asserts.AssertPurchase(t)
	return t
end

keys.PeeringConnectionOptions = { ["AllowEgressFromLocalVpcToRemoteClassicLink"] = true, ["AllowDnsResolutionFromRemoteVpc"] = true, ["AllowEgressFromLocalClassicLinkToRemoteVpc"] = true, nil }

function asserts.AssertPeeringConnectionOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PeeringConnectionOptions to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then asserts.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then asserts.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then asserts.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.PeeringConnectionOptions[k], "PeeringConnectionOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PeeringConnectionOptions
-- <p>Describes the VPC peering connection options.</p>
-- @param _AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.</p>
-- @param _AllowDnsResolutionFromRemoteVpc [Boolean] <p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>
-- @param _AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.</p>
function M.PeeringConnectionOptions(_AllowEgressFromLocalVpcToRemoteClassicLink, _AllowDnsResolutionFromRemoteVpc, _AllowEgressFromLocalClassicLinkToRemoteVpc, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PeeringConnectionOptions")
	local t = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = _AllowEgressFromLocalVpcToRemoteClassicLink,
		["AllowDnsResolutionFromRemoteVpc"] = _AllowDnsResolutionFromRemoteVpc,
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = _AllowEgressFromLocalClassicLinkToRemoteVpc,
	}
	asserts.AssertPeeringConnectionOptions(t)
	return t
end

keys.Vpc = { ["VpcId"] = true, ["InstanceTenancy"] = true, ["Tags"] = true, ["Ipv6CidrBlockAssociationSet"] = true, ["State"] = true, ["DhcpOptionsId"] = true, ["CidrBlock"] = true, ["IsDefault"] = true, nil }

function asserts.AssertVpc(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Vpc to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Ipv6CidrBlockAssociationSet"] then asserts.AssertVpcIpv6CidrBlockAssociationSet(struct["Ipv6CidrBlockAssociationSet"]) end
	if struct["State"] then asserts.AssertVpcState(struct["State"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["IsDefault"] then asserts.AssertBoolean(struct["IsDefault"]) end
	for k,_ in pairs(struct) do
		assert(keys.Vpc[k], "Vpc contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Vpc
-- <p>Describes a VPC.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _InstanceTenancy [Tenancy] <p>The allowed tenancy of instances launched into the VPC.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the VPC.</p>
-- @param _Ipv6CidrBlockAssociationSet [VpcIpv6CidrBlockAssociationSet] <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
-- @param _State [VpcState] <p>The current state of the VPC.</p>
-- @param _DhcpOptionsId [String] <p>The ID of the set of DHCP options you've associated with the VPC (or <code>default</code> if the default options are associated with the VPC).</p>
-- @param _CidrBlock [String] <p>The IPv4 CIDR block for the VPC.</p>
-- @param _IsDefault [Boolean] <p>Indicates whether the VPC is the default VPC.</p>
function M.Vpc(_VpcId, _InstanceTenancy, _Tags, _Ipv6CidrBlockAssociationSet, _State, _DhcpOptionsId, _CidrBlock, _IsDefault, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Vpc")
	local t = { 
		["VpcId"] = _VpcId,
		["InstanceTenancy"] = _InstanceTenancy,
		["Tags"] = _Tags,
		["Ipv6CidrBlockAssociationSet"] = _Ipv6CidrBlockAssociationSet,
		["State"] = _State,
		["DhcpOptionsId"] = _DhcpOptionsId,
		["CidrBlock"] = _CidrBlock,
		["IsDefault"] = _IsDefault,
	}
	asserts.AssertVpc(t)
	return t
end

keys.DescribeVpcEndpointServicesResult = { ["NextToken"] = true, ["ServiceNames"] = true, nil }

function asserts.AssertDescribeVpcEndpointServicesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ServiceNames"] then asserts.AssertValueStringList(struct["ServiceNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServicesResult[k], "DescribeVpcEndpointServicesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicesResult
-- <p>Contains the output of DescribeVpcEndpointServices.</p>
-- @param _NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @param _ServiceNames [ValueStringList] <p>A list of supported AWS services.</p>
function M.DescribeVpcEndpointServicesResult(_NextToken, _ServiceNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcEndpointServicesResult")
	local t = { 
		["NextToken"] = _NextToken,
		["ServiceNames"] = _ServiceNames,
	}
	asserts.AssertDescribeVpcEndpointServicesResult(t)
	return t
end

keys.ReplaceRouteTableAssociationRequest = { ["RouteTableId"] = true, ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertReplaceRouteTableAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteTableAssociationRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceRouteTableAssociationRequest[k], "ReplaceRouteTableAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteTableAssociationRequest
-- <p>Contains the parameters for ReplaceRouteTableAssociation.</p>
-- @param _RouteTableId [String] <p>The ID of the new route table to associate with the subnet.</p>
-- @param _AssociationId [String] <p>The association ID.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: AssociationId
-- Required parameter: RouteTableId
function M.ReplaceRouteTableAssociationRequest(_RouteTableId, _AssociationId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceRouteTableAssociationRequest")
	local t = { 
		["RouteTableId"] = _RouteTableId,
		["AssociationId"] = _AssociationId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertReplaceRouteTableAssociationRequest(t)
	return t
end

keys.CancelBundleTaskResult = { ["BundleTask"] = true, nil }

function asserts.AssertCancelBundleTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelBundleTaskResult to be of type 'table'")
	if struct["BundleTask"] then asserts.AssertBundleTask(struct["BundleTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelBundleTaskResult[k], "CancelBundleTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelBundleTaskResult
-- <p>Contains the output of CancelBundleTask.</p>
-- @param _BundleTask [BundleTask] <p>Information about the bundle task.</p>
function M.CancelBundleTaskResult(_BundleTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelBundleTaskResult")
	local t = { 
		["BundleTask"] = _BundleTask,
	}
	asserts.AssertCancelBundleTaskResult(t)
	return t
end

keys.SecurityGroup = { ["IpPermissionsEgress"] = true, ["Description"] = true, ["Tags"] = true, ["IpPermissions"] = true, ["GroupName"] = true, ["VpcId"] = true, ["OwnerId"] = true, ["GroupId"] = true, nil }

function asserts.AssertSecurityGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityGroup to be of type 'table'")
	if struct["IpPermissionsEgress"] then asserts.AssertIpPermissionList(struct["IpPermissionsEgress"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityGroup[k], "SecurityGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityGroup
-- <p>Describes a security group</p>
-- @param _IpPermissionsEgress [IpPermissionList] <p>[EC2-VPC] One or more outbound rules associated with the security group.</p>
-- @param _Description [String] <p>A description of the security group.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the security group.</p>
-- @param _IpPermissions [IpPermissionList] <p>One or more inbound rules associated with the security group.</p>
-- @param _GroupName [String] <p>The name of the security group.</p>
-- @param _VpcId [String] <p>[EC2-VPC] The ID of the VPC for the security group.</p>
-- @param _OwnerId [String] <p>The AWS account ID of the owner of the security group.</p>
-- @param _GroupId [String] <p>The ID of the security group.</p>
function M.SecurityGroup(_IpPermissionsEgress, _Description, _Tags, _IpPermissions, _GroupName, _VpcId, _OwnerId, _GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SecurityGroup")
	local t = { 
		["IpPermissionsEgress"] = _IpPermissionsEgress,
		["Description"] = _Description,
		["Tags"] = _Tags,
		["IpPermissions"] = _IpPermissions,
		["GroupName"] = _GroupName,
		["VpcId"] = _VpcId,
		["OwnerId"] = _OwnerId,
		["GroupId"] = _GroupId,
	}
	asserts.AssertSecurityGroup(t)
	return t
end

keys.EnableVpcClassicLinkDnsSupportRequest = { ["VpcId"] = true, nil }

function asserts.AssertEnableVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkDnsSupportRequest[k], "EnableVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkDnsSupportRequest
-- <p>Contains the parameters for EnableVpcClassicLinkDnsSupport.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
function M.EnableVpcClassicLinkDnsSupportRequest(_VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVpcClassicLinkDnsSupportRequest")
	local t = { 
		["VpcId"] = _VpcId,
	}
	asserts.AssertEnableVpcClassicLinkDnsSupportRequest(t)
	return t
end

keys.ReportInstanceStatusRequest = { ["Status"] = true, ["ReasonCodes"] = true, ["DryRun"] = true, ["Description"] = true, ["Instances"] = true, ["StartTime"] = true, ["EndTime"] = true, nil }

function asserts.AssertReportInstanceStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReportInstanceStatusRequest to be of type 'table'")
	assert(struct["Instances"], "Expected key Instances to exist in table")
	assert(struct["ReasonCodes"], "Expected key ReasonCodes to exist in table")
	assert(struct["Status"], "Expected key Status to exist in table")
	if struct["Status"] then asserts.AssertReportStatusType(struct["Status"]) end
	if struct["ReasonCodes"] then asserts.AssertReasonCodesList(struct["ReasonCodes"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Instances"] then asserts.AssertInstanceIdStringList(struct["Instances"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReportInstanceStatusRequest[k], "ReportInstanceStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReportInstanceStatusRequest
-- <p>Contains the parameters for ReportInstanceStatus.</p>
-- @param _Status [ReportStatusType] <p>The status of all instances listed.</p>
-- @param _ReasonCodes [ReasonCodesList] <p>One or more reason codes that describes the health state of your instance.</p> <ul> <li> <p> <code>instance-stuck-in-state</code>: My instance is stuck in a state.</p> </li> <li> <p> <code>unresponsive</code>: My instance is unresponsive.</p> </li> <li> <p> <code>not-accepting-credentials</code>: My instance is not accepting my credentials.</p> </li> <li> <p> <code>password-not-available</code>: A password is not available for my instance.</p> </li> <li> <p> <code>performance-network</code>: My instance is experiencing performance problems which I believe are network related.</p> </li> <li> <p> <code>performance-instance-store</code>: My instance is experiencing performance problems which I believe are related to the instance stores.</p> </li> <li> <p> <code>performance-ebs-volume</code>: My instance is experiencing performance problems which I believe are related to an EBS volume.</p> </li> <li> <p> <code>performance-other</code>: My instance is experiencing performance problems.</p> </li> <li> <p> <code>other</code>: [explain using the description parameter]</p> </li> </ul>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>Descriptive text about the health state of your instance.</p>
-- @param _Instances [InstanceIdStringList] <p>One or more instances.</p>
-- @param _StartTime [DateTime] <p>The time at which the reported instance health state began.</p>
-- @param _EndTime [DateTime] <p>The time at which the reported instance health state ended.</p>
-- Required parameter: Instances
-- Required parameter: ReasonCodes
-- Required parameter: Status
function M.ReportInstanceStatusRequest(_Status, _ReasonCodes, _DryRun, _Description, _Instances, _StartTime, _EndTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReportInstanceStatusRequest")
	local t = { 
		["Status"] = _Status,
		["ReasonCodes"] = _ReasonCodes,
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["Instances"] = _Instances,
		["StartTime"] = _StartTime,
		["EndTime"] = _EndTime,
	}
	asserts.AssertReportInstanceStatusRequest(t)
	return t
end

keys.DescribeVolumeAttributeResult = { ["AutoEnableIO"] = true, ["ProductCodes"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDescribeVolumeAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeAttributeResult to be of type 'table'")
	if struct["AutoEnableIO"] then asserts.AssertAttributeBooleanValue(struct["AutoEnableIO"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeAttributeResult[k], "DescribeVolumeAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeAttributeResult
-- <p>Contains the output of DescribeVolumeAttribute.</p>
-- @param _AutoEnableIO [AttributeBooleanValue] <p>The state of <code>autoEnableIO</code> attribute.</p>
-- @param _ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- @param _VolumeId [String] <p>The ID of the volume.</p>
function M.DescribeVolumeAttributeResult(_AutoEnableIO, _ProductCodes, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumeAttributeResult")
	local t = { 
		["AutoEnableIO"] = _AutoEnableIO,
		["ProductCodes"] = _ProductCodes,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertDescribeVolumeAttributeResult(t)
	return t
end

keys.ReservedInstancesId = { ["ReservedInstancesId"] = true, nil }

function asserts.AssertReservedInstancesId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesId to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesId[k], "ReservedInstancesId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesId
-- <p>Describes the ID of a Reserved Instance.</p>
-- @param _ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
function M.ReservedInstancesId(_ReservedInstancesId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesId")
	local t = { 
		["ReservedInstancesId"] = _ReservedInstancesId,
	}
	asserts.AssertReservedInstancesId(t)
	return t
end

keys.AttributeValue = { ["Value"] = true, nil }

function asserts.AssertAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttributeValue to be of type 'table'")
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttributeValue[k], "AttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttributeValue
-- <p>Describes a value for a resource attribute that is a String.</p>
-- @param _Value [String] <p>The attribute value. Note that the value is case-sensitive.</p>
function M.AttributeValue(_Value, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttributeValue")
	local t = { 
		["Value"] = _Value,
	}
	asserts.AssertAttributeValue(t)
	return t
end

keys.DescribeVpcEndpointsRequest = { ["VpcEndpointIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpcEndpointsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointsRequest to be of type 'table'")
	if struct["VpcEndpointIds"] then asserts.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointsRequest[k], "DescribeVpcEndpointsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointsRequest
-- <p>Contains the parameters for DescribeVpcEndpoints.</p>
-- @param _VpcEndpointIds [ValueStringList] <p>One or more endpoint IDs.</p>
-- @param _NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>service-name</code>: The name of the AWS service.</p> </li> <li> <p> <code>vpc-id</code>: The ID of the VPC in which the endpoint resides.</p> </li> <li> <p> <code>vpc-endpoint-id</code>: The ID of the endpoint.</p> </li> <li> <p> <code>vpc-endpoint-state</code>: The state of the endpoint. (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>)</p> </li> </ul>
function M.DescribeVpcEndpointsRequest(_VpcEndpointIds, _NextToken, _DryRun, _MaxResults, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcEndpointsRequest")
	local t = { 
		["VpcEndpointIds"] = _VpcEndpointIds,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeVpcEndpointsRequest(t)
	return t
end

keys.TagDescription = { ["ResourceType"] = true, ["ResourceId"] = true, ["Value"] = true, ["Key"] = true, nil }

function asserts.AssertTagDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TagDescription to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertString(struct["ResourceId"]) end
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.TagDescription[k], "TagDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TagDescription
-- <p>Describes a tag.</p>
-- @param _ResourceType [ResourceType] <p>The resource type.</p>
-- @param _ResourceId [String] <p>The ID of the resource. For example, <code>ami-1a2b3c4d</code>.</p>
-- @param _Value [String] <p>The tag value.</p>
-- @param _Key [String] <p>The tag key.</p>
function M.TagDescription(_ResourceType, _ResourceId, _Value, _Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TagDescription")
	local t = { 
		["ResourceType"] = _ResourceType,
		["ResourceId"] = _ResourceId,
		["Value"] = _Value,
		["Key"] = _Key,
	}
	asserts.AssertTagDescription(t)
	return t
end

keys.DeleteVpcRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcRequest[k], "DeleteVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcRequest
-- <p>Contains the parameters for DeleteVpc.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.DeleteVpcRequest(_VpcId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteVpcRequest(t)
	return t
end

keys.DescribeSnapshotsRequest = { ["OwnerIds"] = true, ["DryRun"] = true, ["SnapshotIds"] = true, ["MaxResults"] = true, ["Filters"] = true, ["RestorableByUserIds"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSnapshotsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotsRequest to be of type 'table'")
	if struct["OwnerIds"] then asserts.AssertOwnerStringList(struct["OwnerIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotIds"] then asserts.AssertSnapshotIdStringList(struct["SnapshotIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["RestorableByUserIds"] then asserts.AssertRestorableByStringList(struct["RestorableByUserIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotsRequest[k], "DescribeSnapshotsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotsRequest
-- <p>Contains the parameters for DescribeSnapshots.</p>
-- @param _OwnerIds [OwnerStringList] <p>Returns the snapshots owned by the specified owner. Multiple owners can be specified.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _SnapshotIds [SnapshotIdStringList] <p>One or more snapshot IDs.</p> <p>Default: Describes snapshots for which you have launch permissions.</p>
-- @param _MaxResults [Integer] <p>The maximum number of snapshot results returned by <code>DescribeSnapshots</code> in paginated output. When this parameter is used, <code>DescribeSnapshots</code> only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>DescribeSnapshots</code> request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then <code>DescribeSnapshots</code> returns all results. You cannot specify this parameter and the snapshot IDs parameter in the same request.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>description</code> - A description of the snapshot.</p> </li> <li> <p> <code>owner-alias</code> - Value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM consolew.</p> </li> <li> <p> <code>owner-id</code> - The ID of the AWS account that owns the snapshot.</p> </li> <li> <p> <code>progress</code> - The progress of the snapshot, as a percentage (for example, 80%).</p> </li> <li> <p> <code>snapshot-id</code> - The snapshot ID.</p> </li> <li> <p> <code>start-time</code> - The time stamp when the snapshot was initiated.</p> </li> <li> <p> <code>status</code> - The status of the snapshot (<code>pending</code> | <code>completed</code> | <code>error</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>volume-id</code> - The ID of the volume the snapshot is for.</p> </li> <li> <p> <code>volume-size</code> - The size of the volume, in GiB.</p> </li> </ul>
-- @param _RestorableByUserIds [RestorableByStringList] <p>One or more AWS accounts IDs that can create volumes from the snapshot.</p>
-- @param _NextToken [String] <p>The <code>NextToken</code> value returned from a previous paginated <code>DescribeSnapshots</code> request where <code>MaxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>NextToken</code> value. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeSnapshotsRequest(_OwnerIds, _DryRun, _SnapshotIds, _MaxResults, _Filters, _RestorableByUserIds, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSnapshotsRequest")
	local t = { 
		["OwnerIds"] = _OwnerIds,
		["DryRun"] = _DryRun,
		["SnapshotIds"] = _SnapshotIds,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
		["RestorableByUserIds"] = _RestorableByUserIds,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeSnapshotsRequest(t)
	return t
end

keys.VpnConnectionOptions = { ["StaticRoutesOnly"] = true, nil }

function asserts.AssertVpnConnectionOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnectionOptions to be of type 'table'")
	if struct["StaticRoutesOnly"] then asserts.AssertBoolean(struct["StaticRoutesOnly"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnConnectionOptions[k], "VpnConnectionOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnectionOptions
-- <p>Describes VPN connection options.</p>
-- @param _StaticRoutesOnly [Boolean] <p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>
function M.VpnConnectionOptions(_StaticRoutesOnly, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnConnectionOptions")
	local t = { 
		["StaticRoutesOnly"] = _StaticRoutesOnly,
	}
	asserts.AssertVpnConnectionOptions(t)
	return t
end

keys.BundleInstanceRequest = { ["InstanceId"] = true, ["DryRun"] = true, ["Storage"] = true, nil }

function asserts.AssertBundleInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["Storage"], "Expected key Storage to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Storage"] then asserts.AssertStorage(struct["Storage"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleInstanceRequest[k], "BundleInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleInstanceRequest
-- <p>Contains the parameters for BundleInstance.</p>
-- @param _InstanceId [String] <p>The ID of the instance to bundle.</p> <p>Type: String</p> <p>Default: None</p> <p>Required: Yes</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Storage [Storage] <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
-- Required parameter: InstanceId
-- Required parameter: Storage
function M.BundleInstanceRequest(_InstanceId, _DryRun, _Storage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BundleInstanceRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["DryRun"] = _DryRun,
		["Storage"] = _Storage,
	}
	asserts.AssertBundleInstanceRequest(t)
	return t
end

keys.ImportVolumeTaskDetails = { ["BytesConverted"] = true, ["Volume"] = true, ["Image"] = true, ["AvailabilityZone"] = true, ["Description"] = true, nil }

function asserts.AssertImportVolumeTaskDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeTaskDetails to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["BytesConverted"], "Expected key BytesConverted to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["BytesConverted"] then asserts.AssertLong(struct["BytesConverted"]) end
	if struct["Volume"] then asserts.AssertDiskImageVolumeDescription(struct["Volume"]) end
	if struct["Image"] then asserts.AssertDiskImageDescription(struct["Image"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportVolumeTaskDetails[k], "ImportVolumeTaskDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeTaskDetails
-- <p>Describes an import volume task.</p>
-- @param _BytesConverted [Long] <p>The number of bytes converted so far.</p>
-- @param _Volume [DiskImageVolumeDescription] <p>The volume.</p>
-- @param _Image [DiskImageDescription] <p>The image.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone where the resulting volume will reside.</p>
-- @param _Description [String] <p>The description you provided when starting the import volume task.</p>
-- Required parameter: AvailabilityZone
-- Required parameter: BytesConverted
-- Required parameter: Image
-- Required parameter: Volume
function M.ImportVolumeTaskDetails(_BytesConverted, _Volume, _Image, _AvailabilityZone, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportVolumeTaskDetails")
	local t = { 
		["BytesConverted"] = _BytesConverted,
		["Volume"] = _Volume,
		["Image"] = _Image,
		["AvailabilityZone"] = _AvailabilityZone,
		["Description"] = _Description,
	}
	asserts.AssertImportVolumeTaskDetails(t)
	return t
end

keys.ImportSnapshotResult = { ["SnapshotTaskDetail"] = true, ["Description"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportSnapshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotResult to be of type 'table'")
	if struct["SnapshotTaskDetail"] then asserts.AssertSnapshotTaskDetail(struct["SnapshotTaskDetail"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportSnapshotResult[k], "ImportSnapshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotResult
-- <p>Contains the output for ImportSnapshot.</p>
-- @param _SnapshotTaskDetail [SnapshotTaskDetail] <p>Information about the import snapshot task.</p>
-- @param _Description [String] <p>A description of the import snapshot task.</p>
-- @param _ImportTaskId [String] <p>The ID of the import snapshot task.</p>
function M.ImportSnapshotResult(_SnapshotTaskDetail, _Description, _ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportSnapshotResult")
	local t = { 
		["SnapshotTaskDetail"] = _SnapshotTaskDetail,
		["Description"] = _Description,
		["ImportTaskId"] = _ImportTaskId,
	}
	asserts.AssertImportSnapshotResult(t)
	return t
end

keys.VolumeStatusEvent = { ["EventId"] = true, ["EventType"] = true, ["NotBefore"] = true, ["Description"] = true, ["NotAfter"] = true, nil }

function asserts.AssertVolumeStatusEvent(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusEvent to be of type 'table'")
	if struct["EventId"] then asserts.AssertString(struct["EventId"]) end
	if struct["EventType"] then asserts.AssertString(struct["EventType"]) end
	if struct["NotBefore"] then asserts.AssertDateTime(struct["NotBefore"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NotAfter"] then asserts.AssertDateTime(struct["NotAfter"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusEvent[k], "VolumeStatusEvent contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusEvent
-- <p>Describes a volume status event.</p>
-- @param _EventId [String] <p>The ID of this event.</p>
-- @param _EventType [String] <p>The type of this event.</p>
-- @param _NotBefore [DateTime] <p>The earliest start time of the event.</p>
-- @param _Description [String] <p>A description of the event.</p>
-- @param _NotAfter [DateTime] <p>The latest end time of the event.</p>
function M.VolumeStatusEvent(_EventId, _EventType, _NotBefore, _Description, _NotAfter, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusEvent")
	local t = { 
		["EventId"] = _EventId,
		["EventType"] = _EventType,
		["NotBefore"] = _NotBefore,
		["Description"] = _Description,
		["NotAfter"] = _NotAfter,
	}
	asserts.AssertVolumeStatusEvent(t)
	return t
end

keys.RejectVpcPeeringConnectionResult = { ["Return"] = true, nil }

function asserts.AssertRejectVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcPeeringConnectionResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.RejectVpcPeeringConnectionResult[k], "RejectVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcPeeringConnectionResult
-- <p>Contains the output of RejectVpcPeeringConnection.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.RejectVpcPeeringConnectionResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RejectVpcPeeringConnectionResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertRejectVpcPeeringConnectionResult(t)
	return t
end

keys.DeleteFlowLogsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertDeleteFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFlowLogsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFlowLogsResult[k], "DeleteFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFlowLogsResult
-- <p>Contains the output of DeleteFlowLogs.</p>
-- @param _Unsuccessful [UnsuccessfulItemSet] <p>Information about the flow logs that could not be deleted successfully.</p>
function M.DeleteFlowLogsResult(_Unsuccessful, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteFlowLogsResult")
	local t = { 
		["Unsuccessful"] = _Unsuccessful,
	}
	asserts.AssertDeleteFlowLogsResult(t)
	return t
end

keys.UserBucket = { ["S3Bucket"] = true, ["S3Key"] = true, nil }

function asserts.AssertUserBucket(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserBucket to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then asserts.AssertString(struct["S3Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserBucket[k], "UserBucket contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserBucket
-- <p>Describes the S3 bucket for the disk image.</p>
-- @param _S3Bucket [String] <p>The name of the S3 bucket where the disk image is located.</p>
-- @param _S3Key [String] <p>The file name of the disk image.</p>
function M.UserBucket(_S3Bucket, _S3Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UserBucket")
	local t = { 
		["S3Bucket"] = _S3Bucket,
		["S3Key"] = _S3Key,
	}
	asserts.AssertUserBucket(t)
	return t
end

keys.CreateFlowLogsResult = { ["Unsuccessful"] = true, ["FlowLogIds"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFlowLogsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	if struct["FlowLogIds"] then asserts.AssertValueStringList(struct["FlowLogIds"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFlowLogsResult[k], "CreateFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFlowLogsResult
-- <p>Contains the output of CreateFlowLogs.</p>
-- @param _Unsuccessful [UnsuccessfulItemSet] <p>Information about the flow logs that could not be created successfully.</p>
-- @param _FlowLogIds [ValueStringList] <p>The IDs of the flow logs.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
function M.CreateFlowLogsResult(_Unsuccessful, _FlowLogIds, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateFlowLogsResult")
	local t = { 
		["Unsuccessful"] = _Unsuccessful,
		["FlowLogIds"] = _FlowLogIds,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertCreateFlowLogsResult(t)
	return t
end

keys.StopInstancesRequest = { ["Force"] = true, ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertStopInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.StopInstancesRequest[k], "StopInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopInstancesRequest
-- <p>Contains the parameters for StopInstances.</p>
-- @param _Force [Boolean] <p>Forces the instances to stop. The instances do not have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures. This option is not recommended for Windows instances.</p> <p>Default: <code>false</code> </p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.StopInstancesRequest(_Force, _DryRun, _InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StopInstancesRequest")
	local t = { 
		["Force"] = _Force,
		["DryRun"] = _DryRun,
		["InstanceIds"] = _InstanceIds,
	}
	asserts.AssertStopInstancesRequest(t)
	return t
end

keys.StopInstancesResult = { ["StoppingInstances"] = true, nil }

function asserts.AssertStopInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopInstancesResult to be of type 'table'")
	if struct["StoppingInstances"] then asserts.AssertInstanceStateChangeList(struct["StoppingInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.StopInstancesResult[k], "StopInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopInstancesResult
-- <p>Contains the output of StopInstances.</p>
-- @param _StoppingInstances [InstanceStateChangeList] <p>Information about one or more stopped instances.</p>
function M.StopInstancesResult(_StoppingInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StopInstancesResult")
	local t = { 
		["StoppingInstances"] = _StoppingInstances,
	}
	asserts.AssertStopInstancesResult(t)
	return t
end

keys.DescribeReservedInstancesListingsRequest = { ["ReservedInstancesId"] = true, ["ReservedInstancesListingId"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeReservedInstancesListingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesListingsRequest to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["ReservedInstancesListingId"] then asserts.AssertString(struct["ReservedInstancesListingId"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesListingsRequest[k], "DescribeReservedInstancesListingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesListingsRequest
-- <p>Contains the parameters for DescribeReservedInstancesListings.</p>
-- @param _ReservedInstancesId [String] <p>One or more Reserved Instance IDs.</p>
-- @param _ReservedInstancesListingId [String] <p>One or more Reserved Instance listing IDs.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instances.</p> </li> <li> <p> <code>reserved-instances-listing-id</code> - The ID of the Reserved Instances listing.</p> </li> <li> <p> <code>status</code> - The status of the Reserved Instance listing (<code>pending</code> | <code>active</code> | <code>cancelled</code> | <code>closed</code>).</p> </li> <li> <p> <code>status-message</code> - The reason for the status.</p> </li> </ul>
function M.DescribeReservedInstancesListingsRequest(_ReservedInstancesId, _ReservedInstancesListingId, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesListingsRequest")
	local t = { 
		["ReservedInstancesId"] = _ReservedInstancesId,
		["ReservedInstancesListingId"] = _ReservedInstancesListingId,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeReservedInstancesListingsRequest(t)
	return t
end

keys.ModifySubnetAttributeRequest = { ["SubnetId"] = true, ["MapPublicIpOnLaunch"] = true, ["AssignIpv6AddressOnCreation"] = true, nil }

function asserts.AssertModifySubnetAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySubnetAttributeRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["MapPublicIpOnLaunch"] then asserts.AssertAttributeBooleanValue(struct["MapPublicIpOnLaunch"]) end
	if struct["AssignIpv6AddressOnCreation"] then asserts.AssertAttributeBooleanValue(struct["AssignIpv6AddressOnCreation"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySubnetAttributeRequest[k], "ModifySubnetAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySubnetAttributeRequest
-- <p>Contains the parameters for ModifySubnetAttribute.</p>
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _MapPublicIpOnLaunch [AttributeBooleanValue] <p>Specify <code>true</code> to indicate that network interfaces created in the specified subnet should be assigned a public IPv4 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives a public IPv4 address).</p>
-- @param _AssignIpv6AddressOnCreation [AttributeBooleanValue] <p>Specify <code>true</code> to indicate that network interfaces created in the specified subnet should be assigned an IPv6 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives an IPv6 address). </p> <p>If you enable the IPv6 addressing feature for your subnet, your network interface or instance only receives an IPv6 address if it's created using version <code>2016-11-15</code> or later of the Amazon EC2 API.</p>
-- Required parameter: SubnetId
function M.ModifySubnetAttributeRequest(_SubnetId, _MapPublicIpOnLaunch, _AssignIpv6AddressOnCreation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifySubnetAttributeRequest")
	local t = { 
		["SubnetId"] = _SubnetId,
		["MapPublicIpOnLaunch"] = _MapPublicIpOnLaunch,
		["AssignIpv6AddressOnCreation"] = _AssignIpv6AddressOnCreation,
	}
	asserts.AssertModifySubnetAttributeRequest(t)
	return t
end

keys.DisassociateAddressRequest = { ["PublicIp"] = true, ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDisassociateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateAddressRequest to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateAddressRequest[k], "DisassociateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateAddressRequest
-- <p>Contains the parameters for DisassociateAddress.</p>
-- @param _PublicIp [String] <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
-- @param _AssociationId [String] <p>[EC2-VPC] The association ID. Required for EC2-VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.DisassociateAddressRequest(_PublicIp, _AssociationId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateAddressRequest")
	local t = { 
		["PublicIp"] = _PublicIp,
		["AssociationId"] = _AssociationId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDisassociateAddressRequest(t)
	return t
end

keys.ExportTask = { ["Description"] = true, ["InstanceExportDetails"] = true, ["ExportTaskId"] = true, ["State"] = true, ["StatusMessage"] = true, ["ExportToS3Task"] = true, nil }

function asserts.AssertExportTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportTask to be of type 'table'")
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["InstanceExportDetails"] then asserts.AssertInstanceExportDetails(struct["InstanceExportDetails"]) end
	if struct["ExportTaskId"] then asserts.AssertString(struct["ExportTaskId"]) end
	if struct["State"] then asserts.AssertExportTaskState(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ExportToS3Task"] then asserts.AssertExportToS3Task(struct["ExportToS3Task"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExportTask[k], "ExportTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportTask
-- <p>Describes an instance export task.</p>
-- @param _Description [String] <p>A description of the resource being exported.</p>
-- @param _InstanceExportDetails [InstanceExportDetails] <p>Information about the instance to export.</p>
-- @param _ExportTaskId [String] <p>The ID of the export task.</p>
-- @param _State [ExportTaskState] <p>The state of the export task.</p>
-- @param _StatusMessage [String] <p>The status message related to the export task.</p>
-- @param _ExportToS3Task [ExportToS3Task] <p>Information about the export task.</p>
function M.ExportTask(_Description, _InstanceExportDetails, _ExportTaskId, _State, _StatusMessage, _ExportToS3Task, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ExportTask")
	local t = { 
		["Description"] = _Description,
		["InstanceExportDetails"] = _InstanceExportDetails,
		["ExportTaskId"] = _ExportTaskId,
		["State"] = _State,
		["StatusMessage"] = _StatusMessage,
		["ExportToS3Task"] = _ExportToS3Task,
	}
	asserts.AssertExportTask(t)
	return t
end

keys.ImportVolumeRequest = { ["Volume"] = true, ["Image"] = true, ["AvailabilityZone"] = true, ["DryRun"] = true, ["Description"] = true, nil }

function asserts.AssertImportVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["Volume"] then asserts.AssertVolumeDetail(struct["Volume"]) end
	if struct["Image"] then asserts.AssertDiskImageDetail(struct["Image"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportVolumeRequest[k], "ImportVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeRequest
-- <p>Contains the parameters for ImportVolume.</p>
-- @param _Volume [VolumeDetail] <p>The volume size.</p>
-- @param _Image [DiskImageDetail] <p>The disk image.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone for the resulting EBS volume.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>A description of the volume.</p>
-- Required parameter: AvailabilityZone
-- Required parameter: Image
-- Required parameter: Volume
function M.ImportVolumeRequest(_Volume, _Image, _AvailabilityZone, _DryRun, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportVolumeRequest")
	local t = { 
		["Volume"] = _Volume,
		["Image"] = _Image,
		["AvailabilityZone"] = _AvailabilityZone,
		["DryRun"] = _DryRun,
		["Description"] = _Description,
	}
	asserts.AssertImportVolumeRequest(t)
	return t
end

keys.DescribeVpnGatewaysResult = { ["VpnGateways"] = true, nil }

function asserts.AssertDescribeVpnGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnGatewaysResult to be of type 'table'")
	if struct["VpnGateways"] then asserts.AssertVpnGatewayList(struct["VpnGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnGatewaysResult[k], "DescribeVpnGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnGatewaysResult
-- <p>Contains the output of DescribeVpnGateways.</p>
-- @param _VpnGateways [VpnGatewayList] <p>Information about one or more virtual private gateways.</p>
function M.DescribeVpnGatewaysResult(_VpnGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpnGatewaysResult")
	local t = { 
		["VpnGateways"] = _VpnGateways,
	}
	asserts.AssertDescribeVpnGatewaysResult(t)
	return t
end

keys.ImageDiskContainer = { ["DeviceName"] = true, ["Description"] = true, ["Format"] = true, ["Url"] = true, ["SnapshotId"] = true, ["UserBucket"] = true, nil }

function asserts.AssertImageDiskContainer(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImageDiskContainer to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["UserBucket"] then asserts.AssertUserBucket(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImageDiskContainer[k], "ImageDiskContainer contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImageDiskContainer
-- <p>Describes the disk container object for an import image task.</p>
-- @param _DeviceName [String] <p>The block device mapping for the disk.</p>
-- @param _Description [String] <p>The description of the disk image.</p>
-- @param _Format [String] <p>The format of the disk image being imported.</p> <p>Valid values: <code>RAW</code> | <code>VHD</code> | <code>VMDK</code> | <code>OVA</code> </p>
-- @param _Url [String] <p>The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an Amazon S3 URL (s3://..)</p>
-- @param _SnapshotId [String] <p>The ID of the EBS snapshot to be used for importing the snapshot.</p>
-- @param _UserBucket [UserBucket] <p>The S3 bucket for the disk image.</p>
function M.ImageDiskContainer(_DeviceName, _Description, _Format, _Url, _SnapshotId, _UserBucket, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImageDiskContainer")
	local t = { 
		["DeviceName"] = _DeviceName,
		["Description"] = _Description,
		["Format"] = _Format,
		["Url"] = _Url,
		["SnapshotId"] = _SnapshotId,
		["UserBucket"] = _UserBucket,
	}
	asserts.AssertImageDiskContainer(t)
	return t
end

keys.DescribeSpotPriceHistoryRequest = { ["NextToken"] = true, ["AvailabilityZone"] = true, ["DryRun"] = true, ["StartTime"] = true, ["InstanceTypes"] = true, ["MaxResults"] = true, ["ProductDescriptions"] = true, ["Filters"] = true, ["EndTime"] = true, nil }

function asserts.AssertDescribeSpotPriceHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotPriceHistoryRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["InstanceTypes"] then asserts.AssertInstanceTypeList(struct["InstanceTypes"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["ProductDescriptions"] then asserts.AssertProductDescriptionList(struct["ProductDescriptions"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotPriceHistoryRequest[k], "DescribeSpotPriceHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotPriceHistoryRequest
-- <p>Contains the parameters for DescribeSpotPriceHistory.</p>
-- @param _NextToken [String] <p>The token for the next set of results.</p>
-- @param _AvailabilityZone [String] <p>Filters the results by the specified Availability Zone.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _StartTime [DateTime] <p>The date and time, up to the past 90 days, from which to start retrieving the price history data, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @param _InstanceTypes [InstanceTypeList] <p>Filters the results by the specified instance types. Note that T2 and HS1 instance types are not supported.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param _ProductDescriptions [ProductDescriptionList] <p>Filters the results by the specified basic product descriptions.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone for which prices should be returned.</p> </li> <li> <p> <code>instance-type</code> - The type of instance (for example, <code>m3.medium</code>).</p> </li> <li> <p> <code>product-description</code> - The product description for the Spot price (<code>Linux/UNIX</code> | <code>SUSE Linux</code> | <code>Windows</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Windows (Amazon VPC)</code>).</p> </li> <li> <p> <code>spot-price</code> - The Spot price. The value must match exactly (or use wildcards; greater than or less than comparison is not supported).</p> </li> <li> <p> <code>timestamp</code> - The timestamp of the Spot price history, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). You can use wildcards (* and ?). Greater than or less than comparison is not supported.</p> </li> </ul>
-- @param _EndTime [DateTime] <p>The date and time, up to the current date, from which to stop retrieving the price history data, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
function M.DescribeSpotPriceHistoryRequest(_NextToken, _AvailabilityZone, _DryRun, _StartTime, _InstanceTypes, _MaxResults, _ProductDescriptions, _Filters, _EndTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotPriceHistoryRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["AvailabilityZone"] = _AvailabilityZone,
		["DryRun"] = _DryRun,
		["StartTime"] = _StartTime,
		["InstanceTypes"] = _InstanceTypes,
		["MaxResults"] = _MaxResults,
		["ProductDescriptions"] = _ProductDescriptions,
		["Filters"] = _Filters,
		["EndTime"] = _EndTime,
	}
	asserts.AssertDescribeSpotPriceHistoryRequest(t)
	return t
end

keys.ModifyHostsRequest = { ["HostIds"] = true, ["AutoPlacement"] = true, nil }

function asserts.AssertModifyHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyHostsRequest to be of type 'table'")
	assert(struct["AutoPlacement"], "Expected key AutoPlacement to exist in table")
	assert(struct["HostIds"], "Expected key HostIds to exist in table")
	if struct["HostIds"] then asserts.AssertRequestHostIdList(struct["HostIds"]) end
	if struct["AutoPlacement"] then asserts.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyHostsRequest[k], "ModifyHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyHostsRequest
-- <p>Contains the parameters for ModifyHosts.</p>
-- @param _HostIds [RequestHostIdList] <p>The host IDs of the Dedicated Hosts you want to modify.</p>
-- @param _AutoPlacement [AutoPlacement] <p>Specify whether to enable or disable auto-placement.</p>
-- Required parameter: AutoPlacement
-- Required parameter: HostIds
function M.ModifyHostsRequest(_HostIds, _AutoPlacement, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyHostsRequest")
	local t = { 
		["HostIds"] = _HostIds,
		["AutoPlacement"] = _AutoPlacement,
	}
	asserts.AssertModifyHostsRequest(t)
	return t
end

keys.ResetImageAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["ImageId"] = true, nil }

function asserts.AssertResetImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetImageAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["Attribute"] then asserts.AssertResetImageAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetImageAttributeRequest[k], "ResetImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetImageAttributeRequest
-- <p>Contains the parameters for ResetImageAttribute.</p>
-- @param _Attribute [ResetImageAttributeName] <p>The attribute to reset (currently you can only reset the launch permission attribute).</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _ImageId [String] <p>The ID of the AMI.</p>
-- Required parameter: Attribute
-- Required parameter: ImageId
function M.ResetImageAttributeRequest(_Attribute, _DryRun, _ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ResetImageAttributeRequest")
	local t = { 
		["Attribute"] = _Attribute,
		["DryRun"] = _DryRun,
		["ImageId"] = _ImageId,
	}
	asserts.AssertResetImageAttributeRequest(t)
	return t
end

keys.DescribeAvailabilityZonesResult = { ["AvailabilityZones"] = true, nil }

function asserts.AssertDescribeAvailabilityZonesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailabilityZonesResult to be of type 'table'")
	if struct["AvailabilityZones"] then asserts.AssertAvailabilityZoneList(struct["AvailabilityZones"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAvailabilityZonesResult[k], "DescribeAvailabilityZonesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailabilityZonesResult
-- <p>Contains the output of DescribeAvailabiltyZones.</p>
-- @param _AvailabilityZones [AvailabilityZoneList] <p>Information about one or more Availability Zones.</p>
function M.DescribeAvailabilityZonesResult(_AvailabilityZones, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAvailabilityZonesResult")
	local t = { 
		["AvailabilityZones"] = _AvailabilityZones,
	}
	asserts.AssertDescribeAvailabilityZonesResult(t)
	return t
end

keys.RecurringCharge = { ["Amount"] = true, ["Frequency"] = true, nil }

function asserts.AssertRecurringCharge(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RecurringCharge to be of type 'table'")
	if struct["Amount"] then asserts.AssertDouble(struct["Amount"]) end
	if struct["Frequency"] then asserts.AssertRecurringChargeFrequency(struct["Frequency"]) end
	for k,_ in pairs(struct) do
		assert(keys.RecurringCharge[k], "RecurringCharge contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RecurringCharge
-- <p>Describes a recurring charge.</p>
-- @param _Amount [Double] <p>The amount of the recurring charge.</p>
-- @param _Frequency [RecurringChargeFrequency] <p>The frequency of the recurring charge.</p>
function M.RecurringCharge(_Amount, _Frequency, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RecurringCharge")
	local t = { 
		["Amount"] = _Amount,
		["Frequency"] = _Frequency,
	}
	asserts.AssertRecurringCharge(t)
	return t
end

keys.InstanceStateChange = { ["InstanceId"] = true, ["CurrentState"] = true, ["PreviousState"] = true, nil }

function asserts.AssertInstanceStateChange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStateChange to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["CurrentState"] then asserts.AssertInstanceState(struct["CurrentState"]) end
	if struct["PreviousState"] then asserts.AssertInstanceState(struct["PreviousState"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStateChange[k], "InstanceStateChange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStateChange
-- <p>Describes an instance state change.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _CurrentState [InstanceState] <p>The current state of the instance.</p>
-- @param _PreviousState [InstanceState] <p>The previous state of the instance.</p>
function M.InstanceStateChange(_InstanceId, _CurrentState, _PreviousState, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStateChange")
	local t = { 
		["InstanceId"] = _InstanceId,
		["CurrentState"] = _CurrentState,
		["PreviousState"] = _PreviousState,
	}
	asserts.AssertInstanceStateChange(t)
	return t
end

keys.PurchaseRequest = { ["InstanceCount"] = true, ["PurchaseToken"] = true, nil }

function asserts.AssertPurchaseRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseRequest to be of type 'table'")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["PurchaseToken"], "Expected key PurchaseToken to exist in table")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["PurchaseToken"] then asserts.AssertString(struct["PurchaseToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseRequest[k], "PurchaseRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseRequest
-- <p>Describes a request to purchase Scheduled Instances.</p>
-- @param _InstanceCount [Integer] <p>The number of instances.</p>
-- @param _PurchaseToken [String] <p>The purchase token.</p>
-- Required parameter: InstanceCount
-- Required parameter: PurchaseToken
function M.PurchaseRequest(_InstanceCount, _PurchaseToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseRequest")
	local t = { 
		["InstanceCount"] = _InstanceCount,
		["PurchaseToken"] = _PurchaseToken,
	}
	asserts.AssertPurchaseRequest(t)
	return t
end

keys.ResetSnapshotAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertResetSnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetSnapshotAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["Attribute"] then asserts.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetSnapshotAttributeRequest[k], "ResetSnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetSnapshotAttributeRequest
-- <p>Contains the parameters for ResetSnapshotAttribute.</p>
-- @param _Attribute [SnapshotAttributeName] <p>The attribute to reset. Currently, only the attribute for permission to create volumes can be reset.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _SnapshotId [String] <p>The ID of the snapshot.</p>
-- Required parameter: Attribute
-- Required parameter: SnapshotId
function M.ResetSnapshotAttributeRequest(_Attribute, _DryRun, _SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ResetSnapshotAttributeRequest")
	local t = { 
		["Attribute"] = _Attribute,
		["DryRun"] = _DryRun,
		["SnapshotId"] = _SnapshotId,
	}
	asserts.AssertResetSnapshotAttributeRequest(t)
	return t
end

keys.DescribeVolumesModificationsResult = { ["VolumesModifications"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeVolumesModificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesModificationsResult to be of type 'table'")
	if struct["VolumesModifications"] then asserts.AssertVolumeModificationList(struct["VolumesModifications"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesModificationsResult[k], "DescribeVolumesModificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesModificationsResult
--  
-- @param _VolumesModifications [VolumeModificationList] <p>A list of returned <a>VolumeModification</a> objects.</p>
-- @param _NextToken [String] <p>Token for pagination, null if there are no more results </p>
function M.DescribeVolumesModificationsResult(_VolumesModifications, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumesModificationsResult")
	local t = { 
		["VolumesModifications"] = _VolumesModifications,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeVolumesModificationsResult(t)
	return t
end

keys.ImportKeyPairRequest = { ["PublicKeyMaterial"] = true, ["KeyName"] = true, ["DryRun"] = true, nil }

function asserts.AssertImportKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	assert(struct["PublicKeyMaterial"], "Expected key PublicKeyMaterial to exist in table")
	if struct["PublicKeyMaterial"] then asserts.AssertBlob(struct["PublicKeyMaterial"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportKeyPairRequest[k], "ImportKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportKeyPairRequest
-- <p>Contains the parameters for ImportKeyPair.</p>
-- @param _PublicKeyMaterial [Blob] <p>The public key. For API calls, the text must be base64-encoded. For command line tools, base64 encoding is performed for you.</p>
-- @param _KeyName [String] <p>A unique name for the key pair.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: KeyName
-- Required parameter: PublicKeyMaterial
function M.ImportKeyPairRequest(_PublicKeyMaterial, _KeyName, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportKeyPairRequest")
	local t = { 
		["PublicKeyMaterial"] = _PublicKeyMaterial,
		["KeyName"] = _KeyName,
		["DryRun"] = _DryRun,
	}
	asserts.AssertImportKeyPairRequest(t)
	return t
end

keys.SpotFleetLaunchSpecification = { ["WeightedCapacity"] = true, ["UserData"] = true, ["SubnetId"] = true, ["Monitoring"] = true, ["ImageId"] = true, ["KeyName"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroups"] = true, ["SpotPrice"] = true, ["RamdiskId"] = true, ["KernelId"] = true, ["Placement"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["AddressingType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertSpotFleetLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetLaunchSpecification to be of type 'table'")
	if struct["WeightedCapacity"] then asserts.AssertDouble(struct["WeightedCapacity"]) end
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then asserts.AssertSpotFleetMonitoring(struct["Monitoring"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then asserts.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Placement"] then asserts.AssertSpotPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then asserts.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetLaunchSpecification[k], "SpotFleetLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetLaunchSpecification
-- <p>Describes the launch specification for one or more Spot instances.</p>
-- @param _WeightedCapacity [Double] <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms (instances or a performance characteristic such as vCPUs, memory, or I/O).</p> <p>If the target capacity divided by this value is not a whole number, we round the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
-- @param _UserData [String] <p>The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param _SubnetId [String] <p>The ID of the subnet in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-a61dafcf, subnet-65ea5f08".</p>
-- @param _Monitoring [SpotFleetMonitoring] <p>Enable or disable monitoring for the instances.</p>
-- @param _ImageId [String] <p>The ID of the AMI.</p>
-- @param _KeyName [String] <p>The name of the key pair.</p>
-- @param _BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p>
-- @param _EbsOptimized [Boolean] <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param _SecurityGroups [GroupIdentifierList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- @param _SpotPrice [String] <p>The bid price per unit hour for the specified instance type. If this value is not specified, the default is the Spot bid price specified for the fleet. To determine the bid price per unit hour, divide the Spot bid price by the value of <code>WeightedCapacity</code>.</p>
-- @param _RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param _KernelId [String] <p>The ID of the kernel.</p>
-- @param _Placement [SpotPlacement] <p>The placement information.</p>
-- @param _IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- @param _InstanceType [InstanceType] <p>The instance type. Note that T2 and HS1 instance types are not supported.</p>
-- @param _AddressingType [String] <p>Deprecated.</p>
-- @param _NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
function M.SpotFleetLaunchSpecification(_WeightedCapacity, _UserData, _SubnetId, _Monitoring, _ImageId, _KeyName, _BlockDeviceMappings, _EbsOptimized, _SecurityGroups, _SpotPrice, _RamdiskId, _KernelId, _Placement, _IamInstanceProfile, _InstanceType, _AddressingType, _NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotFleetLaunchSpecification")
	local t = { 
		["WeightedCapacity"] = _WeightedCapacity,
		["UserData"] = _UserData,
		["SubnetId"] = _SubnetId,
		["Monitoring"] = _Monitoring,
		["ImageId"] = _ImageId,
		["KeyName"] = _KeyName,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["EbsOptimized"] = _EbsOptimized,
		["SecurityGroups"] = _SecurityGroups,
		["SpotPrice"] = _SpotPrice,
		["RamdiskId"] = _RamdiskId,
		["KernelId"] = _KernelId,
		["Placement"] = _Placement,
		["IamInstanceProfile"] = _IamInstanceProfile,
		["InstanceType"] = _InstanceType,
		["AddressingType"] = _AddressingType,
		["NetworkInterfaces"] = _NetworkInterfaces,
	}
	asserts.AssertSpotFleetLaunchSpecification(t)
	return t
end

keys.DeleteNetworkAclRequest = { ["NetworkAclId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteNetworkAclRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkAclRequest to be of type 'table'")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkAclRequest[k], "DeleteNetworkAclRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkAclRequest
-- <p>Contains the parameters for DeleteNetworkAcl.</p>
-- @param _NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: NetworkAclId
function M.DeleteNetworkAclRequest(_NetworkAclId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNetworkAclRequest")
	local t = { 
		["NetworkAclId"] = _NetworkAclId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteNetworkAclRequest(t)
	return t
end

keys.DescribePlacementGroupsRequest = { ["GroupNames"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribePlacementGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePlacementGroupsRequest to be of type 'table'")
	if struct["GroupNames"] then asserts.AssertPlacementGroupStringList(struct["GroupNames"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePlacementGroupsRequest[k], "DescribePlacementGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePlacementGroupsRequest
-- <p>Contains the parameters for DescribePlacementGroups.</p>
-- @param _GroupNames [PlacementGroupStringList] <p>One or more placement group names.</p> <p>Default: Describes all your placement groups, or only those otherwise specified.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>group-name</code> - The name of the placement group.</p> </li> <li> <p> <code>state</code> - The state of the placement group (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>strategy</code> - The strategy of the placement group (<code>cluster</code>).</p> </li> </ul>
function M.DescribePlacementGroupsRequest(_GroupNames, _DryRun, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribePlacementGroupsRequest")
	local t = { 
		["GroupNames"] = _GroupNames,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribePlacementGroupsRequest(t)
	return t
end

keys.DescribeNetworkAclsRequest = { ["NetworkAclIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeNetworkAclsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkAclsRequest to be of type 'table'")
	if struct["NetworkAclIds"] then asserts.AssertValueStringList(struct["NetworkAclIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkAclsRequest[k], "DescribeNetworkAclsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkAclsRequest
-- <p>Contains the parameters for DescribeNetworkAcls.</p>
-- @param _NetworkAclIds [ValueStringList] <p>One or more network ACL IDs.</p> <p>Default: Describes all your network ACLs.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>association.association-id</code> - The ID of an association ID for the ACL.</p> </li> <li> <p> <code>association.network-acl-id</code> - The ID of the network ACL involved in the association.</p> </li> <li> <p> <code>association.subnet-id</code> - The ID of the subnet involved in the association.</p> </li> <li> <p> <code>default</code> - Indicates whether the ACL is the default network ACL for the VPC.</p> </li> <li> <p> <code>entry.cidr</code> - The IPv4 CIDR range specified in the entry.</p> </li> <li> <p> <code>entry.egress</code> - Indicates whether the entry applies to egress traffic.</p> </li> <li> <p> <code>entry.icmp.code</code> - The ICMP code specified in the entry, if any.</p> </li> <li> <p> <code>entry.icmp.type</code> - The ICMP type specified in the entry, if any.</p> </li> <li> <p> <code>entry.ipv6-cidr</code> - The IPv6 CIDR range specified in the entry.</p> </li> <li> <p> <code>entry.port-range.from</code> - The start of the port range specified in the entry. </p> </li> <li> <p> <code>entry.port-range.to</code> - The end of the port range specified in the entry. </p> </li> <li> <p> <code>entry.protocol</code> - The protocol specified in the entry (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p> </li> <li> <p> <code>entry.rule-action</code> - Allows or denies the matching traffic (<code>allow</code> | <code>deny</code>).</p> </li> <li> <p> <code>entry.rule-number</code> - The number of an entry (in other words, rule) in the ACL's set of entries.</p> </li> <li> <p> <code>network-acl-id</code> - The ID of the network ACL.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the network ACL.</p> </li> </ul>
function M.DescribeNetworkAclsRequest(_NetworkAclIds, _DryRun, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkAclsRequest")
	local t = { 
		["NetworkAclIds"] = _NetworkAclIds,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeNetworkAclsRequest(t)
	return t
end

keys.AssignIpv6AddressesRequest = { ["Ipv6Addresses"] = true, ["Ipv6AddressCount"] = true, ["NetworkInterfaceId"] = true, nil }

function asserts.AssertAssignIpv6AddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignIpv6AddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Ipv6Addresses"] then asserts.AssertIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssignIpv6AddressesRequest[k], "AssignIpv6AddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignIpv6AddressesRequest
--  
-- @param _Ipv6Addresses [Ipv6AddressList] <p>One or more specific IPv6 addresses to be assigned to the network interface. You can't use this option if you're specifying a number of IPv6 addresses.</p>
-- @param _Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to the network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- Required parameter: NetworkInterfaceId
function M.AssignIpv6AddressesRequest(_Ipv6Addresses, _Ipv6AddressCount, _NetworkInterfaceId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssignIpv6AddressesRequest")
	local t = { 
		["Ipv6Addresses"] = _Ipv6Addresses,
		["Ipv6AddressCount"] = _Ipv6AddressCount,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
	}
	asserts.AssertAssignIpv6AddressesRequest(t)
	return t
end

keys.MonitorInstancesResult = { ["InstanceMonitorings"] = true, nil }

function asserts.AssertMonitorInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MonitorInstancesResult to be of type 'table'")
	if struct["InstanceMonitorings"] then asserts.AssertInstanceMonitoringList(struct["InstanceMonitorings"]) end
	for k,_ in pairs(struct) do
		assert(keys.MonitorInstancesResult[k], "MonitorInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MonitorInstancesResult
-- <p>Contains the output of MonitorInstances.</p>
-- @param _InstanceMonitorings [InstanceMonitoringList] <p>The monitoring information.</p>
function M.MonitorInstancesResult(_InstanceMonitorings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MonitorInstancesResult")
	local t = { 
		["InstanceMonitorings"] = _InstanceMonitorings,
	}
	asserts.AssertMonitorInstancesResult(t)
	return t
end

keys.SlotDateTimeRangeRequest = { ["LatestTime"] = true, ["EarliestTime"] = true, nil }

function asserts.AssertSlotDateTimeRangeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SlotDateTimeRangeRequest to be of type 'table'")
	assert(struct["EarliestTime"], "Expected key EarliestTime to exist in table")
	assert(struct["LatestTime"], "Expected key LatestTime to exist in table")
	if struct["LatestTime"] then asserts.AssertDateTime(struct["LatestTime"]) end
	if struct["EarliestTime"] then asserts.AssertDateTime(struct["EarliestTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.SlotDateTimeRangeRequest[k], "SlotDateTimeRangeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SlotDateTimeRangeRequest
-- <p>Describes the time period for a Scheduled Instance to start its first schedule. The time period must span less than one day.</p>
-- @param _LatestTime [DateTime] <p>The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.</p>
-- @param _EarliestTime [DateTime] <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
-- Required parameter: EarliestTime
-- Required parameter: LatestTime
function M.SlotDateTimeRangeRequest(_LatestTime, _EarliestTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SlotDateTimeRangeRequest")
	local t = { 
		["LatestTime"] = _LatestTime,
		["EarliestTime"] = _EarliestTime,
	}
	asserts.AssertSlotDateTimeRangeRequest(t)
	return t
end

keys.DescribeVpcEndpointsResult = { ["NextToken"] = true, ["VpcEndpoints"] = true, nil }

function asserts.AssertDescribeVpcEndpointsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["VpcEndpoints"] then asserts.AssertVpcEndpointSet(struct["VpcEndpoints"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointsResult[k], "DescribeVpcEndpointsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointsResult
-- <p>Contains the output of DescribeVpcEndpoints.</p>
-- @param _NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @param _VpcEndpoints [VpcEndpointSet] <p>Information about the endpoints.</p>
function M.DescribeVpcEndpointsResult(_NextToken, _VpcEndpoints, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcEndpointsResult")
	local t = { 
		["NextToken"] = _NextToken,
		["VpcEndpoints"] = _VpcEndpoints,
	}
	asserts.AssertDescribeVpcEndpointsResult(t)
	return t
end

keys.FpgaImage = { ["OwnerAlias"] = true, ["UpdateTime"] = true, ["Name"] = true, ["ProductCodes"] = true, ["PciId"] = true, ["Tags"] = true, ["FpgaImageGlobalId"] = true, ["State"] = true, ["ShellVersion"] = true, ["OwnerId"] = true, ["FpgaImageId"] = true, ["CreateTime"] = true, ["Description"] = true, nil }

function asserts.AssertFpgaImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FpgaImage to be of type 'table'")
	if struct["OwnerAlias"] then asserts.AssertString(struct["OwnerAlias"]) end
	if struct["UpdateTime"] then asserts.AssertDateTime(struct["UpdateTime"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["PciId"] then asserts.AssertPciId(struct["PciId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["FpgaImageGlobalId"] then asserts.AssertString(struct["FpgaImageGlobalId"]) end
	if struct["State"] then asserts.AssertFpgaImageState(struct["State"]) end
	if struct["ShellVersion"] then asserts.AssertString(struct["ShellVersion"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.FpgaImage[k], "FpgaImage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FpgaImage
-- <p>Describes an Amazon FPGA image (AFI).</p>
-- @param _OwnerAlias [String] <p>The alias of the AFI owner. Possible values include <code>self</code>, <code>amazon</code>, and <code>aws-marketplace</code>.</p>
-- @param _UpdateTime [DateTime] <p>The time of the most recent update to the AFI.</p>
-- @param _Name [String] <p>The name of the AFI.</p>
-- @param _ProductCodes [ProductCodeList] <p>The product codes for the AFI.</p>
-- @param _PciId [PciId] <p>Information about the PCI bus.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the AFI.</p>
-- @param _FpgaImageGlobalId [String] <p>The global FPGA image identifier (AGFI ID).</p>
-- @param _State [FpgaImageState] <p>Information about the state of the AFI.</p>
-- @param _ShellVersion [String] <p>The version of the AWS Shell that was used to create the bitstream.</p>
-- @param _OwnerId [String] <p>The AWS account ID of the AFI owner.</p>
-- @param _FpgaImageId [String] <p>The FPGA image identifier (AFI ID).</p>
-- @param _CreateTime [DateTime] <p>The date and time the AFI was created.</p>
-- @param _Description [String] <p>The description of the AFI.</p>
function M.FpgaImage(_OwnerAlias, _UpdateTime, _Name, _ProductCodes, _PciId, _Tags, _FpgaImageGlobalId, _State, _ShellVersion, _OwnerId, _FpgaImageId, _CreateTime, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating FpgaImage")
	local t = { 
		["OwnerAlias"] = _OwnerAlias,
		["UpdateTime"] = _UpdateTime,
		["Name"] = _Name,
		["ProductCodes"] = _ProductCodes,
		["PciId"] = _PciId,
		["Tags"] = _Tags,
		["FpgaImageGlobalId"] = _FpgaImageGlobalId,
		["State"] = _State,
		["ShellVersion"] = _ShellVersion,
		["OwnerId"] = _OwnerId,
		["FpgaImageId"] = _FpgaImageId,
		["CreateTime"] = _CreateTime,
		["Description"] = _Description,
	}
	asserts.AssertFpgaImage(t)
	return t
end

keys.DescribeKeyPairsRequest = { ["DryRun"] = true, ["Filters"] = true, ["KeyNames"] = true, nil }

function asserts.AssertDescribeKeyPairsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeKeyPairsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["KeyNames"] then asserts.AssertKeyNameStringList(struct["KeyNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeKeyPairsRequest[k], "DescribeKeyPairsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeKeyPairsRequest
-- <p>Contains the parameters for DescribeKeyPairs.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>fingerprint</code> - The fingerprint of the key pair.</p> </li> <li> <p> <code>key-name</code> - The name of the key pair.</p> </li> </ul>
-- @param _KeyNames [KeyNameStringList] <p>One or more key pair names.</p> <p>Default: Describes all your key pairs.</p>
function M.DescribeKeyPairsRequest(_DryRun, _Filters, _KeyNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeKeyPairsRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
		["KeyNames"] = _KeyNames,
	}
	asserts.AssertDescribeKeyPairsRequest(t)
	return t
end

keys.PurchaseReservedInstancesOfferingResult = { ["ReservedInstancesId"] = true, nil }

function asserts.AssertPurchaseReservedInstancesOfferingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseReservedInstancesOfferingResult to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseReservedInstancesOfferingResult[k], "PurchaseReservedInstancesOfferingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseReservedInstancesOfferingResult
-- <p>Contains the output of PurchaseReservedInstancesOffering.</p>
-- @param _ReservedInstancesId [String] <p>The IDs of the purchased Reserved Instances.</p>
function M.PurchaseReservedInstancesOfferingResult(_ReservedInstancesId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseReservedInstancesOfferingResult")
	local t = { 
		["ReservedInstancesId"] = _ReservedInstancesId,
	}
	asserts.AssertPurchaseReservedInstancesOfferingResult(t)
	return t
end

keys.CancelBundleTaskRequest = { ["DryRun"] = true, ["BundleId"] = true, nil }

function asserts.AssertCancelBundleTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelBundleTaskRequest to be of type 'table'")
	assert(struct["BundleId"], "Expected key BundleId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["BundleId"] then asserts.AssertString(struct["BundleId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelBundleTaskRequest[k], "CancelBundleTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelBundleTaskRequest
-- <p>Contains the parameters for CancelBundleTask.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _BundleId [String] <p>The ID of the bundle task.</p>
-- Required parameter: BundleId
function M.CancelBundleTaskRequest(_DryRun, _BundleId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelBundleTaskRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["BundleId"] = _BundleId,
	}
	asserts.AssertCancelBundleTaskRequest(t)
	return t
end

keys.ReleaseAddressRequest = { ["PublicIp"] = true, ["DryRun"] = true, ["AllocationId"] = true, nil }

function asserts.AssertReleaseAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseAddressRequest to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReleaseAddressRequest[k], "ReleaseAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseAddressRequest
-- <p>Contains the parameters for ReleaseAddress.</p>
-- @param _PublicIp [String] <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _AllocationId [String] <p>[EC2-VPC] The allocation ID. Required for EC2-VPC.</p>
function M.ReleaseAddressRequest(_PublicIp, _DryRun, _AllocationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReleaseAddressRequest")
	local t = { 
		["PublicIp"] = _PublicIp,
		["DryRun"] = _DryRun,
		["AllocationId"] = _AllocationId,
	}
	asserts.AssertReleaseAddressRequest(t)
	return t
end

keys.TerminateInstancesResult = { ["TerminatingInstances"] = true, nil }

function asserts.AssertTerminateInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateInstancesResult to be of type 'table'")
	if struct["TerminatingInstances"] then asserts.AssertInstanceStateChangeList(struct["TerminatingInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.TerminateInstancesResult[k], "TerminateInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateInstancesResult
-- <p>Contains the output of TerminateInstances.</p>
-- @param _TerminatingInstances [InstanceStateChangeList] <p>Information about one or more terminated instances.</p>
function M.TerminateInstancesResult(_TerminatingInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TerminateInstancesResult")
	local t = { 
		["TerminatingInstances"] = _TerminatingInstances,
	}
	asserts.AssertTerminateInstancesResult(t)
	return t
end

keys.InstanceMonitoring = { ["InstanceId"] = true, ["Monitoring"] = true, nil }

function asserts.AssertInstanceMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceMonitoring to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Monitoring"] then asserts.AssertMonitoring(struct["Monitoring"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceMonitoring[k], "InstanceMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceMonitoring
-- <p>Describes the monitoring of an instance.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _Monitoring [Monitoring] <p>The monitoring for the instance.</p>
function M.InstanceMonitoring(_InstanceId, _Monitoring, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceMonitoring")
	local t = { 
		["InstanceId"] = _InstanceId,
		["Monitoring"] = _Monitoring,
	}
	asserts.AssertInstanceMonitoring(t)
	return t
end

keys.DescribeRegionsResult = { ["Regions"] = true, nil }

function asserts.AssertDescribeRegionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRegionsResult to be of type 'table'")
	if struct["Regions"] then asserts.AssertRegionList(struct["Regions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRegionsResult[k], "DescribeRegionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRegionsResult
-- <p>Contains the output of DescribeRegions.</p>
-- @param _Regions [RegionList] <p>Information about one or more regions.</p>
function M.DescribeRegionsResult(_Regions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeRegionsResult")
	local t = { 
		["Regions"] = _Regions,
	}
	asserts.AssertDescribeRegionsResult(t)
	return t
end

keys.VpcPeeringConnectionOptionsDescription = { ["AllowEgressFromLocalVpcToRemoteClassicLink"] = true, ["AllowDnsResolutionFromRemoteVpc"] = true, ["AllowEgressFromLocalClassicLinkToRemoteVpc"] = true, nil }

function asserts.AssertVpcPeeringConnectionOptionsDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionOptionsDescription to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then asserts.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then asserts.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then asserts.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnectionOptionsDescription[k], "VpcPeeringConnectionOptionsDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionOptionsDescription
-- <p>Describes the VPC peering connection options.</p>
-- @param _AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.</p>
-- @param _AllowDnsResolutionFromRemoteVpc [Boolean] <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.</p>
-- @param _AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.</p>
function M.VpcPeeringConnectionOptionsDescription(_AllowEgressFromLocalVpcToRemoteClassicLink, _AllowDnsResolutionFromRemoteVpc, _AllowEgressFromLocalClassicLinkToRemoteVpc, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcPeeringConnectionOptionsDescription")
	local t = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = _AllowEgressFromLocalVpcToRemoteClassicLink,
		["AllowDnsResolutionFromRemoteVpc"] = _AllowDnsResolutionFromRemoteVpc,
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = _AllowEgressFromLocalClassicLinkToRemoteVpc,
	}
	asserts.AssertVpcPeeringConnectionOptionsDescription(t)
	return t
end

keys.NatGateway = { ["NatGatewayAddresses"] = true, ["ProvisionedBandwidth"] = true, ["VpcId"] = true, ["State"] = true, ["FailureMessage"] = true, ["FailureCode"] = true, ["NatGatewayId"] = true, ["SubnetId"] = true, ["DeleteTime"] = true, ["CreateTime"] = true, nil }

function asserts.AssertNatGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NatGateway to be of type 'table'")
	if struct["NatGatewayAddresses"] then asserts.AssertNatGatewayAddressList(struct["NatGatewayAddresses"]) end
	if struct["ProvisionedBandwidth"] then asserts.AssertProvisionedBandwidth(struct["ProvisionedBandwidth"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["State"] then asserts.AssertNatGatewayState(struct["State"]) end
	if struct["FailureMessage"] then asserts.AssertString(struct["FailureMessage"]) end
	if struct["FailureCode"] then asserts.AssertString(struct["FailureCode"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteTime"] then asserts.AssertDateTime(struct["DeleteTime"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.NatGateway[k], "NatGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NatGateway
-- <p>Describes a NAT gateway.</p>
-- @param _NatGatewayAddresses [NatGatewayAddressList] <p>Information about the IP addresses and network interface associated with the NAT gateway.</p>
-- @param _ProvisionedBandwidth [ProvisionedBandwidth] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param _VpcId [String] <p>The ID of the VPC in which the NAT gateway is located.</p>
-- @param _State [NatGatewayState] <p>The state of the NAT gateway.</p> <ul> <li> <p> <code>pending</code>: The NAT gateway is being created and is not ready to process traffic.</p> </li> <li> <p> <code>failed</code>: The NAT gateway could not be created. Check the <code>failureCode</code> and <code>failureMessage</code> fields for the reason.</p> </li> <li> <p> <code>available</code>: The NAT gateway is able to process traffic. This status remains until you delete the NAT gateway, and does not indicate the health of the NAT gateway.</p> </li> <li> <p> <code>deleting</code>: The NAT gateway is in the process of being terminated and may still be processing traffic.</p> </li> <li> <p> <code>deleted</code>: The NAT gateway has been terminated and is no longer processing traffic.</p> </li> </ul>
-- @param _FailureMessage [String] <p>If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.</p> <ul> <li> <p>For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free addresses to create this NAT gateway"</p> </li> <li> <p>For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway attached"</p> </li> <li> <p>For InvalidAllocationID.NotFound: "Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway"</p> </li> <li> <p>For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx is already associated"</p> </li> <li> <p>For InternalError: "Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again."</p> </li> <li> <p>For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx does not exist or could not be found."</p> </li> </ul>
-- @param _FailureCode [String] <p>If the NAT gateway could not be created, specifies the error code for the failure. (<code>InsufficientFreeAddressesInSubnet</code> | <code>Gateway.NotAttached</code> | <code>InvalidAllocationID.NotFound</code> | <code>Resource.AlreadyAssociated</code> | <code>InternalError</code> | <code>InvalidSubnetID.NotFound</code>)</p>
-- @param _NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- @param _SubnetId [String] <p>The ID of the subnet in which the NAT gateway is located.</p>
-- @param _DeleteTime [DateTime] <p>The date and time the NAT gateway was deleted, if applicable.</p>
-- @param _CreateTime [DateTime] <p>The date and time the NAT gateway was created.</p>
function M.NatGateway(_NatGatewayAddresses, _ProvisionedBandwidth, _VpcId, _State, _FailureMessage, _FailureCode, _NatGatewayId, _SubnetId, _DeleteTime, _CreateTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NatGateway")
	local t = { 
		["NatGatewayAddresses"] = _NatGatewayAddresses,
		["ProvisionedBandwidth"] = _ProvisionedBandwidth,
		["VpcId"] = _VpcId,
		["State"] = _State,
		["FailureMessage"] = _FailureMessage,
		["FailureCode"] = _FailureCode,
		["NatGatewayId"] = _NatGatewayId,
		["SubnetId"] = _SubnetId,
		["DeleteTime"] = _DeleteTime,
		["CreateTime"] = _CreateTime,
	}
	asserts.AssertNatGateway(t)
	return t
end

keys.DescribeVpnConnectionsRequest = { ["DryRun"] = true, ["VpnConnectionIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpnConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnConnectionsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnConnectionIds"] then asserts.AssertVpnConnectionIdStringList(struct["VpnConnectionIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnConnectionsRequest[k], "DescribeVpnConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnConnectionsRequest
-- <p>Contains the parameters for DescribeVpnConnections.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VpnConnectionIds [VpnConnectionIdStringList] <p>One or more VPN connection IDs.</p> <p>Default: Describes your VPN connections.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>customer-gateway-configuration</code> - The configuration information for the customer gateway.</p> </li> <li> <p> <code>customer-gateway-id</code> - The ID of a customer gateway associated with the VPN connection.</p> </li> <li> <p> <code>state</code> - The state of the VPN connection (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>option.static-routes-only</code> - Indicates whether the connection has static routes only. Used for devices that do not support Border Gateway Protocol (BGP).</p> </li> <li> <p> <code>route.destination-cidr-block</code> - The destination CIDR block. This corresponds to the subnet used in a customer data center.</p> </li> <li> <p> <code>bgp-asn</code> - The BGP Autonomous System Number (ASN) associated with a BGP device.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>type</code> - The type of VPN connection. Currently the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>vpn-connection-id</code> - The ID of the VPN connection.</p> </li> <li> <p> <code>vpn-gateway-id</code> - The ID of a virtual private gateway associated with the VPN connection.</p> </li> </ul>
function M.DescribeVpnConnectionsRequest(_DryRun, _VpnConnectionIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpnConnectionsRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["VpnConnectionIds"] = _VpnConnectionIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeVpnConnectionsRequest(t)
	return t
end

keys.SpotDatafeedSubscription = { ["Fault"] = true, ["Prefix"] = true, ["Bucket"] = true, ["State"] = true, ["OwnerId"] = true, nil }

function asserts.AssertSpotDatafeedSubscription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotDatafeedSubscription to be of type 'table'")
	if struct["Fault"] then asserts.AssertSpotInstanceStateFault(struct["Fault"]) end
	if struct["Prefix"] then asserts.AssertString(struct["Prefix"]) end
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	if struct["State"] then asserts.AssertDatafeedSubscriptionState(struct["State"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotDatafeedSubscription[k], "SpotDatafeedSubscription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotDatafeedSubscription
-- <p>Describes the data feed for a Spot instance.</p>
-- @param _Fault [SpotInstanceStateFault] <p>The fault codes for the Spot instance request, if any.</p>
-- @param _Prefix [String] <p>The prefix that is prepended to data feed files.</p>
-- @param _Bucket [String] <p>The Amazon S3 bucket where the Spot instance data feed is located.</p>
-- @param _State [DatafeedSubscriptionState] <p>The state of the Spot instance data feed subscription.</p>
-- @param _OwnerId [String] <p>The AWS account ID of the account.</p>
function M.SpotDatafeedSubscription(_Fault, _Prefix, _Bucket, _State, _OwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotDatafeedSubscription")
	local t = { 
		["Fault"] = _Fault,
		["Prefix"] = _Prefix,
		["Bucket"] = _Bucket,
		["State"] = _State,
		["OwnerId"] = _OwnerId,
	}
	asserts.AssertSpotDatafeedSubscription(t)
	return t
end

keys.StorageLocation = { ["Bucket"] = true, ["Key"] = true, nil }

function asserts.AssertStorageLocation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StorageLocation to be of type 'table'")
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.StorageLocation[k], "StorageLocation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StorageLocation
-- <p>Describes a storage location in Amazon S3.</p>
-- @param _Bucket [String] <p>The name of the S3 bucket.</p>
-- @param _Key [String] <p>The key.</p>
function M.StorageLocation(_Bucket, _Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StorageLocation")
	local t = { 
		["Bucket"] = _Bucket,
		["Key"] = _Key,
	}
	asserts.AssertStorageLocation(t)
	return t
end

keys.ModifyHostsResult = { ["Successful"] = true, ["Unsuccessful"] = true, nil }

function asserts.AssertModifyHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyHostsResult to be of type 'table'")
	if struct["Successful"] then asserts.AssertResponseHostIdList(struct["Successful"]) end
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemList(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyHostsResult[k], "ModifyHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyHostsResult
-- <p>Contains the output of ModifyHosts.</p>
-- @param _Successful [ResponseHostIdList] <p>The IDs of the Dedicated Hosts that were successfully modified.</p>
-- @param _Unsuccessful [UnsuccessfulItemList] <p>The IDs of the Dedicated Hosts that could not be modified. Check whether the setting you requested can be used.</p>
function M.ModifyHostsResult(_Successful, _Unsuccessful, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyHostsResult")
	local t = { 
		["Successful"] = _Successful,
		["Unsuccessful"] = _Unsuccessful,
	}
	asserts.AssertModifyHostsResult(t)
	return t
end

keys.CreateInternetGatewayRequest = { ["DryRun"] = true, nil }

function asserts.AssertCreateInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInternetGatewayRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInternetGatewayRequest[k], "CreateInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInternetGatewayRequest
-- <p>Contains the parameters for CreateInternetGateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.CreateInternetGatewayRequest(_DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateInternetGatewayRequest")
	local t = { 
		["DryRun"] = _DryRun,
	}
	asserts.AssertCreateInternetGatewayRequest(t)
	return t
end

keys.DescribeNetworkInterfacesResult = { ["NetworkInterfaces"] = true, nil }

function asserts.AssertDescribeNetworkInterfacesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacesResult to be of type 'table'")
	if struct["NetworkInterfaces"] then asserts.AssertNetworkInterfaceList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfacesResult[k], "DescribeNetworkInterfacesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacesResult
-- <p>Contains the output of DescribeNetworkInterfaces.</p>
-- @param _NetworkInterfaces [NetworkInterfaceList] <p>Information about one or more network interfaces.</p>
function M.DescribeNetworkInterfacesResult(_NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkInterfacesResult")
	local t = { 
		["NetworkInterfaces"] = _NetworkInterfaces,
	}
	asserts.AssertDescribeNetworkInterfacesResult(t)
	return t
end

keys.InstanceNetworkInterfaceAssociation = { ["PublicIp"] = true, ["PublicDnsName"] = true, ["IpOwnerId"] = true, nil }

function asserts.AssertInstanceNetworkInterfaceAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceAssociation to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["PublicDnsName"] then asserts.AssertString(struct["PublicDnsName"]) end
	if struct["IpOwnerId"] then asserts.AssertString(struct["IpOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterfaceAssociation[k], "InstanceNetworkInterfaceAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceAssociation
-- <p>Describes association information for an Elastic IP address (IPv4).</p>
-- @param _PublicIp [String] <p>The public IP address or Elastic IP address bound to the network interface.</p>
-- @param _PublicDnsName [String] <p>The public DNS name.</p>
-- @param _IpOwnerId [String] <p>The ID of the owner of the Elastic IP address.</p>
function M.InstanceNetworkInterfaceAssociation(_PublicIp, _PublicDnsName, _IpOwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceNetworkInterfaceAssociation")
	local t = { 
		["PublicIp"] = _PublicIp,
		["PublicDnsName"] = _PublicDnsName,
		["IpOwnerId"] = _IpOwnerId,
	}
	asserts.AssertInstanceNetworkInterfaceAssociation(t)
	return t
end

keys.InstanceExportDetails = { ["InstanceId"] = true, ["TargetEnvironment"] = true, nil }

function asserts.AssertInstanceExportDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceExportDetails to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["TargetEnvironment"] then asserts.AssertExportEnvironment(struct["TargetEnvironment"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceExportDetails[k], "InstanceExportDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceExportDetails
-- <p>Describes an instance to export.</p>
-- @param _InstanceId [String] <p>The ID of the resource being exported.</p>
-- @param _TargetEnvironment [ExportEnvironment] <p>The target virtualization environment.</p>
function M.InstanceExportDetails(_InstanceId, _TargetEnvironment, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceExportDetails")
	local t = { 
		["InstanceId"] = _InstanceId,
		["TargetEnvironment"] = _TargetEnvironment,
	}
	asserts.AssertInstanceExportDetails(t)
	return t
end

keys.VpcClassicLink = { ["ClassicLinkEnabled"] = true, ["VpcId"] = true, ["Tags"] = true, nil }

function asserts.AssertVpcClassicLink(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcClassicLink to be of type 'table'")
	if struct["ClassicLinkEnabled"] then asserts.AssertBoolean(struct["ClassicLinkEnabled"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcClassicLink[k], "VpcClassicLink contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcClassicLink
-- <p>Describes whether a VPC is enabled for ClassicLink.</p>
-- @param _ClassicLinkEnabled [Boolean] <p>Indicates whether the VPC is enabled for ClassicLink.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the VPC.</p>
function M.VpcClassicLink(_ClassicLinkEnabled, _VpcId, _Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcClassicLink")
	local t = { 
		["ClassicLinkEnabled"] = _ClassicLinkEnabled,
		["VpcId"] = _VpcId,
		["Tags"] = _Tags,
	}
	asserts.AssertVpcClassicLink(t)
	return t
end

keys.NetworkInterfaceIpv6Address = { ["Ipv6Address"] = true, nil }

function asserts.AssertNetworkInterfaceIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertString(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceIpv6Address[k], "NetworkInterfaceIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceIpv6Address
-- <p>Describes an IPv6 address associated with a network interface.</p>
-- @param _Ipv6Address [String] <p>The IPv6 address.</p>
function M.NetworkInterfaceIpv6Address(_Ipv6Address, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfaceIpv6Address")
	local t = { 
		["Ipv6Address"] = _Ipv6Address,
	}
	asserts.AssertNetworkInterfaceIpv6Address(t)
	return t
end

keys.DisableVpcClassicLinkRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDisableVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkRequest[k], "DisableVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkRequest
-- <p>Contains the parameters for DisableVpcClassicLink.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.DisableVpcClassicLinkRequest(_VpcId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisableVpcClassicLinkRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDisableVpcClassicLinkRequest(t)
	return t
end

keys.SpotFleetRequestConfigData = { ["Type"] = true, ["FulfilledCapacity"] = true, ["TerminateInstancesWithExpiration"] = true, ["LaunchSpecifications"] = true, ["IamFleetRole"] = true, ["ValidUntil"] = true, ["ClientToken"] = true, ["TargetCapacity"] = true, ["ValidFrom"] = true, ["ExcessCapacityTerminationPolicy"] = true, ["ReplaceUnhealthyInstances"] = true, ["SpotPrice"] = true, ["AllocationStrategy"] = true, nil }

function asserts.AssertSpotFleetRequestConfigData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetRequestConfigData to be of type 'table'")
	assert(struct["IamFleetRole"], "Expected key IamFleetRole to exist in table")
	assert(struct["LaunchSpecifications"], "Expected key LaunchSpecifications to exist in table")
	assert(struct["SpotPrice"], "Expected key SpotPrice to exist in table")
	assert(struct["TargetCapacity"], "Expected key TargetCapacity to exist in table")
	if struct["Type"] then asserts.AssertFleetType(struct["Type"]) end
	if struct["FulfilledCapacity"] then asserts.AssertDouble(struct["FulfilledCapacity"]) end
	if struct["TerminateInstancesWithExpiration"] then asserts.AssertBoolean(struct["TerminateInstancesWithExpiration"]) end
	if struct["LaunchSpecifications"] then asserts.AssertLaunchSpecsList(struct["LaunchSpecifications"]) end
	if struct["IamFleetRole"] then asserts.AssertString(struct["IamFleetRole"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["TargetCapacity"] then asserts.AssertInteger(struct["TargetCapacity"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["ExcessCapacityTerminationPolicy"] then asserts.AssertExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	if struct["ReplaceUnhealthyInstances"] then asserts.AssertBoolean(struct["ReplaceUnhealthyInstances"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	if struct["AllocationStrategy"] then asserts.AssertAllocationStrategy(struct["AllocationStrategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetRequestConfigData[k], "SpotFleetRequestConfigData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetRequestConfigData
-- <p>Describes the configuration of a Spot fleet request.</p>
-- @param _Type [FleetType] <p>The type of request. Indicates whether the fleet will only <code>request</code> the target capacity or also attempt to <code>maintain</code> it. When you <code>request</code> a certain target capacity, the fleet will only place the required bids. It will not attempt to replenish Spot instances if capacity is diminished, nor will it submit bids in alternative Spot pools if capacity is not available. When you want to <code>maintain</code> a certain target capacity, fleet will place the required bids to meet this target capacity. It will also automatically replenish any interrupted instances. Default: <code>maintain</code>.</p>
-- @param _FulfilledCapacity [Double] <p>The number of units fulfilled by this request compared to the set target capacity.</p>
-- @param _TerminateInstancesWithExpiration [Boolean] <p>Indicates whether running Spot instances should be terminated when the Spot fleet request expires.</p>
-- @param _LaunchSpecifications [LaunchSpecsList] <p>Information about the launch specifications for the Spot fleet request.</p>
-- @param _IamFleetRole [String] <p>Grants the Spot fleet permission to terminate Spot instances on your behalf when you cancel its Spot fleet request using <a>CancelSpotFleetRequests</a> or when the Spot fleet request expires, if you set <code>terminateInstancesWithExpiration</code>.</p>
-- @param _ValidUntil [DateTime] <p>The end date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). At this point, no new Spot instance requests are placed or enabled to fulfill the request.</p>
-- @param _ClientToken [String] <p>A unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- @param _TargetCapacity [Integer] <p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O.</p>
-- @param _ValidFrom [DateTime] <p>The start date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The default is to start fulfilling the request immediately.</p>
-- @param _ExcessCapacityTerminationPolicy [ExcessCapacityTerminationPolicy] <p>Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.</p>
-- @param _ReplaceUnhealthyInstances [Boolean] <p>Indicates whether Spot fleet should replace unhealthy instances.</p>
-- @param _SpotPrice [String] <p>The bid price per unit hour.</p>
-- @param _AllocationStrategy [AllocationStrategy] <p>Indicates how to allocate the target capacity across the Spot pools specified by the Spot fleet request. The default is <code>lowestPrice</code>.</p>
-- Required parameter: IamFleetRole
-- Required parameter: LaunchSpecifications
-- Required parameter: SpotPrice
-- Required parameter: TargetCapacity
function M.SpotFleetRequestConfigData(_Type, _FulfilledCapacity, _TerminateInstancesWithExpiration, _LaunchSpecifications, _IamFleetRole, _ValidUntil, _ClientToken, _TargetCapacity, _ValidFrom, _ExcessCapacityTerminationPolicy, _ReplaceUnhealthyInstances, _SpotPrice, _AllocationStrategy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotFleetRequestConfigData")
	local t = { 
		["Type"] = _Type,
		["FulfilledCapacity"] = _FulfilledCapacity,
		["TerminateInstancesWithExpiration"] = _TerminateInstancesWithExpiration,
		["LaunchSpecifications"] = _LaunchSpecifications,
		["IamFleetRole"] = _IamFleetRole,
		["ValidUntil"] = _ValidUntil,
		["ClientToken"] = _ClientToken,
		["TargetCapacity"] = _TargetCapacity,
		["ValidFrom"] = _ValidFrom,
		["ExcessCapacityTerminationPolicy"] = _ExcessCapacityTerminationPolicy,
		["ReplaceUnhealthyInstances"] = _ReplaceUnhealthyInstances,
		["SpotPrice"] = _SpotPrice,
		["AllocationStrategy"] = _AllocationStrategy,
	}
	asserts.AssertSpotFleetRequestConfigData(t)
	return t
end

keys.VolumeStatusItem = { ["VolumeStatus"] = true, ["AvailabilityZone"] = true, ["Events"] = true, ["Actions"] = true, ["VolumeId"] = true, nil }

function asserts.AssertVolumeStatusItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusItem to be of type 'table'")
	if struct["VolumeStatus"] then asserts.AssertVolumeStatusInfo(struct["VolumeStatus"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Events"] then asserts.AssertVolumeStatusEventsList(struct["Events"]) end
	if struct["Actions"] then asserts.AssertVolumeStatusActionsList(struct["Actions"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusItem[k], "VolumeStatusItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusItem
-- <p>Describes the volume status.</p>
-- @param _VolumeStatus [VolumeStatusInfo] <p>The volume status.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone of the volume.</p>
-- @param _Events [VolumeStatusEventsList] <p>A list of events associated with the volume.</p>
-- @param _Actions [VolumeStatusActionsList] <p>The details of the operation.</p>
-- @param _VolumeId [String] <p>The volume ID.</p>
function M.VolumeStatusItem(_VolumeStatus, _AvailabilityZone, _Events, _Actions, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusItem")
	local t = { 
		["VolumeStatus"] = _VolumeStatus,
		["AvailabilityZone"] = _AvailabilityZone,
		["Events"] = _Events,
		["Actions"] = _Actions,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertVolumeStatusItem(t)
	return t
end

keys.DescribeVpnGatewaysRequest = { ["DryRun"] = true, ["VpnGatewayIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpnGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnGatewaysRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayIds"] then asserts.AssertVpnGatewayIdStringList(struct["VpnGatewayIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnGatewaysRequest[k], "DescribeVpnGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnGatewaysRequest
-- <p>Contains the parameters for DescribeVpnGateways.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VpnGatewayIds [VpnGatewayIdStringList] <p>One or more virtual private gateway IDs.</p> <p>Default: Describes all your virtual private gateways.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.state</code> - The current state of the attachment between the gateway and the VPC (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>attachment.vpc-id</code> - The ID of an attached VPC.</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone for the virtual private gateway (if applicable).</p> </li> <li> <p> <code>state</code> - The state of the virtual private gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>type</code> - The type of virtual private gateway. Currently the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>vpn-gateway-id</code> - The ID of the virtual private gateway.</p> </li> </ul>
function M.DescribeVpnGatewaysRequest(_DryRun, _VpnGatewayIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpnGatewaysRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["VpnGatewayIds"] = _VpnGatewayIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeVpnGatewaysRequest(t)
	return t
end

keys.DescribeVpcAttributeResult = { ["EnableDnsSupport"] = true, ["VpcId"] = true, ["EnableDnsHostnames"] = true, nil }

function asserts.AssertDescribeVpcAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcAttributeResult to be of type 'table'")
	if struct["EnableDnsSupport"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsSupport"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["EnableDnsHostnames"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsHostnames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcAttributeResult[k], "DescribeVpcAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcAttributeResult
-- <p>Contains the output of DescribeVpcAttribute.</p>
-- @param _EnableDnsSupport [AttributeBooleanValue] <p>Indicates whether DNS resolution is enabled for the VPC. If this attribute is <code>true</code>, the Amazon DNS server resolves DNS hostnames for your instances to their corresponding IP addresses; otherwise, it does not.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _EnableDnsHostnames [AttributeBooleanValue] <p>Indicates whether the instances launched in the VPC get DNS hostnames. If this attribute is <code>true</code>, instances in the VPC get DNS hostnames; otherwise, they do not.</p>
function M.DescribeVpcAttributeResult(_EnableDnsSupport, _VpcId, _EnableDnsHostnames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcAttributeResult")
	local t = { 
		["EnableDnsSupport"] = _EnableDnsSupport,
		["VpcId"] = _VpcId,
		["EnableDnsHostnames"] = _EnableDnsHostnames,
	}
	asserts.AssertDescribeVpcAttributeResult(t)
	return t
end

keys.InstanceNetworkInterface = { ["Status"] = true, ["MacAddress"] = true, ["SourceDestCheck"] = true, ["VpcId"] = true, ["Description"] = true, ["NetworkInterfaceId"] = true, ["PrivateIpAddresses"] = true, ["PrivateDnsName"] = true, ["Attachment"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["OwnerId"] = true, ["PrivateIpAddress"] = true, ["SubnetId"] = true, ["Association"] = true, nil }

function asserts.AssertInstanceNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterface to be of type 'table'")
	if struct["Status"] then asserts.AssertNetworkInterfaceStatus(struct["Status"]) end
	if struct["MacAddress"] then asserts.AssertString(struct["MacAddress"]) end
	if struct["SourceDestCheck"] then asserts.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertInstancePrivateIpAddressList(struct["PrivateIpAddresses"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["Attachment"] then asserts.AssertInstanceNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Association"] then asserts.AssertInstanceNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterface[k], "InstanceNetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterface
-- <p>Describes a network interface.</p>
-- @param _Status [NetworkInterfaceStatus] <p>The status of the network interface.</p>
-- @param _MacAddress [String] <p>The MAC address.</p>
-- @param _SourceDestCheck [Boolean] <p>Indicates whether to validate network traffic to or from this network interface.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _Description [String] <p>The description.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _PrivateIpAddresses [InstancePrivateIpAddressList] <p>One or more private IPv4 addresses associated with the network interface.</p>
-- @param _PrivateDnsName [String] <p>The private DNS name.</p>
-- @param _Attachment [InstanceNetworkInterfaceAttachment] <p>The network interface attachment.</p>
-- @param _Groups [GroupIdentifierList] <p>One or more security groups.</p>
-- @param _Ipv6Addresses [InstanceIpv6AddressList] <p>One or more IPv6 addresses associated with the network interface.</p>
-- @param _OwnerId [String] <p>The ID of the AWS account that created the network interface.</p>
-- @param _PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _Association [InstanceNetworkInterfaceAssociation] <p>The association information for an Elastic IPv4 associated with the network interface.</p>
function M.InstanceNetworkInterface(_Status, _MacAddress, _SourceDestCheck, _VpcId, _Description, _NetworkInterfaceId, _PrivateIpAddresses, _PrivateDnsName, _Attachment, _Groups, _Ipv6Addresses, _OwnerId, _PrivateIpAddress, _SubnetId, _Association, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceNetworkInterface")
	local t = { 
		["Status"] = _Status,
		["MacAddress"] = _MacAddress,
		["SourceDestCheck"] = _SourceDestCheck,
		["VpcId"] = _VpcId,
		["Description"] = _Description,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["PrivateIpAddresses"] = _PrivateIpAddresses,
		["PrivateDnsName"] = _PrivateDnsName,
		["Attachment"] = _Attachment,
		["Groups"] = _Groups,
		["Ipv6Addresses"] = _Ipv6Addresses,
		["OwnerId"] = _OwnerId,
		["PrivateIpAddress"] = _PrivateIpAddress,
		["SubnetId"] = _SubnetId,
		["Association"] = _Association,
	}
	asserts.AssertInstanceNetworkInterface(t)
	return t
end

keys.DescribeExportTasksRequest = { ["ExportTaskIds"] = true, nil }

function asserts.AssertDescribeExportTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeExportTasksRequest to be of type 'table'")
	if struct["ExportTaskIds"] then asserts.AssertExportTaskIdStringList(struct["ExportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeExportTasksRequest[k], "DescribeExportTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeExportTasksRequest
-- <p>Contains the parameters for DescribeExportTasks.</p>
-- @param _ExportTaskIds [ExportTaskIdStringList] <p>One or more export task IDs.</p>
function M.DescribeExportTasksRequest(_ExportTaskIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeExportTasksRequest")
	local t = { 
		["ExportTaskIds"] = _ExportTaskIds,
	}
	asserts.AssertDescribeExportTasksRequest(t)
	return t
end

keys.CreateKeyPairRequest = { ["KeyName"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateKeyPairRequest[k], "CreateKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateKeyPairRequest
-- <p>Contains the parameters for CreateKeyPair.</p>
-- @param _KeyName [String] <p>A unique name for the key pair.</p> <p>Constraints: Up to 255 ASCII characters</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: KeyName
function M.CreateKeyPairRequest(_KeyName, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateKeyPairRequest")
	local t = { 
		["KeyName"] = _KeyName,
		["DryRun"] = _DryRun,
	}
	asserts.AssertCreateKeyPairRequest(t)
	return t
end

keys.DeleteVolumeRequest = { ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDeleteVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVolumeRequest[k], "DeleteVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVolumeRequest
-- <p>Contains the parameters for DeleteVolume.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.DeleteVolumeRequest(_DryRun, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVolumeRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertDeleteVolumeRequest(t)
	return t
end

keys.PurchaseScheduledInstancesRequest = { ["PurchaseRequests"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertPurchaseScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseScheduledInstancesRequest to be of type 'table'")
	assert(struct["PurchaseRequests"], "Expected key PurchaseRequests to exist in table")
	if struct["PurchaseRequests"] then asserts.AssertPurchaseRequestSet(struct["PurchaseRequests"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseScheduledInstancesRequest[k], "PurchaseScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseScheduledInstancesRequest
-- <p>Contains the parameters for PurchaseScheduledInstances.</p>
-- @param _PurchaseRequests [PurchaseRequestSet] <p>One or more purchase requests.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required parameter: PurchaseRequests
function M.PurchaseScheduledInstancesRequest(_PurchaseRequests, _DryRun, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseScheduledInstancesRequest")
	local t = { 
		["PurchaseRequests"] = _PurchaseRequests,
		["DryRun"] = _DryRun,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertPurchaseScheduledInstancesRequest(t)
	return t
end

keys.DescribeImportSnapshotTasksRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["ImportTaskIds"] = true, nil }

function asserts.AssertDescribeImportSnapshotTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportSnapshotTasksRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ImportTaskIds"] then asserts.AssertImportTaskIdList(struct["ImportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportSnapshotTasksRequest[k], "DescribeImportSnapshotTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportSnapshotTasksRequest
-- <p>Contains the parameters for DescribeImportSnapshotTasks.</p>
-- @param _NextToken [String] <p>A token that indicates the next page of results.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p>
-- @param _ImportTaskIds [ImportTaskIdList] <p>A list of import snapshot task IDs.</p>
function M.DescribeImportSnapshotTasksRequest(_NextToken, _DryRun, _MaxResults, _Filters, _ImportTaskIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImportSnapshotTasksRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
		["ImportTaskIds"] = _ImportTaskIds,
	}
	asserts.AssertDescribeImportSnapshotTasksRequest(t)
	return t
end

keys.CreateEgressOnlyInternetGatewayResult = { ["EgressOnlyInternetGateway"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateEgressOnlyInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateEgressOnlyInternetGatewayResult to be of type 'table'")
	if struct["EgressOnlyInternetGateway"] then asserts.AssertEgressOnlyInternetGateway(struct["EgressOnlyInternetGateway"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateEgressOnlyInternetGatewayResult[k], "CreateEgressOnlyInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateEgressOnlyInternetGatewayResult
--  
-- @param _EgressOnlyInternetGateway [EgressOnlyInternetGateway] <p>Information about the egress-only Internet gateway.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
function M.CreateEgressOnlyInternetGatewayResult(_EgressOnlyInternetGateway, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateEgressOnlyInternetGatewayResult")
	local t = { 
		["EgressOnlyInternetGateway"] = _EgressOnlyInternetGateway,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertCreateEgressOnlyInternetGatewayResult(t)
	return t
end

keys.DescribeClassicLinkInstancesResult = { ["Instances"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeClassicLinkInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeClassicLinkInstancesResult to be of type 'table'")
	if struct["Instances"] then asserts.AssertClassicLinkInstanceList(struct["Instances"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeClassicLinkInstancesResult[k], "DescribeClassicLinkInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeClassicLinkInstancesResult
-- <p>Contains the output of DescribeClassicLinkInstances.</p>
-- @param _Instances [ClassicLinkInstanceList] <p>Information about one or more linked EC2-Classic instances.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeClassicLinkInstancesResult(_Instances, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeClassicLinkInstancesResult")
	local t = { 
		["Instances"] = _Instances,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeClassicLinkInstancesResult(t)
	return t
end

keys.CopyImageRequest = { ["SourceRegion"] = true, ["DryRun"] = true, ["Name"] = true, ["Encrypted"] = true, ["SourceImageId"] = true, ["KmsKeyId"] = true, ["ClientToken"] = true, ["Description"] = true, nil }

function asserts.AssertCopyImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyImageRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["SourceImageId"], "Expected key SourceImageId to exist in table")
	assert(struct["SourceRegion"], "Expected key SourceRegion to exist in table")
	if struct["SourceRegion"] then asserts.AssertString(struct["SourceRegion"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["SourceImageId"] then asserts.AssertString(struct["SourceImageId"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopyImageRequest[k], "CopyImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyImageRequest
-- <p>Contains the parameters for CopyImage.</p>
-- @param _SourceRegion [String] <p>The name of the region that contains the AMI to copy.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Name [String] <p>The name of the new AMI in the destination region.</p>
-- @param _Encrypted [Boolean] <p>Specifies whether the destination snapshots of the copied image should be encrypted. The default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with <code>KmsKeyId</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param _SourceImageId [String] <p>The ID of the AMI to copy.</p>
-- @param _KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when encrypting the snapshots of an image during a copy operation. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. The specified CMK must exist in the region that the snapshot is being copied to. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param _Description [String] <p>A description for the new AMI in the destination region.</p>
-- Required parameter: Name
-- Required parameter: SourceImageId
-- Required parameter: SourceRegion
function M.CopyImageRequest(_SourceRegion, _DryRun, _Name, _Encrypted, _SourceImageId, _KmsKeyId, _ClientToken, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CopyImageRequest")
	local t = { 
		["SourceRegion"] = _SourceRegion,
		["DryRun"] = _DryRun,
		["Name"] = _Name,
		["Encrypted"] = _Encrypted,
		["SourceImageId"] = _SourceImageId,
		["KmsKeyId"] = _KmsKeyId,
		["ClientToken"] = _ClientToken,
		["Description"] = _Description,
	}
	asserts.AssertCopyImageRequest(t)
	return t
end

keys.CreateNetworkAclRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateNetworkAclRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkAclRequest[k], "CreateNetworkAclRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclRequest
-- <p>Contains the parameters for CreateNetworkAcl.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.CreateNetworkAclRequest(_VpcId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkAclRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertCreateNetworkAclRequest(t)
	return t
end

keys.DisassociateRouteTableRequest = { ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDisassociateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateRouteTableRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateRouteTableRequest[k], "DisassociateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateRouteTableRequest
-- <p>Contains the parameters for DisassociateRouteTable.</p>
-- @param _AssociationId [String] <p>The association ID representing the current association between the route table and subnet.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: AssociationId
function M.DisassociateRouteTableRequest(_AssociationId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateRouteTableRequest")
	local t = { 
		["AssociationId"] = _AssociationId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDisassociateRouteTableRequest(t)
	return t
end

keys.DescribeAddressesRequest = { ["PublicIps"] = true, ["DryRun"] = true, ["AllocationIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAddressesRequest to be of type 'table'")
	if struct["PublicIps"] then asserts.AssertPublicIpStringList(struct["PublicIps"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AllocationIds"] then asserts.AssertAllocationIdList(struct["AllocationIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAddressesRequest[k], "DescribeAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAddressesRequest
-- <p>Contains the parameters for DescribeAddresses.</p>
-- @param _PublicIps [PublicIpStringList] <p>[EC2-Classic] One or more Elastic IP addresses.</p> <p>Default: Describes all your Elastic IP addresses.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _AllocationIds [AllocationIdList] <p>[EC2-VPC] One or more allocation IDs.</p> <p>Default: Describes all your Elastic IP addresses.</p>
-- @param _Filters [FilterList] <p>One or more filters. Filter names and values are case-sensitive.</p> <ul> <li> <p> <code>allocation-id</code> - [EC2-VPC] The allocation ID for the address.</p> </li> <li> <p> <code>association-id</code> - [EC2-VPC] The association ID for the address.</p> </li> <li> <p> <code>domain</code> - Indicates whether the address is for use in EC2-Classic (<code>standard</code>) or in a VPC (<code>vpc</code>).</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance the address is associated with, if any.</p> </li> <li> <p> <code>network-interface-id</code> - [EC2-VPC] The ID of the network interface that the address is associated with, if any.</p> </li> <li> <p> <code>network-interface-owner-id</code> - The AWS account ID of the owner.</p> </li> <li> <p> <code>private-ip-address</code> - [EC2-VPC] The private IP address associated with the Elastic IP address.</p> </li> <li> <p> <code>public-ip</code> - The Elastic IP address.</p> </li> </ul>
function M.DescribeAddressesRequest(_PublicIps, _DryRun, _AllocationIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAddressesRequest")
	local t = { 
		["PublicIps"] = _PublicIps,
		["DryRun"] = _DryRun,
		["AllocationIds"] = _AllocationIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeAddressesRequest(t)
	return t
end

keys.AllocateAddressResult = { ["PublicIp"] = true, ["Domain"] = true, ["AllocationId"] = true, nil }

function asserts.AssertAllocateAddressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateAddressResult to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["Domain"] then asserts.AssertDomainType(struct["Domain"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateAddressResult[k], "AllocateAddressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateAddressResult
-- <p>Contains the output of AllocateAddress.</p>
-- @param _PublicIp [String] <p>The Elastic IP address.</p>
-- @param _Domain [DomainType] <p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
-- @param _AllocationId [String] <p>[EC2-VPC] The ID that AWS assigns to represent the allocation of the Elastic IP address for use with instances in a VPC.</p>
function M.AllocateAddressResult(_PublicIp, _Domain, _AllocationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AllocateAddressResult")
	local t = { 
		["PublicIp"] = _PublicIp,
		["Domain"] = _Domain,
		["AllocationId"] = _AllocationId,
	}
	asserts.AssertAllocateAddressResult(t)
	return t
end

keys.FpgaImageState = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertFpgaImageState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FpgaImageState to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertFpgaImageStateCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.FpgaImageState[k], "FpgaImageState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FpgaImageState
-- <p>Describes the state of the bitstream generation process for an Amazon FPGA image (AFI).</p>
-- @param _Message [String] <p>If the state is <code>failed</code>, this is the error message.</p>
-- @param _Code [FpgaImageStateCode] <p>The state. The following are the possible values:</p> <ul> <li> <p> <code>pending</code> - AFI bitstream generation is in progress.</p> </li> <li> <p> <code>available</code> - The AFI is available for use.</p> </li> <li> <p> <code>failed</code> - AFI bitstream generation failed.</p> </li> <li> <p> <code>unavailable</code> - The AFI is no longer available for use.</p> </li> </ul>
function M.FpgaImageState(_Message, _Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating FpgaImageState")
	local t = { 
		["Message"] = _Message,
		["Code"] = _Code,
	}
	asserts.AssertFpgaImageState(t)
	return t
end

keys.DescribeNetworkInterfaceAttributeRequest = { ["Attribute"] = true, ["NetworkInterfaceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Attribute"] then asserts.AssertNetworkInterfaceAttribute(struct["Attribute"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfaceAttributeRequest[k], "DescribeNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for DescribeNetworkInterfaceAttribute.</p>
-- @param _Attribute [NetworkInterfaceAttribute] <p>The attribute of the network interface. This parameter is required.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: NetworkInterfaceId
function M.DescribeNetworkInterfaceAttributeRequest(_Attribute, _NetworkInterfaceId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkInterfaceAttributeRequest")
	local t = { 
		["Attribute"] = _Attribute,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDescribeNetworkInterfaceAttributeRequest(t)
	return t
end

keys.DescribeSpotDatafeedSubscriptionRequest = { ["DryRun"] = true, nil }

function asserts.AssertDescribeSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotDatafeedSubscriptionRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotDatafeedSubscriptionRequest[k], "DescribeSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for DescribeSpotDatafeedSubscription.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.DescribeSpotDatafeedSubscriptionRequest(_DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotDatafeedSubscriptionRequest")
	local t = { 
		["DryRun"] = _DryRun,
	}
	asserts.AssertDescribeSpotDatafeedSubscriptionRequest(t)
	return t
end

keys.ReplaceNetworkAclAssociationRequest = { ["NetworkAclId"] = true, ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertReplaceNetworkAclAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclAssociationRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceNetworkAclAssociationRequest[k], "ReplaceNetworkAclAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclAssociationRequest
-- <p>Contains the parameters for ReplaceNetworkAclAssociation.</p>
-- @param _NetworkAclId [String] <p>The ID of the new network ACL to associate with the subnet.</p>
-- @param _AssociationId [String] <p>The ID of the current association between the original network ACL and the subnet.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: AssociationId
-- Required parameter: NetworkAclId
function M.ReplaceNetworkAclAssociationRequest(_NetworkAclId, _AssociationId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceNetworkAclAssociationRequest")
	local t = { 
		["NetworkAclId"] = _NetworkAclId,
		["AssociationId"] = _AssociationId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertReplaceNetworkAclAssociationRequest(t)
	return t
end

keys.DeleteNetworkAclEntryRequest = { ["NetworkAclId"] = true, ["Egress"] = true, ["DryRun"] = true, ["RuleNumber"] = true, nil }

function asserts.AssertDeleteNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkAclEntryRequest[k], "DeleteNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkAclEntryRequest
-- <p>Contains the parameters for DeleteNetworkAclEntry.</p>
-- @param _NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param _Egress [Boolean] <p>Indicates whether the rule is an egress rule.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _RuleNumber [Integer] <p>The rule number of the entry to delete.</p>
-- Required parameter: Egress
-- Required parameter: NetworkAclId
-- Required parameter: RuleNumber
function M.DeleteNetworkAclEntryRequest(_NetworkAclId, _Egress, _DryRun, _RuleNumber, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNetworkAclEntryRequest")
	local t = { 
		["NetworkAclId"] = _NetworkAclId,
		["Egress"] = _Egress,
		["DryRun"] = _DryRun,
		["RuleNumber"] = _RuleNumber,
	}
	asserts.AssertDeleteNetworkAclEntryRequest(t)
	return t
end

keys.DeleteSpotDatafeedSubscriptionRequest = { ["DryRun"] = true, nil }

function asserts.AssertDeleteSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSpotDatafeedSubscriptionRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSpotDatafeedSubscriptionRequest[k], "DeleteSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for DeleteSpotDatafeedSubscription.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.DeleteSpotDatafeedSubscriptionRequest(_DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteSpotDatafeedSubscriptionRequest")
	local t = { 
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteSpotDatafeedSubscriptionRequest(t)
	return t
end

keys.DescribeBundleTasksResult = { ["BundleTasks"] = true, nil }

function asserts.AssertDescribeBundleTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeBundleTasksResult to be of type 'table'")
	if struct["BundleTasks"] then asserts.AssertBundleTaskList(struct["BundleTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeBundleTasksResult[k], "DescribeBundleTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeBundleTasksResult
-- <p>Contains the output of DescribeBundleTasks.</p>
-- @param _BundleTasks [BundleTaskList] <p>Information about one or more bundle tasks.</p>
function M.DescribeBundleTasksResult(_BundleTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeBundleTasksResult")
	local t = { 
		["BundleTasks"] = _BundleTasks,
	}
	asserts.AssertDescribeBundleTasksResult(t)
	return t
end

keys.ReplaceIamInstanceProfileAssociationRequest = { ["AssociationId"] = true, ["IamInstanceProfile"] = true, nil }

function asserts.AssertReplaceIamInstanceProfileAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceIamInstanceProfileAssociationRequest to be of type 'table'")
	assert(struct["IamInstanceProfile"], "Expected key IamInstanceProfile to exist in table")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceIamInstanceProfileAssociationRequest[k], "ReplaceIamInstanceProfileAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceIamInstanceProfileAssociationRequest
--  
-- @param _AssociationId [String] <p>The ID of the existing IAM instance profile association.</p>
-- @param _IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- Required parameter: IamInstanceProfile
-- Required parameter: AssociationId
function M.ReplaceIamInstanceProfileAssociationRequest(_AssociationId, _IamInstanceProfile, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceIamInstanceProfileAssociationRequest")
	local t = { 
		["AssociationId"] = _AssociationId,
		["IamInstanceProfile"] = _IamInstanceProfile,
	}
	asserts.AssertReplaceIamInstanceProfileAssociationRequest(t)
	return t
end

keys.PurchaseHostReservationResult = { ["TotalHourlyPrice"] = true, ["Purchase"] = true, ["CurrencyCode"] = true, ["TotalUpfrontPrice"] = true, ["ClientToken"] = true, nil }

function asserts.AssertPurchaseHostReservationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseHostReservationResult to be of type 'table'")
	if struct["TotalHourlyPrice"] then asserts.AssertString(struct["TotalHourlyPrice"]) end
	if struct["Purchase"] then asserts.AssertPurchaseSet(struct["Purchase"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["TotalUpfrontPrice"] then asserts.AssertString(struct["TotalUpfrontPrice"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseHostReservationResult[k], "PurchaseHostReservationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseHostReservationResult
--  
-- @param _TotalHourlyPrice [String] <p>The total hourly price of the reservation calculated per hour.</p>
-- @param _Purchase [PurchaseSet] <p>Describes the details of the purchase.</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param _TotalUpfrontPrice [String] <p>The total amount that will be charged to your account when you purchase the reservation.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i> </p>
function M.PurchaseHostReservationResult(_TotalHourlyPrice, _Purchase, _CurrencyCode, _TotalUpfrontPrice, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseHostReservationResult")
	local t = { 
		["TotalHourlyPrice"] = _TotalHourlyPrice,
		["Purchase"] = _Purchase,
		["CurrencyCode"] = _CurrencyCode,
		["TotalUpfrontPrice"] = _TotalUpfrontPrice,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertPurchaseHostReservationResult(t)
	return t
end

keys.ModifyVolumeAttributeRequest = { ["AutoEnableIO"] = true, ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertModifyVolumeAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeAttributeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["AutoEnableIO"] then asserts.AssertAttributeBooleanValue(struct["AutoEnableIO"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVolumeAttributeRequest[k], "ModifyVolumeAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeAttributeRequest
-- <p>Contains the parameters for ModifyVolumeAttribute.</p>
-- @param _AutoEnableIO [AttributeBooleanValue] <p>Indicates whether the volume should be auto-enabled for I/O operations.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.ModifyVolumeAttributeRequest(_AutoEnableIO, _DryRun, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVolumeAttributeRequest")
	local t = { 
		["AutoEnableIO"] = _AutoEnableIO,
		["DryRun"] = _DryRun,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertModifyVolumeAttributeRequest(t)
	return t
end

keys.CreateRouteResult = { ["Return"] = true, nil }

function asserts.AssertCreateRouteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteResult[k], "CreateRouteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteResult
-- <p>Contains the output of CreateRoute.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.CreateRouteResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateRouteResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertCreateRouteResult(t)
	return t
end

keys.ImportInstanceLaunchSpecification = { ["AdditionalInfo"] = true, ["Monitoring"] = true, ["UserData"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["GroupNames"] = true, ["Architecture"] = true, ["SubnetId"] = true, ["Placement"] = true, ["InstanceType"] = true, ["PrivateIpAddress"] = true, ["GroupIds"] = true, nil }

function asserts.AssertImportInstanceLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceLaunchSpecification to be of type 'table'")
	if struct["AdditionalInfo"] then asserts.AssertString(struct["AdditionalInfo"]) end
	if struct["Monitoring"] then asserts.AssertBoolean(struct["Monitoring"]) end
	if struct["UserData"] then asserts.AssertUserData(struct["UserData"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["GroupNames"] then asserts.AssertSecurityGroupStringList(struct["GroupNames"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Placement"] then asserts.AssertPlacement(struct["Placement"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["GroupIds"] then asserts.AssertSecurityGroupIdStringList(struct["GroupIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceLaunchSpecification[k], "ImportInstanceLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceLaunchSpecification
-- <p>Describes the launch specification for VM import.</p>
-- @param _AdditionalInfo [String] <p>Reserved.</p>
-- @param _Monitoring [Boolean] <p>Indicates whether monitoring is enabled.</p>
-- @param _UserData [UserData] <p>The user data to make available to the instance. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param _InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- @param _GroupNames [SecurityGroupStringList] <p>One or more security group names.</p>
-- @param _Architecture [ArchitectureValues] <p>The architecture of the instance.</p>
-- @param _SubnetId [String] <p>[EC2-VPC] The ID of the subnet in which to launch the instance.</p>
-- @param _Placement [Placement] <p>The placement information for the instance.</p>
-- @param _InstanceType [InstanceType] <p>The instance type. For more information about the instance types that you can import, see <a href="http://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html#vmimport-instance-types">Instance Types</a> in the VM Import/Export User Guide.</p>
-- @param _PrivateIpAddress [String] <p>[EC2-VPC] An available IP address from the IP address range of the subnet.</p>
-- @param _GroupIds [SecurityGroupIdStringList] <p>One or more security group IDs.</p>
function M.ImportInstanceLaunchSpecification(_AdditionalInfo, _Monitoring, _UserData, _InstanceInitiatedShutdownBehavior, _GroupNames, _Architecture, _SubnetId, _Placement, _InstanceType, _PrivateIpAddress, _GroupIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceLaunchSpecification")
	local t = { 
		["AdditionalInfo"] = _AdditionalInfo,
		["Monitoring"] = _Monitoring,
		["UserData"] = _UserData,
		["InstanceInitiatedShutdownBehavior"] = _InstanceInitiatedShutdownBehavior,
		["GroupNames"] = _GroupNames,
		["Architecture"] = _Architecture,
		["SubnetId"] = _SubnetId,
		["Placement"] = _Placement,
		["InstanceType"] = _InstanceType,
		["PrivateIpAddress"] = _PrivateIpAddress,
		["GroupIds"] = _GroupIds,
	}
	asserts.AssertImportInstanceLaunchSpecification(t)
	return t
end

keys.CreateDhcpOptionsRequest = { ["DryRun"] = true, ["DhcpConfigurations"] = true, nil }

function asserts.AssertCreateDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpConfigurations"], "Expected key DhcpConfigurations to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpConfigurations"] then asserts.AssertNewDhcpConfigurationList(struct["DhcpConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDhcpOptionsRequest[k], "CreateDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDhcpOptionsRequest
-- <p>Contains the parameters for CreateDhcpOptions.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _DhcpConfigurations [NewDhcpConfigurationList] <p>A DHCP configuration option.</p>
-- Required parameter: DhcpConfigurations
function M.CreateDhcpOptionsRequest(_DryRun, _DhcpConfigurations, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateDhcpOptionsRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["DhcpConfigurations"] = _DhcpConfigurations,
	}
	asserts.AssertCreateDhcpOptionsRequest(t)
	return t
end

keys.DisassociateVpcCidrBlockResult = { ["Ipv6CidrBlockAssociation"] = true, ["VpcId"] = true, nil }

function asserts.AssertDisassociateVpcCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateVpcCidrBlockResult to be of type 'table'")
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertVpcIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateVpcCidrBlockResult[k], "DisassociateVpcCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateVpcCidrBlockResult
--  
-- @param _Ipv6CidrBlockAssociation [VpcIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
function M.DisassociateVpcCidrBlockResult(_Ipv6CidrBlockAssociation, _VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateVpcCidrBlockResult")
	local t = { 
		["Ipv6CidrBlockAssociation"] = _Ipv6CidrBlockAssociation,
		["VpcId"] = _VpcId,
	}
	asserts.AssertDisassociateVpcCidrBlockResult(t)
	return t
end

keys.DeleteVpnConnectionRequest = { ["VpnConnectionId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpnConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnConnectionRequest to be of type 'table'")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpnConnectionRequest[k], "DeleteVpnConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnConnectionRequest
-- <p>Contains the parameters for DeleteVpnConnection.</p>
-- @param _VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpnConnectionId
function M.DeleteVpnConnectionRequest(_VpnConnectionId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpnConnectionRequest")
	local t = { 
		["VpnConnectionId"] = _VpnConnectionId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteVpnConnectionRequest(t)
	return t
end

keys.CreateVpnGatewayResult = { ["VpnGateway"] = true, nil }

function asserts.AssertCreateVpnGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnGatewayResult to be of type 'table'")
	if struct["VpnGateway"] then asserts.AssertVpnGateway(struct["VpnGateway"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnGatewayResult[k], "CreateVpnGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnGatewayResult
-- <p>Contains the output of CreateVpnGateway.</p>
-- @param _VpnGateway [VpnGateway] <p>Information about the virtual private gateway.</p>
function M.CreateVpnGatewayResult(_VpnGateway, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnGatewayResult")
	local t = { 
		["VpnGateway"] = _VpnGateway,
	}
	asserts.AssertCreateVpnGatewayResult(t)
	return t
end

keys.ModifyIdentityIdFormatRequest = { ["UseLongIds"] = true, ["PrincipalArn"] = true, ["Resource"] = true, nil }

function asserts.AssertModifyIdentityIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyIdentityIdFormatRequest to be of type 'table'")
	assert(struct["PrincipalArn"], "Expected key PrincipalArn to exist in table")
	assert(struct["Resource"], "Expected key Resource to exist in table")
	assert(struct["UseLongIds"], "Expected key UseLongIds to exist in table")
	if struct["UseLongIds"] then asserts.AssertBoolean(struct["UseLongIds"]) end
	if struct["PrincipalArn"] then asserts.AssertString(struct["PrincipalArn"]) end
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyIdentityIdFormatRequest[k], "ModifyIdentityIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyIdentityIdFormatRequest
-- <p>Contains the parameters of ModifyIdentityIdFormat.</p>
-- @param _UseLongIds [Boolean] <p>Indicates whether the resource should use longer IDs (17-character IDs)</p>
-- @param _PrincipalArn [String] <p>The ARN of the principal, which can be an IAM user, IAM role, or the root user. Specify <code>all</code> to modify the ID format for all IAM users, IAM roles, and the root user of the account.</p>
-- @param _Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- Required parameter: PrincipalArn
-- Required parameter: Resource
-- Required parameter: UseLongIds
function M.ModifyIdentityIdFormatRequest(_UseLongIds, _PrincipalArn, _Resource, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyIdentityIdFormatRequest")
	local t = { 
		["UseLongIds"] = _UseLongIds,
		["PrincipalArn"] = _PrincipalArn,
		["Resource"] = _Resource,
	}
	asserts.AssertModifyIdentityIdFormatRequest(t)
	return t
end

keys.AttachVolumeRequest = { ["Device"] = true, ["InstanceId"] = true, ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertAttachVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVolumeRequest to be of type 'table'")
	assert(struct["Device"], "Expected key Device to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Device"] then asserts.AssertString(struct["Device"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachVolumeRequest[k], "AttachVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVolumeRequest
-- <p>Contains the parameters for AttachVolume.</p>
-- @param _Device [String] <p>The device name to expose to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VolumeId [String] <p>The ID of the EBS volume. The volume and instance must be within the same Availability Zone.</p>
-- Required parameter: Device
-- Required parameter: InstanceId
-- Required parameter: VolumeId
function M.AttachVolumeRequest(_Device, _InstanceId, _DryRun, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachVolumeRequest")
	local t = { 
		["Device"] = _Device,
		["InstanceId"] = _InstanceId,
		["DryRun"] = _DryRun,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertAttachVolumeRequest(t)
	return t
end

keys.SnapshotDiskContainer = { ["Url"] = true, ["UserBucket"] = true, ["Description"] = true, ["Format"] = true, nil }

function asserts.AssertSnapshotDiskContainer(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotDiskContainer to be of type 'table'")
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["UserBucket"] then asserts.AssertUserBucket(struct["UserBucket"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnapshotDiskContainer[k], "SnapshotDiskContainer contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotDiskContainer
-- <p>The disk container object for the import snapshot request.</p>
-- @param _Url [String] <p>The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..).</p>
-- @param _UserBucket [UserBucket] <p>The S3 bucket for the disk image.</p>
-- @param _Description [String] <p>The description of the disk image being imported.</p>
-- @param _Format [String] <p>The format of the disk image being imported.</p> <p>Valid values: <code>RAW</code> | <code>VHD</code> | <code>VMDK</code> | <code>OVA</code> </p>
function M.SnapshotDiskContainer(_Url, _UserBucket, _Description, _Format, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SnapshotDiskContainer")
	local t = { 
		["Url"] = _Url,
		["UserBucket"] = _UserBucket,
		["Description"] = _Description,
		["Format"] = _Format,
	}
	asserts.AssertSnapshotDiskContainer(t)
	return t
end

keys.InstanceStatusEvent = { ["Code"] = true, ["Description"] = true, ["NotBefore"] = true, ["NotAfter"] = true, nil }

function asserts.AssertInstanceStatusEvent(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusEvent to be of type 'table'")
	if struct["Code"] then asserts.AssertEventCode(struct["Code"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NotBefore"] then asserts.AssertDateTime(struct["NotBefore"]) end
	if struct["NotAfter"] then asserts.AssertDateTime(struct["NotAfter"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatusEvent[k], "InstanceStatusEvent contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusEvent
-- <p>Describes a scheduled event for an instance.</p>
-- @param _Code [EventCode] <p>The event code.</p>
-- @param _Description [String] <p>A description of the event.</p> <p>After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].</p>
-- @param _NotBefore [DateTime] <p>The earliest scheduled start time for the event.</p>
-- @param _NotAfter [DateTime] <p>The latest scheduled end time for the event.</p>
function M.InstanceStatusEvent(_Code, _Description, _NotBefore, _NotAfter, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStatusEvent")
	local t = { 
		["Code"] = _Code,
		["Description"] = _Description,
		["NotBefore"] = _NotBefore,
		["NotAfter"] = _NotAfter,
	}
	asserts.AssertInstanceStatusEvent(t)
	return t
end

keys.BundleTask = { ["UpdateTime"] = true, ["InstanceId"] = true, ["Storage"] = true, ["BundleTaskError"] = true, ["State"] = true, ["StartTime"] = true, ["Progress"] = true, ["BundleId"] = true, nil }

function asserts.AssertBundleTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleTask to be of type 'table'")
	if struct["UpdateTime"] then asserts.AssertDateTime(struct["UpdateTime"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Storage"] then asserts.AssertStorage(struct["Storage"]) end
	if struct["BundleTaskError"] then asserts.AssertBundleTaskError(struct["BundleTaskError"]) end
	if struct["State"] then asserts.AssertBundleTaskState(struct["State"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["BundleId"] then asserts.AssertString(struct["BundleId"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleTask[k], "BundleTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleTask
-- <p>Describes a bundle task.</p>
-- @param _UpdateTime [DateTime] <p>The time of the most recent update for the task.</p>
-- @param _InstanceId [String] <p>The ID of the instance associated with this bundle task.</p>
-- @param _Storage [Storage] <p>The Amazon S3 storage locations.</p>
-- @param _BundleTaskError [BundleTaskError] <p>If the task fails, a description of the error.</p>
-- @param _State [BundleTaskState] <p>The state of the task.</p>
-- @param _StartTime [DateTime] <p>The time this task started.</p>
-- @param _Progress [String] <p>The level of task completion, as a percent (for example, 20%).</p>
-- @param _BundleId [String] <p>The ID of the bundle task.</p>
function M.BundleTask(_UpdateTime, _InstanceId, _Storage, _BundleTaskError, _State, _StartTime, _Progress, _BundleId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BundleTask")
	local t = { 
		["UpdateTime"] = _UpdateTime,
		["InstanceId"] = _InstanceId,
		["Storage"] = _Storage,
		["BundleTaskError"] = _BundleTaskError,
		["State"] = _State,
		["StartTime"] = _StartTime,
		["Progress"] = _Progress,
		["BundleId"] = _BundleId,
	}
	asserts.AssertBundleTask(t)
	return t
end

keys.VpcPeeringConnectionVpcInfo = { ["PeeringOptions"] = true, ["Ipv6CidrBlockSet"] = true, ["VpcId"] = true, ["CidrBlock"] = true, ["OwnerId"] = true, nil }

function asserts.AssertVpcPeeringConnectionVpcInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionVpcInfo to be of type 'table'")
	if struct["PeeringOptions"] then asserts.AssertVpcPeeringConnectionOptionsDescription(struct["PeeringOptions"]) end
	if struct["Ipv6CidrBlockSet"] then asserts.AssertIpv6CidrBlockSet(struct["Ipv6CidrBlockSet"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnectionVpcInfo[k], "VpcPeeringConnectionVpcInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionVpcInfo
-- <p>Describes a VPC in a VPC peering connection.</p>
-- @param _PeeringOptions [VpcPeeringConnectionOptionsDescription] <p>Information about the VPC peering connection options for the accepter or requester VPC.</p>
-- @param _Ipv6CidrBlockSet [Ipv6CidrBlockSet] <p>The IPv6 CIDR block for the VPC.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _CidrBlock [String] <p>The IPv4 CIDR block for the VPC.</p>
-- @param _OwnerId [String] <p>The AWS account ID of the VPC owner.</p>
function M.VpcPeeringConnectionVpcInfo(_PeeringOptions, _Ipv6CidrBlockSet, _VpcId, _CidrBlock, _OwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcPeeringConnectionVpcInfo")
	local t = { 
		["PeeringOptions"] = _PeeringOptions,
		["Ipv6CidrBlockSet"] = _Ipv6CidrBlockSet,
		["VpcId"] = _VpcId,
		["CidrBlock"] = _CidrBlock,
		["OwnerId"] = _OwnerId,
	}
	asserts.AssertVpcPeeringConnectionVpcInfo(t)
	return t
end

keys.ImportImageResult = { ["Status"] = true, ["LicenseType"] = true, ["Description"] = true, ["Hypervisor"] = true, ["ImageId"] = true, ["Platform"] = true, ["Architecture"] = true, ["SnapshotDetails"] = true, ["Progress"] = true, ["StatusMessage"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageResult to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["LicenseType"] then asserts.AssertString(struct["LicenseType"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Hypervisor"] then asserts.AssertString(struct["Hypervisor"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["Architecture"] then asserts.AssertString(struct["Architecture"]) end
	if struct["SnapshotDetails"] then asserts.AssertSnapshotDetailList(struct["SnapshotDetails"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportImageResult[k], "ImportImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageResult
-- <p>Contains the output for ImportImage.</p>
-- @param _Status [String] <p>A brief status of the task.</p>
-- @param _LicenseType [String] <p>The license type of the virtual machine.</p>
-- @param _Description [String] <p>A description of the import task.</p>
-- @param _Hypervisor [String] <p>The target hypervisor of the import task.</p>
-- @param _ImageId [String] <p>The ID of the Amazon Machine Image (AMI) created by the import task.</p>
-- @param _Platform [String] <p>The operating system of the virtual machine.</p>
-- @param _Architecture [String] <p>The architecture of the virtual machine.</p>
-- @param _SnapshotDetails [SnapshotDetailList] <p>Information about the snapshots.</p>
-- @param _Progress [String] <p>The progress of the task.</p>
-- @param _StatusMessage [String] <p>A detailed status message of the import task.</p>
-- @param _ImportTaskId [String] <p>The task ID of the import image task.</p>
function M.ImportImageResult(_Status, _LicenseType, _Description, _Hypervisor, _ImageId, _Platform, _Architecture, _SnapshotDetails, _Progress, _StatusMessage, _ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportImageResult")
	local t = { 
		["Status"] = _Status,
		["LicenseType"] = _LicenseType,
		["Description"] = _Description,
		["Hypervisor"] = _Hypervisor,
		["ImageId"] = _ImageId,
		["Platform"] = _Platform,
		["Architecture"] = _Architecture,
		["SnapshotDetails"] = _SnapshotDetails,
		["Progress"] = _Progress,
		["StatusMessage"] = _StatusMessage,
		["ImportTaskId"] = _ImportTaskId,
	}
	asserts.AssertImportImageResult(t)
	return t
end

keys.CreateNetworkInterfaceResult = { ["NetworkInterface"] = true, nil }

function asserts.AssertCreateNetworkInterfaceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfaceResult to be of type 'table'")
	if struct["NetworkInterface"] then asserts.AssertNetworkInterface(struct["NetworkInterface"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkInterfaceResult[k], "CreateNetworkInterfaceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfaceResult
-- <p>Contains the output of CreateNetworkInterface.</p>
-- @param _NetworkInterface [NetworkInterface] <p>Information about the network interface.</p>
function M.CreateNetworkInterfaceResult(_NetworkInterface, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkInterfaceResult")
	local t = { 
		["NetworkInterface"] = _NetworkInterface,
	}
	asserts.AssertCreateNetworkInterfaceResult(t)
	return t
end

keys.ModifyImageAttributeRequest = { ["ProductCodes"] = true, ["UserGroups"] = true, ["DryRun"] = true, ["Description"] = true, ["Attribute"] = true, ["UserIds"] = true, ["Value"] = true, ["ImageId"] = true, ["OperationType"] = true, ["LaunchPermission"] = true, nil }

function asserts.AssertModifyImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyImageAttributeRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["ProductCodes"] then asserts.AssertProductCodeStringList(struct["ProductCodes"]) end
	if struct["UserGroups"] then asserts.AssertUserGroupStringList(struct["UserGroups"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	if struct["Attribute"] then asserts.AssertString(struct["Attribute"]) end
	if struct["UserIds"] then asserts.AssertUserIdStringList(struct["UserIds"]) end
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["OperationType"] then asserts.AssertOperationType(struct["OperationType"]) end
	if struct["LaunchPermission"] then asserts.AssertLaunchPermissionModifications(struct["LaunchPermission"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyImageAttributeRequest[k], "ModifyImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyImageAttributeRequest
-- <p>Contains the parameters for ModifyImageAttribute.</p>
-- @param _ProductCodes [ProductCodeStringList] <p>One or more product codes. After you add a product code to an AMI, it can't be removed. This is only valid when modifying the <code>productCodes</code> attribute.</p>
-- @param _UserGroups [UserGroupStringList] <p>One or more user groups. This is only valid when modifying the <code>launchPermission</code> attribute.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [AttributeValue] <p>A description for the AMI.</p>
-- @param _Attribute [String] <p>The name of the attribute to modify.</p>
-- @param _UserIds [UserIdStringList] <p>One or more AWS account IDs. This is only valid when modifying the <code>launchPermission</code> attribute.</p>
-- @param _Value [String] <p>The value of the attribute being modified. This is only valid when modifying the <code>description</code> attribute.</p>
-- @param _ImageId [String] <p>The ID of the AMI.</p>
-- @param _OperationType [OperationType] <p>The operation type.</p>
-- @param _LaunchPermission [LaunchPermissionModifications] <p>A launch permission modification.</p>
-- Required parameter: ImageId
function M.ModifyImageAttributeRequest(_ProductCodes, _UserGroups, _DryRun, _Description, _Attribute, _UserIds, _Value, _ImageId, _OperationType, _LaunchPermission, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyImageAttributeRequest")
	local t = { 
		["ProductCodes"] = _ProductCodes,
		["UserGroups"] = _UserGroups,
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["Attribute"] = _Attribute,
		["UserIds"] = _UserIds,
		["Value"] = _Value,
		["ImageId"] = _ImageId,
		["OperationType"] = _OperationType,
		["LaunchPermission"] = _LaunchPermission,
	}
	asserts.AssertModifyImageAttributeRequest(t)
	return t
end

keys.DescribeSpotFleetRequestsResponse = { ["SpotFleetRequestConfigs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestsResponse to be of type 'table'")
	assert(struct["SpotFleetRequestConfigs"], "Expected key SpotFleetRequestConfigs to exist in table")
	if struct["SpotFleetRequestConfigs"] then asserts.AssertSpotFleetRequestConfigSet(struct["SpotFleetRequestConfigs"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestsResponse[k], "DescribeSpotFleetRequestsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestsResponse
-- <p>Contains the output of DescribeSpotFleetRequests.</p>
-- @param _SpotFleetRequestConfigs [SpotFleetRequestConfigSet] <p>Information about the configuration of your Spot fleet.</p>
-- @param _NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- Required parameter: SpotFleetRequestConfigs
function M.DescribeSpotFleetRequestsResponse(_SpotFleetRequestConfigs, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetRequestsResponse")
	local t = { 
		["SpotFleetRequestConfigs"] = _SpotFleetRequestConfigs,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeSpotFleetRequestsResponse(t)
	return t
end

keys.DescribeVpcEndpointServicesRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeVpcEndpointServicesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicesRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServicesRequest[k], "DescribeVpcEndpointServicesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicesRequest
-- <p>Contains the parameters for DescribeVpcEndpointServices.</p>
-- @param _NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
function M.DescribeVpcEndpointServicesRequest(_NextToken, _DryRun, _MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcEndpointServicesRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
	}
	asserts.AssertDescribeVpcEndpointServicesRequest(t)
	return t
end

keys.NewDhcpConfiguration = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertNewDhcpConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NewDhcpConfiguration to be of type 'table'")
	if struct["Values"] then asserts.AssertValueStringList(struct["Values"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.NewDhcpConfiguration[k], "NewDhcpConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NewDhcpConfiguration
--  
-- @param _Values [ValueStringList] 
-- @param _Key [String] 
function M.NewDhcpConfiguration(_Values, _Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NewDhcpConfiguration")
	local t = { 
		["Values"] = _Values,
		["Key"] = _Key,
	}
	asserts.AssertNewDhcpConfiguration(t)
	return t
end

keys.ModifyVpcPeeringConnectionOptionsResult = { ["RequesterPeeringConnectionOptions"] = true, ["AccepterPeeringConnectionOptions"] = true, nil }

function asserts.AssertModifyVpcPeeringConnectionOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcPeeringConnectionOptionsResult to be of type 'table'")
	if struct["RequesterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptions(struct["RequesterPeeringConnectionOptions"]) end
	if struct["AccepterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptions(struct["AccepterPeeringConnectionOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcPeeringConnectionOptionsResult[k], "ModifyVpcPeeringConnectionOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcPeeringConnectionOptionsResult
--  
-- @param _RequesterPeeringConnectionOptions [PeeringConnectionOptions] <p>Information about the VPC peering connection options for the requester VPC.</p>
-- @param _AccepterPeeringConnectionOptions [PeeringConnectionOptions] <p>Information about the VPC peering connection options for the accepter VPC.</p>
function M.ModifyVpcPeeringConnectionOptionsResult(_RequesterPeeringConnectionOptions, _AccepterPeeringConnectionOptions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcPeeringConnectionOptionsResult")
	local t = { 
		["RequesterPeeringConnectionOptions"] = _RequesterPeeringConnectionOptions,
		["AccepterPeeringConnectionOptions"] = _AccepterPeeringConnectionOptions,
	}
	asserts.AssertModifyVpcPeeringConnectionOptionsResult(t)
	return t
end

keys.StateReason = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertStateReason(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StateReason to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.StateReason[k], "StateReason contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StateReason
-- <p>Describes a state change.</p>
-- @param _Message [String] <p>The message for the state change.</p> <ul> <li> <p> <code>Server.InsufficientInstanceCapacity</code>: There was insufficient instance capacity to satisfy the launch request.</p> </li> <li> <p> <code>Server.InternalError</code>: An internal error occurred during instance launch, resulting in termination.</p> </li> <li> <p> <code>Server.ScheduledStop</code>: The instance was stopped due to a scheduled retirement.</p> </li> <li> <p> <code>Server.SpotInstanceTermination</code>: A Spot instance was terminated due to an increase in the market price.</p> </li> <li> <p> <code>Client.InternalError</code>: A client error caused the instance to terminate on launch.</p> </li> <li> <p> <code>Client.InstanceInitiatedShutdown</code>: The instance was shut down using the <code>shutdown -h</code> command from the instance.</p> </li> <li> <p> <code>Client.UserInitiatedShutdown</code>: The instance was shut down using the Amazon EC2 API.</p> </li> <li> <p> <code>Client.VolumeLimitExceeded</code>: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your limits.</p> </li> <li> <p> <code>Client.InvalidSnapshot.NotFound</code>: The specified snapshot was not found.</p> </li> </ul>
-- @param _Code [String] <p>The reason code for the state change.</p>
function M.StateReason(_Message, _Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StateReason")
	local t = { 
		["Message"] = _Message,
		["Code"] = _Code,
	}
	asserts.AssertStateReason(t)
	return t
end

keys.VpcPeeringConnectionStateReason = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertVpcPeeringConnectionStateReason(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionStateReason to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertVpcPeeringConnectionStateReasonCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnectionStateReason[k], "VpcPeeringConnectionStateReason contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionStateReason
-- <p>Describes the status of a VPC peering connection.</p>
-- @param _Message [String] <p>A message that provides more information about the status, if applicable.</p>
-- @param _Code [VpcPeeringConnectionStateReasonCode] <p>The status of the VPC peering connection.</p>
function M.VpcPeeringConnectionStateReason(_Message, _Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcPeeringConnectionStateReason")
	local t = { 
		["Message"] = _Message,
		["Code"] = _Code,
	}
	asserts.AssertVpcPeeringConnectionStateReason(t)
	return t
end

keys.IamInstanceProfile = { ["Id"] = true, ["Arn"] = true, nil }

function asserts.AssertIamInstanceProfile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfile to be of type 'table'")
	if struct["Id"] then asserts.AssertString(struct["Id"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.IamInstanceProfile[k], "IamInstanceProfile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfile
-- <p>Describes an IAM instance profile.</p>
-- @param _Id [String] <p>The ID of the instance profile.</p>
-- @param _Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
function M.IamInstanceProfile(_Id, _Arn, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IamInstanceProfile")
	local t = { 
		["Id"] = _Id,
		["Arn"] = _Arn,
	}
	asserts.AssertIamInstanceProfile(t)
	return t
end

keys.IpRange = { ["CidrIp"] = true, nil }

function asserts.AssertIpRange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IpRange to be of type 'table'")
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	for k,_ in pairs(struct) do
		assert(keys.IpRange[k], "IpRange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IpRange
-- <p>Describes an IPv4 range.</p>
-- @param _CidrIp [String] <p>The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix.</p>
function M.IpRange(_CidrIp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IpRange")
	local t = { 
		["CidrIp"] = _CidrIp,
	}
	asserts.AssertIpRange(t)
	return t
end

keys.InstanceCount = { ["State"] = true, ["InstanceCount"] = true, nil }

function asserts.AssertInstanceCount(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCount to be of type 'table'")
	if struct["State"] then asserts.AssertListingState(struct["State"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceCount[k], "InstanceCount contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCount
-- <p>Describes a Reserved Instance listing state.</p>
-- @param _State [ListingState] <p>The states of the listed Reserved Instances.</p>
-- @param _InstanceCount [Integer] <p>The number of listed Reserved Instances in the state specified by the <code>state</code>.</p>
function M.InstanceCount(_State, _InstanceCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceCount")
	local t = { 
		["State"] = _State,
		["InstanceCount"] = _InstanceCount,
	}
	asserts.AssertInstanceCount(t)
	return t
end

keys.ScheduledInstancesIamInstanceProfile = { ["Name"] = true, ["Arn"] = true, nil }

function asserts.AssertScheduledInstancesIamInstanceProfile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesIamInstanceProfile to be of type 'table'")
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesIamInstanceProfile[k], "ScheduledInstancesIamInstanceProfile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesIamInstanceProfile
-- <p>Describes an IAM instance profile for a Scheduled Instance.</p>
-- @param _Name [String] <p>The name.</p>
-- @param _Arn [String] <p>The Amazon Resource Name (ARN).</p>
function M.ScheduledInstancesIamInstanceProfile(_Name, _Arn, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesIamInstanceProfile")
	local t = { 
		["Name"] = _Name,
		["Arn"] = _Arn,
	}
	asserts.AssertScheduledInstancesIamInstanceProfile(t)
	return t
end

keys.VolumeStatusAction = { ["EventId"] = true, ["EventType"] = true, ["Code"] = true, ["Description"] = true, nil }

function asserts.AssertVolumeStatusAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusAction to be of type 'table'")
	if struct["EventId"] then asserts.AssertString(struct["EventId"]) end
	if struct["EventType"] then asserts.AssertString(struct["EventType"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusAction[k], "VolumeStatusAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusAction
-- <p>Describes a volume status operation code.</p>
-- @param _EventId [String] <p>The ID of the event associated with this operation.</p>
-- @param _EventType [String] <p>The event type associated with this operation.</p>
-- @param _Code [String] <p>The code identifying the operation, for example, <code>enable-volume-io</code>.</p>
-- @param _Description [String] <p>A description of the operation.</p>
function M.VolumeStatusAction(_EventId, _EventType, _Code, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusAction")
	local t = { 
		["EventId"] = _EventId,
		["EventType"] = _EventType,
		["Code"] = _Code,
		["Description"] = _Description,
	}
	asserts.AssertVolumeStatusAction(t)
	return t
end

keys.VgwTelemetry = { ["Status"] = true, ["AcceptedRouteCount"] = true, ["LastStatusChange"] = true, ["OutsideIpAddress"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertVgwTelemetry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VgwTelemetry to be of type 'table'")
	if struct["Status"] then asserts.AssertTelemetryStatus(struct["Status"]) end
	if struct["AcceptedRouteCount"] then asserts.AssertInteger(struct["AcceptedRouteCount"]) end
	if struct["LastStatusChange"] then asserts.AssertDateTime(struct["LastStatusChange"]) end
	if struct["OutsideIpAddress"] then asserts.AssertString(struct["OutsideIpAddress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.VgwTelemetry[k], "VgwTelemetry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VgwTelemetry
-- <p>Describes telemetry for a VPN tunnel.</p>
-- @param _Status [TelemetryStatus] <p>The status of the VPN tunnel.</p>
-- @param _AcceptedRouteCount [Integer] <p>The number of accepted routes.</p>
-- @param _LastStatusChange [DateTime] <p>The date and time of the last change in status.</p>
-- @param _OutsideIpAddress [String] <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
-- @param _StatusMessage [String] <p>If an error occurs, a description of the error.</p>
function M.VgwTelemetry(_Status, _AcceptedRouteCount, _LastStatusChange, _OutsideIpAddress, _StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VgwTelemetry")
	local t = { 
		["Status"] = _Status,
		["AcceptedRouteCount"] = _AcceptedRouteCount,
		["LastStatusChange"] = _LastStatusChange,
		["OutsideIpAddress"] = _OutsideIpAddress,
		["StatusMessage"] = _StatusMessage,
	}
	asserts.AssertVgwTelemetry(t)
	return t
end

keys.VpcEndpoint = { ["VpcId"] = true, ["ServiceName"] = true, ["State"] = true, ["PolicyDocument"] = true, ["RouteTableIds"] = true, ["VpcEndpointId"] = true, ["CreationTimestamp"] = true, nil }

function asserts.AssertVpcEndpoint(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcEndpoint to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["ServiceName"] then asserts.AssertString(struct["ServiceName"]) end
	if struct["State"] then asserts.AssertState(struct["State"]) end
	if struct["PolicyDocument"] then asserts.AssertString(struct["PolicyDocument"]) end
	if struct["RouteTableIds"] then asserts.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["VpcEndpointId"] then asserts.AssertString(struct["VpcEndpointId"]) end
	if struct["CreationTimestamp"] then asserts.AssertDateTime(struct["CreationTimestamp"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcEndpoint[k], "VpcEndpoint contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcEndpoint
-- <p>Describes a VPC endpoint.</p>
-- @param _VpcId [String] <p>The ID of the VPC to which the endpoint is associated.</p>
-- @param _ServiceName [String] <p>The name of the AWS service to which the endpoint is associated.</p>
-- @param _State [State] <p>The state of the VPC endpoint.</p>
-- @param _PolicyDocument [String] <p>The policy document associated with the endpoint.</p>
-- @param _RouteTableIds [ValueStringList] <p>One or more route tables associated with the endpoint.</p>
-- @param _VpcEndpointId [String] <p>The ID of the VPC endpoint.</p>
-- @param _CreationTimestamp [DateTime] <p>The date and time the VPC endpoint was created.</p>
function M.VpcEndpoint(_VpcId, _ServiceName, _State, _PolicyDocument, _RouteTableIds, _VpcEndpointId, _CreationTimestamp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcEndpoint")
	local t = { 
		["VpcId"] = _VpcId,
		["ServiceName"] = _ServiceName,
		["State"] = _State,
		["PolicyDocument"] = _PolicyDocument,
		["RouteTableIds"] = _RouteTableIds,
		["VpcEndpointId"] = _VpcEndpointId,
		["CreationTimestamp"] = _CreationTimestamp,
	}
	asserts.AssertVpcEndpoint(t)
	return t
end

keys.AssociateAddressResult = { ["AssociationId"] = true, nil }

function asserts.AssertAssociateAddressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateAddressResult to be of type 'table'")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateAddressResult[k], "AssociateAddressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateAddressResult
-- <p>Contains the output of AssociateAddress.</p>
-- @param _AssociationId [String] <p>[EC2-VPC] The ID that represents the association of the Elastic IP address with an instance.</p>
function M.AssociateAddressResult(_AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateAddressResult")
	local t = { 
		["AssociationId"] = _AssociationId,
	}
	asserts.AssertAssociateAddressResult(t)
	return t
end

keys.InternetGatewayAttachment = { ["State"] = true, ["VpcId"] = true, nil }

function asserts.AssertInternetGatewayAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InternetGatewayAttachment to be of type 'table'")
	if struct["State"] then asserts.AssertAttachmentStatus(struct["State"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.InternetGatewayAttachment[k], "InternetGatewayAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InternetGatewayAttachment
-- <p>Describes the attachment of a VPC to an Internet gateway or an egress-only Internet gateway.</p>
-- @param _State [AttachmentStatus] <p>The current state of the attachment.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
function M.InternetGatewayAttachment(_State, _VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InternetGatewayAttachment")
	local t = { 
		["State"] = _State,
		["VpcId"] = _VpcId,
	}
	asserts.AssertInternetGatewayAttachment(t)
	return t
end

keys.CancelSpotFleetRequestsSuccessItem = { ["PreviousSpotFleetRequestState"] = true, ["CurrentSpotFleetRequestState"] = true, ["SpotFleetRequestId"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsSuccessItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsSuccessItem to be of type 'table'")
	assert(struct["CurrentSpotFleetRequestState"], "Expected key CurrentSpotFleetRequestState to exist in table")
	assert(struct["PreviousSpotFleetRequestState"], "Expected key PreviousSpotFleetRequestState to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["PreviousSpotFleetRequestState"] then asserts.AssertBatchState(struct["PreviousSpotFleetRequestState"]) end
	if struct["CurrentSpotFleetRequestState"] then asserts.AssertBatchState(struct["CurrentSpotFleetRequestState"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsSuccessItem[k], "CancelSpotFleetRequestsSuccessItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsSuccessItem
-- <p>Describes a Spot fleet request that was successfully canceled.</p>
-- @param _PreviousSpotFleetRequestState [BatchState] <p>The previous state of the Spot fleet request.</p>
-- @param _CurrentSpotFleetRequestState [BatchState] <p>The current state of the Spot fleet request.</p>
-- @param _SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- Required parameter: CurrentSpotFleetRequestState
-- Required parameter: PreviousSpotFleetRequestState
-- Required parameter: SpotFleetRequestId
function M.CancelSpotFleetRequestsSuccessItem(_PreviousSpotFleetRequestState, _CurrentSpotFleetRequestState, _SpotFleetRequestId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsSuccessItem")
	local t = { 
		["PreviousSpotFleetRequestState"] = _PreviousSpotFleetRequestState,
		["CurrentSpotFleetRequestState"] = _CurrentSpotFleetRequestState,
		["SpotFleetRequestId"] = _SpotFleetRequestId,
	}
	asserts.AssertCancelSpotFleetRequestsSuccessItem(t)
	return t
end

keys.RevokeSecurityGroupEgressRequest = { ["DryRun"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertRevokeSecurityGroupEgressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RevokeSecurityGroupEgressRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RevokeSecurityGroupEgressRequest[k], "RevokeSecurityGroupEgressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RevokeSecurityGroupEgressRequest
-- <p>Contains the parameters for RevokeSecurityGroupEgress.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _CidrIp [String] <p>The CIDR IP address range. We recommend that you specify the CIDR range in a set of IP permissions instead.</p>
-- @param _IpPermissions [IpPermissionList] <p>A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.</p>
-- @param _FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- @param _SourceSecurityGroupOwnerId [String] <p>The AWS account number for a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- @param _SourceSecurityGroupName [String] <p>The name of a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- @param _ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- @param _IpProtocol [String] <p>The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.</p>
-- @param _GroupId [String] <p>The ID of the security group.</p>
-- Required parameter: GroupId
function M.RevokeSecurityGroupEgressRequest(_DryRun, _CidrIp, _IpPermissions, _FromPort, _SourceSecurityGroupOwnerId, _SourceSecurityGroupName, _ToPort, _IpProtocol, _GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RevokeSecurityGroupEgressRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["CidrIp"] = _CidrIp,
		["IpPermissions"] = _IpPermissions,
		["FromPort"] = _FromPort,
		["SourceSecurityGroupOwnerId"] = _SourceSecurityGroupOwnerId,
		["SourceSecurityGroupName"] = _SourceSecurityGroupName,
		["ToPort"] = _ToPort,
		["IpProtocol"] = _IpProtocol,
		["GroupId"] = _GroupId,
	}
	asserts.AssertRevokeSecurityGroupEgressRequest(t)
	return t
end

keys.DescribeImportImageTasksRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["ImportTaskIds"] = true, nil }

function asserts.AssertDescribeImportImageTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportImageTasksRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ImportTaskIds"] then asserts.AssertImportTaskIdList(struct["ImportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportImageTasksRequest[k], "DescribeImportImageTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportImageTasksRequest
-- <p>Contains the parameters for DescribeImportImageTasks.</p>
-- @param _NextToken [String] <p>A token that indicates the next page of results.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param _Filters [FilterList] <p>Filter tasks using the <code>task-state</code> filter and one of the following values: active, completed, deleting, deleted.</p>
-- @param _ImportTaskIds [ImportTaskIdList] <p>A list of import image task IDs.</p>
function M.DescribeImportImageTasksRequest(_NextToken, _DryRun, _MaxResults, _Filters, _ImportTaskIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImportImageTasksRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
		["ImportTaskIds"] = _ImportTaskIds,
	}
	asserts.AssertDescribeImportImageTasksRequest(t)
	return t
end

keys.DescribeVpcClassicLinkDnsSupportResult = { ["Vpcs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Vpcs"] then asserts.AssertClassicLinkDnsSupportList(struct["Vpcs"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkDnsSupportResult[k], "DescribeVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkDnsSupportResult
-- <p>Contains the output of DescribeVpcClassicLinkDnsSupport.</p>
-- @param _Vpcs [ClassicLinkDnsSupportList] <p>Information about the ClassicLink DNS support status of the VPCs.</p>
-- @param _NextToken [NextToken] <p>The token to use when requesting the next set of items.</p>
function M.DescribeVpcClassicLinkDnsSupportResult(_Vpcs, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcClassicLinkDnsSupportResult")
	local t = { 
		["Vpcs"] = _Vpcs,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeVpcClassicLinkDnsSupportResult(t)
	return t
end

keys.RegisterImageRequest = { ["VirtualizationType"] = true, ["DryRun"] = true, ["Description"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["BlockDeviceMappings"] = true, ["Architecture"] = true, ["BillingProducts"] = true, ["ImageLocation"] = true, ["KernelId"] = true, ["RamdiskId"] = true, ["RootDeviceName"] = true, ["Name"] = true, nil }

function asserts.AssertRegisterImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterImageRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["VirtualizationType"] then asserts.AssertString(struct["VirtualizationType"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["EnaSupport"] then asserts.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertString(struct["SriovNetSupport"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["BillingProducts"] then asserts.AssertBillingProductList(struct["BillingProducts"]) end
	if struct["ImageLocation"] then asserts.AssertString(struct["ImageLocation"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["RootDeviceName"] then asserts.AssertString(struct["RootDeviceName"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterImageRequest[k], "RegisterImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterImageRequest
-- <p>Contains the parameters for RegisterImage.</p>
-- @param _VirtualizationType [String] <p>The type of virtualization.</p> <p>Default: <code>paravirtual</code> </p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>A description for your AMI.</p>
-- @param _EnaSupport [Boolean] <p>Set to <code>true</code> to enable enhanced networking with ENA for the AMI and any instances that you launch from the AMI.</p> <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
-- @param _SriovNetSupport [String] <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI.</p> <p>There is no way to disable <code>sriovNetSupport</code> at this time.</p> <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
-- @param _BlockDeviceMappings [BlockDeviceMappingRequestList] <p>One or more block device mapping entries.</p>
-- @param _Architecture [ArchitectureValues] <p>The architecture of the AMI.</p> <p>Default: For Amazon EBS-backed AMIs, <code>i386</code>. For instance store-backed AMIs, the architecture specified in the manifest file.</p>
-- @param _BillingProducts [BillingProductList] <p>The billing product codes. Your account must be authorized to specify billing product codes. Otherwise, you can use the AWS Marketplace to bill for the use of an AMI.</p>
-- @param _ImageLocation [String] <p>The full path to your AMI manifest in Amazon S3 storage.</p>
-- @param _KernelId [String] <p>The ID of the kernel.</p>
-- @param _RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param _RootDeviceName [String] <p>The name of the root device (for example, <code>/dev/sda1</code>, or <code>/dev/xvda</code>).</p>
-- @param _Name [String] <p>A name for your AMI.</p> <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
-- Required parameter: Name
function M.RegisterImageRequest(_VirtualizationType, _DryRun, _Description, _EnaSupport, _SriovNetSupport, _BlockDeviceMappings, _Architecture, _BillingProducts, _ImageLocation, _KernelId, _RamdiskId, _RootDeviceName, _Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RegisterImageRequest")
	local t = { 
		["VirtualizationType"] = _VirtualizationType,
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["EnaSupport"] = _EnaSupport,
		["SriovNetSupport"] = _SriovNetSupport,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["Architecture"] = _Architecture,
		["BillingProducts"] = _BillingProducts,
		["ImageLocation"] = _ImageLocation,
		["KernelId"] = _KernelId,
		["RamdiskId"] = _RamdiskId,
		["RootDeviceName"] = _RootDeviceName,
		["Name"] = _Name,
	}
	asserts.AssertRegisterImageRequest(t)
	return t
end

keys.IcmpTypeCode = { ["Code"] = true, ["Type"] = true, nil }

function asserts.AssertIcmpTypeCode(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IcmpTypeCode to be of type 'table'")
	if struct["Code"] then asserts.AssertInteger(struct["Code"]) end
	if struct["Type"] then asserts.AssertInteger(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.IcmpTypeCode[k], "IcmpTypeCode contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IcmpTypeCode
-- <p>Describes the ICMP type and code.</p>
-- @param _Code [Integer] <p>The ICMP code. A value of -1 means all codes for the specified ICMP type.</p>
-- @param _Type [Integer] <p>The ICMP type. A value of -1 means all types.</p>
function M.IcmpTypeCode(_Code, _Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IcmpTypeCode")
	local t = { 
		["Code"] = _Code,
		["Type"] = _Type,
	}
	asserts.AssertIcmpTypeCode(t)
	return t
end

keys.DescribeInternetGatewaysRequest = { ["DryRun"] = true, ["InternetGatewayIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInternetGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInternetGatewaysRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayIds"] then asserts.AssertValueStringList(struct["InternetGatewayIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInternetGatewaysRequest[k], "DescribeInternetGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInternetGatewaysRequest
-- <p>Contains the parameters for DescribeInternetGateways.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InternetGatewayIds [ValueStringList] <p>One or more Internet gateway IDs.</p> <p>Default: Describes all your Internet gateways.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.state</code> - The current state of the attachment between the gateway and the VPC (<code>available</code>). Present only if a VPC is attached.</p> </li> <li> <p> <code>attachment.vpc-id</code> - The ID of an attached VPC.</p> </li> <li> <p> <code>internet-gateway-id</code> - The ID of the Internet gateway.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
function M.DescribeInternetGatewaysRequest(_DryRun, _InternetGatewayIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInternetGatewaysRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["InternetGatewayIds"] = _InternetGatewayIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeInternetGatewaysRequest(t)
	return t
end

keys.CreateVpcPeeringConnectionResult = { ["VpcPeeringConnection"] = true, nil }

function asserts.AssertCreateVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcPeeringConnectionResult to be of type 'table'")
	if struct["VpcPeeringConnection"] then asserts.AssertVpcPeeringConnection(struct["VpcPeeringConnection"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcPeeringConnectionResult[k], "CreateVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcPeeringConnectionResult
-- <p>Contains the output of CreateVpcPeeringConnection.</p>
-- @param _VpcPeeringConnection [VpcPeeringConnection] <p>Information about the VPC peering connection.</p>
function M.CreateVpcPeeringConnectionResult(_VpcPeeringConnection, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcPeeringConnectionResult")
	local t = { 
		["VpcPeeringConnection"] = _VpcPeeringConnection,
	}
	asserts.AssertCreateVpcPeeringConnectionResult(t)
	return t
end

keys.NetworkInterfaceAttachmentChanges = { ["DeleteOnTermination"] = true, ["AttachmentId"] = true, nil }

function asserts.AssertNetworkInterfaceAttachmentChanges(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAttachmentChanges to be of type 'table'")
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceAttachmentChanges[k], "NetworkInterfaceAttachmentChanges contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAttachmentChanges
-- <p>Describes an attachment change.</p>
-- @param _DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- @param _AttachmentId [String] <p>The ID of the network interface attachment.</p>
function M.NetworkInterfaceAttachmentChanges(_DeleteOnTermination, _AttachmentId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfaceAttachmentChanges")
	local t = { 
		["DeleteOnTermination"] = _DeleteOnTermination,
		["AttachmentId"] = _AttachmentId,
	}
	asserts.AssertNetworkInterfaceAttachmentChanges(t)
	return t
end

keys.CreateNetworkInterfaceRequest = { ["DryRun"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["PrivateIpAddresses"] = true, ["SubnetId"] = true, ["SecondaryPrivateIpAddressCount"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertCreateNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfaceRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkInterfaceRequest[k], "CreateNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfaceRequest
-- <p>Contains the parameters for CreateNetworkInterface.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>A description for the network interface.</p>
-- @param _Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses. If your subnet has the <code>AssignIpv6AddressOnCreation</code> attribute set to <code>true</code>, you can specify <code>0</code> to override this setting.</p>
-- @param _PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses.</p>
-- @param _SubnetId [String] <p>The ID of the subnet to associate with the network interface.</p>
-- @param _SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using <code>privateIpAddresses</code>.</p> <p>The number of IP addresses you can assign to a network interface varies by instance type. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI">IP Addresses Per ENI Per Instance Type</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- @param _Groups [SecurityGroupIdStringList] <p>The IDs of one or more security groups.</p>
-- @param _Ipv6Addresses [InstanceIpv6AddressList] <p>One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.</p>
-- @param _PrivateIpAddress [String] <p>The primary private IPv4 address of the network interface. If you don't specify an IPv4 address, Amazon EC2 selects one for you from the subnet's IPv4 CIDR range. If you specify an IP address, you cannot indicate any IP addresses specified in <code>privateIpAddresses</code> as primary (only one IP address can be designated as primary).</p>
-- Required parameter: SubnetId
function M.CreateNetworkInterfaceRequest(_DryRun, _Description, _Ipv6AddressCount, _PrivateIpAddresses, _SubnetId, _SecondaryPrivateIpAddressCount, _Groups, _Ipv6Addresses, _PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkInterfaceRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["Ipv6AddressCount"] = _Ipv6AddressCount,
		["PrivateIpAddresses"] = _PrivateIpAddresses,
		["SubnetId"] = _SubnetId,
		["SecondaryPrivateIpAddressCount"] = _SecondaryPrivateIpAddressCount,
		["Groups"] = _Groups,
		["Ipv6Addresses"] = _Ipv6Addresses,
		["PrivateIpAddress"] = _PrivateIpAddress,
	}
	asserts.AssertCreateNetworkInterfaceRequest(t)
	return t
end

keys.DescribeImportSnapshotTasksResult = { ["NextToken"] = true, ["ImportSnapshotTasks"] = true, nil }

function asserts.AssertDescribeImportSnapshotTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportSnapshotTasksResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ImportSnapshotTasks"] then asserts.AssertImportSnapshotTaskList(struct["ImportSnapshotTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportSnapshotTasksResult[k], "DescribeImportSnapshotTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportSnapshotTasksResult
-- <p>Contains the output for DescribeImportSnapshotTasks.</p>
-- @param _NextToken [String] <p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _ImportSnapshotTasks [ImportSnapshotTaskList] <p>A list of zero or more import snapshot tasks that are currently active or were completed or canceled in the previous 7 days.</p>
function M.DescribeImportSnapshotTasksResult(_NextToken, _ImportSnapshotTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImportSnapshotTasksResult")
	local t = { 
		["NextToken"] = _NextToken,
		["ImportSnapshotTasks"] = _ImportSnapshotTasks,
	}
	asserts.AssertDescribeImportSnapshotTasksResult(t)
	return t
end

keys.DescribeStaleSecurityGroupsResult = { ["StaleSecurityGroupSet"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeStaleSecurityGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStaleSecurityGroupsResult to be of type 'table'")
	if struct["StaleSecurityGroupSet"] then asserts.AssertStaleSecurityGroupSet(struct["StaleSecurityGroupSet"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeStaleSecurityGroupsResult[k], "DescribeStaleSecurityGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStaleSecurityGroupsResult
--  
-- @param _StaleSecurityGroupSet [StaleSecurityGroupSet] <p>Information about the stale security groups.</p>
-- @param _NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
function M.DescribeStaleSecurityGroupsResult(_StaleSecurityGroupSet, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeStaleSecurityGroupsResult")
	local t = { 
		["StaleSecurityGroupSet"] = _StaleSecurityGroupSet,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeStaleSecurityGroupsResult(t)
	return t
end

keys.PriceScheduleSpecification = { ["Term"] = true, ["CurrencyCode"] = true, ["Price"] = true, nil }

function asserts.AssertPriceScheduleSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PriceScheduleSpecification to be of type 'table'")
	if struct["Term"] then asserts.AssertLong(struct["Term"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Price"] then asserts.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(keys.PriceScheduleSpecification[k], "PriceScheduleSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PriceScheduleSpecification
-- <p>Describes the price for a Reserved Instance.</p>
-- @param _Term [Long] <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>
-- @param _Price [Double] <p>The fixed price for the term.</p>
function M.PriceScheduleSpecification(_Term, _CurrencyCode, _Price, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PriceScheduleSpecification")
	local t = { 
		["Term"] = _Term,
		["CurrencyCode"] = _CurrencyCode,
		["Price"] = _Price,
	}
	asserts.AssertPriceScheduleSpecification(t)
	return t
end

keys.UnassignIpv6AddressesResult = { ["NetworkInterfaceId"] = true, ["UnassignedIpv6Addresses"] = true, nil }

function asserts.AssertUnassignIpv6AddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignIpv6AddressesResult to be of type 'table'")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["UnassignedIpv6Addresses"] then asserts.AssertIpv6AddressList(struct["UnassignedIpv6Addresses"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnassignIpv6AddressesResult[k], "UnassignIpv6AddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignIpv6AddressesResult
--  
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _UnassignedIpv6Addresses [Ipv6AddressList] <p>The IPv6 addresses that have been unassigned from the network interface.</p>
function M.UnassignIpv6AddressesResult(_NetworkInterfaceId, _UnassignedIpv6Addresses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnassignIpv6AddressesResult")
	local t = { 
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["UnassignedIpv6Addresses"] = _UnassignedIpv6Addresses,
	}
	asserts.AssertUnassignIpv6AddressesResult(t)
	return t
end

keys.DescribeImageAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["ImageId"] = true, nil }

function asserts.AssertDescribeImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImageAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["Attribute"] then asserts.AssertImageAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImageAttributeRequest[k], "DescribeImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImageAttributeRequest
-- <p>Contains the parameters for DescribeImageAttribute.</p>
-- @param _Attribute [ImageAttributeName] <p>The AMI attribute.</p> <p> <b>Note</b>: Depending on your account privileges, the <code>blockDeviceMapping</code> attribute may return a <code>Client.AuthFailure</code> error. If this happens, use <a>DescribeImages</a> to get information about the block device mapping for the AMI.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _ImageId [String] <p>The ID of the AMI.</p>
-- Required parameter: Attribute
-- Required parameter: ImageId
function M.DescribeImageAttributeRequest(_Attribute, _DryRun, _ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeImageAttributeRequest")
	local t = { 
		["Attribute"] = _Attribute,
		["DryRun"] = _DryRun,
		["ImageId"] = _ImageId,
	}
	asserts.AssertDescribeImageAttributeRequest(t)
	return t
end

keys.DescribeEgressOnlyInternetGatewaysResult = { ["NextToken"] = true, ["EgressOnlyInternetGateways"] = true, nil }

function asserts.AssertDescribeEgressOnlyInternetGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEgressOnlyInternetGatewaysResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["EgressOnlyInternetGateways"] then asserts.AssertEgressOnlyInternetGatewayList(struct["EgressOnlyInternetGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEgressOnlyInternetGatewaysResult[k], "DescribeEgressOnlyInternetGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEgressOnlyInternetGatewaysResult
--  
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- @param _EgressOnlyInternetGateways [EgressOnlyInternetGatewayList] <p>Information about the egress-only Internet gateways.</p>
function M.DescribeEgressOnlyInternetGatewaysResult(_NextToken, _EgressOnlyInternetGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeEgressOnlyInternetGatewaysResult")
	local t = { 
		["NextToken"] = _NextToken,
		["EgressOnlyInternetGateways"] = _EgressOnlyInternetGateways,
	}
	asserts.AssertDescribeEgressOnlyInternetGatewaysResult(t)
	return t
end

keys.InstanceNetworkInterfaceAttachment = { ["Status"] = true, ["DeviceIndex"] = true, ["DeleteOnTermination"] = true, ["AttachmentId"] = true, ["AttachTime"] = true, nil }

function asserts.AssertInstanceNetworkInterfaceAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceAttachment to be of type 'table'")
	if struct["Status"] then asserts.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterfaceAttachment[k], "InstanceNetworkInterfaceAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceAttachment
-- <p>Describes a network interface attachment.</p>
-- @param _Status [AttachmentStatus] <p>The attachment state.</p>
-- @param _DeviceIndex [Integer] <p>The index of the device on the instance for the network interface attachment.</p>
-- @param _DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- @param _AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- @param _AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
function M.InstanceNetworkInterfaceAttachment(_Status, _DeviceIndex, _DeleteOnTermination, _AttachmentId, _AttachTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceNetworkInterfaceAttachment")
	local t = { 
		["Status"] = _Status,
		["DeviceIndex"] = _DeviceIndex,
		["DeleteOnTermination"] = _DeleteOnTermination,
		["AttachmentId"] = _AttachmentId,
		["AttachTime"] = _AttachTime,
	}
	asserts.AssertInstanceNetworkInterfaceAttachment(t)
	return t
end

keys.DescribeSubnetsRequest = { ["SubnetIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeSubnetsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSubnetsRequest to be of type 'table'")
	if struct["SubnetIds"] then asserts.AssertSubnetIdStringList(struct["SubnetIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSubnetsRequest[k], "DescribeSubnetsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSubnetsRequest
-- <p>Contains the parameters for DescribeSubnets.</p>
-- @param _SubnetIds [SubnetIdStringList] <p>One or more subnet IDs.</p> <p>Default: Describes all your subnets.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availabilityZone</code> - The Availability Zone for the subnet. You can also use <code>availability-zone</code> as the filter name.</p> </li> <li> <p> <code>available-ip-address-count</code> - The number of IPv4 addresses in the subnet that are available.</p> </li> <li> <p> <code>cidrBlock</code> - The IPv4 CIDR block of the subnet. The CIDR block you specify must exactly match the subnet's CIDR block for information to be returned for the subnet. You can also use <code>cidr</code> or <code>cidr-block</code> as the filter names.</p> </li> <li> <p> <code>defaultForAz</code> - Indicates whether this is the default subnet for the Availability Zone. You can also use <code>default-for-az</code> as the filter name.</p> </li> <li> <p> <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>ipv6-cidr-block-association.association-id</code> - An association ID for an IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>state</code> - The state of the subnet (<code>pending</code> | <code>available</code>).</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the subnet.</p> </li> </ul>
function M.DescribeSubnetsRequest(_SubnetIds, _DryRun, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSubnetsRequest")
	local t = { 
		["SubnetIds"] = _SubnetIds,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeSubnetsRequest(t)
	return t
end

keys.CreateSubnetRequest = { ["VpcId"] = true, ["Ipv6CidrBlock"] = true, ["DryRun"] = true, ["AvailabilityZone"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertCreateSubnetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSubnetRequest to be of type 'table'")
	assert(struct["CidrBlock"], "Expected key CidrBlock to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSubnetRequest[k], "CreateSubnetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSubnetRequest
-- <p>Contains the parameters for CreateSubnet.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _Ipv6CidrBlock [String] <p>The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone for the subnet.</p> <p>Default: AWS selects one for you. If you create more than one subnet in your VPC, we may not necessarily select a different zone for each subnet.</p>
-- @param _CidrBlock [String] <p>The IPv4 network range for the subnet, in CIDR notation. For example, <code>10.0.0.0/24</code>.</p>
-- Required parameter: CidrBlock
-- Required parameter: VpcId
function M.CreateSubnetRequest(_VpcId, _Ipv6CidrBlock, _DryRun, _AvailabilityZone, _CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSubnetRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["Ipv6CidrBlock"] = _Ipv6CidrBlock,
		["DryRun"] = _DryRun,
		["AvailabilityZone"] = _AvailabilityZone,
		["CidrBlock"] = _CidrBlock,
	}
	asserts.AssertCreateSubnetRequest(t)
	return t
end

keys.ConfirmProductInstanceRequest = { ["InstanceId"] = true, ["ProductCode"] = true, ["DryRun"] = true, nil }

function asserts.AssertConfirmProductInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConfirmProductInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["ProductCode"], "Expected key ProductCode to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["ProductCode"] then asserts.AssertString(struct["ProductCode"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConfirmProductInstanceRequest[k], "ConfirmProductInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConfirmProductInstanceRequest
-- <p>Contains the parameters for ConfirmProductInstance.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _ProductCode [String] <p>The product code. This must be a product code that you own.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
-- Required parameter: ProductCode
function M.ConfirmProductInstanceRequest(_InstanceId, _ProductCode, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ConfirmProductInstanceRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["ProductCode"] = _ProductCode,
		["DryRun"] = _DryRun,
	}
	asserts.AssertConfirmProductInstanceRequest(t)
	return t
end

keys.ScheduledInstanceRecurrenceRequest = { ["OccurrenceDays"] = true, ["Interval"] = true, ["Frequency"] = true, ["OccurrenceRelativeToEnd"] = true, ["OccurrenceUnit"] = true, nil }

function asserts.AssertScheduledInstanceRecurrenceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceRecurrenceRequest to be of type 'table'")
	if struct["OccurrenceDays"] then asserts.AssertOccurrenceDayRequestSet(struct["OccurrenceDays"]) end
	if struct["Interval"] then asserts.AssertInteger(struct["Interval"]) end
	if struct["Frequency"] then asserts.AssertString(struct["Frequency"]) end
	if struct["OccurrenceRelativeToEnd"] then asserts.AssertBoolean(struct["OccurrenceRelativeToEnd"]) end
	if struct["OccurrenceUnit"] then asserts.AssertString(struct["OccurrenceUnit"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstanceRecurrenceRequest[k], "ScheduledInstanceRecurrenceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceRecurrenceRequest
-- <p>Describes the recurring schedule for a Scheduled Instance.</p>
-- @param _OccurrenceDays [OccurrenceDayRequestSet] <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday). You can't specify this value with a daily schedule. If the occurrence is relative to the end of the month, you can specify only a single day.</p>
-- @param _Interval [Integer] <p>The interval quantity. The interval unit depends on the value of <code>Frequency</code>. For example, every 2 weeks or every 2 months.</p>
-- @param _Frequency [String] <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
-- @param _OccurrenceRelativeToEnd [Boolean] <p>Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.</p>
-- @param _OccurrenceUnit [String] <p>The unit for <code>OccurrenceDays</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>). This value is required for a monthly schedule. You can't specify <code>DayOfWeek</code> with a weekly schedule. You can't specify this value with a daily schedule.</p>
function M.ScheduledInstanceRecurrenceRequest(_OccurrenceDays, _Interval, _Frequency, _OccurrenceRelativeToEnd, _OccurrenceUnit, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstanceRecurrenceRequest")
	local t = { 
		["OccurrenceDays"] = _OccurrenceDays,
		["Interval"] = _Interval,
		["Frequency"] = _Frequency,
		["OccurrenceRelativeToEnd"] = _OccurrenceRelativeToEnd,
		["OccurrenceUnit"] = _OccurrenceUnit,
	}
	asserts.AssertScheduledInstanceRecurrenceRequest(t)
	return t
end

keys.DescribeStaleSecurityGroupsRequest = { ["VpcId"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeStaleSecurityGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStaleSecurityGroupsRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeStaleSecurityGroupsRequest[k], "DescribeStaleSecurityGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStaleSecurityGroupsRequest
--  
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.</p>
-- @param _MaxResults [MaxResults] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required parameter: VpcId
function M.DescribeStaleSecurityGroupsRequest(_VpcId, _NextToken, _DryRun, _MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeStaleSecurityGroupsRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
	}
	asserts.AssertDescribeStaleSecurityGroupsRequest(t)
	return t
end

keys.ReservationValue = { ["RemainingUpfrontValue"] = true, ["HourlyPrice"] = true, ["RemainingTotalValue"] = true, nil }

function asserts.AssertReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservationValue to be of type 'table'")
	if struct["RemainingUpfrontValue"] then asserts.AssertString(struct["RemainingUpfrontValue"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["RemainingTotalValue"] then asserts.AssertString(struct["RemainingTotalValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservationValue[k], "ReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservationValue
-- <p>The cost associated with the Reserved Instance.</p>
-- @param _RemainingUpfrontValue [String] <p>The remaining upfront cost of the reservation.</p>
-- @param _HourlyPrice [String] <p>The hourly rate of the reservation.</p>
-- @param _RemainingTotalValue [String] <p>The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).</p>
function M.ReservationValue(_RemainingUpfrontValue, _HourlyPrice, _RemainingTotalValue, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservationValue")
	local t = { 
		["RemainingUpfrontValue"] = _RemainingUpfrontValue,
		["HourlyPrice"] = _HourlyPrice,
		["RemainingTotalValue"] = _RemainingTotalValue,
	}
	asserts.AssertReservationValue(t)
	return t
end

keys.AssociateVpcCidrBlockRequest = { ["VpcId"] = true, ["AmazonProvidedIpv6CidrBlock"] = true, nil }

function asserts.AssertAssociateVpcCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateVpcCidrBlockRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["AmazonProvidedIpv6CidrBlock"] then asserts.AssertBoolean(struct["AmazonProvidedIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateVpcCidrBlockRequest[k], "AssociateVpcCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateVpcCidrBlockRequest
--  
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _AmazonProvidedIpv6CidrBlock [Boolean] <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.</p>
-- Required parameter: VpcId
function M.AssociateVpcCidrBlockRequest(_VpcId, _AmazonProvidedIpv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateVpcCidrBlockRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["AmazonProvidedIpv6CidrBlock"] = _AmazonProvidedIpv6CidrBlock,
	}
	asserts.AssertAssociateVpcCidrBlockRequest(t)
	return t
end

keys.ExportToS3Task = { ["S3Bucket"] = true, ["S3Key"] = true, ["DiskImageFormat"] = true, ["ContainerFormat"] = true, nil }

function asserts.AssertExportToS3Task(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportToS3Task to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then asserts.AssertString(struct["S3Key"]) end
	if struct["DiskImageFormat"] then asserts.AssertDiskImageFormat(struct["DiskImageFormat"]) end
	if struct["ContainerFormat"] then asserts.AssertContainerFormat(struct["ContainerFormat"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExportToS3Task[k], "ExportToS3Task contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportToS3Task
-- <p>Describes the format and location for an instance export task.</p>
-- @param _S3Bucket [String] <p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>
-- @param _S3Key [String] <p>The encryption key for your S3 bucket.</p>
-- @param _DiskImageFormat [DiskImageFormat] <p>The format for the exported image.</p>
-- @param _ContainerFormat [ContainerFormat] <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>
function M.ExportToS3Task(_S3Bucket, _S3Key, _DiskImageFormat, _ContainerFormat, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ExportToS3Task")
	local t = { 
		["S3Bucket"] = _S3Bucket,
		["S3Key"] = _S3Key,
		["DiskImageFormat"] = _DiskImageFormat,
		["ContainerFormat"] = _ContainerFormat,
	}
	asserts.AssertExportToS3Task(t)
	return t
end

keys.AuthorizeSecurityGroupIngressRequest = { ["DryRun"] = true, ["GroupName"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertAuthorizeSecurityGroupIngressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizeSecurityGroupIngressRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthorizeSecurityGroupIngressRequest[k], "AuthorizeSecurityGroupIngressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizeSecurityGroupIngressRequest
-- <p>Contains the parameters for AuthorizeSecurityGroupIngress.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group.</p>
-- @param _CidrIp [String] <p>The CIDR IPv4 address range. You can't specify this parameter when specifying a source security group.</p>
-- @param _IpPermissions [IpPermissionList] <p>A set of IP permissions. Can be used to specify multiple rules in a single command.</p>
-- @param _FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. For the ICMP/ICMPv6 type number, use <code>-1</code> to specify all types.</p>
-- @param _SourceSecurityGroupOwnerId [String] <p>[EC2-Classic] The AWS account number for the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead.</p>
-- @param _SourceSecurityGroupName [String] <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead. For EC2-VPC, the source security group must be in the same VPC.</p>
-- @param _ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code number. For the ICMP/ICMPv6 code number, use <code>-1</code> to specify all codes.</p>
-- @param _IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). (VPC only) Use <code>-1</code> to specify all protocols. If you specify <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>58</code> (ICMPv6), traffic on all ports is allowed, regardless of any ports you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For protocol <code>58</code> (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed.</p>
-- @param _GroupId [String] <p>The ID of the security group. Required for a nondefault VPC.</p>
function M.AuthorizeSecurityGroupIngressRequest(_DryRun, _GroupName, _CidrIp, _IpPermissions, _FromPort, _SourceSecurityGroupOwnerId, _SourceSecurityGroupName, _ToPort, _IpProtocol, _GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AuthorizeSecurityGroupIngressRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["GroupName"] = _GroupName,
		["CidrIp"] = _CidrIp,
		["IpPermissions"] = _IpPermissions,
		["FromPort"] = _FromPort,
		["SourceSecurityGroupOwnerId"] = _SourceSecurityGroupOwnerId,
		["SourceSecurityGroupName"] = _SourceSecurityGroupName,
		["ToPort"] = _ToPort,
		["IpProtocol"] = _IpProtocol,
		["GroupId"] = _GroupId,
	}
	asserts.AssertAuthorizeSecurityGroupIngressRequest(t)
	return t
end

keys.DescribeAccountAttributesRequest = { ["DryRun"] = true, ["AttributeNames"] = true, nil }

function asserts.AssertDescribeAccountAttributesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAttributesRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AttributeNames"] then asserts.AssertAccountAttributeNameStringList(struct["AttributeNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAccountAttributesRequest[k], "DescribeAccountAttributesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAttributesRequest
-- <p>Contains the parameters for DescribeAccountAttributes.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _AttributeNames [AccountAttributeNameStringList] <p>One or more account attribute names.</p>
function M.DescribeAccountAttributesRequest(_DryRun, _AttributeNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAccountAttributesRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["AttributeNames"] = _AttributeNames,
	}
	asserts.AssertDescribeAccountAttributesRequest(t)
	return t
end

keys.VpcPeeringConnection = { ["Status"] = true, ["Tags"] = true, ["RequesterVpcInfo"] = true, ["VpcPeeringConnectionId"] = true, ["ExpirationTime"] = true, ["AccepterVpcInfo"] = true, nil }

function asserts.AssertVpcPeeringConnection(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnection to be of type 'table'")
	if struct["Status"] then asserts.AssertVpcPeeringConnectionStateReason(struct["Status"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["RequesterVpcInfo"] then asserts.AssertVpcPeeringConnectionVpcInfo(struct["RequesterVpcInfo"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["ExpirationTime"] then asserts.AssertDateTime(struct["ExpirationTime"]) end
	if struct["AccepterVpcInfo"] then asserts.AssertVpcPeeringConnectionVpcInfo(struct["AccepterVpcInfo"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnection[k], "VpcPeeringConnection contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnection
-- <p>Describes a VPC peering connection.</p>
-- @param _Status [VpcPeeringConnectionStateReason] <p>The status of the VPC peering connection.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the resource.</p>
-- @param _RequesterVpcInfo [VpcPeeringConnectionVpcInfo] <p>Information about the requester VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- @param _ExpirationTime [DateTime] <p>The time that an unaccepted VPC peering connection will expire.</p>
-- @param _AccepterVpcInfo [VpcPeeringConnectionVpcInfo] <p>Information about the accepter VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
function M.VpcPeeringConnection(_Status, _Tags, _RequesterVpcInfo, _VpcPeeringConnectionId, _ExpirationTime, _AccepterVpcInfo, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpcPeeringConnection")
	local t = { 
		["Status"] = _Status,
		["Tags"] = _Tags,
		["RequesterVpcInfo"] = _RequesterVpcInfo,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
		["ExpirationTime"] = _ExpirationTime,
		["AccepterVpcInfo"] = _AccepterVpcInfo,
	}
	asserts.AssertVpcPeeringConnection(t)
	return t
end

keys.DescribeScheduledInstanceAvailabilityResult = { ["NextToken"] = true, ["ScheduledInstanceAvailabilitySet"] = true, nil }

function asserts.AssertDescribeScheduledInstanceAvailabilityResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstanceAvailabilityResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ScheduledInstanceAvailabilitySet"] then asserts.AssertScheduledInstanceAvailabilitySet(struct["ScheduledInstanceAvailabilitySet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstanceAvailabilityResult[k], "DescribeScheduledInstanceAvailabilityResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstanceAvailabilityResult
-- <p>Contains the output of DescribeScheduledInstanceAvailability.</p>
-- @param _NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _ScheduledInstanceAvailabilitySet [ScheduledInstanceAvailabilitySet] <p>Information about the available Scheduled Instances.</p>
function M.DescribeScheduledInstanceAvailabilityResult(_NextToken, _ScheduledInstanceAvailabilitySet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeScheduledInstanceAvailabilityResult")
	local t = { 
		["NextToken"] = _NextToken,
		["ScheduledInstanceAvailabilitySet"] = _ScheduledInstanceAvailabilitySet,
	}
	asserts.AssertDescribeScheduledInstanceAvailabilityResult(t)
	return t
end

keys.DescribeIamInstanceProfileAssociationsRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, ["AssociationIds"] = true, nil }

function asserts.AssertDescribeIamInstanceProfileAssociationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIamInstanceProfileAssociationsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["AssociationIds"] then asserts.AssertAssociationIdList(struct["AssociationIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIamInstanceProfileAssociationsRequest[k], "DescribeIamInstanceProfileAssociationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIamInstanceProfileAssociationsRequest
--  
-- @param _NextToken [NextToken] <p>The token to request the next page of results.</p>
-- @param _MaxResults [MaxResults] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>state</code> - The state of the association (<code>associating</code> | <code>associated</code> | <code>disassociating</code> | <code>disassociated</code>).</p> </li> </ul>
-- @param _AssociationIds [AssociationIdList] <p>One or more IAM instance profile associations.</p>
function M.DescribeIamInstanceProfileAssociationsRequest(_NextToken, _MaxResults, _Filters, _AssociationIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIamInstanceProfileAssociationsRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
		["AssociationIds"] = _AssociationIds,
	}
	asserts.AssertDescribeIamInstanceProfileAssociationsRequest(t)
	return t
end

keys.ConversionTask = { ["ImportInstance"] = true, ["ImportVolume"] = true, ["Tags"] = true, ["ConversionTaskId"] = true, ["State"] = true, ["ExpirationTime"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertConversionTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConversionTask to be of type 'table'")
	assert(struct["ConversionTaskId"], "Expected key ConversionTaskId to exist in table")
	assert(struct["State"], "Expected key State to exist in table")
	if struct["ImportInstance"] then asserts.AssertImportInstanceTaskDetails(struct["ImportInstance"]) end
	if struct["ImportVolume"] then asserts.AssertImportVolumeTaskDetails(struct["ImportVolume"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["ConversionTaskId"] then asserts.AssertString(struct["ConversionTaskId"]) end
	if struct["State"] then asserts.AssertConversionTaskState(struct["State"]) end
	if struct["ExpirationTime"] then asserts.AssertString(struct["ExpirationTime"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConversionTask[k], "ConversionTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConversionTask
-- <p>Describes a conversion task.</p>
-- @param _ImportInstance [ImportInstanceTaskDetails] <p>If the task is for importing an instance, this contains information about the import instance task.</p>
-- @param _ImportVolume [ImportVolumeTaskDetails] <p>If the task is for importing a volume, this contains information about the import volume task.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the task.</p>
-- @param _ConversionTaskId [String] <p>The ID of the conversion task.</p>
-- @param _State [ConversionTaskState] <p>The state of the conversion task.</p>
-- @param _ExpirationTime [String] <p>The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel the task.</p>
-- @param _StatusMessage [String] <p>The status message related to the conversion task.</p>
-- Required parameter: ConversionTaskId
-- Required parameter: State
function M.ConversionTask(_ImportInstance, _ImportVolume, _Tags, _ConversionTaskId, _State, _ExpirationTime, _StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ConversionTask")
	local t = { 
		["ImportInstance"] = _ImportInstance,
		["ImportVolume"] = _ImportVolume,
		["Tags"] = _Tags,
		["ConversionTaskId"] = _ConversionTaskId,
		["State"] = _State,
		["ExpirationTime"] = _ExpirationTime,
		["StatusMessage"] = _StatusMessage,
	}
	asserts.AssertConversionTask(t)
	return t
end

keys.CreateVpcEndpointResult = { ["VpcEndpoint"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateVpcEndpointResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointResult to be of type 'table'")
	if struct["VpcEndpoint"] then asserts.AssertVpcEndpoint(struct["VpcEndpoint"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointResult[k], "CreateVpcEndpointResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointResult
-- <p>Contains the output of CreateVpcEndpoint.</p>
-- @param _VpcEndpoint [VpcEndpoint] <p>Information about the endpoint.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
function M.CreateVpcEndpointResult(_VpcEndpoint, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcEndpointResult")
	local t = { 
		["VpcEndpoint"] = _VpcEndpoint,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertCreateVpcEndpointResult(t)
	return t
end

keys.DescribeSpotPriceHistoryResult = { ["NextToken"] = true, ["SpotPriceHistory"] = true, nil }

function asserts.AssertDescribeSpotPriceHistoryResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotPriceHistoryResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["SpotPriceHistory"] then asserts.AssertSpotPriceHistoryList(struct["SpotPriceHistory"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotPriceHistoryResult[k], "DescribeSpotPriceHistoryResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotPriceHistoryResult
-- <p>Contains the output of DescribeSpotPriceHistory.</p>
-- @param _NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _SpotPriceHistory [SpotPriceHistoryList] <p>The historical Spot prices.</p>
function M.DescribeSpotPriceHistoryResult(_NextToken, _SpotPriceHistory, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotPriceHistoryResult")
	local t = { 
		["NextToken"] = _NextToken,
		["SpotPriceHistory"] = _SpotPriceHistory,
	}
	asserts.AssertDescribeSpotPriceHistoryResult(t)
	return t
end

keys.DescribeScheduledInstanceAvailabilityRequest = { ["DryRun"] = true, ["Filters"] = true, ["MinSlotDurationInHours"] = true, ["MaxResults"] = true, ["FirstSlotStartTimeRange"] = true, ["Recurrence"] = true, ["MaxSlotDurationInHours"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeScheduledInstanceAvailabilityRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstanceAvailabilityRequest to be of type 'table'")
	assert(struct["FirstSlotStartTimeRange"], "Expected key FirstSlotStartTimeRange to exist in table")
	assert(struct["Recurrence"], "Expected key Recurrence to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MinSlotDurationInHours"] then asserts.AssertInteger(struct["MinSlotDurationInHours"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["FirstSlotStartTimeRange"] then asserts.AssertSlotDateTimeRangeRequest(struct["FirstSlotStartTimeRange"]) end
	if struct["Recurrence"] then asserts.AssertScheduledInstanceRecurrenceRequest(struct["Recurrence"]) end
	if struct["MaxSlotDurationInHours"] then asserts.AssertInteger(struct["MaxSlotDurationInHours"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstanceAvailabilityRequest[k], "DescribeScheduledInstanceAvailabilityRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstanceAvailabilityRequest
-- <p>Contains the parameters for DescribeScheduledInstanceAvailability.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p> </li> <li> <p> <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p> </li> <li> <p> <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p> </li> <li> <p> <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p> </li> </ul>
-- @param _MinSlotDurationInHours [Integer] <p>The minimum available duration, in hours. The minimum required duration is 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 300. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param _FirstSlotStartTimeRange [SlotDateTimeRangeRequest] <p>The time period for the first schedule to start.</p>
-- @param _Recurrence [ScheduledInstanceRecurrenceRequest] <p>The schedule recurrence.</p>
-- @param _MaxSlotDurationInHours [Integer] <p>The maximum available duration, in hours. This value must be greater than <code>MinSlotDurationInHours</code> and less than 1,720.</p>
-- @param _NextToken [String] <p>The token for the next set of results.</p>
-- Required parameter: FirstSlotStartTimeRange
-- Required parameter: Recurrence
function M.DescribeScheduledInstanceAvailabilityRequest(_DryRun, _Filters, _MinSlotDurationInHours, _MaxResults, _FirstSlotStartTimeRange, _Recurrence, _MaxSlotDurationInHours, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeScheduledInstanceAvailabilityRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
		["MinSlotDurationInHours"] = _MinSlotDurationInHours,
		["MaxResults"] = _MaxResults,
		["FirstSlotStartTimeRange"] = _FirstSlotStartTimeRange,
		["Recurrence"] = _Recurrence,
		["MaxSlotDurationInHours"] = _MaxSlotDurationInHours,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeScheduledInstanceAvailabilityRequest(t)
	return t
end

keys.DescribeNatGatewaysResult = { ["NextToken"] = true, ["NatGateways"] = true, nil }

function asserts.AssertDescribeNatGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNatGatewaysResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["NatGateways"] then asserts.AssertNatGatewayList(struct["NatGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNatGatewaysResult[k], "DescribeNatGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNatGatewaysResult
-- <p>Contains the output of DescribeNatGateways.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _NatGateways [NatGatewayList] <p>Information about the NAT gateways.</p>
function M.DescribeNatGatewaysResult(_NextToken, _NatGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNatGatewaysResult")
	local t = { 
		["NextToken"] = _NextToken,
		["NatGateways"] = _NatGateways,
	}
	asserts.AssertDescribeNatGatewaysResult(t)
	return t
end

keys.ReplaceIamInstanceProfileAssociationResult = { ["IamInstanceProfileAssociation"] = true, nil }

function asserts.AssertReplaceIamInstanceProfileAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceIamInstanceProfileAssociationResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then asserts.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceIamInstanceProfileAssociationResult[k], "ReplaceIamInstanceProfileAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceIamInstanceProfileAssociationResult
--  
-- @param _IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
function M.ReplaceIamInstanceProfileAssociationResult(_IamInstanceProfileAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReplaceIamInstanceProfileAssociationResult")
	local t = { 
		["IamInstanceProfileAssociation"] = _IamInstanceProfileAssociation,
	}
	asserts.AssertReplaceIamInstanceProfileAssociationResult(t)
	return t
end

keys.ProvisionedBandwidth = { ["Status"] = true, ["Provisioned"] = true, ["RequestTime"] = true, ["Requested"] = true, ["ProvisionTime"] = true, nil }

function asserts.AssertProvisionedBandwidth(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProvisionedBandwidth to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["Provisioned"] then asserts.AssertString(struct["Provisioned"]) end
	if struct["RequestTime"] then asserts.AssertDateTime(struct["RequestTime"]) end
	if struct["Requested"] then asserts.AssertString(struct["Requested"]) end
	if struct["ProvisionTime"] then asserts.AssertDateTime(struct["ProvisionTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.ProvisionedBandwidth[k], "ProvisionedBandwidth contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProvisionedBandwidth
-- <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param _Status [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param _Provisioned [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param _RequestTime [DateTime] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param _Requested [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param _ProvisionTime [DateTime] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
function M.ProvisionedBandwidth(_Status, _Provisioned, _RequestTime, _Requested, _ProvisionTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ProvisionedBandwidth")
	local t = { 
		["Status"] = _Status,
		["Provisioned"] = _Provisioned,
		["RequestTime"] = _RequestTime,
		["Requested"] = _Requested,
		["ProvisionTime"] = _ProvisionTime,
	}
	asserts.AssertProvisionedBandwidth(t)
	return t
end

keys.DescribePlacementGroupsResult = { ["PlacementGroups"] = true, nil }

function asserts.AssertDescribePlacementGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePlacementGroupsResult to be of type 'table'")
	if struct["PlacementGroups"] then asserts.AssertPlacementGroupList(struct["PlacementGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePlacementGroupsResult[k], "DescribePlacementGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePlacementGroupsResult
-- <p>Contains the output of DescribePlacementGroups.</p>
-- @param _PlacementGroups [PlacementGroupList] <p>One or more placement groups.</p>
function M.DescribePlacementGroupsResult(_PlacementGroups, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribePlacementGroupsResult")
	local t = { 
		["PlacementGroups"] = _PlacementGroups,
	}
	asserts.AssertDescribePlacementGroupsResult(t)
	return t
end

keys.UnmonitorInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertUnmonitorInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnmonitorInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnmonitorInstancesRequest[k], "UnmonitorInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnmonitorInstancesRequest
-- <p>Contains the parameters for UnmonitorInstances.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.UnmonitorInstancesRequest(_DryRun, _InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnmonitorInstancesRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["InstanceIds"] = _InstanceIds,
	}
	asserts.AssertUnmonitorInstancesRequest(t)
	return t
end

keys.BundleInstanceResult = { ["BundleTask"] = true, nil }

function asserts.AssertBundleInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleInstanceResult to be of type 'table'")
	if struct["BundleTask"] then asserts.AssertBundleTask(struct["BundleTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleInstanceResult[k], "BundleInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleInstanceResult
-- <p>Contains the output of BundleInstance.</p>
-- @param _BundleTask [BundleTask] <p>Information about the bundle task.</p>
function M.BundleInstanceResult(_BundleTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BundleInstanceResult")
	local t = { 
		["BundleTask"] = _BundleTask,
	}
	asserts.AssertBundleInstanceResult(t)
	return t
end

keys.AccountAttributeValue = { ["AttributeValue"] = true, nil }

function asserts.AssertAccountAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AccountAttributeValue to be of type 'table'")
	if struct["AttributeValue"] then asserts.AssertString(struct["AttributeValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.AccountAttributeValue[k], "AccountAttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AccountAttributeValue
-- <p>Describes a value of an account attribute.</p>
-- @param _AttributeValue [String] <p>The value of the attribute.</p>
function M.AccountAttributeValue(_AttributeValue, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AccountAttributeValue")
	local t = { 
		["AttributeValue"] = _AttributeValue,
	}
	asserts.AssertAccountAttributeValue(t)
	return t
end

keys.DescribeHostReservationsRequest = { ["Filter"] = true, ["HostReservationIdSet"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeHostReservationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationsRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["HostReservationIdSet"] then asserts.AssertHostReservationIdSet(struct["HostReservationIdSet"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationsRequest[k], "DescribeHostReservationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationsRequest
--  
-- @param _Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-family</code> - The instance family (e.g., <code>m4</code>).</p> </li> <li> <p> <code>payment-option</code> - The payment option (<code>NoUpfront</code> | <code>PartialUpfront</code> | <code>AllUpfront</code>).</p> </li> <li> <p> <code>state</code> - The state of the reservation (<code>payment-pending</code> | <code>payment-failed</code> | <code>active</code> | <code>retired</code>).</p> </li> </ul>
-- @param _HostReservationIdSet [HostReservationIdSet] <p>One or more host reservation IDs.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500; if <code>maxResults</code> is given a larger value than 500, you will receive an error.</p>
function M.DescribeHostReservationsRequest(_Filter, _HostReservationIdSet, _NextToken, _MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostReservationsRequest")
	local t = { 
		["Filter"] = _Filter,
		["HostReservationIdSet"] = _HostReservationIdSet,
		["NextToken"] = _NextToken,
		["MaxResults"] = _MaxResults,
	}
	asserts.AssertDescribeHostReservationsRequest(t)
	return t
end

keys.DescribeScheduledInstancesRequest = { ["ScheduledInstanceIds"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["SlotStartTimeRange"] = true, ["Filters"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstancesRequest to be of type 'table'")
	if struct["ScheduledInstanceIds"] then asserts.AssertScheduledInstanceIdRequestSet(struct["ScheduledInstanceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["SlotStartTimeRange"] then asserts.AssertSlotStartTimeRangeRequest(struct["SlotStartTimeRange"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstancesRequest[k], "DescribeScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstancesRequest
-- <p>Contains the parameters for DescribeScheduledInstances.</p>
-- @param _ScheduledInstanceIds [ScheduledInstanceIdRequestSet] <p>One or more Scheduled Instance IDs.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 100. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param _SlotStartTimeRange [SlotStartTimeRangeRequest] <p>The time period for the first schedule to start.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p> </li> <li> <p> <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p> </li> <li> <p> <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p> </li> <li> <p> <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p> </li> </ul>
-- @param _NextToken [String] <p>The token for the next set of results.</p>
function M.DescribeScheduledInstancesRequest(_ScheduledInstanceIds, _DryRun, _MaxResults, _SlotStartTimeRange, _Filters, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeScheduledInstancesRequest")
	local t = { 
		["ScheduledInstanceIds"] = _ScheduledInstanceIds,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
		["SlotStartTimeRange"] = _SlotStartTimeRange,
		["Filters"] = _Filters,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeScheduledInstancesRequest(t)
	return t
end

keys.GetConsoleScreenshotRequest = { ["InstanceId"] = true, ["WakeUp"] = true, ["DryRun"] = true, nil }

function asserts.AssertGetConsoleScreenshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleScreenshotRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["WakeUp"] then asserts.AssertBoolean(struct["WakeUp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleScreenshotRequest[k], "GetConsoleScreenshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleScreenshotRequest
-- <p>Contains the parameters for the request.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _WakeUp [Boolean] <p>When set to <code>true</code>, acts as keystroke input and wakes up an instance that's in standby or "sleep" mode.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: InstanceId
function M.GetConsoleScreenshotRequest(_InstanceId, _WakeUp, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetConsoleScreenshotRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["WakeUp"] = _WakeUp,
		["DryRun"] = _DryRun,
	}
	asserts.AssertGetConsoleScreenshotRequest(t)
	return t
end

keys.NetworkAclAssociation = { ["SubnetId"] = true, ["NetworkAclId"] = true, ["NetworkAclAssociationId"] = true, nil }

function asserts.AssertNetworkAclAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAclAssociation to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["NetworkAclAssociationId"] then asserts.AssertString(struct["NetworkAclAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkAclAssociation[k], "NetworkAclAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAclAssociation
-- <p>Describes an association between a network ACL and a subnet.</p>
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param _NetworkAclAssociationId [String] <p>The ID of the association between a network ACL and a subnet.</p>
function M.NetworkAclAssociation(_SubnetId, _NetworkAclId, _NetworkAclAssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkAclAssociation")
	local t = { 
		["SubnetId"] = _SubnetId,
		["NetworkAclId"] = _NetworkAclId,
		["NetworkAclAssociationId"] = _NetworkAclAssociationId,
	}
	asserts.AssertNetworkAclAssociation(t)
	return t
end

keys.DescribeExportTasksResult = { ["ExportTasks"] = true, nil }

function asserts.AssertDescribeExportTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeExportTasksResult to be of type 'table'")
	if struct["ExportTasks"] then asserts.AssertExportTaskList(struct["ExportTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeExportTasksResult[k], "DescribeExportTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeExportTasksResult
-- <p>Contains the output for DescribeExportTasks.</p>
-- @param _ExportTasks [ExportTaskList] <p>Information about the export tasks.</p>
function M.DescribeExportTasksResult(_ExportTasks, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeExportTasksResult")
	local t = { 
		["ExportTasks"] = _ExportTasks,
	}
	asserts.AssertDescribeExportTasksResult(t)
	return t
end

keys.CancelSpotFleetRequestsRequest = { ["SpotFleetRequestIds"] = true, ["DryRun"] = true, ["TerminateInstances"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsRequest to be of type 'table'")
	assert(struct["SpotFleetRequestIds"], "Expected key SpotFleetRequestIds to exist in table")
	assert(struct["TerminateInstances"], "Expected key TerminateInstances to exist in table")
	if struct["SpotFleetRequestIds"] then asserts.AssertValueStringList(struct["SpotFleetRequestIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TerminateInstances"] then asserts.AssertBoolean(struct["TerminateInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsRequest[k], "CancelSpotFleetRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsRequest
-- <p>Contains the parameters for CancelSpotFleetRequests.</p>
-- @param _SpotFleetRequestIds [ValueStringList] <p>The IDs of the Spot fleet requests.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _TerminateInstances [Boolean] <p>Indicates whether to terminate instances for a Spot fleet request if it is canceled successfully.</p>
-- Required parameter: SpotFleetRequestIds
-- Required parameter: TerminateInstances
function M.CancelSpotFleetRequestsRequest(_SpotFleetRequestIds, _DryRun, _TerminateInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsRequest")
	local t = { 
		["SpotFleetRequestIds"] = _SpotFleetRequestIds,
		["DryRun"] = _DryRun,
		["TerminateInstances"] = _TerminateInstances,
	}
	asserts.AssertCancelSpotFleetRequestsRequest(t)
	return t
end

keys.DiskImage = { ["Volume"] = true, ["Image"] = true, ["Description"] = true, nil }

function asserts.AssertDiskImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImage to be of type 'table'")
	if struct["Volume"] then asserts.AssertVolumeDetail(struct["Volume"]) end
	if struct["Image"] then asserts.AssertDiskImageDetail(struct["Image"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImage[k], "DiskImage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImage
-- <p>Describes a disk image.</p>
-- @param _Volume [VolumeDetail] <p>Information about the volume.</p>
-- @param _Image [DiskImageDetail] <p>Information about the disk image.</p>
-- @param _Description [String] <p>A description of the disk image.</p>
function M.DiskImage(_Volume, _Image, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DiskImage")
	local t = { 
		["Volume"] = _Volume,
		["Image"] = _Image,
		["Description"] = _Description,
	}
	asserts.AssertDiskImage(t)
	return t
end

keys.AttachInternetGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertAttachInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachInternetGatewayRequest[k], "AttachInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachInternetGatewayRequest
-- <p>Contains the parameters for AttachInternetGateway.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- Required parameter: InternetGatewayId
-- Required parameter: VpcId
function M.AttachInternetGatewayRequest(_VpcId, _DryRun, _InternetGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachInternetGatewayRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
		["InternetGatewayId"] = _InternetGatewayId,
	}
	asserts.AssertAttachInternetGatewayRequest(t)
	return t
end

keys.AttachClassicLinkVpcRequest = { ["InstanceId"] = true, ["VpcId"] = true, ["DryRun"] = true, ["Groups"] = true, nil }

function asserts.AssertAttachClassicLinkVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachClassicLinkVpcRequest to be of type 'table'")
	assert(struct["Groups"], "Expected key Groups to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Groups"] then asserts.AssertGroupIdStringList(struct["Groups"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachClassicLinkVpcRequest[k], "AttachClassicLinkVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachClassicLinkVpcRequest
-- <p>Contains the parameters for AttachClassicLinkVpc.</p>
-- @param _InstanceId [String] <p>The ID of an EC2-Classic instance to link to the ClassicLink-enabled VPC.</p>
-- @param _VpcId [String] <p>The ID of a ClassicLink-enabled VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Groups [GroupIdStringList] <p>The ID of one or more of the VPC's security groups. You cannot specify security groups from a different VPC.</p>
-- Required parameter: Groups
-- Required parameter: InstanceId
-- Required parameter: VpcId
function M.AttachClassicLinkVpcRequest(_InstanceId, _VpcId, _DryRun, _Groups, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachClassicLinkVpcRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
		["Groups"] = _Groups,
	}
	asserts.AssertAttachClassicLinkVpcRequest(t)
	return t
end

keys.Storage = { ["S3"] = true, nil }

function asserts.AssertStorage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Storage to be of type 'table'")
	if struct["S3"] then asserts.AssertS3Storage(struct["S3"]) end
	for k,_ in pairs(struct) do
		assert(keys.Storage[k], "Storage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Storage
-- <p>Describes the storage location for an instance store-backed AMI.</p>
-- @param _S3 [S3Storage] <p>An Amazon S3 storage location.</p>
function M.Storage(_S3, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Storage")
	local t = { 
		["S3"] = _S3,
	}
	asserts.AssertStorage(t)
	return t
end

keys.DescribeMovingAddressesRequest = { ["PublicIps"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeMovingAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMovingAddressesRequest to be of type 'table'")
	if struct["PublicIps"] then asserts.AssertValueStringList(struct["PublicIps"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMovingAddressesRequest[k], "DescribeMovingAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMovingAddressesRequest
-- <p>Contains the parameters for DescribeMovingAddresses.</p>
-- @param _PublicIps [ValueStringList] <p>One or more Elastic IP addresses.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value outside of this range, an error is returned.</p> <p>Default: If no value is provided, the default is 1000.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>moving-status</code> - The status of the Elastic IP address (<code>MovingToVpc</code> | <code>RestoringToClassic</code>).</p> </li> </ul>
function M.DescribeMovingAddressesRequest(_PublicIps, _NextToken, _DryRun, _MaxResults, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeMovingAddressesRequest")
	local t = { 
		["PublicIps"] = _PublicIps,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeMovingAddressesRequest(t)
	return t
end

keys.CopySnapshotRequest = { ["DryRun"] = true, ["Description"] = true, ["Encrypted"] = true, ["PresignedUrl"] = true, ["SourceRegion"] = true, ["KmsKeyId"] = true, ["SourceSnapshotId"] = true, ["DestinationRegion"] = true, nil }

function asserts.AssertCopySnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopySnapshotRequest to be of type 'table'")
	assert(struct["SourceRegion"], "Expected key SourceRegion to exist in table")
	assert(struct["SourceSnapshotId"], "Expected key SourceSnapshotId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["PresignedUrl"] then asserts.AssertString(struct["PresignedUrl"]) end
	if struct["SourceRegion"] then asserts.AssertString(struct["SourceRegion"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["SourceSnapshotId"] then asserts.AssertString(struct["SourceSnapshotId"]) end
	if struct["DestinationRegion"] then asserts.AssertString(struct["DestinationRegion"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopySnapshotRequest[k], "CopySnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopySnapshotRequest
-- <p>Contains the parameters for CopySnapshot.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>A description for the EBS snapshot.</p>
-- @param _Encrypted [Boolean] <p>Specifies whether the destination snapshot should be encrypted. You can encrypt a copy of an unencrypted snapshot using this flag, but you cannot use it to create an unencrypted copy from an encrypted snapshot. Your default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with <code>KmsKeyId</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param _PresignedUrl [String] <p>The pre-signed URL that facilitates copying an encrypted snapshot. This parameter is only required when copying an encrypted snapshot with the Amazon EC2 Query API; it is available as an optional parameter in all other cases. The <code>PresignedUrl</code> should use the snapshot source endpoint, the <code>CopySnapshot</code> action, and include the <code>SourceRegion</code>, <code>SourceSnapshotId</code>, and <code>DestinationRegion</code> parameters. The <code>PresignedUrl</code> must be signed using AWS Signature Version 4. Because EBS snapshots are stored in Amazon S3, the signing algorithm for this parameter uses the same logic that is described in <a href="http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">Authenticating Requests by Using Query Parameters (AWS Signature Version 4)</a> in the <i>Amazon Simple Storage Service API Reference</i>. An invalid or improperly signed <code>PresignedUrl</code> will cause the copy operation to fail asynchronously, and the snapshot will move to an <code>error</code> state.</p>
-- @param _SourceRegion [String] <p>The ID of the region that contains the snapshot to be copied.</p>
-- @param _KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when creating the snapshot copy. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. The specified CMK must exist in the region that the snapshot is being copied to. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set.</p>
-- @param _SourceSnapshotId [String] <p>The ID of the EBS snapshot to copy.</p>
-- @param _DestinationRegion [String] <p>The destination region to use in the <code>PresignedUrl</code> parameter of a snapshot copy operation. This parameter is only valid for specifying the destination region in a <code>PresignedUrl</code> parameter, where it is required.</p> <note> <p> <code>CopySnapshot</code> sends the snapshot copy to the regional endpoint that you send the HTTP request to, such as <code>ec2.us-east-1.amazonaws.com</code> (in the AWS CLI, this is specified with the <code>--region</code> parameter or the default region in your AWS configuration file).</p> </note>
-- Required parameter: SourceRegion
-- Required parameter: SourceSnapshotId
function M.CopySnapshotRequest(_DryRun, _Description, _Encrypted, _PresignedUrl, _SourceRegion, _KmsKeyId, _SourceSnapshotId, _DestinationRegion, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CopySnapshotRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["Encrypted"] = _Encrypted,
		["PresignedUrl"] = _PresignedUrl,
		["SourceRegion"] = _SourceRegion,
		["KmsKeyId"] = _KmsKeyId,
		["SourceSnapshotId"] = _SourceSnapshotId,
		["DestinationRegion"] = _DestinationRegion,
	}
	asserts.AssertCopySnapshotRequest(t)
	return t
end

keys.ModifyVpcPeeringConnectionOptionsRequest = { ["DryRun"] = true, ["RequesterPeeringConnectionOptions"] = true, ["VpcPeeringConnectionId"] = true, ["AccepterPeeringConnectionOptions"] = true, nil }

function asserts.AssertModifyVpcPeeringConnectionOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcPeeringConnectionOptionsRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["RequesterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptionsRequest(struct["RequesterPeeringConnectionOptions"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["AccepterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptionsRequest(struct["AccepterPeeringConnectionOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcPeeringConnectionOptionsRequest[k], "ModifyVpcPeeringConnectionOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcPeeringConnectionOptionsRequest
--  
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _RequesterPeeringConnectionOptions [PeeringConnectionOptionsRequest] <p>The VPC peering connection options for the requester VPC.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- @param _AccepterPeeringConnectionOptions [PeeringConnectionOptionsRequest] <p>The VPC peering connection options for the accepter VPC.</p>
-- Required parameter: VpcPeeringConnectionId
function M.ModifyVpcPeeringConnectionOptionsRequest(_DryRun, _RequesterPeeringConnectionOptions, _VpcPeeringConnectionId, _AccepterPeeringConnectionOptions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcPeeringConnectionOptionsRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["RequesterPeeringConnectionOptions"] = _RequesterPeeringConnectionOptions,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
		["AccepterPeeringConnectionOptions"] = _AccepterPeeringConnectionOptions,
	}
	asserts.AssertModifyVpcPeeringConnectionOptionsRequest(t)
	return t
end

keys.RequestSpotInstancesResult = { ["SpotInstanceRequests"] = true, nil }

function asserts.AssertRequestSpotInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotInstancesResult to be of type 'table'")
	if struct["SpotInstanceRequests"] then asserts.AssertSpotInstanceRequestList(struct["SpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotInstancesResult[k], "RequestSpotInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotInstancesResult
-- <p>Contains the output of RequestSpotInstances.</p>
-- @param _SpotInstanceRequests [SpotInstanceRequestList] <p>One or more Spot instance requests.</p>
function M.RequestSpotInstancesResult(_SpotInstanceRequests, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotInstancesResult")
	local t = { 
		["SpotInstanceRequests"] = _SpotInstanceRequests,
	}
	asserts.AssertRequestSpotInstancesResult(t)
	return t
end

keys.DeleteVpnGatewayRequest = { ["DryRun"] = true, ["VpnGatewayId"] = true, nil }

function asserts.AssertDeleteVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnGatewayRequest to be of type 'table'")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpnGatewayRequest[k], "DeleteVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnGatewayRequest
-- <p>Contains the parameters for DeleteVpnGateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required parameter: VpnGatewayId
function M.DeleteVpnGatewayRequest(_DryRun, _VpnGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpnGatewayRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["VpnGatewayId"] = _VpnGatewayId,
	}
	asserts.AssertDeleteVpnGatewayRequest(t)
	return t
end

keys.InstanceAttribute = { ["ProductCodes"] = true, ["SourceDestCheck"] = true, ["UserData"] = true, ["InstanceId"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["Groups"] = true, ["KernelId"] = true, ["RamdiskId"] = true, ["RootDeviceName"] = true, ["DisableApiTermination"] = true, ["InstanceType"] = true, nil }

function asserts.AssertInstanceAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceAttribute to be of type 'table'")
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["UserData"] then asserts.AssertAttributeValue(struct["UserData"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["EnaSupport"] then asserts.AssertAttributeBooleanValue(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertAttributeValue(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertInstanceBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertAttributeBooleanValue(struct["EbsOptimized"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["KernelId"] then asserts.AssertAttributeValue(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertAttributeValue(struct["RamdiskId"]) end
	if struct["RootDeviceName"] then asserts.AssertAttributeValue(struct["RootDeviceName"]) end
	if struct["DisableApiTermination"] then asserts.AssertAttributeBooleanValue(struct["DisableApiTermination"]) end
	if struct["InstanceType"] then asserts.AssertAttributeValue(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceAttribute[k], "InstanceAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceAttribute
-- <p>Describes an instance attribute.</p>
-- @param _ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- @param _SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT.</p>
-- @param _UserData [AttributeValue] <p>The user data.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _EnaSupport [AttributeBooleanValue] <p>Indicates whether enhanced networking with ENA is enabled.</p>
-- @param _SriovNetSupport [AttributeValue] <p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- @param _InstanceInitiatedShutdownBehavior [AttributeValue] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- @param _BlockDeviceMappings [InstanceBlockDeviceMappingList] <p>The block device mapping of the instance.</p>
-- @param _EbsOptimized [AttributeBooleanValue] <p>Indicates whether the instance is optimized for EBS I/O.</p>
-- @param _Groups [GroupIdentifierList] <p>The security groups associated with the instance.</p>
-- @param _KernelId [AttributeValue] <p>The kernel ID.</p>
-- @param _RamdiskId [AttributeValue] <p>The RAM disk ID.</p>
-- @param _RootDeviceName [AttributeValue] <p>The name of the root device (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p>
-- @param _DisableApiTermination [AttributeBooleanValue] <p>If the value is <code>true</code>, you can't terminate the instance through the Amazon EC2 console, CLI, or API; otherwise, you can.</p>
-- @param _InstanceType [AttributeValue] <p>The instance type.</p>
function M.InstanceAttribute(_ProductCodes, _SourceDestCheck, _UserData, _InstanceId, _EnaSupport, _SriovNetSupport, _InstanceInitiatedShutdownBehavior, _BlockDeviceMappings, _EbsOptimized, _Groups, _KernelId, _RamdiskId, _RootDeviceName, _DisableApiTermination, _InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceAttribute")
	local t = { 
		["ProductCodes"] = _ProductCodes,
		["SourceDestCheck"] = _SourceDestCheck,
		["UserData"] = _UserData,
		["InstanceId"] = _InstanceId,
		["EnaSupport"] = _EnaSupport,
		["SriovNetSupport"] = _SriovNetSupport,
		["InstanceInitiatedShutdownBehavior"] = _InstanceInitiatedShutdownBehavior,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["EbsOptimized"] = _EbsOptimized,
		["Groups"] = _Groups,
		["KernelId"] = _KernelId,
		["RamdiskId"] = _RamdiskId,
		["RootDeviceName"] = _RootDeviceName,
		["DisableApiTermination"] = _DisableApiTermination,
		["InstanceType"] = _InstanceType,
	}
	asserts.AssertInstanceAttribute(t)
	return t
end

keys.DeleteEgressOnlyInternetGatewayResult = { ["ReturnCode"] = true, nil }

function asserts.AssertDeleteEgressOnlyInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteEgressOnlyInternetGatewayResult to be of type 'table'")
	if struct["ReturnCode"] then asserts.AssertBoolean(struct["ReturnCode"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteEgressOnlyInternetGatewayResult[k], "DeleteEgressOnlyInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteEgressOnlyInternetGatewayResult
--  
-- @param _ReturnCode [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DeleteEgressOnlyInternetGatewayResult(_ReturnCode, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteEgressOnlyInternetGatewayResult")
	local t = { 
		["ReturnCode"] = _ReturnCode,
	}
	asserts.AssertDeleteEgressOnlyInternetGatewayResult(t)
	return t
end

keys.DeleteNatGatewayRequest = { ["NatGatewayId"] = true, nil }

function asserts.AssertDeleteNatGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNatGatewayRequest to be of type 'table'")
	assert(struct["NatGatewayId"], "Expected key NatGatewayId to exist in table")
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNatGatewayRequest[k], "DeleteNatGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNatGatewayRequest
-- <p>Contains the parameters for DeleteNatGateway.</p>
-- @param _NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- Required parameter: NatGatewayId
function M.DeleteNatGatewayRequest(_NatGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNatGatewayRequest")
	local t = { 
		["NatGatewayId"] = _NatGatewayId,
	}
	asserts.AssertDeleteNatGatewayRequest(t)
	return t
end

keys.CopySnapshotResult = { ["SnapshotId"] = true, nil }

function asserts.AssertCopySnapshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopySnapshotResult to be of type 'table'")
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopySnapshotResult[k], "CopySnapshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopySnapshotResult
-- <p>Contains the output of CopySnapshot.</p>
-- @param _SnapshotId [String] <p>The ID of the new snapshot.</p>
function M.CopySnapshotResult(_SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CopySnapshotResult")
	local t = { 
		["SnapshotId"] = _SnapshotId,
	}
	asserts.AssertCopySnapshotResult(t)
	return t
end

keys.InstanceBlockDeviceMappingSpecification = { ["VirtualName"] = true, ["DeviceName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertInstanceBlockDeviceMappingSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceBlockDeviceMappingSpecification to be of type 'table'")
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertEbsInstanceBlockDeviceSpecification(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceBlockDeviceMappingSpecification[k], "InstanceBlockDeviceMappingSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceBlockDeviceMappingSpecification
-- <p>Describes a block device mapping entry.</p>
-- @param _VirtualName [String] <p>The virtual device name.</p>
-- @param _DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param _NoDevice [String] <p>suppress the specified device included in the block device mapping.</p>
-- @param _Ebs [EbsInstanceBlockDeviceSpecification] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
function M.InstanceBlockDeviceMappingSpecification(_VirtualName, _DeviceName, _NoDevice, _Ebs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceBlockDeviceMappingSpecification")
	local t = { 
		["VirtualName"] = _VirtualName,
		["DeviceName"] = _DeviceName,
		["NoDevice"] = _NoDevice,
		["Ebs"] = _Ebs,
	}
	asserts.AssertInstanceBlockDeviceMappingSpecification(t)
	return t
end

keys.StartInstancesRequest = { ["AdditionalInfo"] = true, ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertStartInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["AdditionalInfo"] then asserts.AssertString(struct["AdditionalInfo"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartInstancesRequest[k], "StartInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartInstancesRequest
-- <p>Contains the parameters for StartInstances.</p>
-- @param _AdditionalInfo [String] <p>Reserved.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.StartInstancesRequest(_AdditionalInfo, _DryRun, _InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StartInstancesRequest")
	local t = { 
		["AdditionalInfo"] = _AdditionalInfo,
		["DryRun"] = _DryRun,
		["InstanceIds"] = _InstanceIds,
	}
	asserts.AssertStartInstancesRequest(t)
	return t
end

keys.DescribeIdFormatResult = { ["Statuses"] = true, nil }

function asserts.AssertDescribeIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdFormatResult to be of type 'table'")
	if struct["Statuses"] then asserts.AssertIdFormatList(struct["Statuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdFormatResult[k], "DescribeIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdFormatResult
-- <p>Contains the output of DescribeIdFormat.</p>
-- @param _Statuses [IdFormatList] <p>Information about the ID format for the resource.</p>
function M.DescribeIdFormatResult(_Statuses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIdFormatResult")
	local t = { 
		["Statuses"] = _Statuses,
	}
	asserts.AssertDescribeIdFormatResult(t)
	return t
end

keys.CancelReservedInstancesListingResult = { ["ReservedInstancesListings"] = true, nil }

function asserts.AssertCancelReservedInstancesListingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelReservedInstancesListingResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then asserts.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelReservedInstancesListingResult[k], "CancelReservedInstancesListingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelReservedInstancesListingResult
-- <p>Contains the output of CancelReservedInstancesListing.</p>
-- @param _ReservedInstancesListings [ReservedInstancesListingList] <p>The Reserved Instance listing.</p>
function M.CancelReservedInstancesListingResult(_ReservedInstancesListings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelReservedInstancesListingResult")
	local t = { 
		["ReservedInstancesListings"] = _ReservedInstancesListings,
	}
	asserts.AssertCancelReservedInstancesListingResult(t)
	return t
end

keys.RestoreAddressToClassicResult = { ["PublicIp"] = true, ["Status"] = true, nil }

function asserts.AssertRestoreAddressToClassicResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RestoreAddressToClassicResult to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["Status"] then asserts.AssertStatus(struct["Status"]) end
	for k,_ in pairs(struct) do
		assert(keys.RestoreAddressToClassicResult[k], "RestoreAddressToClassicResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RestoreAddressToClassicResult
-- <p>Contains the output of RestoreAddressToClassic.</p>
-- @param _PublicIp [String] <p>The Elastic IP address.</p>
-- @param _Status [Status] <p>The move status for the IP address.</p>
function M.RestoreAddressToClassicResult(_PublicIp, _Status, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RestoreAddressToClassicResult")
	local t = { 
		["PublicIp"] = _PublicIp,
		["Status"] = _Status,
	}
	asserts.AssertRestoreAddressToClassicResult(t)
	return t
end

keys.PrefixListId = { ["PrefixListId"] = true, nil }

function asserts.AssertPrefixListId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrefixListId to be of type 'table'")
	if struct["PrefixListId"] then asserts.AssertString(struct["PrefixListId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrefixListId[k], "PrefixListId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrefixListId
-- <p>The ID of the prefix.</p>
-- @param _PrefixListId [String] <p>The ID of the prefix.</p>
function M.PrefixListId(_PrefixListId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PrefixListId")
	local t = { 
		["PrefixListId"] = _PrefixListId,
	}
	asserts.AssertPrefixListId(t)
	return t
end

keys.Placement = { ["HostId"] = true, ["AvailabilityZone"] = true, ["SpreadDomain"] = true, ["GroupName"] = true, ["Tenancy"] = true, ["Affinity"] = true, nil }

function asserts.AssertPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Placement to be of type 'table'")
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["SpreadDomain"] then asserts.AssertString(struct["SpreadDomain"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["Tenancy"] then asserts.AssertTenancy(struct["Tenancy"]) end
	if struct["Affinity"] then asserts.AssertString(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(keys.Placement[k], "Placement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Placement
-- <p>Describes the placement of an instance.</p>
-- @param _HostId [String] <p>The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the <a>ImportInstance</a> command.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone of the instance.</p>
-- @param _SpreadDomain [String] <p>Reserved for future use.</p>
-- @param _GroupName [String] <p>The name of the placement group the instance is in (for cluster compute instances).</p>
-- @param _Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for the <a>ImportInstance</a> command.</p>
-- @param _Affinity [String] <p>The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the <a>ImportInstance</a> command.</p>
function M.Placement(_HostId, _AvailabilityZone, _SpreadDomain, _GroupName, _Tenancy, _Affinity, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Placement")
	local t = { 
		["HostId"] = _HostId,
		["AvailabilityZone"] = _AvailabilityZone,
		["SpreadDomain"] = _SpreadDomain,
		["GroupName"] = _GroupName,
		["Tenancy"] = _Tenancy,
		["Affinity"] = _Affinity,
	}
	asserts.AssertPlacement(t)
	return t
end

keys.ScheduledInstancesBlockDeviceMapping = { ["VirtualName"] = true, ["DeviceName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertScheduledInstancesBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesBlockDeviceMapping to be of type 'table'")
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertScheduledInstancesEbs(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesBlockDeviceMapping[k], "ScheduledInstancesBlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesBlockDeviceMapping
-- <p>Describes a block device mapping for a Scheduled Instance.</p>
-- @param _VirtualName [String] <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with two available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
-- @param _DeviceName [String] <p>The device name exposed to the instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- @param _NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- @param _Ebs [ScheduledInstancesEbs] <p>Parameters used to set up EBS volumes automatically when the instance is launched.</p>
function M.ScheduledInstancesBlockDeviceMapping(_VirtualName, _DeviceName, _NoDevice, _Ebs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesBlockDeviceMapping")
	local t = { 
		["VirtualName"] = _VirtualName,
		["DeviceName"] = _DeviceName,
		["NoDevice"] = _NoDevice,
		["Ebs"] = _Ebs,
	}
	asserts.AssertScheduledInstancesBlockDeviceMapping(t)
	return t
end

keys.CreateVolumePermissionModifications = { ["Add"] = true, ["Remove"] = true, nil }

function asserts.AssertCreateVolumePermissionModifications(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumePermissionModifications to be of type 'table'")
	if struct["Add"] then asserts.AssertCreateVolumePermissionList(struct["Add"]) end
	if struct["Remove"] then asserts.AssertCreateVolumePermissionList(struct["Remove"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVolumePermissionModifications[k], "CreateVolumePermissionModifications contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumePermissionModifications
-- <p>Describes modifications to the permissions for a volume.</p>
-- @param _Add [CreateVolumePermissionList] <p>Adds a specific AWS account ID or group to a volume's list of create volume permissions.</p>
-- @param _Remove [CreateVolumePermissionList] <p>Removes a specific AWS account ID or group from a volume's list of create volume permissions.</p>
function M.CreateVolumePermissionModifications(_Add, _Remove, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVolumePermissionModifications")
	local t = { 
		["Add"] = _Add,
		["Remove"] = _Remove,
	}
	asserts.AssertCreateVolumePermissionModifications(t)
	return t
end

keys.EbsBlockDevice = { ["VolumeSize"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["DeleteOnTermination"] = true, ["SnapshotId"] = true, ["Iops"] = true, nil }

function asserts.AssertEbsBlockDevice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsBlockDevice to be of type 'table'")
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	for k,_ in pairs(struct) do
		assert(keys.EbsBlockDevice[k], "EbsBlockDevice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsBlockDevice
-- <p>Describes a block device for an EBS volume.</p>
-- @param _VolumeSize [Integer] <p>The size of the volume, in GiB.</p> <p>Constraints: 1-16384 for General Purpose SSD (<code>gp2</code>), 4-16384 for Provisioned IOPS SSD (<code>io1</code>), 500-16384 for Throughput Optimized HDD (<code>st1</code>), 500-16384 for Cold HDD (<code>sc1</code>), and 1-1024 for Magnetic (<code>standard</code>) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- @param _Encrypted [Boolean] <p>Indicates whether the EBS volume is encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption.</p>
-- @param _VolumeType [VolumeType] <p>The volume type: <code>gp2</code>, <code>io1</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code>.</p> <p>Default: <code>standard</code> </p>
-- @param _DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- @param _SnapshotId [String] <p>The ID of the snapshot.</p>
-- @param _Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For <code>io1</code>, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code>, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for <code>io1</code> volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
function M.EbsBlockDevice(_VolumeSize, _Encrypted, _VolumeType, _DeleteOnTermination, _SnapshotId, _Iops, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EbsBlockDevice")
	local t = { 
		["VolumeSize"] = _VolumeSize,
		["Encrypted"] = _Encrypted,
		["VolumeType"] = _VolumeType,
		["DeleteOnTermination"] = _DeleteOnTermination,
		["SnapshotId"] = _SnapshotId,
		["Iops"] = _Iops,
	}
	asserts.AssertEbsBlockDevice(t)
	return t
end

keys.TargetConfiguration = { ["InstanceCount"] = true, ["OfferingId"] = true, nil }

function asserts.AssertTargetConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetConfiguration to be of type 'table'")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetConfiguration[k], "TargetConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetConfiguration
-- <p>Information about the Convertible Reserved Instance offering.</p>
-- @param _InstanceCount [Integer] <p>The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>
-- @param _OfferingId [String] <p>The ID of the Convertible Reserved Instance offering.</p>
function M.TargetConfiguration(_InstanceCount, _OfferingId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TargetConfiguration")
	local t = { 
		["InstanceCount"] = _InstanceCount,
		["OfferingId"] = _OfferingId,
	}
	asserts.AssertTargetConfiguration(t)
	return t
end

keys.DescribeVolumesModificationsRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["VolumeIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVolumesModificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesModificationsRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeIds"] then asserts.AssertVolumeIdStringList(struct["VolumeIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesModificationsRequest[k], "DescribeVolumesModificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesModificationsRequest
--  
-- @param _MaxResults [Integer] <p>The maximum number of results (up to a limit of 500) to be returned in a paginated request.</p>
-- @param _NextToken [String] <p>The <code>nextToken</code> value returned by a previous paginated request.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VolumeIds [VolumeIdStringList] <p>One or more volume IDs for which in-progress modifications will be described.</p>
-- @param _Filters [FilterList] <p>One or more filters. Supported filters: <code>volume-id</code>, <code>modification-state</code>, <code>target-size</code>, <code>target-iops</code>, <code>target-volume-type</code>, <code>original-size</code>, <code>original-iops</code>, <code>original-volume-type</code>, <code>start-time</code>. </p>
function M.DescribeVolumesModificationsRequest(_MaxResults, _NextToken, _DryRun, _VolumeIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumesModificationsRequest")
	local t = { 
		["MaxResults"] = _MaxResults,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["VolumeIds"] = _VolumeIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeVolumesModificationsRequest(t)
	return t
end

keys.UserData = { ["Data"] = true, nil }

function asserts.AssertUserData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserData to be of type 'table'")
	if struct["Data"] then asserts.AssertString(struct["Data"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserData[k], "UserData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserData
-- <p>Describes the user data for an instance.</p>
-- @param _Data [String] <p>The user data. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
function M.UserData(_Data, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UserData")
	local t = { 
		["Data"] = _Data,
	}
	asserts.AssertUserData(t)
	return t
end

keys.ImportInstanceVolumeDetailItem = { ["Status"] = true, ["AvailabilityZone"] = true, ["Description"] = true, ["Image"] = true, ["Volume"] = true, ["BytesConverted"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertImportInstanceVolumeDetailItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceVolumeDetailItem to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["BytesConverted"], "Expected key BytesConverted to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Status"], "Expected key Status to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Image"] then asserts.AssertDiskImageDescription(struct["Image"]) end
	if struct["Volume"] then asserts.AssertDiskImageVolumeDescription(struct["Volume"]) end
	if struct["BytesConverted"] then asserts.AssertLong(struct["BytesConverted"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceVolumeDetailItem[k], "ImportInstanceVolumeDetailItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceVolumeDetailItem
-- <p>Describes an import volume task.</p>
-- @param _Status [String] <p>The status of the import of this particular disk image.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone where the resulting instance will reside.</p>
-- @param _Description [String] <p>A description of the task.</p>
-- @param _Image [DiskImageDescription] <p>The image.</p>
-- @param _Volume [DiskImageVolumeDescription] <p>The volume.</p>
-- @param _BytesConverted [Long] <p>The number of bytes converted so far.</p>
-- @param _StatusMessage [String] <p>The status information or errors related to the disk image.</p>
-- Required parameter: AvailabilityZone
-- Required parameter: BytesConverted
-- Required parameter: Image
-- Required parameter: Status
-- Required parameter: Volume
function M.ImportInstanceVolumeDetailItem(_Status, _AvailabilityZone, _Description, _Image, _Volume, _BytesConverted, _StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportInstanceVolumeDetailItem")
	local t = { 
		["Status"] = _Status,
		["AvailabilityZone"] = _AvailabilityZone,
		["Description"] = _Description,
		["Image"] = _Image,
		["Volume"] = _Volume,
		["BytesConverted"] = _BytesConverted,
		["StatusMessage"] = _StatusMessage,
	}
	asserts.AssertImportInstanceVolumeDetailItem(t)
	return t
end

keys.DescribeReservedInstancesModificationsRequest = { ["NextToken"] = true, ["ReservedInstancesModificationIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeReservedInstancesModificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesModificationsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesModificationIds"] then asserts.AssertReservedInstancesModificationIdStringList(struct["ReservedInstancesModificationIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesModificationsRequest[k], "DescribeReservedInstancesModificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesModificationsRequest
-- <p>Contains the parameters for DescribeReservedInstancesModifications.</p>
-- @param _NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param _ReservedInstancesModificationIds [ReservedInstancesModificationIdStringList] <p>IDs for the submitted modification request.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>client-token</code> - The idempotency token for the modification request.</p> </li> <li> <p> <code>create-date</code> - The time when the modification request was created.</p> </li> <li> <p> <code>effective-date</code> - The time when the modification becomes effective.</p> </li> <li> <p> <code>modification-result.reserved-instances-id</code> - The ID for the Reserved Instances created as part of the modification request. This ID is only available when the status of the modification is <code>fulfilled</code>.</p> </li> <li> <p> <code>modification-result.target-configuration.availability-zone</code> - The Availability Zone for the new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.instance-count </code> - The number of new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.instance-type</code> - The instance type of the new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.platform</code> - The network platform of the new Reserved Instances (<code>EC2-Classic</code> | <code>EC2-VPC</code>).</p> </li> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instances modified.</p> </li> <li> <p> <code>reserved-instances-modification-id</code> - The ID of the modification request.</p> </li> <li> <p> <code>status</code> - The status of the Reserved Instances modification request (<code>processing</code> | <code>fulfilled</code> | <code>failed</code>).</p> </li> <li> <p> <code>status-message</code> - The reason for the status.</p> </li> <li> <p> <code>update-date</code> - The time when the modification request was last updated.</p> </li> </ul>
function M.DescribeReservedInstancesModificationsRequest(_NextToken, _ReservedInstancesModificationIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesModificationsRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["ReservedInstancesModificationIds"] = _ReservedInstancesModificationIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeReservedInstancesModificationsRequest(t)
	return t
end

keys.DescribeIdFormatRequest = { ["Resource"] = true, nil }

function asserts.AssertDescribeIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdFormatRequest to be of type 'table'")
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdFormatRequest[k], "DescribeIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdFormatRequest
-- <p>Contains the parameters for DescribeIdFormat.</p>
-- @param _Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
function M.DescribeIdFormatRequest(_Resource, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIdFormatRequest")
	local t = { 
		["Resource"] = _Resource,
	}
	asserts.AssertDescribeIdFormatRequest(t)
	return t
end

keys.CreateSecurityGroupRequest = { ["GroupName"] = true, ["VpcId"] = true, ["DryRun"] = true, ["Description"] = true, nil }

function asserts.AssertCreateSecurityGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityGroupRequest to be of type 'table'")
	assert(struct["Description"], "Expected key Description to exist in table")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSecurityGroupRequest[k], "CreateSecurityGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityGroupRequest
-- <p>Contains the parameters for CreateSecurityGroup.</p>
-- @param _GroupName [String] <p>The name of the security group.</p> <p>Constraints: Up to 255 characters in length</p> <p>Constraints for EC2-Classic: ASCII characters</p> <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
-- @param _VpcId [String] <p>[EC2-VPC] The ID of the VPC. Required for EC2-VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>A description for the security group. This is informational only.</p> <p>Constraints: Up to 255 characters in length</p> <p>Constraints for EC2-Classic: ASCII characters</p> <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
-- Required parameter: Description
-- Required parameter: GroupName
function M.CreateSecurityGroupRequest(_GroupName, _VpcId, _DryRun, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSecurityGroupRequest")
	local t = { 
		["GroupName"] = _GroupName,
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
		["Description"] = _Description,
	}
	asserts.AssertCreateSecurityGroupRequest(t)
	return t
end

keys.BundleTaskError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertBundleTaskError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleTaskError to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleTaskError[k], "BundleTaskError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleTaskError
-- <p>Describes an error for <a>BundleInstance</a>.</p>
-- @param _Message [String] <p>The error message.</p>
-- @param _Code [String] <p>The error code.</p>
function M.BundleTaskError(_Message, _Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating BundleTaskError")
	local t = { 
		["Message"] = _Message,
		["Code"] = _Code,
	}
	asserts.AssertBundleTaskError(t)
	return t
end

keys.CreateFlowLogsRequest = { ["ResourceType"] = true, ["LogGroupName"] = true, ["TrafficType"] = true, ["ResourceIds"] = true, ["DeliverLogsPermissionArn"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFlowLogsRequest to be of type 'table'")
	assert(struct["DeliverLogsPermissionArn"], "Expected key DeliverLogsPermissionArn to exist in table")
	assert(struct["LogGroupName"], "Expected key LogGroupName to exist in table")
	assert(struct["ResourceIds"], "Expected key ResourceIds to exist in table")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	assert(struct["TrafficType"], "Expected key TrafficType to exist in table")
	if struct["ResourceType"] then asserts.AssertFlowLogsResourceType(struct["ResourceType"]) end
	if struct["LogGroupName"] then asserts.AssertString(struct["LogGroupName"]) end
	if struct["TrafficType"] then asserts.AssertTrafficType(struct["TrafficType"]) end
	if struct["ResourceIds"] then asserts.AssertValueStringList(struct["ResourceIds"]) end
	if struct["DeliverLogsPermissionArn"] then asserts.AssertString(struct["DeliverLogsPermissionArn"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFlowLogsRequest[k], "CreateFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFlowLogsRequest
-- <p>Contains the parameters for CreateFlowLogs.</p>
-- @param _ResourceType [FlowLogsResourceType] <p>The type of resource on which to create the flow log.</p>
-- @param _LogGroupName [String] <p>The name of the CloudWatch log group.</p>
-- @param _TrafficType [TrafficType] <p>The type of traffic to log.</p>
-- @param _ResourceIds [ValueStringList] <p>One or more subnet, network interface, or VPC IDs.</p> <p>Constraints: Maximum of 1000 resources</p>
-- @param _DeliverLogsPermissionArn [String] <p>The ARN for the IAM role that's used to post flow logs to a CloudWatch Logs log group.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required parameter: DeliverLogsPermissionArn
-- Required parameter: LogGroupName
-- Required parameter: ResourceIds
-- Required parameter: ResourceType
-- Required parameter: TrafficType
function M.CreateFlowLogsRequest(_ResourceType, _LogGroupName, _TrafficType, _ResourceIds, _DeliverLogsPermissionArn, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateFlowLogsRequest")
	local t = { 
		["ResourceType"] = _ResourceType,
		["LogGroupName"] = _LogGroupName,
		["TrafficType"] = _TrafficType,
		["ResourceIds"] = _ResourceIds,
		["DeliverLogsPermissionArn"] = _DeliverLogsPermissionArn,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertCreateFlowLogsRequest(t)
	return t
end

keys.S3Storage = { ["UploadPolicySignature"] = true, ["Prefix"] = true, ["AWSAccessKeyId"] = true, ["Bucket"] = true, ["UploadPolicy"] = true, nil }

function asserts.AssertS3Storage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected S3Storage to be of type 'table'")
	if struct["UploadPolicySignature"] then asserts.AssertString(struct["UploadPolicySignature"]) end
	if struct["Prefix"] then asserts.AssertString(struct["Prefix"]) end
	if struct["AWSAccessKeyId"] then asserts.AssertString(struct["AWSAccessKeyId"]) end
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	if struct["UploadPolicy"] then asserts.AssertBlob(struct["UploadPolicy"]) end
	for k,_ in pairs(struct) do
		assert(keys.S3Storage[k], "S3Storage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type S3Storage
-- <p>Describes the storage parameters for S3 and S3 buckets for an instance store-backed AMI.</p>
-- @param _UploadPolicySignature [String] <p>The signature of the JSON document.</p>
-- @param _Prefix [String] <p>The beginning of the file name of the AMI.</p>
-- @param _AWSAccessKeyId [String] <p>The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance in <a href="http://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html">Best Practices for Managing AWS Access Keys</a>.</p>
-- @param _Bucket [String] <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
-- @param _UploadPolicy [Blob] <p>An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.</p>
function M.S3Storage(_UploadPolicySignature, _Prefix, _AWSAccessKeyId, _Bucket, _UploadPolicy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating S3Storage")
	local t = { 
		["UploadPolicySignature"] = _UploadPolicySignature,
		["Prefix"] = _Prefix,
		["AWSAccessKeyId"] = _AWSAccessKeyId,
		["Bucket"] = _Bucket,
		["UploadPolicy"] = _UploadPolicy,
	}
	asserts.AssertS3Storage(t)
	return t
end

keys.EnableVgwRoutePropagationRequest = { ["GatewayId"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertEnableVgwRoutePropagationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVgwRoutePropagationRequest to be of type 'table'")
	assert(struct["GatewayId"], "Expected key GatewayId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVgwRoutePropagationRequest[k], "EnableVgwRoutePropagationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVgwRoutePropagationRequest
-- <p>Contains the parameters for EnableVgwRoutePropagation.</p>
-- @param _GatewayId [String] <p>The ID of the virtual private gateway.</p>
-- @param _RouteTableId [String] <p>The ID of the route table.</p>
-- Required parameter: GatewayId
-- Required parameter: RouteTableId
function M.EnableVgwRoutePropagationRequest(_GatewayId, _RouteTableId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVgwRoutePropagationRequest")
	local t = { 
		["GatewayId"] = _GatewayId,
		["RouteTableId"] = _RouteTableId,
	}
	asserts.AssertEnableVgwRoutePropagationRequest(t)
	return t
end

keys.IamInstanceProfileAssociation = { ["InstanceId"] = true, ["Timestamp"] = true, ["State"] = true, ["AssociationId"] = true, ["IamInstanceProfile"] = true, nil }

function asserts.AssertIamInstanceProfileAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfileAssociation to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	if struct["State"] then asserts.AssertIamInstanceProfileAssociationState(struct["State"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfile(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(keys.IamInstanceProfileAssociation[k], "IamInstanceProfileAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfileAssociation
-- <p>Describes an association between an IAM instance profile and an instance.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _Timestamp [DateTime] <p>The time the IAM instance profile was associated with the instance.</p>
-- @param _State [IamInstanceProfileAssociationState] <p>The state of the association.</p>
-- @param _AssociationId [String] <p>The ID of the association.</p>
-- @param _IamInstanceProfile [IamInstanceProfile] <p>The IAM instance profile.</p>
function M.IamInstanceProfileAssociation(_InstanceId, _Timestamp, _State, _AssociationId, _IamInstanceProfile, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IamInstanceProfileAssociation")
	local t = { 
		["InstanceId"] = _InstanceId,
		["Timestamp"] = _Timestamp,
		["State"] = _State,
		["AssociationId"] = _AssociationId,
		["IamInstanceProfile"] = _IamInstanceProfile,
	}
	asserts.AssertIamInstanceProfileAssociation(t)
	return t
end

keys.ScheduledInstance = { ["AvailabilityZone"] = true, ["ScheduledInstanceId"] = true, ["HourlyPrice"] = true, ["CreateDate"] = true, ["Recurrence"] = true, ["Platform"] = true, ["TermEndDate"] = true, ["InstanceCount"] = true, ["SlotDurationInHours"] = true, ["PreviousSlotEndTime"] = true, ["TermStartDate"] = true, ["NetworkPlatform"] = true, ["TotalScheduledInstanceHours"] = true, ["NextSlotStartTime"] = true, ["InstanceType"] = true, nil }

function asserts.AssertScheduledInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstance to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["ScheduledInstanceId"] then asserts.AssertString(struct["ScheduledInstanceId"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["Recurrence"] then asserts.AssertScheduledInstanceRecurrence(struct["Recurrence"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["TermEndDate"] then asserts.AssertDateTime(struct["TermEndDate"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["SlotDurationInHours"] then asserts.AssertInteger(struct["SlotDurationInHours"]) end
	if struct["PreviousSlotEndTime"] then asserts.AssertDateTime(struct["PreviousSlotEndTime"]) end
	if struct["TermStartDate"] then asserts.AssertDateTime(struct["TermStartDate"]) end
	if struct["NetworkPlatform"] then asserts.AssertString(struct["NetworkPlatform"]) end
	if struct["TotalScheduledInstanceHours"] then asserts.AssertInteger(struct["TotalScheduledInstanceHours"]) end
	if struct["NextSlotStartTime"] then asserts.AssertDateTime(struct["NextSlotStartTime"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstance[k], "ScheduledInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstance
-- <p>Describes a Scheduled Instance.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone.</p>
-- @param _ScheduledInstanceId [String] <p>The Scheduled Instance ID.</p>
-- @param _HourlyPrice [String] <p>The hourly price for a single instance.</p>
-- @param _CreateDate [DateTime] <p>The date when the Scheduled Instance was purchased.</p>
-- @param _Recurrence [ScheduledInstanceRecurrence] <p>The schedule recurrence.</p>
-- @param _Platform [String] <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
-- @param _TermEndDate [DateTime] <p>The end date for the Scheduled Instance.</p>
-- @param _InstanceCount [Integer] <p>The number of instances.</p>
-- @param _SlotDurationInHours [Integer] <p>The number of hours in the schedule.</p>
-- @param _PreviousSlotEndTime [DateTime] <p>The time that the previous schedule ended or will end.</p>
-- @param _TermStartDate [DateTime] <p>The start date for the Scheduled Instance.</p>
-- @param _NetworkPlatform [String] <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
-- @param _TotalScheduledInstanceHours [Integer] <p>The total number of hours for a single instance for the entire term.</p>
-- @param _NextSlotStartTime [DateTime] <p>The time for the next schedule to start.</p>
-- @param _InstanceType [String] <p>The instance type.</p>
function M.ScheduledInstance(_AvailabilityZone, _ScheduledInstanceId, _HourlyPrice, _CreateDate, _Recurrence, _Platform, _TermEndDate, _InstanceCount, _SlotDurationInHours, _PreviousSlotEndTime, _TermStartDate, _NetworkPlatform, _TotalScheduledInstanceHours, _NextSlotStartTime, _InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstance")
	local t = { 
		["AvailabilityZone"] = _AvailabilityZone,
		["ScheduledInstanceId"] = _ScheduledInstanceId,
		["HourlyPrice"] = _HourlyPrice,
		["CreateDate"] = _CreateDate,
		["Recurrence"] = _Recurrence,
		["Platform"] = _Platform,
		["TermEndDate"] = _TermEndDate,
		["InstanceCount"] = _InstanceCount,
		["SlotDurationInHours"] = _SlotDurationInHours,
		["PreviousSlotEndTime"] = _PreviousSlotEndTime,
		["TermStartDate"] = _TermStartDate,
		["NetworkPlatform"] = _NetworkPlatform,
		["TotalScheduledInstanceHours"] = _TotalScheduledInstanceHours,
		["NextSlotStartTime"] = _NextSlotStartTime,
		["InstanceType"] = _InstanceType,
	}
	asserts.AssertScheduledInstance(t)
	return t
end

keys.HostInstance = { ["InstanceId"] = true, ["InstanceType"] = true, nil }

function asserts.AssertHostInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostInstance to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostInstance[k], "HostInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostInstance
-- <p>Describes an instance running on a Dedicated Host.</p>
-- @param _InstanceId [String] <p>the IDs of instances that are running on the Dedicated Host.</p>
-- @param _InstanceType [String] <p>The instance type size (for example, <code>m3.medium</code>) of the running instance.</p>
function M.HostInstance(_InstanceId, _InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HostInstance")
	local t = { 
		["InstanceId"] = _InstanceId,
		["InstanceType"] = _InstanceType,
	}
	asserts.AssertHostInstance(t)
	return t
end

keys.Monitoring = { ["State"] = true, nil }

function asserts.AssertMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Monitoring to be of type 'table'")
	if struct["State"] then asserts.AssertMonitoringState(struct["State"]) end
	for k,_ in pairs(struct) do
		assert(keys.Monitoring[k], "Monitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Monitoring
-- <p>Describes the monitoring of an instance.</p>
-- @param _State [MonitoringState] <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
function M.Monitoring(_State, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Monitoring")
	local t = { 
		["State"] = _State,
	}
	asserts.AssertMonitoring(t)
	return t
end

keys.AttachVpnGatewayResult = { ["VpcAttachment"] = true, nil }

function asserts.AssertAttachVpnGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVpnGatewayResult to be of type 'table'")
	if struct["VpcAttachment"] then asserts.AssertVpcAttachment(struct["VpcAttachment"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachVpnGatewayResult[k], "AttachVpnGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVpnGatewayResult
-- <p>Contains the output of AttachVpnGateway.</p>
-- @param _VpcAttachment [VpcAttachment] <p>Information about the attachment.</p>
function M.AttachVpnGatewayResult(_VpcAttachment, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachVpnGatewayResult")
	local t = { 
		["VpcAttachment"] = _VpcAttachment,
	}
	asserts.AssertAttachVpnGatewayResult(t)
	return t
end

keys.DeletePlacementGroupRequest = { ["GroupName"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeletePlacementGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeletePlacementGroupRequest to be of type 'table'")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeletePlacementGroupRequest[k], "DeletePlacementGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeletePlacementGroupRequest
-- <p>Contains the parameters for DeletePlacementGroup.</p>
-- @param _GroupName [String] <p>The name of the placement group.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: GroupName
function M.DeletePlacementGroupRequest(_GroupName, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeletePlacementGroupRequest")
	local t = { 
		["GroupName"] = _GroupName,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeletePlacementGroupRequest(t)
	return t
end

keys.MoveAddressToVpcRequest = { ["PublicIp"] = true, ["DryRun"] = true, nil }

function asserts.AssertMoveAddressToVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MoveAddressToVpcRequest to be of type 'table'")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.MoveAddressToVpcRequest[k], "MoveAddressToVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MoveAddressToVpcRequest
-- <p>Contains the parameters for MoveAddressToVpc.</p>
-- @param _PublicIp [String] <p>The Elastic IP address.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: PublicIp
function M.MoveAddressToVpcRequest(_PublicIp, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MoveAddressToVpcRequest")
	local t = { 
		["PublicIp"] = _PublicIp,
		["DryRun"] = _DryRun,
	}
	asserts.AssertMoveAddressToVpcRequest(t)
	return t
end

keys.CreateNatGatewayResult = { ["NatGateway"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateNatGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNatGatewayResult to be of type 'table'")
	if struct["NatGateway"] then asserts.AssertNatGateway(struct["NatGateway"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNatGatewayResult[k], "CreateNatGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNatGatewayResult
-- <p>Contains the output of CreateNatGateway.</p>
-- @param _NatGateway [NatGateway] <p>Information about the NAT gateway.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.</p>
function M.CreateNatGatewayResult(_NatGateway, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNatGatewayResult")
	local t = { 
		["NatGateway"] = _NatGateway,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertCreateNatGatewayResult(t)
	return t
end

keys.DisassociateSubnetCidrBlockRequest = { ["AssociationId"] = true, nil }

function asserts.AssertDisassociateSubnetCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateSubnetCidrBlockRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateSubnetCidrBlockRequest[k], "DisassociateSubnetCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateSubnetCidrBlockRequest
--  
-- @param _AssociationId [String] <p>The association ID for the CIDR block.</p>
-- Required parameter: AssociationId
function M.DisassociateSubnetCidrBlockRequest(_AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateSubnetCidrBlockRequest")
	local t = { 
		["AssociationId"] = _AssociationId,
	}
	asserts.AssertDisassociateSubnetCidrBlockRequest(t)
	return t
end

keys.InternetGateway = { ["Tags"] = true, ["Attachments"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertInternetGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InternetGateway to be of type 'table'")
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Attachments"] then asserts.AssertInternetGatewayAttachmentList(struct["Attachments"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.InternetGateway[k], "InternetGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InternetGateway
-- <p>Describes an Internet gateway.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the Internet gateway.</p>
-- @param _Attachments [InternetGatewayAttachmentList] <p>Any VPCs attached to the Internet gateway.</p>
-- @param _InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
function M.InternetGateway(_Tags, _Attachments, _InternetGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InternetGateway")
	local t = { 
		["Tags"] = _Tags,
		["Attachments"] = _Attachments,
		["InternetGatewayId"] = _InternetGatewayId,
	}
	asserts.AssertInternetGateway(t)
	return t
end

keys.AccountAttribute = { ["AttributeName"] = true, ["AttributeValues"] = true, nil }

function asserts.AssertAccountAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AccountAttribute to be of type 'table'")
	if struct["AttributeName"] then asserts.AssertString(struct["AttributeName"]) end
	if struct["AttributeValues"] then asserts.AssertAccountAttributeValueList(struct["AttributeValues"]) end
	for k,_ in pairs(struct) do
		assert(keys.AccountAttribute[k], "AccountAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AccountAttribute
-- <p>Describes an account attribute.</p>
-- @param _AttributeName [String] <p>The name of the account attribute.</p>
-- @param _AttributeValues [AccountAttributeValueList] <p>One or more values for the account attribute.</p>
function M.AccountAttribute(_AttributeName, _AttributeValues, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AccountAttribute")
	local t = { 
		["AttributeName"] = _AttributeName,
		["AttributeValues"] = _AttributeValues,
	}
	asserts.AssertAccountAttribute(t)
	return t
end

keys.DescribeDhcpOptionsResult = { ["DhcpOptions"] = true, nil }

function asserts.AssertDescribeDhcpOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDhcpOptionsResult to be of type 'table'")
	if struct["DhcpOptions"] then asserts.AssertDhcpOptionsList(struct["DhcpOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDhcpOptionsResult[k], "DescribeDhcpOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDhcpOptionsResult
-- <p>Contains the output of DescribeDhcpOptions.</p>
-- @param _DhcpOptions [DhcpOptionsList] <p>Information about one or more DHCP options sets.</p>
function M.DescribeDhcpOptionsResult(_DhcpOptions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeDhcpOptionsResult")
	local t = { 
		["DhcpOptions"] = _DhcpOptions,
	}
	asserts.AssertDescribeDhcpOptionsResult(t)
	return t
end

keys.DeleteTagsRequest = { ["DryRun"] = true, ["Resources"] = true, ["Tags"] = true, nil }

function asserts.AssertDeleteTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteTagsRequest to be of type 'table'")
	assert(struct["Resources"], "Expected key Resources to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Resources"] then asserts.AssertResourceIdList(struct["Resources"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteTagsRequest[k], "DeleteTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteTagsRequest
-- <p>Contains the parameters for DeleteTags.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Resources [ResourceIdList] <p>The ID of the resource. For example, ami-1a2b3c4d. You can specify more than one resource ID.</p>
-- @param _Tags [TagList] <p>One or more tags to delete. If you omit the <code>value</code> parameter, we delete the tag regardless of its value. If you specify this parameter with an empty string as the value, we delete the key only if its value is an empty string.</p>
-- Required parameter: Resources
function M.DeleteTagsRequest(_DryRun, _Resources, _Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteTagsRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Resources"] = _Resources,
		["Tags"] = _Tags,
	}
	asserts.AssertDeleteTagsRequest(t)
	return t
end

keys.ModifyVpcAttributeRequest = { ["VpcId"] = true, ["EnableDnsSupport"] = true, ["EnableDnsHostnames"] = true, nil }

function asserts.AssertModifyVpcAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcAttributeRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["EnableDnsSupport"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsSupport"]) end
	if struct["EnableDnsHostnames"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsHostnames"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcAttributeRequest[k], "ModifyVpcAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcAttributeRequest
-- <p>Contains the parameters for ModifyVpcAttribute.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _EnableDnsSupport [AttributeBooleanValue] <p>Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" will succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled.</p> <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute.</p>
-- @param _EnableDnsHostnames [AttributeBooleanValue] <p>Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not.</p> <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute. You can only enable DNS hostnames if you've enabled DNS support.</p>
-- Required parameter: VpcId
function M.ModifyVpcAttributeRequest(_VpcId, _EnableDnsSupport, _EnableDnsHostnames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcAttributeRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["EnableDnsSupport"] = _EnableDnsSupport,
		["EnableDnsHostnames"] = _EnableDnsHostnames,
	}
	asserts.AssertModifyVpcAttributeRequest(t)
	return t
end

keys.ScheduledInstancesIpv6Address = { ["Ipv6Address"] = true, nil }

function asserts.AssertScheduledInstancesIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertIpv6Address(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesIpv6Address[k], "ScheduledInstancesIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesIpv6Address
-- <p>Describes an IPv6 address.</p>
-- @param _Ipv6Address [Ipv6Address] <p>The IPv6 address.</p>
function M.ScheduledInstancesIpv6Address(_Ipv6Address, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesIpv6Address")
	local t = { 
		["Ipv6Address"] = _Ipv6Address,
	}
	asserts.AssertScheduledInstancesIpv6Address(t)
	return t
end

keys.SpotInstanceRequest = { ["Status"] = true, ["ActualBlockHourlyPrice"] = true, ["ValidUntil"] = true, ["LaunchGroup"] = true, ["Tags"] = true, ["InstanceId"] = true, ["Fault"] = true, ["BlockDurationMinutes"] = true, ["SpotInstanceRequestId"] = true, ["State"] = true, ["ProductDescription"] = true, ["AvailabilityZoneGroup"] = true, ["LaunchSpecification"] = true, ["ValidFrom"] = true, ["Type"] = true, ["CreateTime"] = true, ["SpotPrice"] = true, ["LaunchedAvailabilityZone"] = true, nil }

function asserts.AssertSpotInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceRequest to be of type 'table'")
	if struct["Status"] then asserts.AssertSpotInstanceStatus(struct["Status"]) end
	if struct["ActualBlockHourlyPrice"] then asserts.AssertString(struct["ActualBlockHourlyPrice"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["LaunchGroup"] then asserts.AssertString(struct["LaunchGroup"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Fault"] then asserts.AssertSpotInstanceStateFault(struct["Fault"]) end
	if struct["BlockDurationMinutes"] then asserts.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	if struct["State"] then asserts.AssertSpotInstanceState(struct["State"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["AvailabilityZoneGroup"] then asserts.AssertString(struct["AvailabilityZoneGroup"]) end
	if struct["LaunchSpecification"] then asserts.AssertLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["Type"] then asserts.AssertSpotInstanceType(struct["Type"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	if struct["LaunchedAvailabilityZone"] then asserts.AssertString(struct["LaunchedAvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotInstanceRequest[k], "SpotInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceRequest
-- <p>Describes a Spot instance request.</p>
-- @param _Status [SpotInstanceStatus] <p>The status code and status message describing the Spot instance request.</p>
-- @param _ActualBlockHourlyPrice [String] <p>If you specified a duration and your Spot instance request was fulfilled, this is the fixed hourly price in effect for the Spot instance while it runs.</p>
-- @param _ValidUntil [DateTime] <p>The end date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). If this is a one-time request, it remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date is reached.</p>
-- @param _LaunchGroup [String] <p>The instance launch group. Launch groups are Spot instances that launch together and terminate together.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the resource.</p>
-- @param _InstanceId [String] <p>The instance ID, if an instance has been launched to fulfill the Spot instance request.</p>
-- @param _Fault [SpotInstanceStateFault] <p>The fault codes for the Spot instance request, if any.</p>
-- @param _BlockDurationMinutes [Integer] <p>The duration for the Spot instance, in minutes.</p>
-- @param _SpotInstanceRequestId [String] <p>The ID of the Spot instance request.</p>
-- @param _State [SpotInstanceState] <p>The state of the Spot instance request. Spot bid status information can help you track your Spot instance requests. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot Bid Status</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param _ProductDescription [RIProductDescription] <p>The product description associated with the Spot instance.</p>
-- @param _AvailabilityZoneGroup [String] <p>The Availability Zone group. If you specify the same Availability Zone group for all Spot instance requests, all Spot instances are launched in the same Availability Zone.</p>
-- @param _LaunchSpecification [LaunchSpecification] <p>Additional information for launching instances.</p>
-- @param _ValidFrom [DateTime] <p>The start date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The request becomes active at this date and time.</p>
-- @param _Type [SpotInstanceType] <p>The Spot instance request type.</p>
-- @param _CreateTime [DateTime] <p>The date and time when the Spot instance request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @param _SpotPrice [String] <p>The maximum hourly price (bid) for the Spot instance launched to fulfill the request.</p>
-- @param _LaunchedAvailabilityZone [String] <p>The Availability Zone in which the bid is launched.</p>
function M.SpotInstanceRequest(_Status, _ActualBlockHourlyPrice, _ValidUntil, _LaunchGroup, _Tags, _InstanceId, _Fault, _BlockDurationMinutes, _SpotInstanceRequestId, _State, _ProductDescription, _AvailabilityZoneGroup, _LaunchSpecification, _ValidFrom, _Type, _CreateTime, _SpotPrice, _LaunchedAvailabilityZone, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotInstanceRequest")
	local t = { 
		["Status"] = _Status,
		["ActualBlockHourlyPrice"] = _ActualBlockHourlyPrice,
		["ValidUntil"] = _ValidUntil,
		["LaunchGroup"] = _LaunchGroup,
		["Tags"] = _Tags,
		["InstanceId"] = _InstanceId,
		["Fault"] = _Fault,
		["BlockDurationMinutes"] = _BlockDurationMinutes,
		["SpotInstanceRequestId"] = _SpotInstanceRequestId,
		["State"] = _State,
		["ProductDescription"] = _ProductDescription,
		["AvailabilityZoneGroup"] = _AvailabilityZoneGroup,
		["LaunchSpecification"] = _LaunchSpecification,
		["ValidFrom"] = _ValidFrom,
		["Type"] = _Type,
		["CreateTime"] = _CreateTime,
		["SpotPrice"] = _SpotPrice,
		["LaunchedAvailabilityZone"] = _LaunchedAvailabilityZone,
	}
	asserts.AssertSpotInstanceRequest(t)
	return t
end

keys.DescribeReservedInstancesResult = { ["ReservedInstances"] = true, nil }

function asserts.AssertDescribeReservedInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesResult to be of type 'table'")
	if struct["ReservedInstances"] then asserts.AssertReservedInstancesList(struct["ReservedInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesResult[k], "DescribeReservedInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesResult
-- <p>Contains the output for DescribeReservedInstances.</p>
-- @param _ReservedInstances [ReservedInstancesList] <p>A list of Reserved Instances.</p>
function M.DescribeReservedInstancesResult(_ReservedInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesResult")
	local t = { 
		["ReservedInstances"] = _ReservedInstances,
	}
	asserts.AssertDescribeReservedInstancesResult(t)
	return t
end

keys.DescribeAccountAttributesResult = { ["AccountAttributes"] = true, nil }

function asserts.AssertDescribeAccountAttributesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAttributesResult to be of type 'table'")
	if struct["AccountAttributes"] then asserts.AssertAccountAttributeList(struct["AccountAttributes"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAccountAttributesResult[k], "DescribeAccountAttributesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAttributesResult
-- <p>Contains the output of DescribeAccountAttributes.</p>
-- @param _AccountAttributes [AccountAttributeList] <p>Information about one or more account attributes.</p>
function M.DescribeAccountAttributesResult(_AccountAttributes, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAccountAttributesResult")
	local t = { 
		["AccountAttributes"] = _AccountAttributes,
	}
	asserts.AssertDescribeAccountAttributesResult(t)
	return t
end

keys.UserIdGroupPair = { ["VpcId"] = true, ["PeeringStatus"] = true, ["UserId"] = true, ["GroupName"] = true, ["VpcPeeringConnectionId"] = true, ["GroupId"] = true, nil }

function asserts.AssertUserIdGroupPair(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserIdGroupPair to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PeeringStatus"] then asserts.AssertString(struct["PeeringStatus"]) end
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserIdGroupPair[k], "UserIdGroupPair contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserIdGroupPair
-- <p>Describes a security group and AWS account ID pair.</p>
-- @param _VpcId [String] <p>The ID of the VPC for the referenced security group, if applicable.</p>
-- @param _PeeringStatus [String] <p>The status of a VPC peering connection, if applicable.</p>
-- @param _UserId [String] <p>The ID of an AWS account. For a referenced security group in another VPC, the account ID of the referenced security group is returned.</p> <p>[EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.</p>
-- @param _GroupName [String] <p>The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection, if applicable.</p>
-- @param _GroupId [String] <p>The ID of the security group.</p>
function M.UserIdGroupPair(_VpcId, _PeeringStatus, _UserId, _GroupName, _VpcPeeringConnectionId, _GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UserIdGroupPair")
	local t = { 
		["VpcId"] = _VpcId,
		["PeeringStatus"] = _PeeringStatus,
		["UserId"] = _UserId,
		["GroupName"] = _GroupName,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
		["GroupId"] = _GroupId,
	}
	asserts.AssertUserIdGroupPair(t)
	return t
end

keys.DescribeRouteTablesRequest = { ["RouteTableIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeRouteTablesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRouteTablesRequest to be of type 'table'")
	if struct["RouteTableIds"] then asserts.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRouteTablesRequest[k], "DescribeRouteTablesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRouteTablesRequest
-- <p>Contains the parameters for DescribeRouteTables.</p>
-- @param _RouteTableIds [ValueStringList] <p>One or more route table IDs.</p> <p>Default: Describes all your route tables.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>association.route-table-association-id</code> - The ID of an association ID for the route table.</p> </li> <li> <p> <code>association.route-table-id</code> - The ID of the route table involved in the association.</p> </li> <li> <p> <code>association.subnet-id</code> - The ID of the subnet involved in the association.</p> </li> <li> <p> <code>association.main</code> - Indicates whether the route table is the main route table for the VPC (<code>true</code> | <code>false</code>). Route tables that do not have an association ID are not returned in the response.</p> </li> <li> <p> <code>route-table-id</code> - The ID of the route table.</p> </li> <li> <p> <code>route.destination-cidr-block</code> - The IPv4 CIDR range specified in a route in the table.</p> </li> <li> <p> <code>route.destination-ipv6-cidr-block</code> - The IPv6 CIDR range specified in a route in the route table.</p> </li> <li> <p> <code>route.destination-prefix-list-id</code> - The ID (prefix) of the AWS service specified in a route in the table.</p> </li> <li> <p> <code>route.egress-only-internet-gateway-id</code> - The ID of an egress-only Internet gateway specified in a route in the route table.</p> </li> <li> <p> <code>route.gateway-id</code> - The ID of a gateway specified in a route in the table.</p> </li> <li> <p> <code>route.instance-id</code> - The ID of an instance specified in a route in the table.</p> </li> <li> <p> <code>route.nat-gateway-id</code> - The ID of a NAT gateway.</p> </li> <li> <p> <code>route.origin</code> - Describes how the route was created. <code>CreateRouteTable</code> indicates that the route was automatically created when the route table was created; <code>CreateRoute</code> indicates that the route was manually added to the route table; <code>EnableVgwRoutePropagation</code> indicates that the route was propagated by route propagation.</p> </li> <li> <p> <code>route.state</code> - The state of a route in the route table (<code>active</code> | <code>blackhole</code>). The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, the specified NAT instance has been terminated, and so on).</p> </li> <li> <p> <code>route.vpc-peering-connection-id</code> - The ID of a VPC peering connection specified in a route in the table.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the route table.</p> </li> </ul>
function M.DescribeRouteTablesRequest(_RouteTableIds, _DryRun, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeRouteTablesRequest")
	local t = { 
		["RouteTableIds"] = _RouteTableIds,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeRouteTablesRequest(t)
	return t
end

keys.DescribeInternetGatewaysResult = { ["InternetGateways"] = true, nil }

function asserts.AssertDescribeInternetGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInternetGatewaysResult to be of type 'table'")
	if struct["InternetGateways"] then asserts.AssertInternetGatewayList(struct["InternetGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInternetGatewaysResult[k], "DescribeInternetGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInternetGatewaysResult
-- <p>Contains the output of DescribeInternetGateways.</p>
-- @param _InternetGateways [InternetGatewayList] <p>Information about one or more Internet gateways.</p>
function M.DescribeInternetGatewaysResult(_InternetGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInternetGatewaysResult")
	local t = { 
		["InternetGateways"] = _InternetGateways,
	}
	asserts.AssertDescribeInternetGatewaysResult(t)
	return t
end

keys.DescribeSecurityGroupReferencesRequest = { ["DryRun"] = true, ["GroupId"] = true, nil }

function asserts.AssertDescribeSecurityGroupReferencesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupReferencesRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then asserts.AssertGroupIds(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupReferencesRequest[k], "DescribeSecurityGroupReferencesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupReferencesRequest
--  
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.</p>
-- @param _GroupId [GroupIds] <p>One or more security group IDs in your account.</p>
-- Required parameter: GroupId
function M.DescribeSecurityGroupReferencesRequest(_DryRun, _GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSecurityGroupReferencesRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["GroupId"] = _GroupId,
	}
	asserts.AssertDescribeSecurityGroupReferencesRequest(t)
	return t
end

keys.ImportImageRequest = { ["LicenseType"] = true, ["DryRun"] = true, ["Description"] = true, ["ClientData"] = true, ["Hypervisor"] = true, ["DiskContainers"] = true, ["Platform"] = true, ["Architecture"] = true, ["ClientToken"] = true, ["RoleName"] = true, nil }

function asserts.AssertImportImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageRequest to be of type 'table'")
	if struct["LicenseType"] then asserts.AssertString(struct["LicenseType"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ClientData"] then asserts.AssertClientData(struct["ClientData"]) end
	if struct["Hypervisor"] then asserts.AssertString(struct["Hypervisor"]) end
	if struct["DiskContainers"] then asserts.AssertImageDiskContainerList(struct["DiskContainers"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["Architecture"] then asserts.AssertString(struct["Architecture"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["RoleName"] then asserts.AssertString(struct["RoleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportImageRequest[k], "ImportImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageRequest
-- <p>Contains the parameters for ImportImage.</p>
-- @param _LicenseType [String] <p>The license type to be used for the Amazon Machine Image (AMI) after importing.</p> <p> <b>Note:</b> You may only use BYOL if you have existing licenses with rights to use these licenses in a third party cloud like AWS. For more information, see <a href="http://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html#prerequisites-image">Prerequisites</a> in the VM Import/Export User Guide.</p> <p>Valid values: <code>AWS</code> | <code>BYOL</code> </p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [String] <p>A description string for the import image task.</p>
-- @param _ClientData [ClientData] <p>The client-specific data.</p>
-- @param _Hypervisor [String] <p>The target hypervisor platform.</p> <p>Valid values: <code>xen</code> </p>
-- @param _DiskContainers [ImageDiskContainerList] <p>Information about the disk containers.</p>
-- @param _Platform [String] <p>The operating system of the virtual machine.</p> <p>Valid values: <code>Windows</code> | <code>Linux</code> </p>
-- @param _Architecture [String] <p>The architecture of the virtual machine.</p> <p>Valid values: <code>i386</code> | <code>x86_64</code> </p>
-- @param _ClientToken [String] <p>The token to enable idempotency for VM import requests.</p>
-- @param _RoleName [String] <p>The name of the role to use when not using the default role, 'vmimport'.</p>
function M.ImportImageRequest(_LicenseType, _DryRun, _Description, _ClientData, _Hypervisor, _DiskContainers, _Platform, _Architecture, _ClientToken, _RoleName, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportImageRequest")
	local t = { 
		["LicenseType"] = _LicenseType,
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["ClientData"] = _ClientData,
		["Hypervisor"] = _Hypervisor,
		["DiskContainers"] = _DiskContainers,
		["Platform"] = _Platform,
		["Architecture"] = _Architecture,
		["ClientToken"] = _ClientToken,
		["RoleName"] = _RoleName,
	}
	asserts.AssertImportImageRequest(t)
	return t
end

keys.DescribeReservedInstancesOfferingsResult = { ["NextToken"] = true, ["ReservedInstancesOfferings"] = true, nil }

function asserts.AssertDescribeReservedInstancesOfferingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesOfferingsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesOfferings"] then asserts.AssertReservedInstancesOfferingList(struct["ReservedInstancesOfferings"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesOfferingsResult[k], "DescribeReservedInstancesOfferingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesOfferingsResult
-- <p>Contains the output of DescribeReservedInstancesOfferings.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _ReservedInstancesOfferings [ReservedInstancesOfferingList] <p>A list of Reserved Instances offerings.</p>
function M.DescribeReservedInstancesOfferingsResult(_NextToken, _ReservedInstancesOfferings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesOfferingsResult")
	local t = { 
		["NextToken"] = _NextToken,
		["ReservedInstancesOfferings"] = _ReservedInstancesOfferings,
	}
	asserts.AssertDescribeReservedInstancesOfferingsResult(t)
	return t
end

keys.ScheduledInstancesMonitoring = { ["Enabled"] = true, nil }

function asserts.AssertScheduledInstancesMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesMonitoring to be of type 'table'")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesMonitoring[k], "ScheduledInstancesMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesMonitoring
-- <p>Describes whether monitoring is enabled for a Scheduled Instance.</p>
-- @param _Enabled [Boolean] <p>Indicates whether monitoring is enabled.</p>
function M.ScheduledInstancesMonitoring(_Enabled, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesMonitoring")
	local t = { 
		["Enabled"] = _Enabled,
	}
	asserts.AssertScheduledInstancesMonitoring(t)
	return t
end

keys.ScheduledInstancesLaunchSpecification = { ["UserData"] = true, ["SubnetId"] = true, ["Monitoring"] = true, ["ImageId"] = true, ["KeyName"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroupIds"] = true, ["RamdiskId"] = true, ["KernelId"] = true, ["Placement"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertScheduledInstancesLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesLaunchSpecification to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then asserts.AssertScheduledInstancesMonitoring(struct["Monitoring"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertScheduledInstancesBlockDeviceMappingSet(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroupIds"] then asserts.AssertScheduledInstancesSecurityGroupIdSet(struct["SecurityGroupIds"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Placement"] then asserts.AssertScheduledInstancesPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then asserts.AssertScheduledInstancesIamInstanceProfile(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertScheduledInstancesNetworkInterfaceSet(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesLaunchSpecification[k], "ScheduledInstancesLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesLaunchSpecification
-- <p>Describes the launch specification for a Scheduled Instance.</p> <p>If you are launching the Scheduled Instance in EC2-VPC, you must specify the ID of the subnet. You can specify the subnet using either <code>SubnetId</code> or <code>NetworkInterface</code>.</p>
-- @param _UserData [String] <p>The base64-encoded MIME user data.</p>
-- @param _SubnetId [String] <p>The ID of the subnet in which to launch the instances.</p>
-- @param _Monitoring [ScheduledInstancesMonitoring] <p>Enable or disable monitoring for the instances.</p>
-- @param _ImageId [String] <p>The ID of the Amazon Machine Image (AMI).</p>
-- @param _KeyName [String] <p>The name of the key pair.</p>
-- @param _BlockDeviceMappings [ScheduledInstancesBlockDeviceMappingSet] <p>One or more block device mapping entries.</p>
-- @param _EbsOptimized [Boolean] <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param _SecurityGroupIds [ScheduledInstancesSecurityGroupIdSet] <p>The IDs of one or more security groups.</p>
-- @param _RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param _KernelId [String] <p>The ID of the kernel.</p>
-- @param _Placement [ScheduledInstancesPlacement] <p>The placement information.</p>
-- @param _IamInstanceProfile [ScheduledInstancesIamInstanceProfile] <p>The IAM instance profile.</p>
-- @param _InstanceType [String] <p>The instance type.</p>
-- @param _NetworkInterfaces [ScheduledInstancesNetworkInterfaceSet] <p>One or more network interfaces.</p>
-- Required parameter: ImageId
function M.ScheduledInstancesLaunchSpecification(_UserData, _SubnetId, _Monitoring, _ImageId, _KeyName, _BlockDeviceMappings, _EbsOptimized, _SecurityGroupIds, _RamdiskId, _KernelId, _Placement, _IamInstanceProfile, _InstanceType, _NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstancesLaunchSpecification")
	local t = { 
		["UserData"] = _UserData,
		["SubnetId"] = _SubnetId,
		["Monitoring"] = _Monitoring,
		["ImageId"] = _ImageId,
		["KeyName"] = _KeyName,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["EbsOptimized"] = _EbsOptimized,
		["SecurityGroupIds"] = _SecurityGroupIds,
		["RamdiskId"] = _RamdiskId,
		["KernelId"] = _KernelId,
		["Placement"] = _Placement,
		["IamInstanceProfile"] = _IamInstanceProfile,
		["InstanceType"] = _InstanceType,
		["NetworkInterfaces"] = _NetworkInterfaces,
	}
	asserts.AssertScheduledInstancesLaunchSpecification(t)
	return t
end

keys.InstanceCapacity = { ["AvailableCapacity"] = true, ["InstanceType"] = true, ["TotalCapacity"] = true, nil }

function asserts.AssertInstanceCapacity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCapacity to be of type 'table'")
	if struct["AvailableCapacity"] then asserts.AssertInteger(struct["AvailableCapacity"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["TotalCapacity"] then asserts.AssertInteger(struct["TotalCapacity"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceCapacity[k], "InstanceCapacity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCapacity
-- <p>Information about the instance type that the Dedicated Host supports.</p>
-- @param _AvailableCapacity [Integer] <p>The number of instances that can still be launched onto the Dedicated Host.</p>
-- @param _InstanceType [String] <p>The instance type size supported by the Dedicated Host.</p>
-- @param _TotalCapacity [Integer] <p>The total number of instances that can be launched onto the Dedicated Host.</p>
function M.InstanceCapacity(_AvailableCapacity, _InstanceType, _TotalCapacity, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceCapacity")
	local t = { 
		["AvailableCapacity"] = _AvailableCapacity,
		["InstanceType"] = _InstanceType,
		["TotalCapacity"] = _TotalCapacity,
	}
	asserts.AssertInstanceCapacity(t)
	return t
end

keys.DescribeInstancesRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["InstanceIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancesRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancesRequest[k], "DescribeInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancesRequest
-- <p>Contains the parameters for DescribeInstances.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter or tag filters in the same call.</p>
-- @param _NextToken [String] <p>The token to request the next page of results.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Default: Describes all your instances.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>affinity</code> - The affinity setting for an instance running on a Dedicated Host (<code>default</code> | <code>host</code>).</p> </li> <li> <p> <code>architecture</code> - The instance architecture (<code>i386</code> | <code>x86_64</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>block-device-mapping.attach-time</code> - The attach time for an EBS volume mapped to the instance, for example, <code>2010-09-15T17:15:20.000Z</code>.</p> </li> <li> <p> <code>block-device-mapping.delete-on-termination</code> - A Boolean that indicates whether the EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>block-device-mapping.device-name</code> - The device name for the EBS volume (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p> </li> <li> <p> <code>block-device-mapping.status</code> - The status for the EBS volume (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>block-device-mapping.volume-id</code> - The volume ID of the EBS volume.</p> </li> <li> <p> <code>client-token</code> - The idempotency token you provided when you launched the instance.</p> </li> <li> <p> <code>dns-name</code> - The public DNS name of the instance.</p> </li> <li> <p> <code>group-id</code> - The ID of the security group for the instance. EC2-Classic only.</p> </li> <li> <p> <code>group-name</code> - The name of the security group for the instance. EC2-Classic only.</p> </li> <li> <p> <code>host-id</code> - The ID of the Dedicated Host on which the instance is running, if applicable.</p> </li> <li> <p> <code>hypervisor</code> - The hypervisor type of the instance (<code>ovm</code> | <code>xen</code>).</p> </li> <li> <p> <code>iam-instance-profile.arn</code> - The instance profile associated with the instance. Specified as an ARN.</p> </li> <li> <p> <code>image-id</code> - The ID of the image used to launch the instance.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>instance-lifecycle</code> - Indicates whether this is a Spot Instance or a Scheduled Instance (<code>spot</code> | <code>scheduled</code>).</p> </li> <li> <p> <code>instance-state-code</code> - The state of the instance, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are: 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).</p> </li> <li> <p> <code>instance-state-name</code> - The state of the instance (<code>pending</code> | <code>running</code> | <code>shutting-down</code> | <code>terminated</code> | <code>stopping</code> | <code>stopped</code>).</p> </li> <li> <p> <code>instance-type</code> - The type of instance (for example, <code>t2.micro</code>).</p> </li> <li> <p> <code>instance.group-id</code> - The ID of the security group for the instance. </p> </li> <li> <p> <code>instance.group-name</code> - The name of the security group for the instance. </p> </li> <li> <p> <code>ip-address</code> - The public IPv4 address of the instance.</p> </li> <li> <p> <code>kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>key-name</code> - The name of the key pair used when the instance was launched.</p> </li> <li> <p> <code>launch-index</code> - When launching multiple instances, this is the index for the instance in the launch group (for example, 0, 1, 2, and so on). </p> </li> <li> <p> <code>launch-time</code> - The time when the instance was launched.</p> </li> <li> <p> <code>monitoring-state</code> - Indicates whether detailed monitoring is enabled (<code>disabled</code> | <code>enabled</code>).</p> </li> <li> <p> <code>network-interface.addresses.private-ip-address</code> - The private IPv4 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.addresses.primary</code> - Specifies whether the IPv4 address of the network interface is the primary private IPv4 address.</p> </li> <li> <p> <code>network-interface.addresses.association.public-ip</code> - The ID of the association of an Elastic IP address (IPv4) with a network interface.</p> </li> <li> <p> <code>network-interface.addresses.association.ip-owner-id</code> - The owner ID of the private IPv4 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.association.public-ip</code> - The address of the Elastic IP address (IPv4) bound to the network interface.</p> </li> <li> <p> <code>network-interface.association.ip-owner-id</code> - The owner of the Elastic IP address (IPv4) associated with the network interface.</p> </li> <li> <p> <code>network-interface.association.allocation-id</code> - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.</p> </li> <li> <p> <code>network-interface.association.association-id</code> - The association ID returned when the network interface was associated with an IPv4 address.</p> </li> <li> <p> <code>network-interface.attachment.attachment-id</code> - The ID of the interface attachment.</p> </li> <li> <p> <code>network-interface.attachment.instance-id</code> - The ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.instance-owner-id</code> - The owner ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.device-index</code> - The device index to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.status</code> - The status of the attachment (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>network-interface.attachment.attach-time</code> - The time that the network interface was attached to an instance.</p> </li> <li> <p> <code>network-interface.attachment.delete-on-termination</code> - Specifies whether the attachment is deleted when an instance is terminated.</p> </li> <li> <p> <code>network-interface.availability-zone</code> - The Availability Zone for the network interface.</p> </li> <li> <p> <code>network-interface.description</code> - The description of the network interface.</p> </li> <li> <p> <code>network-interface.group-id</code> - The ID of a security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.group-name</code> - The name of a security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.ipv6-addresses.ipv6-address</code> - The IPv6 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.mac-address</code> - The MAC address of the network interface.</p> </li> <li> <p> <code>network-interface.network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>network-interface.owner-id</code> - The ID of the owner of the network interface.</p> </li> <li> <p> <code>network-interface.private-dns-name</code> - The private DNS name of the network interface.</p> </li> <li> <p> <code>network-interface.requester-id</code> - The requester ID for the network interface.</p> </li> <li> <p> <code>network-interface.requester-managed</code> - Indicates whether the network interface is being managed by AWS.</p> </li> <li> <p> <code>network-interface.status</code> - The status of the network interface (<code>available</code>) | <code>in-use</code>).</p> </li> <li> <p> <code>network-interface.source-dest-check</code> - Whether the network interface performs source/destination checking. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the network interface to perform network address translation (NAT) in your VPC.</p> </li> <li> <p> <code>network-interface.subnet-id</code> - The ID of the subnet for the network interface.</p> </li> <li> <p> <code>network-interface.vpc-id</code> - The ID of the VPC for the network interface.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the instance owner.</p> </li> <li> <p> <code>placement-group-name</code> - The name of the placement group for the instance.</p> </li> <li> <p> <code>platform</code> - The platform. Use <code>windows</code> if you have Windows instances; otherwise, leave blank.</p> </li> <li> <p> <code>private-dns-name</code> - The private IPv4 DNS name of the instance.</p> </li> <li> <p> <code>private-ip-address</code> - The private IPv4 address of the instance.</p> </li> <li> <p> <code>product-code</code> - The product code associated with the AMI used to launch the instance.</p> </li> <li> <p> <code>product-code.type</code> - The type of product code (<code>devpay</code> | <code>marketplace</code>).</p> </li> <li> <p> <code>ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>reason</code> - The reason for the current state of the instance (for example, shows "User Initiated [date]" when you stop or terminate the instance). Similar to the state-reason-code filter.</p> </li> <li> <p> <code>requester-id</code> - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>reservation-id</code> - The ID of the instance's reservation. A reservation ID is created any time you launch an instance. A reservation ID has a one-to-one relationship with an instance launch request, but can be associated with more than one instance if you launch multiple instances using the same launch request. For example, if you launch one instance, you'll get one reservation ID. If you launch ten instances using the same launch request, you'll also get one reservation ID.</p> </li> <li> <p> <code>root-device-name</code> - The name of the root device for the instance (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p> </li> <li> <p> <code>root-device-type</code> - The type of root device that the instance uses (<code>ebs</code> | <code>instance-store</code>).</p> </li> <li> <p> <code>source-dest-check</code> - Indicates whether the instance performs source/destination checking. A value of <code>true</code> means that checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the instance to perform network address translation (NAT) in your VPC. </p> </li> <li> <p> <code>spot-instance-request-id</code> - The ID of the Spot instance request.</p> </li> <li> <p> <code>state-reason-code</code> - The reason code for the state change.</p> </li> <li> <p> <code>state-reason-message</code> - A message that describes the state change.</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet for the instance.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>tenancy</code> - The tenancy of an instance (<code>dedicated</code> | <code>default</code> | <code>host</code>).</p> </li> <li> <p> <code>virtualization-type</code> - The virtualization type of the instance (<code>paravirtual</code> | <code>hvm</code>).</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC that the instance is running in.</p> </li> </ul>
function M.DescribeInstancesRequest(_MaxResults, _NextToken, _DryRun, _InstanceIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstancesRequest")
	local t = { 
		["MaxResults"] = _MaxResults,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["InstanceIds"] = _InstanceIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeInstancesRequest(t)
	return t
end

keys.ReservedInstancesModificationResult = { ["ReservedInstancesId"] = true, ["TargetConfiguration"] = true, nil }

function asserts.AssertReservedInstancesModificationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesModificationResult to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["TargetConfiguration"] then asserts.AssertReservedInstancesConfiguration(struct["TargetConfiguration"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesModificationResult[k], "ReservedInstancesModificationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesModificationResult
-- <p>Describes the modification request/s.</p>
-- @param _ReservedInstancesId [String] <p>The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.</p>
-- @param _TargetConfiguration [ReservedInstancesConfiguration] <p>The target Reserved Instances configurations supplied as part of the modification request.</p>
function M.ReservedInstancesModificationResult(_ReservedInstancesId, _TargetConfiguration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesModificationResult")
	local t = { 
		["ReservedInstancesId"] = _ReservedInstancesId,
		["TargetConfiguration"] = _TargetConfiguration,
	}
	asserts.AssertReservedInstancesModificationResult(t)
	return t
end

keys.CreateRouteTableRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteTableRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteTableRequest[k], "CreateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteTableRequest
-- <p>Contains the parameters for CreateRouteTable.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.CreateRouteTableRequest(_VpcId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateRouteTableRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertCreateRouteTableRequest(t)
	return t
end

keys.DescribeSpotDatafeedSubscriptionResult = { ["SpotDatafeedSubscription"] = true, nil }

function asserts.AssertDescribeSpotDatafeedSubscriptionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotDatafeedSubscriptionResult to be of type 'table'")
	if struct["SpotDatafeedSubscription"] then asserts.AssertSpotDatafeedSubscription(struct["SpotDatafeedSubscription"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotDatafeedSubscriptionResult[k], "DescribeSpotDatafeedSubscriptionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotDatafeedSubscriptionResult
-- <p>Contains the output of DescribeSpotDatafeedSubscription.</p>
-- @param _SpotDatafeedSubscription [SpotDatafeedSubscription] <p>The Spot instance data feed subscription.</p>
function M.DescribeSpotDatafeedSubscriptionResult(_SpotDatafeedSubscription, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotDatafeedSubscriptionResult")
	local t = { 
		["SpotDatafeedSubscription"] = _SpotDatafeedSubscription,
	}
	asserts.AssertDescribeSpotDatafeedSubscriptionResult(t)
	return t
end

keys.DescribeCustomerGatewaysRequest = { ["CustomerGatewayIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeCustomerGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCustomerGatewaysRequest to be of type 'table'")
	if struct["CustomerGatewayIds"] then asserts.AssertCustomerGatewayIdStringList(struct["CustomerGatewayIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCustomerGatewaysRequest[k], "DescribeCustomerGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCustomerGatewaysRequest
-- <p>Contains the parameters for DescribeCustomerGateways.</p>
-- @param _CustomerGatewayIds [CustomerGatewayIdStringList] <p>One or more customer gateway IDs.</p> <p>Default: Describes all your customer gateways.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>bgp-asn</code> - The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p> </li> <li> <p> <code>customer-gateway-id</code> - The ID of the customer gateway.</p> </li> <li> <p> <code>ip-address</code> - The IP address of the customer gateway's Internet-routable external interface.</p> </li> <li> <p> <code>state</code> - The state of the customer gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>type</code> - The type of customer gateway. Currently, the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> </ul>
function M.DescribeCustomerGatewaysRequest(_CustomerGatewayIds, _DryRun, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeCustomerGatewaysRequest")
	local t = { 
		["CustomerGatewayIds"] = _CustomerGatewayIds,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeCustomerGatewaysRequest(t)
	return t
end

keys.CancelledSpotInstanceRequest = { ["State"] = true, ["SpotInstanceRequestId"] = true, nil }

function asserts.AssertCancelledSpotInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelledSpotInstanceRequest to be of type 'table'")
	if struct["State"] then asserts.AssertCancelSpotInstanceRequestState(struct["State"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelledSpotInstanceRequest[k], "CancelledSpotInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelledSpotInstanceRequest
-- <p>Describes a request to cancel a Spot instance.</p>
-- @param _State [CancelSpotInstanceRequestState] <p>The state of the Spot instance request.</p>
-- @param _SpotInstanceRequestId [String] <p>The ID of the Spot instance request.</p>
function M.CancelledSpotInstanceRequest(_State, _SpotInstanceRequestId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelledSpotInstanceRequest")
	local t = { 
		["State"] = _State,
		["SpotInstanceRequestId"] = _SpotInstanceRequestId,
	}
	asserts.AssertCancelledSpotInstanceRequest(t)
	return t
end

keys.ScheduledInstanceAvailability = { ["AvailabilityZone"] = true, ["TotalScheduledInstanceHours"] = true, ["HourlyPrice"] = true, ["MinTermDurationInDays"] = true, ["AvailableInstanceCount"] = true, ["SlotDurationInHours"] = true, ["Recurrence"] = true, ["MaxTermDurationInDays"] = true, ["FirstSlotStartTime"] = true, ["Platform"] = true, ["NetworkPlatform"] = true, ["InstanceType"] = true, ["PurchaseToken"] = true, nil }

function asserts.AssertScheduledInstanceAvailability(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceAvailability to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["TotalScheduledInstanceHours"] then asserts.AssertInteger(struct["TotalScheduledInstanceHours"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["MinTermDurationInDays"] then asserts.AssertInteger(struct["MinTermDurationInDays"]) end
	if struct["AvailableInstanceCount"] then asserts.AssertInteger(struct["AvailableInstanceCount"]) end
	if struct["SlotDurationInHours"] then asserts.AssertInteger(struct["SlotDurationInHours"]) end
	if struct["Recurrence"] then asserts.AssertScheduledInstanceRecurrence(struct["Recurrence"]) end
	if struct["MaxTermDurationInDays"] then asserts.AssertInteger(struct["MaxTermDurationInDays"]) end
	if struct["FirstSlotStartTime"] then asserts.AssertDateTime(struct["FirstSlotStartTime"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["NetworkPlatform"] then asserts.AssertString(struct["NetworkPlatform"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["PurchaseToken"] then asserts.AssertString(struct["PurchaseToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstanceAvailability[k], "ScheduledInstanceAvailability contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceAvailability
-- <p>Describes a schedule that is available for your Scheduled Instances.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone.</p>
-- @param _TotalScheduledInstanceHours [Integer] <p>The total number of hours for a single instance for the entire term.</p>
-- @param _HourlyPrice [String] <p>The hourly price for a single instance.</p>
-- @param _MinTermDurationInDays [Integer] <p>The minimum term. The only possible value is 365 days.</p>
-- @param _AvailableInstanceCount [Integer] <p>The number of available instances.</p>
-- @param _SlotDurationInHours [Integer] <p>The number of hours in the schedule.</p>
-- @param _Recurrence [ScheduledInstanceRecurrence] <p>The schedule recurrence.</p>
-- @param _MaxTermDurationInDays [Integer] <p>The maximum term. The only possible value is 365 days.</p>
-- @param _FirstSlotStartTime [DateTime] <p>The time period for the first schedule to start.</p>
-- @param _Platform [String] <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
-- @param _NetworkPlatform [String] <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
-- @param _InstanceType [String] <p>The instance type. You can specify one of the C3, C4, M4, or R3 instance types.</p>
-- @param _PurchaseToken [String] <p>The purchase token. This token expires in two hours.</p>
function M.ScheduledInstanceAvailability(_AvailabilityZone, _TotalScheduledInstanceHours, _HourlyPrice, _MinTermDurationInDays, _AvailableInstanceCount, _SlotDurationInHours, _Recurrence, _MaxTermDurationInDays, _FirstSlotStartTime, _Platform, _NetworkPlatform, _InstanceType, _PurchaseToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ScheduledInstanceAvailability")
	local t = { 
		["AvailabilityZone"] = _AvailabilityZone,
		["TotalScheduledInstanceHours"] = _TotalScheduledInstanceHours,
		["HourlyPrice"] = _HourlyPrice,
		["MinTermDurationInDays"] = _MinTermDurationInDays,
		["AvailableInstanceCount"] = _AvailableInstanceCount,
		["SlotDurationInHours"] = _SlotDurationInHours,
		["Recurrence"] = _Recurrence,
		["MaxTermDurationInDays"] = _MaxTermDurationInDays,
		["FirstSlotStartTime"] = _FirstSlotStartTime,
		["Platform"] = _Platform,
		["NetworkPlatform"] = _NetworkPlatform,
		["InstanceType"] = _InstanceType,
		["PurchaseToken"] = _PurchaseToken,
	}
	asserts.AssertScheduledInstanceAvailability(t)
	return t
end

keys.DescribeSnapshotsResult = { ["NextToken"] = true, ["Snapshots"] = true, nil }

function asserts.AssertDescribeSnapshotsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Snapshots"] then asserts.AssertSnapshotList(struct["Snapshots"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotsResult[k], "DescribeSnapshotsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotsResult
-- <p>Contains the output of DescribeSnapshots.</p>
-- @param _NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeSnapshots</code> request. When the results of a <code>DescribeSnapshots</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _Snapshots [SnapshotList] <p>Information about the snapshots.</p>
function M.DescribeSnapshotsResult(_NextToken, _Snapshots, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSnapshotsResult")
	local t = { 
		["NextToken"] = _NextToken,
		["Snapshots"] = _Snapshots,
	}
	asserts.AssertDescribeSnapshotsResult(t)
	return t
end

keys.DeleteInternetGatewayRequest = { ["DryRun"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertDeleteInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteInternetGatewayRequest[k], "DeleteInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteInternetGatewayRequest
-- <p>Contains the parameters for DeleteInternetGateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InternetGatewayId [String] <p>The ID of the Internet gateway.</p>
-- Required parameter: InternetGatewayId
function M.DeleteInternetGatewayRequest(_DryRun, _InternetGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteInternetGatewayRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["InternetGatewayId"] = _InternetGatewayId,
	}
	asserts.AssertDeleteInternetGatewayRequest(t)
	return t
end

keys.UnmonitorInstancesResult = { ["InstanceMonitorings"] = true, nil }

function asserts.AssertUnmonitorInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnmonitorInstancesResult to be of type 'table'")
	if struct["InstanceMonitorings"] then asserts.AssertInstanceMonitoringList(struct["InstanceMonitorings"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnmonitorInstancesResult[k], "UnmonitorInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnmonitorInstancesResult
-- <p>Contains the output of UnmonitorInstances.</p>
-- @param _InstanceMonitorings [InstanceMonitoringList] <p>The monitoring information.</p>
function M.UnmonitorInstancesResult(_InstanceMonitorings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnmonitorInstancesResult")
	local t = { 
		["InstanceMonitorings"] = _InstanceMonitorings,
	}
	asserts.AssertUnmonitorInstancesResult(t)
	return t
end

keys.StaleIpPermission = { ["PrefixListIds"] = true, ["FromPort"] = true, ["IpRanges"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["UserIdGroupPairs"] = true, nil }

function asserts.AssertStaleIpPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StaleIpPermission to be of type 'table'")
	if struct["PrefixListIds"] then asserts.AssertPrefixListIdSet(struct["PrefixListIds"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["IpRanges"] then asserts.AssertIpRanges(struct["IpRanges"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["UserIdGroupPairs"] then asserts.AssertUserIdGroupPairSet(struct["UserIdGroupPairs"]) end
	for k,_ in pairs(struct) do
		assert(keys.StaleIpPermission[k], "StaleIpPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StaleIpPermission
-- <p>Describes a stale rule in a security group.</p>
-- @param _PrefixListIds [PrefixListIdSet] <p>One or more prefix list IDs for an AWS service. Not applicable for stale security group rules.</p>
-- @param _FromPort [Integer] <p>The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>
-- @param _IpRanges [IpRanges] <p>One or more IP ranges. Not applicable for stale security group rules.</p>
-- @param _ToPort [Integer] <p>The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>
-- @param _IpProtocol [String] <p>The IP protocol name (for <code>tcp</code>, <code>udp</code>, and <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers)</a>.</p>
-- @param _UserIdGroupPairs [UserIdGroupPairSet] <p>One or more security group pairs. Returns the ID of the referenced security group and VPC, and the ID and status of the VPC peering connection.</p>
function M.StaleIpPermission(_PrefixListIds, _FromPort, _IpRanges, _ToPort, _IpProtocol, _UserIdGroupPairs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StaleIpPermission")
	local t = { 
		["PrefixListIds"] = _PrefixListIds,
		["FromPort"] = _FromPort,
		["IpRanges"] = _IpRanges,
		["ToPort"] = _ToPort,
		["IpProtocol"] = _IpProtocol,
		["UserIdGroupPairs"] = _UserIdGroupPairs,
	}
	asserts.AssertStaleIpPermission(t)
	return t
end

keys.DescribeRegionsRequest = { ["DryRun"] = true, ["Filters"] = true, ["RegionNames"] = true, nil }

function asserts.AssertDescribeRegionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRegionsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["RegionNames"] then asserts.AssertRegionNameStringList(struct["RegionNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRegionsRequest[k], "DescribeRegionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRegionsRequest
-- <p>Contains the parameters for DescribeRegions.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>endpoint</code> - The endpoint of the region (for example, <code>ec2.us-east-1.amazonaws.com</code>).</p> </li> <li> <p> <code>region-name</code> - The name of the region (for example, <code>us-east-1</code>).</p> </li> </ul>
-- @param _RegionNames [RegionNameStringList] <p>The names of one or more regions.</p>
function M.DescribeRegionsRequest(_DryRun, _Filters, _RegionNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeRegionsRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
		["RegionNames"] = _RegionNames,
	}
	asserts.AssertDescribeRegionsRequest(t)
	return t
end

keys.CancelSpotFleetRequestsResponse = { ["SuccessfulFleetRequests"] = true, ["UnsuccessfulFleetRequests"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsResponse to be of type 'table'")
	if struct["SuccessfulFleetRequests"] then asserts.AssertCancelSpotFleetRequestsSuccessSet(struct["SuccessfulFleetRequests"]) end
	if struct["UnsuccessfulFleetRequests"] then asserts.AssertCancelSpotFleetRequestsErrorSet(struct["UnsuccessfulFleetRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsResponse[k], "CancelSpotFleetRequestsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsResponse
-- <p>Contains the output of CancelSpotFleetRequests.</p>
-- @param _SuccessfulFleetRequests [CancelSpotFleetRequestsSuccessSet] <p>Information about the Spot fleet requests that are successfully canceled.</p>
-- @param _UnsuccessfulFleetRequests [CancelSpotFleetRequestsErrorSet] <p>Information about the Spot fleet requests that are not successfully canceled.</p>
function M.CancelSpotFleetRequestsResponse(_SuccessfulFleetRequests, _UnsuccessfulFleetRequests, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsResponse")
	local t = { 
		["SuccessfulFleetRequests"] = _SuccessfulFleetRequests,
		["UnsuccessfulFleetRequests"] = _UnsuccessfulFleetRequests,
	}
	asserts.AssertCancelSpotFleetRequestsResponse(t)
	return t
end

keys.PlacementGroup = { ["GroupName"] = true, ["State"] = true, ["Strategy"] = true, nil }

function asserts.AssertPlacementGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PlacementGroup to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["State"] then asserts.AssertPlacementGroupState(struct["State"]) end
	if struct["Strategy"] then asserts.AssertPlacementStrategy(struct["Strategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.PlacementGroup[k], "PlacementGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PlacementGroup
-- <p>Describes a placement group.</p>
-- @param _GroupName [String] <p>The name of the placement group.</p>
-- @param _State [PlacementGroupState] <p>The state of the placement group.</p>
-- @param _Strategy [PlacementStrategy] <p>The placement strategy.</p>
function M.PlacementGroup(_GroupName, _State, _Strategy, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PlacementGroup")
	local t = { 
		["GroupName"] = _GroupName,
		["State"] = _State,
		["Strategy"] = _Strategy,
	}
	asserts.AssertPlacementGroup(t)
	return t
end

keys.AssociateIamInstanceProfileRequest = { ["InstanceId"] = true, ["IamInstanceProfile"] = true, nil }

function asserts.AssertAssociateIamInstanceProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateIamInstanceProfileRequest to be of type 'table'")
	assert(struct["IamInstanceProfile"], "Expected key IamInstanceProfile to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateIamInstanceProfileRequest[k], "AssociateIamInstanceProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateIamInstanceProfileRequest
--  
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- Required parameter: IamInstanceProfile
-- Required parameter: InstanceId
function M.AssociateIamInstanceProfileRequest(_InstanceId, _IamInstanceProfile, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateIamInstanceProfileRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["IamInstanceProfile"] = _IamInstanceProfile,
	}
	asserts.AssertAssociateIamInstanceProfileRequest(t)
	return t
end

keys.CreateNatGatewayRequest = { ["SubnetId"] = true, ["AllocationId"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateNatGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNatGatewayRequest to be of type 'table'")
	assert(struct["AllocationId"], "Expected key AllocationId to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNatGatewayRequest[k], "CreateNatGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNatGatewayRequest
-- <p>Contains the parameters for CreateNatGateway.</p>
-- @param _SubnetId [String] <p>The subnet in which to create the NAT gateway.</p>
-- @param _AllocationId [String] <p>The allocation ID of an Elastic IP address to associate with the NAT gateway. If the Elastic IP address is associated with another resource, you must first disassociate it.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p> <p>Constraint: Maximum 64 ASCII characters.</p>
-- Required parameter: AllocationId
-- Required parameter: SubnetId
function M.CreateNatGatewayRequest(_SubnetId, _AllocationId, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNatGatewayRequest")
	local t = { 
		["SubnetId"] = _SubnetId,
		["AllocationId"] = _AllocationId,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertCreateNatGatewayRequest(t)
	return t
end

keys.PricingDetail = { ["Count"] = true, ["Price"] = true, nil }

function asserts.AssertPricingDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PricingDetail to be of type 'table'")
	if struct["Count"] then asserts.AssertInteger(struct["Count"]) end
	if struct["Price"] then asserts.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(keys.PricingDetail[k], "PricingDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PricingDetail
-- <p>Describes a Reserved Instance offering.</p>
-- @param _Count [Integer] <p>The number of reservations available for the price.</p>
-- @param _Price [Double] <p>The price per instance.</p>
function M.PricingDetail(_Count, _Price, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PricingDetail")
	local t = { 
		["Count"] = _Count,
		["Price"] = _Price,
	}
	asserts.AssertPricingDetail(t)
	return t
end

keys.UnassignIpv6AddressesRequest = { ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, nil }

function asserts.AssertUnassignIpv6AddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignIpv6AddressesRequest to be of type 'table'")
	assert(struct["Ipv6Addresses"], "Expected key Ipv6Addresses to exist in table")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Ipv6Addresses"] then asserts.AssertIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnassignIpv6AddressesRequest[k], "UnassignIpv6AddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignIpv6AddressesRequest
--  
-- @param _Ipv6Addresses [Ipv6AddressList] <p>The IPv6 addresses to unassign from the network interface.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- Required parameter: Ipv6Addresses
-- Required parameter: NetworkInterfaceId
function M.UnassignIpv6AddressesRequest(_Ipv6Addresses, _NetworkInterfaceId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnassignIpv6AddressesRequest")
	local t = { 
		["Ipv6Addresses"] = _Ipv6Addresses,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
	}
	asserts.AssertUnassignIpv6AddressesRequest(t)
	return t
end

keys.EnableVpcClassicLinkResult = { ["Return"] = true, nil }

function asserts.AssertEnableVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkResult[k], "EnableVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkResult
-- <p>Contains the output of EnableVpcClassicLink.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.EnableVpcClassicLinkResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVpcClassicLinkResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertEnableVpcClassicLinkResult(t)
	return t
end

keys.SpotPlacement = { ["Tenancy"] = true, ["GroupName"] = true, ["AvailabilityZone"] = true, nil }

function asserts.AssertSpotPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotPlacement to be of type 'table'")
	if struct["Tenancy"] then asserts.AssertTenancy(struct["Tenancy"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotPlacement[k], "SpotPlacement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotPlacement
-- <p>Describes Spot instance placement.</p>
-- @param _Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for Spot instances.</p>
-- @param _GroupName [String] <p>The name of the placement group (for cluster instances).</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone.</p> <p>[Spot fleet only] To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".</p>
function M.SpotPlacement(_Tenancy, _GroupName, _AvailabilityZone, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotPlacement")
	local t = { 
		["Tenancy"] = _Tenancy,
		["GroupName"] = _GroupName,
		["AvailabilityZone"] = _AvailabilityZone,
	}
	asserts.AssertSpotPlacement(t)
	return t
end

keys.DeleteVpcEndpointsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertDeleteVpcEndpointsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointsResult[k], "DeleteVpcEndpointsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointsResult
-- <p>Contains the output of DeleteVpcEndpoints.</p>
-- @param _Unsuccessful [UnsuccessfulItemSet] <p>Information about the endpoints that were not successfully deleted.</p>
function M.DeleteVpcEndpointsResult(_Unsuccessful, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcEndpointsResult")
	local t = { 
		["Unsuccessful"] = _Unsuccessful,
	}
	asserts.AssertDeleteVpcEndpointsResult(t)
	return t
end

keys.EbsInstanceBlockDevice = { ["Status"] = true, ["DeleteOnTermination"] = true, ["VolumeId"] = true, ["AttachTime"] = true, nil }

function asserts.AssertEbsInstanceBlockDevice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsInstanceBlockDevice to be of type 'table'")
	if struct["Status"] then asserts.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.EbsInstanceBlockDevice[k], "EbsInstanceBlockDevice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsInstanceBlockDevice
-- <p>Describes a parameter used to set up an EBS volume in a block device mapping.</p>
-- @param _Status [AttachmentStatus] <p>The attachment state.</p>
-- @param _DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- @param _VolumeId [String] <p>The ID of the EBS volume.</p>
-- @param _AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
function M.EbsInstanceBlockDevice(_Status, _DeleteOnTermination, _VolumeId, _AttachTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EbsInstanceBlockDevice")
	local t = { 
		["Status"] = _Status,
		["DeleteOnTermination"] = _DeleteOnTermination,
		["VolumeId"] = _VolumeId,
		["AttachTime"] = _AttachTime,
	}
	asserts.AssertEbsInstanceBlockDevice(t)
	return t
end

keys.VolumeStatusDetails = { ["Status"] = true, ["Name"] = true, nil }

function asserts.AssertVolumeStatusDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusDetails to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["Name"] then asserts.AssertVolumeStatusName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusDetails[k], "VolumeStatusDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusDetails
-- <p>Describes a volume status.</p>
-- @param _Status [String] <p>The intended status of the volume status.</p>
-- @param _Name [VolumeStatusName] <p>The name of the volume status.</p>
function M.VolumeStatusDetails(_Status, _Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeStatusDetails")
	local t = { 
		["Status"] = _Status,
		["Name"] = _Name,
	}
	asserts.AssertVolumeStatusDetails(t)
	return t
end

keys.DescribeHostReservationOfferingsRequest = { ["OfferingId"] = true, ["MaxResults"] = true, ["Filter"] = true, ["MinDuration"] = true, ["NextToken"] = true, ["MaxDuration"] = true, nil }

function asserts.AssertDescribeHostReservationOfferingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationOfferingsRequest to be of type 'table'")
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["MinDuration"] then asserts.AssertInteger(struct["MinDuration"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxDuration"] then asserts.AssertInteger(struct["MaxDuration"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationOfferingsRequest[k], "DescribeHostReservationOfferingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationOfferingsRequest
--  
-- @param _OfferingId [String] <p>The ID of the reservation offering.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500; if <code>maxResults</code> is given a larger value than 500, you will receive an error.</p>
-- @param _Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-family</code> - The instance family of the offering (e.g., <code>m4</code>).</p> </li> <li> <p> <code>payment-option</code> - The payment option (<code>NoUpfront</code> | <code>PartialUpfront</code> | <code>AllUpfront</code>).</p> </li> </ul>
-- @param _MinDuration [Integer] <p>This is the minimum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 31536000 for one year.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- @param _MaxDuration [Integer] <p>This is the maximum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 94608000 for three years.</p>
function M.DescribeHostReservationOfferingsRequest(_OfferingId, _MaxResults, _Filter, _MinDuration, _NextToken, _MaxDuration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostReservationOfferingsRequest")
	local t = { 
		["OfferingId"] = _OfferingId,
		["MaxResults"] = _MaxResults,
		["Filter"] = _Filter,
		["MinDuration"] = _MinDuration,
		["NextToken"] = _NextToken,
		["MaxDuration"] = _MaxDuration,
	}
	asserts.AssertDescribeHostReservationOfferingsRequest(t)
	return t
end

keys.StartInstancesResult = { ["StartingInstances"] = true, nil }

function asserts.AssertStartInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartInstancesResult to be of type 'table'")
	if struct["StartingInstances"] then asserts.AssertInstanceStateChangeList(struct["StartingInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartInstancesResult[k], "StartInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartInstancesResult
-- <p>Contains the output of StartInstances.</p>
-- @param _StartingInstances [InstanceStateChangeList] <p>Information about one or more started instances.</p>
function M.StartInstancesResult(_StartingInstances, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating StartInstancesResult")
	local t = { 
		["StartingInstances"] = _StartingInstances,
	}
	asserts.AssertStartInstancesResult(t)
	return t
end

keys.Address = { ["Domain"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["AssociationId"] = true, ["NetworkInterfaceOwnerId"] = true, ["PublicIp"] = true, ["AllocationId"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Address to be of type 'table'")
	if struct["Domain"] then asserts.AssertDomainType(struct["Domain"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["NetworkInterfaceOwnerId"] then asserts.AssertString(struct["NetworkInterfaceOwnerId"]) end
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.Address[k], "Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Address
-- <p>Describes an Elastic IP address.</p>
-- @param _Domain [DomainType] <p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
-- @param _InstanceId [String] <p>The ID of the instance that the address is associated with (if any).</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _AssociationId [String] <p>The ID representing the association of the address with an instance in a VPC.</p>
-- @param _NetworkInterfaceOwnerId [String] <p>The ID of the AWS account that owns the network interface.</p>
-- @param _PublicIp [String] <p>The Elastic IP address.</p>
-- @param _AllocationId [String] <p>The ID representing the allocation of the address for use with EC2-VPC.</p>
-- @param _PrivateIpAddress [String] <p>The private IP address associated with the Elastic IP address.</p>
function M.Address(_Domain, _InstanceId, _NetworkInterfaceId, _AssociationId, _NetworkInterfaceOwnerId, _PublicIp, _AllocationId, _PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Address")
	local t = { 
		["Domain"] = _Domain,
		["InstanceId"] = _InstanceId,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["AssociationId"] = _AssociationId,
		["NetworkInterfaceOwnerId"] = _NetworkInterfaceOwnerId,
		["PublicIp"] = _PublicIp,
		["AllocationId"] = _AllocationId,
		["PrivateIpAddress"] = _PrivateIpAddress,
	}
	asserts.AssertAddress(t)
	return t
end

keys.VpnGateway = { ["AvailabilityZone"] = true, ["Tags"] = true, ["VpcAttachments"] = true, ["State"] = true, ["VpnGatewayId"] = true, ["Type"] = true, nil }

function asserts.AssertVpnGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnGateway to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["VpcAttachments"] then asserts.AssertVpcAttachmentList(struct["VpcAttachments"]) end
	if struct["State"] then asserts.AssertVpnState(struct["State"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnGateway[k], "VpnGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnGateway
-- <p>Describes a virtual private gateway.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the virtual private gateway.</p>
-- @param _VpcAttachments [VpcAttachmentList] <p>Any VPCs attached to the virtual private gateway.</p>
-- @param _State [VpnState] <p>The current state of the virtual private gateway.</p>
-- @param _VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- @param _Type [GatewayType] <p>The type of VPN connection the virtual private gateway supports.</p>
function M.VpnGateway(_AvailabilityZone, _Tags, _VpcAttachments, _State, _VpnGatewayId, _Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnGateway")
	local t = { 
		["AvailabilityZone"] = _AvailabilityZone,
		["Tags"] = _Tags,
		["VpcAttachments"] = _VpcAttachments,
		["State"] = _State,
		["VpnGatewayId"] = _VpnGatewayId,
		["Type"] = _Type,
	}
	asserts.AssertVpnGateway(t)
	return t
end

keys.ReleaseHostsRequest = { ["HostIds"] = true, nil }

function asserts.AssertReleaseHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseHostsRequest to be of type 'table'")
	assert(struct["HostIds"], "Expected key HostIds to exist in table")
	if struct["HostIds"] then asserts.AssertRequestHostIdList(struct["HostIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReleaseHostsRequest[k], "ReleaseHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseHostsRequest
-- <p>Contains the parameters for ReleaseHosts.</p>
-- @param _HostIds [RequestHostIdList] <p>The IDs of the Dedicated Hosts you want to release.</p>
-- Required parameter: HostIds
function M.ReleaseHostsRequest(_HostIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReleaseHostsRequest")
	local t = { 
		["HostIds"] = _HostIds,
	}
	asserts.AssertReleaseHostsRequest(t)
	return t
end

keys.EbsInstanceBlockDeviceSpecification = { ["DeleteOnTermination"] = true, ["VolumeId"] = true, nil }

function asserts.AssertEbsInstanceBlockDeviceSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsInstanceBlockDeviceSpecification to be of type 'table'")
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EbsInstanceBlockDeviceSpecification[k], "EbsInstanceBlockDeviceSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsInstanceBlockDeviceSpecification
-- <p>Describes information used to set up an EBS volume specified in a block device mapping.</p>
-- @param _DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- @param _VolumeId [String] <p>The ID of the EBS volume.</p>
function M.EbsInstanceBlockDeviceSpecification(_DeleteOnTermination, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EbsInstanceBlockDeviceSpecification")
	local t = { 
		["DeleteOnTermination"] = _DeleteOnTermination,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertEbsInstanceBlockDeviceSpecification(t)
	return t
end

keys.EnableVolumeIORequest = { ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertEnableVolumeIORequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVolumeIORequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVolumeIORequest[k], "EnableVolumeIORequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVolumeIORequest
-- <p>Contains the parameters for EnableVolumeIO.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.EnableVolumeIORequest(_DryRun, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVolumeIORequest")
	local t = { 
		["DryRun"] = _DryRun,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertEnableVolumeIORequest(t)
	return t
end

keys.DescribeScheduledInstancesResult = { ["NextToken"] = true, ["ScheduledInstanceSet"] = true, nil }

function asserts.AssertDescribeScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstancesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ScheduledInstanceSet"] then asserts.AssertScheduledInstanceSet(struct["ScheduledInstanceSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstancesResult[k], "DescribeScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstancesResult
-- <p>Contains the output of DescribeScheduledInstances.</p>
-- @param _NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _ScheduledInstanceSet [ScheduledInstanceSet] <p>Information about the Scheduled Instances.</p>
function M.DescribeScheduledInstancesResult(_NextToken, _ScheduledInstanceSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeScheduledInstancesResult")
	local t = { 
		["NextToken"] = _NextToken,
		["ScheduledInstanceSet"] = _ScheduledInstanceSet,
	}
	asserts.AssertDescribeScheduledInstancesResult(t)
	return t
end

keys.AssociateVpcCidrBlockResult = { ["Ipv6CidrBlockAssociation"] = true, ["VpcId"] = true, nil }

function asserts.AssertAssociateVpcCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateVpcCidrBlockResult to be of type 'table'")
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertVpcIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateVpcCidrBlockResult[k], "AssociateVpcCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateVpcCidrBlockResult
--  
-- @param _Ipv6CidrBlockAssociation [VpcIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
function M.AssociateVpcCidrBlockResult(_Ipv6CidrBlockAssociation, _VpcId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateVpcCidrBlockResult")
	local t = { 
		["Ipv6CidrBlockAssociation"] = _Ipv6CidrBlockAssociation,
		["VpcId"] = _VpcId,
	}
	asserts.AssertAssociateVpcCidrBlockResult(t)
	return t
end

keys.PciId = { ["SubsystemVendorId"] = true, ["VendorId"] = true, ["DeviceId"] = true, ["SubsystemId"] = true, nil }

function asserts.AssertPciId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PciId to be of type 'table'")
	if struct["SubsystemVendorId"] then asserts.AssertString(struct["SubsystemVendorId"]) end
	if struct["VendorId"] then asserts.AssertString(struct["VendorId"]) end
	if struct["DeviceId"] then asserts.AssertString(struct["DeviceId"]) end
	if struct["SubsystemId"] then asserts.AssertString(struct["SubsystemId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PciId[k], "PciId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PciId
-- <p>Describes the data that identifies an Amazon FPGA image (AFI) on the PCI bus.</p>
-- @param _SubsystemVendorId [String] <p>The ID of the vendor for the subsystem.</p>
-- @param _VendorId [String] <p>The ID of the vendor.</p>
-- @param _DeviceId [String] <p>The ID of the device.</p>
-- @param _SubsystemId [String] <p>The ID of the subsystem.</p>
function M.PciId(_SubsystemVendorId, _VendorId, _DeviceId, _SubsystemId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PciId")
	local t = { 
		["SubsystemVendorId"] = _SubsystemVendorId,
		["VendorId"] = _VendorId,
		["DeviceId"] = _DeviceId,
		["SubsystemId"] = _SubsystemId,
	}
	asserts.AssertPciId(t)
	return t
end

keys.RequestSpotLaunchSpecification = { ["UserData"] = true, ["SubnetId"] = true, ["Monitoring"] = true, ["KeyName"] = true, ["SecurityGroupIds"] = true, ["ImageId"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroups"] = true, ["RamdiskId"] = true, ["KernelId"] = true, ["Placement"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["AddressingType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertRequestSpotLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotLaunchSpecification to be of type 'table'")
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then asserts.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroupIds"] then asserts.AssertValueStringList(struct["SecurityGroupIds"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then asserts.AssertValueStringList(struct["SecurityGroups"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Placement"] then asserts.AssertSpotPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then asserts.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotLaunchSpecification[k], "RequestSpotLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotLaunchSpecification
-- <p>Describes the launch specification for an instance.</p>
-- @param _UserData [String] <p>The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param _SubnetId [String] <p>The ID of the subnet in which to launch the instance.</p>
-- @param _Monitoring [RunInstancesMonitoringEnabled] <p>Indicates whether basic or detailed monitoring is enabled for the instance.</p> <p>Default: Disabled</p>
-- @param _KeyName [String] <p>The name of the key pair.</p>
-- @param _SecurityGroupIds [ValueStringList] <p>One or more security group IDs.</p>
-- @param _ImageId [String] <p>The ID of the AMI.</p>
-- @param _BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p> <p>Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.</p>
-- @param _EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param _SecurityGroups [ValueStringList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- @param _RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param _KernelId [String] <p>The ID of the kernel.</p>
-- @param _Placement [SpotPlacement] <p>The placement information for the instance.</p>
-- @param _IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- @param _InstanceType [InstanceType] <p>The instance type.</p>
-- @param _AddressingType [String] <p>Deprecated.</p>
-- @param _NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
function M.RequestSpotLaunchSpecification(_UserData, _SubnetId, _Monitoring, _KeyName, _SecurityGroupIds, _ImageId, _BlockDeviceMappings, _EbsOptimized, _SecurityGroups, _RamdiskId, _KernelId, _Placement, _IamInstanceProfile, _InstanceType, _AddressingType, _NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotLaunchSpecification")
	local t = { 
		["UserData"] = _UserData,
		["SubnetId"] = _SubnetId,
		["Monitoring"] = _Monitoring,
		["KeyName"] = _KeyName,
		["SecurityGroupIds"] = _SecurityGroupIds,
		["ImageId"] = _ImageId,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["EbsOptimized"] = _EbsOptimized,
		["SecurityGroups"] = _SecurityGroups,
		["RamdiskId"] = _RamdiskId,
		["KernelId"] = _KernelId,
		["Placement"] = _Placement,
		["IamInstanceProfile"] = _IamInstanceProfile,
		["InstanceType"] = _InstanceType,
		["AddressingType"] = _AddressingType,
		["NetworkInterfaces"] = _NetworkInterfaces,
	}
	asserts.AssertRequestSpotLaunchSpecification(t)
	return t
end

keys.CustomerGateway = { ["Tags"] = true, ["IpAddress"] = true, ["State"] = true, ["CustomerGatewayId"] = true, ["BgpAsn"] = true, ["Type"] = true, nil }

function asserts.AssertCustomerGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CustomerGateway to be of type 'table'")
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["IpAddress"] then asserts.AssertString(struct["IpAddress"]) end
	if struct["State"] then asserts.AssertString(struct["State"]) end
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["BgpAsn"] then asserts.AssertString(struct["BgpAsn"]) end
	if struct["Type"] then asserts.AssertString(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.CustomerGateway[k], "CustomerGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CustomerGateway
-- <p>Describes a customer gateway.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the customer gateway.</p>
-- @param _IpAddress [String] <p>The Internet-routable IP address of the customer gateway's outside interface.</p>
-- @param _State [String] <p>The current state of the customer gateway (<code>pending | available | deleting | deleted</code>).</p>
-- @param _CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- @param _BgpAsn [String] <p>The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p>
-- @param _Type [String] <p>The type of VPN connection the customer gateway supports (<code>ipsec.1</code>).</p>
function M.CustomerGateway(_Tags, _IpAddress, _State, _CustomerGatewayId, _BgpAsn, _Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CustomerGateway")
	local t = { 
		["Tags"] = _Tags,
		["IpAddress"] = _IpAddress,
		["State"] = _State,
		["CustomerGatewayId"] = _CustomerGatewayId,
		["BgpAsn"] = _BgpAsn,
		["Type"] = _Type,
	}
	asserts.AssertCustomerGateway(t)
	return t
end

keys.CreateSpotDatafeedSubscriptionRequest = { ["DryRun"] = true, ["Prefix"] = true, ["Bucket"] = true, nil }

function asserts.AssertCreateSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSpotDatafeedSubscriptionRequest to be of type 'table'")
	assert(struct["Bucket"], "Expected key Bucket to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Prefix"] then asserts.AssertString(struct["Prefix"]) end
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSpotDatafeedSubscriptionRequest[k], "CreateSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for CreateSpotDatafeedSubscription.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Prefix [String] <p>A prefix for the data feed file names.</p>
-- @param _Bucket [String] <p>The Amazon S3 bucket in which to store the Spot instance data feed.</p>
-- Required parameter: Bucket
function M.CreateSpotDatafeedSubscriptionRequest(_DryRun, _Prefix, _Bucket, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSpotDatafeedSubscriptionRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Prefix"] = _Prefix,
		["Bucket"] = _Bucket,
	}
	asserts.AssertCreateSpotDatafeedSubscriptionRequest(t)
	return t
end

keys.DeleteFlowLogsRequest = { ["FlowLogIds"] = true, nil }

function asserts.AssertDeleteFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFlowLogsRequest to be of type 'table'")
	assert(struct["FlowLogIds"], "Expected key FlowLogIds to exist in table")
	if struct["FlowLogIds"] then asserts.AssertValueStringList(struct["FlowLogIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFlowLogsRequest[k], "DeleteFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFlowLogsRequest
-- <p>Contains the parameters for DeleteFlowLogs.</p>
-- @param _FlowLogIds [ValueStringList] <p>One or more flow log IDs.</p>
-- Required parameter: FlowLogIds
function M.DeleteFlowLogsRequest(_FlowLogIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteFlowLogsRequest")
	local t = { 
		["FlowLogIds"] = _FlowLogIds,
	}
	asserts.AssertDeleteFlowLogsRequest(t)
	return t
end

keys.DescribeSpotFleetInstancesRequest = { ["SpotFleetRequestId"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeSpotFleetInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetInstancesRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetInstancesRequest[k], "DescribeSpotFleetInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetInstancesRequest
-- <p>Contains the parameters for DescribeSpotFleetInstances.</p>
-- @param _SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param _NextToken [String] <p>The token for the next set of results.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- Required parameter: SpotFleetRequestId
function M.DescribeSpotFleetInstancesRequest(_SpotFleetRequestId, _NextToken, _DryRun, _MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetInstancesRequest")
	local t = { 
		["SpotFleetRequestId"] = _SpotFleetRequestId,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
	}
	asserts.AssertDescribeSpotFleetInstancesRequest(t)
	return t
end

keys.AvailableCapacity = { ["AvailableInstanceCapacity"] = true, ["AvailableVCpus"] = true, nil }

function asserts.AssertAvailableCapacity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailableCapacity to be of type 'table'")
	if struct["AvailableInstanceCapacity"] then asserts.AssertAvailableInstanceCapacityList(struct["AvailableInstanceCapacity"]) end
	if struct["AvailableVCpus"] then asserts.AssertInteger(struct["AvailableVCpus"]) end
	for k,_ in pairs(struct) do
		assert(keys.AvailableCapacity[k], "AvailableCapacity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailableCapacity
-- <p>The capacity information for instances launched onto the Dedicated Host.</p>
-- @param _AvailableInstanceCapacity [AvailableInstanceCapacityList] <p>The total number of instances that the Dedicated Host supports.</p>
-- @param _AvailableVCpus [Integer] <p>The number of vCPUs available on the Dedicated Host.</p>
function M.AvailableCapacity(_AvailableInstanceCapacity, _AvailableVCpus, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AvailableCapacity")
	local t = { 
		["AvailableInstanceCapacity"] = _AvailableInstanceCapacity,
		["AvailableVCpus"] = _AvailableVCpus,
	}
	asserts.AssertAvailableCapacity(t)
	return t
end

keys.LaunchPermissionModifications = { ["Add"] = true, ["Remove"] = true, nil }

function asserts.AssertLaunchPermissionModifications(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchPermissionModifications to be of type 'table'")
	if struct["Add"] then asserts.AssertLaunchPermissionList(struct["Add"]) end
	if struct["Remove"] then asserts.AssertLaunchPermissionList(struct["Remove"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchPermissionModifications[k], "LaunchPermissionModifications contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchPermissionModifications
-- <p>Describes a launch permission modification.</p>
-- @param _Add [LaunchPermissionList] <p>The AWS account ID to add to the list of launch permissions for the AMI.</p>
-- @param _Remove [LaunchPermissionList] <p>The AWS account ID to remove from the list of launch permissions for the AMI.</p>
function M.LaunchPermissionModifications(_Add, _Remove, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating LaunchPermissionModifications")
	local t = { 
		["Add"] = _Add,
		["Remove"] = _Remove,
	}
	asserts.AssertLaunchPermissionModifications(t)
	return t
end

keys.GetReservedInstancesExchangeQuoteRequest = { ["ReservedInstanceIds"] = true, ["DryRun"] = true, ["TargetConfigurations"] = true, nil }

function asserts.AssertGetReservedInstancesExchangeQuoteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetReservedInstancesExchangeQuoteRequest to be of type 'table'")
	assert(struct["ReservedInstanceIds"], "Expected key ReservedInstanceIds to exist in table")
	if struct["ReservedInstanceIds"] then asserts.AssertReservedInstanceIdSet(struct["ReservedInstanceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TargetConfigurations"] then asserts.AssertTargetConfigurationRequestSet(struct["TargetConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetReservedInstancesExchangeQuoteRequest[k], "GetReservedInstancesExchangeQuoteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetReservedInstancesExchangeQuoteRequest
-- <p>Contains the parameters for GetReservedInstanceExchangeQuote.</p>
-- @param _ReservedInstanceIds [ReservedInstanceIdSet] <p>The IDs of the Convertible Reserved Instances to exchange.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _TargetConfigurations [TargetConfigurationRequestSet] <p>The configuration requirements of the Convertible Reserved Instances to exchange for your current Convertible Reserved Instances.</p>
-- Required parameter: ReservedInstanceIds
function M.GetReservedInstancesExchangeQuoteRequest(_ReservedInstanceIds, _DryRun, _TargetConfigurations, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetReservedInstancesExchangeQuoteRequest")
	local t = { 
		["ReservedInstanceIds"] = _ReservedInstanceIds,
		["DryRun"] = _DryRun,
		["TargetConfigurations"] = _TargetConfigurations,
	}
	asserts.AssertGetReservedInstancesExchangeQuoteRequest(t)
	return t
end

keys.VpnStaticRoute = { ["DestinationCidrBlock"] = true, ["State"] = true, ["Source"] = true, nil }

function asserts.AssertVpnStaticRoute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnStaticRoute to be of type 'table'")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["State"] then asserts.AssertVpnState(struct["State"]) end
	if struct["Source"] then asserts.AssertVpnStaticRouteSource(struct["Source"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnStaticRoute[k], "VpnStaticRoute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnStaticRoute
-- <p>Describes a static route for a VPN connection.</p>
-- @param _DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer data center.</p>
-- @param _State [VpnState] <p>The current state of the static route.</p>
-- @param _Source [VpnStaticRouteSource] <p>Indicates how the routes were provided.</p>
function M.VpnStaticRoute(_DestinationCidrBlock, _State, _Source, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnStaticRoute")
	local t = { 
		["DestinationCidrBlock"] = _DestinationCidrBlock,
		["State"] = _State,
		["Source"] = _Source,
	}
	asserts.AssertVpnStaticRoute(t)
	return t
end

keys.DeleteVpcPeeringConnectionRequest = { ["DryRun"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertDeleteVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcPeeringConnectionRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcPeeringConnectionRequest[k], "DeleteVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcPeeringConnectionRequest
-- <p>Contains the parameters for DeleteVpcPeeringConnection.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required parameter: VpcPeeringConnectionId
function M.DeleteVpcPeeringConnectionRequest(_DryRun, _VpcPeeringConnectionId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcPeeringConnectionRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
	}
	asserts.AssertDeleteVpcPeeringConnectionRequest(t)
	return t
end

keys.DescribeReservedInstancesModificationsResult = { ["NextToken"] = true, ["ReservedInstancesModifications"] = true, nil }

function asserts.AssertDescribeReservedInstancesModificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesModificationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesModifications"] then asserts.AssertReservedInstancesModificationList(struct["ReservedInstancesModifications"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesModificationsResult[k], "DescribeReservedInstancesModificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesModificationsResult
-- <p>Contains the output of DescribeReservedInstancesModifications.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _ReservedInstancesModifications [ReservedInstancesModificationList] <p>The Reserved Instance modification information.</p>
function M.DescribeReservedInstancesModificationsResult(_NextToken, _ReservedInstancesModifications, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesModificationsResult")
	local t = { 
		["NextToken"] = _NextToken,
		["ReservedInstancesModifications"] = _ReservedInstancesModifications,
	}
	asserts.AssertDescribeReservedInstancesModificationsResult(t)
	return t
end

keys.IdFormat = { ["Resource"] = true, ["Deadline"] = true, ["UseLongIds"] = true, nil }

function asserts.AssertIdFormat(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IdFormat to be of type 'table'")
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	if struct["Deadline"] then asserts.AssertDateTime(struct["Deadline"]) end
	if struct["UseLongIds"] then asserts.AssertBoolean(struct["UseLongIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.IdFormat[k], "IdFormat contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IdFormat
-- <p>Describes the ID format for a resource.</p>
-- @param _Resource [String] <p>The type of resource.</p>
-- @param _Deadline [DateTime] <p>The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.</p>
-- @param _UseLongIds [Boolean] <p>Indicates whether longer IDs (17-character IDs) are enabled for the resource.</p>
function M.IdFormat(_Resource, _Deadline, _UseLongIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IdFormat")
	local t = { 
		["Resource"] = _Resource,
		["Deadline"] = _Deadline,
		["UseLongIds"] = _UseLongIds,
	}
	asserts.AssertIdFormat(t)
	return t
end

keys.TargetConfigurationRequest = { ["InstanceCount"] = true, ["OfferingId"] = true, nil }

function asserts.AssertTargetConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetConfigurationRequest to be of type 'table'")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetConfigurationRequest[k], "TargetConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetConfigurationRequest
-- <p>Details about the target configuration.</p>
-- @param _InstanceCount [Integer] <p>The number of instances the Covertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>
-- @param _OfferingId [String] <p>The Convertible Reserved Instance offering ID.</p>
-- Required parameter: OfferingId
function M.TargetConfigurationRequest(_InstanceCount, _OfferingId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TargetConfigurationRequest")
	local t = { 
		["InstanceCount"] = _InstanceCount,
		["OfferingId"] = _OfferingId,
	}
	asserts.AssertTargetConfigurationRequest(t)
	return t
end

keys.InstanceState = { ["Code"] = true, ["Name"] = true, nil }

function asserts.AssertInstanceState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceState to be of type 'table'")
	if struct["Code"] then asserts.AssertInteger(struct["Code"]) end
	if struct["Name"] then asserts.AssertInstanceStateName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceState[k], "InstanceState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceState
-- <p>Describes the current state of an instance.</p>
-- @param _Code [Integer] <p>The low byte represents the state. The high byte is an opaque internal value and should be ignored.</p> <ul> <li> <p> <code>0</code> : <code>pending</code> </p> </li> <li> <p> <code>16</code> : <code>running</code> </p> </li> <li> <p> <code>32</code> : <code>shutting-down</code> </p> </li> <li> <p> <code>48</code> : <code>terminated</code> </p> </li> <li> <p> <code>64</code> : <code>stopping</code> </p> </li> <li> <p> <code>80</code> : <code>stopped</code> </p> </li> </ul>
-- @param _Name [InstanceStateName] <p>The current state of the instance.</p>
function M.InstanceState(_Code, _Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceState")
	local t = { 
		["Code"] = _Code,
		["Name"] = _Name,
	}
	asserts.AssertInstanceState(t)
	return t
end

keys.AttachClassicLinkVpcResult = { ["Return"] = true, nil }

function asserts.AssertAttachClassicLinkVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachClassicLinkVpcResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachClassicLinkVpcResult[k], "AttachClassicLinkVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachClassicLinkVpcResult
-- <p>Contains the output of AttachClassicLinkVpc.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.AttachClassicLinkVpcResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachClassicLinkVpcResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertAttachClassicLinkVpcResult(t)
	return t
end

keys.DetachClassicLinkVpcResult = { ["Return"] = true, nil }

function asserts.AssertDetachClassicLinkVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachClassicLinkVpcResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachClassicLinkVpcResult[k], "DetachClassicLinkVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachClassicLinkVpcResult
-- <p>Contains the output of DetachClassicLinkVpc.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.DetachClassicLinkVpcResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachClassicLinkVpcResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertDetachClassicLinkVpcResult(t)
	return t
end

keys.DisassociateSubnetCidrBlockResult = { ["SubnetId"] = true, ["Ipv6CidrBlockAssociation"] = true, nil }

function asserts.AssertDisassociateSubnetCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateSubnetCidrBlockResult to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertSubnetIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateSubnetCidrBlockResult[k], "DisassociateSubnetCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateSubnetCidrBlockResult
--  
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _Ipv6CidrBlockAssociation [SubnetIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
function M.DisassociateSubnetCidrBlockResult(_SubnetId, _Ipv6CidrBlockAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateSubnetCidrBlockResult")
	local t = { 
		["SubnetId"] = _SubnetId,
		["Ipv6CidrBlockAssociation"] = _Ipv6CidrBlockAssociation,
	}
	asserts.AssertDisassociateSubnetCidrBlockResult(t)
	return t
end

keys.ModifyInstanceAttributeRequest = { ["Ramdisk"] = true, ["Kernel"] = true, ["SourceDestCheck"] = true, ["DryRun"] = true, ["UserData"] = true, ["InstanceId"] = true, ["Attribute"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["BlockDeviceMappings"] = true, ["Value"] = true, ["Groups"] = true, ["EbsOptimized"] = true, ["DisableApiTermination"] = true, ["InstanceType"] = true, nil }

function asserts.AssertModifyInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstanceAttributeRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["Ramdisk"] then asserts.AssertAttributeValue(struct["Ramdisk"]) end
	if struct["Kernel"] then asserts.AssertAttributeValue(struct["Kernel"]) end
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["UserData"] then asserts.AssertBlobAttributeValue(struct["UserData"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then asserts.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["EnaSupport"] then asserts.AssertAttributeBooleanValue(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertAttributeValue(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertInstanceBlockDeviceMappingSpecificationList(struct["BlockDeviceMappings"]) end
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["Groups"] then asserts.AssertGroupIdStringList(struct["Groups"]) end
	if struct["EbsOptimized"] then asserts.AssertAttributeBooleanValue(struct["EbsOptimized"]) end
	if struct["DisableApiTermination"] then asserts.AssertAttributeBooleanValue(struct["DisableApiTermination"]) end
	if struct["InstanceType"] then asserts.AssertAttributeValue(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstanceAttributeRequest[k], "ModifyInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstanceAttributeRequest
-- <p>Contains the parameters for ModifyInstanceAttribute.</p>
-- @param _Ramdisk [AttributeValue] <p>Changes the instance's RAM disk to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
-- @param _Kernel [AttributeValue] <p>Changes the instance's kernel to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
-- @param _SourceDestCheck [AttributeBooleanValue] <p>Specifies whether source/destination checking is enabled. A value of <code>true</code> means that checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _UserData [BlobAttributeValue] <p>Changes the instance's user data to the specified value. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _Attribute [InstanceAttributeName] <p>The name of the attribute.</p>
-- @param _EnaSupport [AttributeBooleanValue] <p>Set to <code>true</code> to enable enhanced networking with ENA for the instance.</p> <p>This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.</p>
-- @param _SriovNetSupport [AttributeValue] <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual Function interface for the instance.</p> <p>There is no way to disable enhanced networking with the Intel 82599 Virtual Function interface at this time.</p> <p>This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.</p>
-- @param _InstanceInitiatedShutdownBehavior [AttributeValue] <p>Specifies whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- @param _BlockDeviceMappings [InstanceBlockDeviceMappingSpecificationList] <p>Modifies the <code>DeleteOnTermination</code> attribute for volumes that are currently attached. The volume must be owned by the caller. If no value is specified for <code>DeleteOnTermination</code>, the default is <code>true</code> and the volume is deleted when the instance is terminated.</p> <p>To add instance store volumes to an Amazon EBS-backed instance, you must add them when you launch the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html#Using_OverridingAMIBDM">Updating the Block Device Mapping when Launching an Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param _Value [String] <p>A new value for the attribute. Use only with the <code>kernel</code>, <code>ramdisk</code>, <code>userData</code>, <code>disableApiTermination</code>, or <code>instanceInitiatedShutdownBehavior</code> attribute.</p>
-- @param _Groups [GroupIdStringList] <p>[EC2-VPC] Changes the security groups of the instance. You must specify at least one security group, even if it's just the default security group for the VPC. You must specify the security group ID, not the security group name.</p>
-- @param _EbsOptimized [AttributeBooleanValue] <p>Specifies whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
-- @param _DisableApiTermination [AttributeBooleanValue] <p>If the value is <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this paramater for Spot Instances.</p>
-- @param _InstanceType [AttributeValue] <p>Changes the instance type to the specified value. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a>. If the instance type is not valid, the error returned is <code>InvalidInstanceAttributeValue</code>.</p>
-- Required parameter: InstanceId
function M.ModifyInstanceAttributeRequest(_Ramdisk, _Kernel, _SourceDestCheck, _DryRun, _UserData, _InstanceId, _Attribute, _EnaSupport, _SriovNetSupport, _InstanceInitiatedShutdownBehavior, _BlockDeviceMappings, _Value, _Groups, _EbsOptimized, _DisableApiTermination, _InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyInstanceAttributeRequest")
	local t = { 
		["Ramdisk"] = _Ramdisk,
		["Kernel"] = _Kernel,
		["SourceDestCheck"] = _SourceDestCheck,
		["DryRun"] = _DryRun,
		["UserData"] = _UserData,
		["InstanceId"] = _InstanceId,
		["Attribute"] = _Attribute,
		["EnaSupport"] = _EnaSupport,
		["SriovNetSupport"] = _SriovNetSupport,
		["InstanceInitiatedShutdownBehavior"] = _InstanceInitiatedShutdownBehavior,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["Value"] = _Value,
		["Groups"] = _Groups,
		["EbsOptimized"] = _EbsOptimized,
		["DisableApiTermination"] = _DisableApiTermination,
		["InstanceType"] = _InstanceType,
	}
	asserts.AssertModifyInstanceAttributeRequest(t)
	return t
end

keys.GetHostReservationPurchasePreviewRequest = { ["HostIdSet"] = true, ["OfferingId"] = true, nil }

function asserts.AssertGetHostReservationPurchasePreviewRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetHostReservationPurchasePreviewRequest to be of type 'table'")
	assert(struct["HostIdSet"], "Expected key HostIdSet to exist in table")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["HostIdSet"] then asserts.AssertRequestHostIdSet(struct["HostIdSet"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetHostReservationPurchasePreviewRequest[k], "GetHostReservationPurchasePreviewRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetHostReservationPurchasePreviewRequest
--  
-- @param _HostIdSet [RequestHostIdSet] <p>The ID/s of the Dedicated Host/s that the reservation will be associated with.</p>
-- @param _OfferingId [String] <p>The offering ID of the reservation.</p>
-- Required parameter: HostIdSet
-- Required parameter: OfferingId
function M.GetHostReservationPurchasePreviewRequest(_HostIdSet, _OfferingId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetHostReservationPurchasePreviewRequest")
	local t = { 
		["HostIdSet"] = _HostIdSet,
		["OfferingId"] = _OfferingId,
	}
	asserts.AssertGetHostReservationPurchasePreviewRequest(t)
	return t
end

keys.EnableVpcClassicLinkDnsSupportResult = { ["Return"] = true, nil }

function asserts.AssertEnableVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkDnsSupportResult[k], "EnableVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkDnsSupportResult
-- <p>Contains the output of EnableVpcClassicLinkDnsSupport.</p>
-- @param _Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
function M.EnableVpcClassicLinkDnsSupportResult(_Return, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVpcClassicLinkDnsSupportResult")
	local t = { 
		["Return"] = _Return,
	}
	asserts.AssertEnableVpcClassicLinkDnsSupportResult(t)
	return t
end

keys.GetPasswordDataResult = { ["InstanceId"] = true, ["Timestamp"] = true, ["PasswordData"] = true, nil }

function asserts.AssertGetPasswordDataResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPasswordDataResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	if struct["PasswordData"] then asserts.AssertString(struct["PasswordData"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPasswordDataResult[k], "GetPasswordDataResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPasswordDataResult
-- <p>Contains the output of GetPasswordData.</p>
-- @param _InstanceId [String] <p>The ID of the Windows instance.</p>
-- @param _Timestamp [DateTime] <p>The time the data was last updated.</p>
-- @param _PasswordData [String] <p>The password of the instance.</p>
function M.GetPasswordDataResult(_InstanceId, _Timestamp, _PasswordData, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetPasswordDataResult")
	local t = { 
		["InstanceId"] = _InstanceId,
		["Timestamp"] = _Timestamp,
		["PasswordData"] = _PasswordData,
	}
	asserts.AssertGetPasswordDataResult(t)
	return t
end

keys.KeyPairInfo = { ["KeyName"] = true, ["KeyFingerprint"] = true, nil }

function asserts.AssertKeyPairInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KeyPairInfo to be of type 'table'")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then asserts.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(keys.KeyPairInfo[k], "KeyPairInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KeyPairInfo
-- <p>Describes a key pair.</p>
-- @param _KeyName [String] <p>The name of the key pair.</p>
-- @param _KeyFingerprint [String] <p>If you used <a>CreateKeyPair</a> to create the key pair, this is the SHA-1 digest of the DER encoded private key. If you used <a>ImportKeyPair</a> to provide AWS the public key, this is the MD5 public key fingerprint as specified in section 4 of RFC4716.</p>
function M.KeyPairInfo(_KeyName, _KeyFingerprint, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating KeyPairInfo")
	local t = { 
		["KeyName"] = _KeyName,
		["KeyFingerprint"] = _KeyFingerprint,
	}
	asserts.AssertKeyPairInfo(t)
	return t
end

keys.DescribeVpcClassicLinkResult = { ["Vpcs"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkResult to be of type 'table'")
	if struct["Vpcs"] then asserts.AssertVpcClassicLinkList(struct["Vpcs"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkResult[k], "DescribeVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkResult
-- <p>Contains the output of DescribeVpcClassicLink.</p>
-- @param _Vpcs [VpcClassicLinkList] <p>The ClassicLink status of one or more VPCs.</p>
function M.DescribeVpcClassicLinkResult(_Vpcs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcClassicLinkResult")
	local t = { 
		["Vpcs"] = _Vpcs,
	}
	asserts.AssertDescribeVpcClassicLinkResult(t)
	return t
end

keys.DescribeEgressOnlyInternetGatewaysRequest = { ["EgressOnlyInternetGatewayIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeEgressOnlyInternetGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEgressOnlyInternetGatewaysRequest to be of type 'table'")
	if struct["EgressOnlyInternetGatewayIds"] then asserts.AssertEgressOnlyInternetGatewayIdList(struct["EgressOnlyInternetGatewayIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEgressOnlyInternetGatewaysRequest[k], "DescribeEgressOnlyInternetGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEgressOnlyInternetGatewaysRequest
--  
-- @param _EgressOnlyInternetGatewayIds [EgressOnlyInternetGatewayIdList] <p>One or more egress-only Internet gateway IDs.</p>
-- @param _NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned.</p>
function M.DescribeEgressOnlyInternetGatewaysRequest(_EgressOnlyInternetGatewayIds, _NextToken, _DryRun, _MaxResults, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeEgressOnlyInternetGatewaysRequest")
	local t = { 
		["EgressOnlyInternetGatewayIds"] = _EgressOnlyInternetGatewayIds,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
	}
	asserts.AssertDescribeEgressOnlyInternetGatewaysRequest(t)
	return t
end

keys.DetachVpnGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["VpnGatewayId"] = true, nil }

function asserts.AssertDetachVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachVpnGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachVpnGatewayRequest[k], "DetachVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachVpnGatewayRequest
-- <p>Contains the parameters for DetachVpnGateway.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required parameter: VpcId
-- Required parameter: VpnGatewayId
function M.DetachVpnGatewayRequest(_VpcId, _DryRun, _VpnGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachVpnGatewayRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
		["VpnGatewayId"] = _VpnGatewayId,
	}
	asserts.AssertDetachVpnGatewayRequest(t)
	return t
end

keys.DescribeBundleTasksRequest = { ["DryRun"] = true, ["Filters"] = true, ["BundleIds"] = true, nil }

function asserts.AssertDescribeBundleTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeBundleTasksRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["BundleIds"] then asserts.AssertBundleIdStringList(struct["BundleIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeBundleTasksRequest[k], "DescribeBundleTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeBundleTasksRequest
-- <p>Contains the parameters for DescribeBundleTasks.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>bundle-id</code> - The ID of the bundle task.</p> </li> <li> <p> <code>error-code</code> - If the task failed, the error code returned.</p> </li> <li> <p> <code>error-message</code> - If the task failed, the error message returned.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>progress</code> - The level of task completion, as a percentage (for example, 20%).</p> </li> <li> <p> <code>s3-bucket</code> - The Amazon S3 bucket to store the AMI.</p> </li> <li> <p> <code>s3-prefix</code> - The beginning of the AMI name.</p> </li> <li> <p> <code>start-time</code> - The time the task started (for example, 2013-09-15T17:15:20.000Z).</p> </li> <li> <p> <code>state</code> - The state of the task (<code>pending</code> | <code>waiting-for-shutdown</code> | <code>bundling</code> | <code>storing</code> | <code>cancelling</code> | <code>complete</code> | <code>failed</code>).</p> </li> <li> <p> <code>update-time</code> - The time of the most recent update for the task.</p> </li> </ul>
-- @param _BundleIds [BundleIdStringList] <p>One or more bundle task IDs.</p> <p>Default: Describes all your bundle tasks.</p>
function M.DescribeBundleTasksRequest(_DryRun, _Filters, _BundleIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeBundleTasksRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
		["BundleIds"] = _BundleIds,
	}
	asserts.AssertDescribeBundleTasksRequest(t)
	return t
end

keys.PurchaseHostReservationRequest = { ["CurrencyCode"] = true, ["OfferingId"] = true, ["LimitPrice"] = true, ["HostIdSet"] = true, ["ClientToken"] = true, nil }

function asserts.AssertPurchaseHostReservationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseHostReservationRequest to be of type 'table'")
	assert(struct["HostIdSet"], "Expected key HostIdSet to exist in table")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["LimitPrice"] then asserts.AssertString(struct["LimitPrice"]) end
	if struct["HostIdSet"] then asserts.AssertRequestHostIdSet(struct["HostIdSet"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseHostReservationRequest[k], "PurchaseHostReservationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseHostReservationRequest
--  
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code>, <code>LimitPrice</code>, and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @param _OfferingId [String] <p>The ID of the offering.</p>
-- @param _LimitPrice [String] <p>The specified limit is checked against the total upfront cost of the reservation (calculated as the offering's upfront cost multiplied by the host count). If the total upfront cost is greater than the specified price limit, the request will fail. This is used to ensure that the purchase does not exceed the expected upfront cost of the purchase. At this time, the only supported currency is <code>USD</code>. For example, to indicate a limit price of USD 100, specify 100.00.</p>
-- @param _HostIdSet [RequestHostIdSet] <p>The ID/s of the Dedicated Host/s that the reservation will be associated with.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- Required parameter: HostIdSet
-- Required parameter: OfferingId
function M.PurchaseHostReservationRequest(_CurrencyCode, _OfferingId, _LimitPrice, _HostIdSet, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PurchaseHostReservationRequest")
	local t = { 
		["CurrencyCode"] = _CurrencyCode,
		["OfferingId"] = _OfferingId,
		["LimitPrice"] = _LimitPrice,
		["HostIdSet"] = _HostIdSet,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertPurchaseHostReservationRequest(t)
	return t
end

keys.ReleaseHostsResult = { ["Successful"] = true, ["Unsuccessful"] = true, nil }

function asserts.AssertReleaseHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseHostsResult to be of type 'table'")
	if struct["Successful"] then asserts.AssertResponseHostIdList(struct["Successful"]) end
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemList(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReleaseHostsResult[k], "ReleaseHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseHostsResult
-- <p>Contains the output of ReleaseHosts.</p>
-- @param _Successful [ResponseHostIdList] <p>The IDs of the Dedicated Hosts that were successfully released.</p>
-- @param _Unsuccessful [UnsuccessfulItemList] <p>The IDs of the Dedicated Hosts that could not be released, including an error message.</p>
function M.ReleaseHostsResult(_Successful, _Unsuccessful, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReleaseHostsResult")
	local t = { 
		["Successful"] = _Successful,
		["Unsuccessful"] = _Unsuccessful,
	}
	asserts.AssertReleaseHostsResult(t)
	return t
end

keys.LaunchSpecification = { ["UserData"] = true, ["SubnetId"] = true, ["Placement"] = true, ["Monitoring"] = true, ["ImageId"] = true, ["KeyName"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroups"] = true, ["KernelId"] = true, ["RamdiskId"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["AddressingType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchSpecification to be of type 'table'")
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Placement"] then asserts.AssertSpotPlacement(struct["Placement"]) end
	if struct["Monitoring"] then asserts.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then asserts.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then asserts.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchSpecification[k], "LaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchSpecification
-- <p>Describes the launch specification for an instance.</p>
-- @param _UserData [String] <p>The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @param _SubnetId [String] <p>The ID of the subnet in which to launch the instance.</p>
-- @param _Placement [SpotPlacement] <p>The placement information for the instance.</p>
-- @param _Monitoring [RunInstancesMonitoringEnabled] 
-- @param _ImageId [String] <p>The ID of the AMI.</p>
-- @param _KeyName [String] <p>The name of the key pair.</p>
-- @param _BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p> <p>Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.</p>
-- @param _EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- @param _SecurityGroups [GroupIdentifierList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- @param _KernelId [String] <p>The ID of the kernel.</p>
-- @param _RamdiskId [String] <p>The ID of the RAM disk.</p>
-- @param _IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- @param _InstanceType [InstanceType] <p>The instance type.</p>
-- @param _AddressingType [String] <p>Deprecated.</p>
-- @param _NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
function M.LaunchSpecification(_UserData, _SubnetId, _Placement, _Monitoring, _ImageId, _KeyName, _BlockDeviceMappings, _EbsOptimized, _SecurityGroups, _KernelId, _RamdiskId, _IamInstanceProfile, _InstanceType, _AddressingType, _NetworkInterfaces, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating LaunchSpecification")
	local t = { 
		["UserData"] = _UserData,
		["SubnetId"] = _SubnetId,
		["Placement"] = _Placement,
		["Monitoring"] = _Monitoring,
		["ImageId"] = _ImageId,
		["KeyName"] = _KeyName,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["EbsOptimized"] = _EbsOptimized,
		["SecurityGroups"] = _SecurityGroups,
		["KernelId"] = _KernelId,
		["RamdiskId"] = _RamdiskId,
		["IamInstanceProfile"] = _IamInstanceProfile,
		["InstanceType"] = _InstanceType,
		["AddressingType"] = _AddressingType,
		["NetworkInterfaces"] = _NetworkInterfaces,
	}
	asserts.AssertLaunchSpecification(t)
	return t
end

keys.CreateRouteRequest = { ["DestinationCidrBlock"] = true, ["EgressOnlyInternetGatewayId"] = true, ["DryRun"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["RouteTableId"] = true, ["NatGatewayId"] = true, ["VpcPeeringConnectionId"] = true, ["GatewayId"] = true, ["DestinationIpv6CidrBlock"] = true, nil }

function asserts.AssertCreateRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteRequest[k], "CreateRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteRequest
-- <p>Contains the parameters for CreateRoute.</p>
-- @param _DestinationCidrBlock [String] <p>The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match.</p>
-- @param _EgressOnlyInternetGatewayId [String] <p>[IPv6 traffic only] The ID of an egress-only Internet gateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceId [String] <p>The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of a network interface.</p>
-- @param _RouteTableId [String] <p>The ID of the route table for the route.</p>
-- @param _NatGatewayId [String] <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of a VPC peering connection.</p>
-- @param _GatewayId [String] <p>The ID of an Internet gateway or virtual private gateway attached to your VPC.</p>
-- @param _DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.</p>
-- Required parameter: RouteTableId
function M.CreateRouteRequest(_DestinationCidrBlock, _EgressOnlyInternetGatewayId, _DryRun, _InstanceId, _NetworkInterfaceId, _RouteTableId, _NatGatewayId, _VpcPeeringConnectionId, _GatewayId, _DestinationIpv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateRouteRequest")
	local t = { 
		["DestinationCidrBlock"] = _DestinationCidrBlock,
		["EgressOnlyInternetGatewayId"] = _EgressOnlyInternetGatewayId,
		["DryRun"] = _DryRun,
		["InstanceId"] = _InstanceId,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["RouteTableId"] = _RouteTableId,
		["NatGatewayId"] = _NatGatewayId,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
		["GatewayId"] = _GatewayId,
		["DestinationIpv6CidrBlock"] = _DestinationIpv6CidrBlock,
	}
	asserts.AssertCreateRouteRequest(t)
	return t
end

keys.AssociateIamInstanceProfileResult = { ["IamInstanceProfileAssociation"] = true, nil }

function asserts.AssertAssociateIamInstanceProfileResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateIamInstanceProfileResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then asserts.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateIamInstanceProfileResult[k], "AssociateIamInstanceProfileResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateIamInstanceProfileResult
--  
-- @param _IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
function M.AssociateIamInstanceProfileResult(_IamInstanceProfileAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateIamInstanceProfileResult")
	local t = { 
		["IamInstanceProfileAssociation"] = _IamInstanceProfileAssociation,
	}
	asserts.AssertAssociateIamInstanceProfileResult(t)
	return t
end

keys.MoveAddressToVpcResult = { ["Status"] = true, ["AllocationId"] = true, nil }

function asserts.AssertMoveAddressToVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MoveAddressToVpcResult to be of type 'table'")
	if struct["Status"] then asserts.AssertStatus(struct["Status"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.MoveAddressToVpcResult[k], "MoveAddressToVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MoveAddressToVpcResult
-- <p>Contains the output of MoveAddressToVpc.</p>
-- @param _Status [Status] <p>The status of the move of the IP address.</p>
-- @param _AllocationId [String] <p>The allocation ID for the Elastic IP address.</p>
function M.MoveAddressToVpcResult(_Status, _AllocationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MoveAddressToVpcResult")
	local t = { 
		["Status"] = _Status,
		["AllocationId"] = _AllocationId,
	}
	asserts.AssertMoveAddressToVpcResult(t)
	return t
end

keys.AssociateDhcpOptionsRequest = { ["VpcId"] = true, ["DryRun"] = true, ["DhcpOptionsId"] = true, nil }

function asserts.AssertAssociateDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpOptionsId"], "Expected key DhcpOptionsId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateDhcpOptionsRequest[k], "AssociateDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateDhcpOptionsRequest
-- <p>Contains the parameters for AssociateDhcpOptions.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _DhcpOptionsId [String] <p>The ID of the DHCP options set, or <code>default</code> to associate no DHCP options with the VPC.</p>
-- Required parameter: DhcpOptionsId
-- Required parameter: VpcId
function M.AssociateDhcpOptionsRequest(_VpcId, _DryRun, _DhcpOptionsId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateDhcpOptionsRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
		["DhcpOptionsId"] = _DhcpOptionsId,
	}
	asserts.AssertAssociateDhcpOptionsRequest(t)
	return t
end

keys.MovingAddressStatus = { ["PublicIp"] = true, ["MoveStatus"] = true, nil }

function asserts.AssertMovingAddressStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MovingAddressStatus to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["MoveStatus"] then asserts.AssertMoveStatus(struct["MoveStatus"]) end
	for k,_ in pairs(struct) do
		assert(keys.MovingAddressStatus[k], "MovingAddressStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MovingAddressStatus
-- <p>Describes the status of a moving Elastic IP address.</p>
-- @param _PublicIp [String] <p>The Elastic IP address.</p>
-- @param _MoveStatus [MoveStatus] <p>The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.</p>
function M.MovingAddressStatus(_PublicIp, _MoveStatus, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MovingAddressStatus")
	local t = { 
		["PublicIp"] = _PublicIp,
		["MoveStatus"] = _MoveStatus,
	}
	asserts.AssertMovingAddressStatus(t)
	return t
end

keys.DeleteSubnetRequest = { ["SubnetId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteSubnetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSubnetRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSubnetRequest[k], "DeleteSubnetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSubnetRequest
-- <p>Contains the parameters for DeleteSubnet.</p>
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: SubnetId
function M.DeleteSubnetRequest(_SubnetId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteSubnetRequest")
	local t = { 
		["SubnetId"] = _SubnetId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteSubnetRequest(t)
	return t
end

keys.SpotInstanceStateFault = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertSpotInstanceStateFault(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceStateFault to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotInstanceStateFault[k], "SpotInstanceStateFault contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceStateFault
-- <p>Describes a Spot instance state change.</p>
-- @param _Message [String] <p>The message for the Spot instance state change.</p>
-- @param _Code [String] <p>The reason code for the Spot instance state change.</p>
function M.SpotInstanceStateFault(_Message, _Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotInstanceStateFault")
	local t = { 
		["Message"] = _Message,
		["Code"] = _Code,
	}
	asserts.AssertSpotInstanceStateFault(t)
	return t
end

keys.DhcpConfiguration = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertDhcpConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DhcpConfiguration to be of type 'table'")
	if struct["Values"] then asserts.AssertDhcpConfigurationValueList(struct["Values"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.DhcpConfiguration[k], "DhcpConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DhcpConfiguration
-- <p>Describes a DHCP configuration option.</p>
-- @param _Values [DhcpConfigurationValueList] <p>One or more values for the DHCP option.</p>
-- @param _Key [String] <p>The name of a DHCP option.</p>
function M.DhcpConfiguration(_Values, _Key, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DhcpConfiguration")
	local t = { 
		["Values"] = _Values,
		["Key"] = _Key,
	}
	asserts.AssertDhcpConfiguration(t)
	return t
end

keys.VolumeDetail = { ["Size"] = true, nil }

function asserts.AssertVolumeDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeDetail to be of type 'table'")
	assert(struct["Size"], "Expected key Size to exist in table")
	if struct["Size"] then asserts.AssertLong(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeDetail[k], "VolumeDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeDetail
-- <p>Describes an EBS volume.</p>
-- @param _Size [Long] <p>The size of the volume, in GiB.</p>
-- Required parameter: Size
function M.VolumeDetail(_Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeDetail")
	local t = { 
		["Size"] = _Size,
	}
	asserts.AssertVolumeDetail(t)
	return t
end

keys.DisassociateVpcCidrBlockRequest = { ["AssociationId"] = true, nil }

function asserts.AssertDisassociateVpcCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateVpcCidrBlockRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateVpcCidrBlockRequest[k], "DisassociateVpcCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateVpcCidrBlockRequest
--  
-- @param _AssociationId [String] <p>The association ID for the CIDR block.</p>
-- Required parameter: AssociationId
function M.DisassociateVpcCidrBlockRequest(_AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateVpcCidrBlockRequest")
	local t = { 
		["AssociationId"] = _AssociationId,
	}
	asserts.AssertDisassociateVpcCidrBlockRequest(t)
	return t
end

keys.Instance = { ["Monitoring"] = true, ["StateReason"] = true, ["PublicDnsName"] = true, ["Platform"] = true, ["State"] = true, ["EbsOptimized"] = true, ["LaunchTime"] = true, ["PublicIpAddress"] = true, ["RamdiskId"] = true, ["PrivateIpAddress"] = true, ["ProductCodes"] = true, ["VpcId"] = true, ["StateTransitionReason"] = true, ["InstanceId"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["ImageId"] = true, ["PrivateDnsName"] = true, ["KeyName"] = true, ["SecurityGroups"] = true, ["ClientToken"] = true, ["SubnetId"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, ["SourceDestCheck"] = true, ["Placement"] = true, ["Hypervisor"] = true, ["InstanceLifecycle"] = true, ["BlockDeviceMappings"] = true, ["Architecture"] = true, ["KernelId"] = true, ["IamInstanceProfile"] = true, ["RootDeviceName"] = true, ["VirtualizationType"] = true, ["RootDeviceType"] = true, ["Tags"] = true, ["SpotInstanceRequestId"] = true, ["AmiLaunchIndex"] = true, nil }

function asserts.AssertInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Instance to be of type 'table'")
	if struct["Monitoring"] then asserts.AssertMonitoring(struct["Monitoring"]) end
	if struct["StateReason"] then asserts.AssertStateReason(struct["StateReason"]) end
	if struct["PublicDnsName"] then asserts.AssertString(struct["PublicDnsName"]) end
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["State"] then asserts.AssertInstanceState(struct["State"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["LaunchTime"] then asserts.AssertDateTime(struct["LaunchTime"]) end
	if struct["PublicIpAddress"] then asserts.AssertString(struct["PublicIpAddress"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["StateTransitionReason"] then asserts.AssertString(struct["StateTransitionReason"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["EnaSupport"] then asserts.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertString(struct["SriovNetSupport"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then asserts.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceList(struct["NetworkInterfaces"]) end
	if struct["SourceDestCheck"] then asserts.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["Placement"] then asserts.AssertPlacement(struct["Placement"]) end
	if struct["Hypervisor"] then asserts.AssertHypervisorType(struct["Hypervisor"]) end
	if struct["InstanceLifecycle"] then asserts.AssertInstanceLifecycleType(struct["InstanceLifecycle"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertInstanceBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfile(struct["IamInstanceProfile"]) end
	if struct["RootDeviceName"] then asserts.AssertString(struct["RootDeviceName"]) end
	if struct["VirtualizationType"] then asserts.AssertVirtualizationType(struct["VirtualizationType"]) end
	if struct["RootDeviceType"] then asserts.AssertDeviceType(struct["RootDeviceType"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	if struct["AmiLaunchIndex"] then asserts.AssertInteger(struct["AmiLaunchIndex"]) end
	for k,_ in pairs(struct) do
		assert(keys.Instance[k], "Instance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Instance
-- <p>Describes an instance.</p>
-- @param _Monitoring [Monitoring] <p>The monitoring for the instance.</p>
-- @param _StateReason [StateReason] <p>The reason for the most recent state transition.</p>
-- @param _PublicDnsName [String] <p>(IPv4 only) The public DNS name assigned to the instance. This name is not available until the instance enters the <code>running</code> state. For EC2-VPC, this name is only available if you've enabled DNS hostnames for your VPC.</p>
-- @param _Platform [PlatformValues] <p>The value is <code>Windows</code> for Windows instances; otherwise blank.</p>
-- @param _State [InstanceState] <p>The current state of the instance.</p>
-- @param _EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
-- @param _LaunchTime [DateTime] <p>The time the instance was launched.</p>
-- @param _PublicIpAddress [String] <p>The public IPv4 address assigned to the instance, if applicable.</p>
-- @param _RamdiskId [String] <p>The RAM disk associated with this instance, if applicable.</p>
-- @param _PrivateIpAddress [String] <p>The private IPv4 address assigned to the instance.</p>
-- @param _ProductCodes [ProductCodeList] <p>The product codes attached to this instance, if applicable.</p>
-- @param _VpcId [String] <p>[EC2-VPC] The ID of the VPC in which the instance is running.</p>
-- @param _StateTransitionReason [String] <p>The reason for the most recent state transition. This might be an empty string.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _EnaSupport [Boolean] <p>Specifies whether enhanced networking with ENA is enabled.</p>
-- @param _SriovNetSupport [String] <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- @param _ImageId [String] <p>The ID of the AMI used to launch the instance.</p>
-- @param _PrivateDnsName [String] <p>(IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the <code>running</code> state. </p> <p>[EC2-VPC] The Amazon-provided DNS server will resolve Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.</p>
-- @param _KeyName [String] <p>The name of the key pair, if this instance was launched with an associated key pair.</p>
-- @param _SecurityGroups [GroupIdentifierList] <p>One or more security groups for the instance.</p>
-- @param _ClientToken [String] <p>The idempotency token you provided when you launched the instance, if applicable.</p>
-- @param _SubnetId [String] <p>[EC2-VPC] The ID of the subnet in which the instance is running.</p>
-- @param _InstanceType [InstanceType] <p>The instance type.</p>
-- @param _NetworkInterfaces [InstanceNetworkInterfaceList] <p>[EC2-VPC] One or more network interfaces for the instance.</p>
-- @param _SourceDestCheck [Boolean] <p>Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the instance to perform NAT. For more information, see <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html">NAT Instances</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- @param _Placement [Placement] <p>The location where the instance launched, if applicable.</p>
-- @param _Hypervisor [HypervisorType] <p>The hypervisor type of the instance.</p>
-- @param _InstanceLifecycle [InstanceLifecycleType] <p>Indicates whether this is a Spot instance or a Scheduled Instance.</p>
-- @param _BlockDeviceMappings [InstanceBlockDeviceMappingList] <p>Any block device mapping entries for the instance.</p>
-- @param _Architecture [ArchitectureValues] <p>The architecture of the image.</p>
-- @param _KernelId [String] <p>The kernel associated with this instance, if applicable.</p>
-- @param _IamInstanceProfile [IamInstanceProfile] <p>The IAM instance profile associated with the instance, if applicable.</p>
-- @param _RootDeviceName [String] <p>The root device name (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p>
-- @param _VirtualizationType [VirtualizationType] <p>The virtualization type of the instance.</p>
-- @param _RootDeviceType [DeviceType] <p>The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the instance.</p>
-- @param _SpotInstanceRequestId [String] <p>If the request is a Spot instance request, the ID of the request.</p>
-- @param _AmiLaunchIndex [Integer] <p>The AMI launch index, which can be used to find this instance in the launch group.</p>
function M.Instance(_Monitoring, _StateReason, _PublicDnsName, _Platform, _State, _EbsOptimized, _LaunchTime, _PublicIpAddress, _RamdiskId, _PrivateIpAddress, _ProductCodes, _VpcId, _StateTransitionReason, _InstanceId, _EnaSupport, _SriovNetSupport, _ImageId, _PrivateDnsName, _KeyName, _SecurityGroups, _ClientToken, _SubnetId, _InstanceType, _NetworkInterfaces, _SourceDestCheck, _Placement, _Hypervisor, _InstanceLifecycle, _BlockDeviceMappings, _Architecture, _KernelId, _IamInstanceProfile, _RootDeviceName, _VirtualizationType, _RootDeviceType, _Tags, _SpotInstanceRequestId, _AmiLaunchIndex, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Instance")
	local t = { 
		["Monitoring"] = _Monitoring,
		["StateReason"] = _StateReason,
		["PublicDnsName"] = _PublicDnsName,
		["Platform"] = _Platform,
		["State"] = _State,
		["EbsOptimized"] = _EbsOptimized,
		["LaunchTime"] = _LaunchTime,
		["PublicIpAddress"] = _PublicIpAddress,
		["RamdiskId"] = _RamdiskId,
		["PrivateIpAddress"] = _PrivateIpAddress,
		["ProductCodes"] = _ProductCodes,
		["VpcId"] = _VpcId,
		["StateTransitionReason"] = _StateTransitionReason,
		["InstanceId"] = _InstanceId,
		["EnaSupport"] = _EnaSupport,
		["SriovNetSupport"] = _SriovNetSupport,
		["ImageId"] = _ImageId,
		["PrivateDnsName"] = _PrivateDnsName,
		["KeyName"] = _KeyName,
		["SecurityGroups"] = _SecurityGroups,
		["ClientToken"] = _ClientToken,
		["SubnetId"] = _SubnetId,
		["InstanceType"] = _InstanceType,
		["NetworkInterfaces"] = _NetworkInterfaces,
		["SourceDestCheck"] = _SourceDestCheck,
		["Placement"] = _Placement,
		["Hypervisor"] = _Hypervisor,
		["InstanceLifecycle"] = _InstanceLifecycle,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["Architecture"] = _Architecture,
		["KernelId"] = _KernelId,
		["IamInstanceProfile"] = _IamInstanceProfile,
		["RootDeviceName"] = _RootDeviceName,
		["VirtualizationType"] = _VirtualizationType,
		["RootDeviceType"] = _RootDeviceType,
		["Tags"] = _Tags,
		["SpotInstanceRequestId"] = _SpotInstanceRequestId,
		["AmiLaunchIndex"] = _AmiLaunchIndex,
	}
	asserts.AssertInstance(t)
	return t
end

keys.DeleteNetworkInterfaceRequest = { ["NetworkInterfaceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkInterfaceRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkInterfaceRequest[k], "DeleteNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkInterfaceRequest
-- <p>Contains the parameters for DeleteNetworkInterface.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: NetworkInterfaceId
function M.DeleteNetworkInterfaceRequest(_NetworkInterfaceId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNetworkInterfaceRequest")
	local t = { 
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteNetworkInterfaceRequest(t)
	return t
end

keys.SpotFleetMonitoring = { ["Enabled"] = true, nil }

function asserts.AssertSpotFleetMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetMonitoring to be of type 'table'")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetMonitoring[k], "SpotFleetMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetMonitoring
-- <p>Describes whether monitoring is enabled.</p>
-- @param _Enabled [Boolean] <p>Enables monitoring for the instance.</p> <p>Default: <code>false</code> </p>
function M.SpotFleetMonitoring(_Enabled, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotFleetMonitoring")
	local t = { 
		["Enabled"] = _Enabled,
	}
	asserts.AssertSpotFleetMonitoring(t)
	return t
end

keys.RouteTable = { ["Associations"] = true, ["RouteTableId"] = true, ["VpcId"] = true, ["PropagatingVgws"] = true, ["Tags"] = true, ["Routes"] = true, nil }

function asserts.AssertRouteTable(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RouteTable to be of type 'table'")
	if struct["Associations"] then asserts.AssertRouteTableAssociationList(struct["Associations"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PropagatingVgws"] then asserts.AssertPropagatingVgwList(struct["PropagatingVgws"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Routes"] then asserts.AssertRouteList(struct["Routes"]) end
	for k,_ in pairs(struct) do
		assert(keys.RouteTable[k], "RouteTable contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RouteTable
-- <p>Describes a route table.</p>
-- @param _Associations [RouteTableAssociationList] <p>The associations between the route table and one or more subnets.</p>
-- @param _RouteTableId [String] <p>The ID of the route table.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _PropagatingVgws [PropagatingVgwList] <p>Any virtual private gateway (VGW) propagating routes.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the route table.</p>
-- @param _Routes [RouteList] <p>The routes in the route table.</p>
function M.RouteTable(_Associations, _RouteTableId, _VpcId, _PropagatingVgws, _Tags, _Routes, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RouteTable")
	local t = { 
		["Associations"] = _Associations,
		["RouteTableId"] = _RouteTableId,
		["VpcId"] = _VpcId,
		["PropagatingVgws"] = _PropagatingVgws,
		["Tags"] = _Tags,
		["Routes"] = _Routes,
	}
	asserts.AssertRouteTable(t)
	return t
end

keys.VpnConnectionOptionsSpecification = { ["StaticRoutesOnly"] = true, nil }

function asserts.AssertVpnConnectionOptionsSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnectionOptionsSpecification to be of type 'table'")
	if struct["StaticRoutesOnly"] then asserts.AssertBoolean(struct["StaticRoutesOnly"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnConnectionOptionsSpecification[k], "VpnConnectionOptionsSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnectionOptionsSpecification
-- <p>Describes VPN connection options.</p>
-- @param _StaticRoutesOnly [Boolean] <p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>
function M.VpnConnectionOptionsSpecification(_StaticRoutesOnly, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VpnConnectionOptionsSpecification")
	local t = { 
		["StaticRoutesOnly"] = _StaticRoutesOnly,
	}
	asserts.AssertVpnConnectionOptionsSpecification(t)
	return t
end

keys.DescribeNetworkAclsResult = { ["NetworkAcls"] = true, nil }

function asserts.AssertDescribeNetworkAclsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkAclsResult to be of type 'table'")
	if struct["NetworkAcls"] then asserts.AssertNetworkAclList(struct["NetworkAcls"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkAclsResult[k], "DescribeNetworkAclsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkAclsResult
-- <p>Contains the output of DescribeNetworkAcls.</p>
-- @param _NetworkAcls [NetworkAclList] <p>Information about one or more network ACLs.</p>
function M.DescribeNetworkAclsResult(_NetworkAcls, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkAclsResult")
	local t = { 
		["NetworkAcls"] = _NetworkAcls,
	}
	asserts.AssertDescribeNetworkAclsResult(t)
	return t
end

keys.CreateTagsRequest = { ["DryRun"] = true, ["Resources"] = true, ["Tags"] = true, nil }

function asserts.AssertCreateTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateTagsRequest to be of type 'table'")
	assert(struct["Resources"], "Expected key Resources to exist in table")
	assert(struct["Tags"], "Expected key Tags to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Resources"] then asserts.AssertResourceIdList(struct["Resources"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateTagsRequest[k], "CreateTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateTagsRequest
-- <p>Contains the parameters for CreateTags.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Resources [ResourceIdList] <p>The IDs of one or more resources to tag. For example, ami-1a2b3c4d.</p>
-- @param _Tags [TagList] <p>One or more tags. The <code>value</code> parameter is required, but if you don't want the tag to have a value, specify the parameter with no value, and we set the value to an empty string. </p>
-- Required parameter: Resources
-- Required parameter: Tags
function M.CreateTagsRequest(_DryRun, _Resources, _Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateTagsRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Resources"] = _Resources,
		["Tags"] = _Tags,
	}
	asserts.AssertCreateTagsRequest(t)
	return t
end

keys.HostOffering = { ["HourlyPrice"] = true, ["OfferingId"] = true, ["CurrencyCode"] = true, ["InstanceFamily"] = true, ["PaymentOption"] = true, ["UpfrontPrice"] = true, ["Duration"] = true, nil }

function asserts.AssertHostOffering(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostOffering to be of type 'table'")
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["InstanceFamily"] then asserts.AssertString(struct["InstanceFamily"]) end
	if struct["PaymentOption"] then asserts.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["UpfrontPrice"] then asserts.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then asserts.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostOffering[k], "HostOffering contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostOffering
-- <p>Details about the Dedicated Host Reservation offering.</p>
-- @param _HourlyPrice [String] <p>The hourly price of the offering.</p>
-- @param _OfferingId [String] <p>The ID of the offering.</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency of the offering.</p>
-- @param _InstanceFamily [String] <p>The instance family of the offering.</p>
-- @param _PaymentOption [PaymentOption] <p>The available payment option.</p>
-- @param _UpfrontPrice [String] <p>The upfront price of the offering. Does not apply to No Upfront offerings.</p>
-- @param _Duration [Integer] <p>The duration of the offering (in seconds).</p>
function M.HostOffering(_HourlyPrice, _OfferingId, _CurrencyCode, _InstanceFamily, _PaymentOption, _UpfrontPrice, _Duration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HostOffering")
	local t = { 
		["HourlyPrice"] = _HourlyPrice,
		["OfferingId"] = _OfferingId,
		["CurrencyCode"] = _CurrencyCode,
		["InstanceFamily"] = _InstanceFamily,
		["PaymentOption"] = _PaymentOption,
		["UpfrontPrice"] = _UpfrontPrice,
		["Duration"] = _Duration,
	}
	asserts.AssertHostOffering(t)
	return t
end

keys.DescribeVpcClassicLinkDnsSupportRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["VpcIds"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["VpcIds"] then asserts.AssertVpcClassicLinkIdList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkDnsSupportRequest[k], "DescribeVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkDnsSupportRequest
-- <p>Contains the parameters for DescribeVpcClassicLinkDnsSupport.</p>
-- @param _NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- @param _MaxResults [MaxResults] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- @param _VpcIds [VpcClassicLinkIdList] <p>One or more VPC IDs.</p>
function M.DescribeVpcClassicLinkDnsSupportRequest(_NextToken, _MaxResults, _VpcIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcClassicLinkDnsSupportRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["MaxResults"] = _MaxResults,
		["VpcIds"] = _VpcIds,
	}
	asserts.AssertDescribeVpcClassicLinkDnsSupportRequest(t)
	return t
end

keys.DescribeSpotInstanceRequestsRequest = { ["SpotInstanceRequestIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeSpotInstanceRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotInstanceRequestsRequest to be of type 'table'")
	if struct["SpotInstanceRequestIds"] then asserts.AssertSpotInstanceRequestIdList(struct["SpotInstanceRequestIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotInstanceRequestsRequest[k], "DescribeSpotInstanceRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotInstanceRequestsRequest
-- <p>Contains the parameters for DescribeSpotInstanceRequests.</p>
-- @param _SpotInstanceRequestIds [SpotInstanceRequestIdList] <p>One or more Spot instance request IDs.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone-group</code> - The Availability Zone group.</p> </li> <li> <p> <code>create-time</code> - The time stamp when the Spot instance request was created.</p> </li> <li> <p> <code>fault-code</code> - The fault code related to the request.</p> </li> <li> <p> <code>fault-message</code> - The fault message related to the request.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance that fulfilled the request.</p> </li> <li> <p> <code>launch-group</code> - The Spot instance launch group.</p> </li> <li> <p> <code>launch.block-device-mapping.delete-on-termination</code> - Indicates whether the Amazon EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>launch.block-device-mapping.device-name</code> - The device name for the Amazon EBS volume (for example, <code>/dev/sdh</code>).</p> </li> <li> <p> <code>launch.block-device-mapping.snapshot-id</code> - The ID of the snapshot used for the Amazon EBS volume.</p> </li> <li> <p> <code>launch.block-device-mapping.volume-size</code> - The size of the Amazon EBS volume, in GiB.</p> </li> <li> <p> <code>launch.block-device-mapping.volume-type</code> - The type of the Amazon EBS volume: <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code>for Cold HDD, or <code>standard</code> for Magnetic.</p> </li> <li> <p> <code>launch.group-id</code> - The security group for the instance.</p> </li> <li> <p> <code>launch.image-id</code> - The ID of the AMI.</p> </li> <li> <p> <code>launch.instance-type</code> - The type of instance (for example, <code>m3.medium</code>).</p> </li> <li> <p> <code>launch.kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>launch.key-name</code> - The name of the key pair the instance launched with.</p> </li> <li> <p> <code>launch.monitoring-enabled</code> - Whether monitoring is enabled for the Spot instance.</p> </li> <li> <p> <code>launch.ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>network-interface.network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>network-interface.device-index</code> - The index of the device for the network interface attachment on the instance.</p> </li> <li> <p> <code>network-interface.subnet-id</code> - The ID of the subnet for the instance.</p> </li> <li> <p> <code>network-interface.description</code> - A description of the network interface.</p> </li> <li> <p> <code>network-interface.private-ip-address</code> - The primary private IP address of the network interface.</p> </li> <li> <p> <code>network-interface.delete-on-termination</code> - Indicates whether the network interface is deleted when the instance is terminated.</p> </li> <li> <p> <code>network-interface.group-id</code> - The ID of the security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.group-name</code> - The name of the security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.addresses.primary</code> - Indicates whether the IP address is the primary private IP address.</p> </li> <li> <p> <code>product-description</code> - The product description associated with the instance (<code>Linux/UNIX</code> | <code>Windows</code>).</p> </li> <li> <p> <code>spot-instance-request-id</code> - The Spot instance request ID.</p> </li> <li> <p> <code>spot-price</code> - The maximum hourly price for any Spot instance launched to fulfill the request.</p> </li> <li> <p> <code>state</code> - The state of the Spot instance request (<code>open</code> | <code>active</code> | <code>closed</code> | <code>cancelled</code> | <code>failed</code>). Spot bid status information can help you track your Amazon EC2 Spot instance requests. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot Bid Status</a> in the Amazon Elastic Compute Cloud User Guide.</p> </li> <li> <p> <code>status-code</code> - The short code describing the most recent evaluation of your Spot instance request.</p> </li> <li> <p> <code>status-message</code> - The message explaining the status of the Spot instance request.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>type</code> - The type of Spot instance request (<code>one-time</code> | <code>persistent</code>).</p> </li> <li> <p> <code>launched-availability-zone</code> - The Availability Zone in which the bid is launched.</p> </li> <li> <p> <code>valid-from</code> - The start date of the request.</p> </li> <li> <p> <code>valid-until</code> - The end date of the request.</p> </li> </ul>
function M.DescribeSpotInstanceRequestsRequest(_SpotInstanceRequestIds, _DryRun, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotInstanceRequestsRequest")
	local t = { 
		["SpotInstanceRequestIds"] = _SpotInstanceRequestIds,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeSpotInstanceRequestsRequest(t)
	return t
end

keys.DeleteRouteTableRequest = { ["RouteTableId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRouteTableRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteRouteTableRequest[k], "DeleteRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRouteTableRequest
-- <p>Contains the parameters for DeleteRouteTable.</p>
-- @param _RouteTableId [String] <p>The ID of the route table.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: RouteTableId
function M.DeleteRouteTableRequest(_RouteTableId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteRouteTableRequest")
	local t = { 
		["RouteTableId"] = _RouteTableId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteRouteTableRequest(t)
	return t
end

keys.CreateVpnConnectionRouteRequest = { ["VpnConnectionId"] = true, ["DestinationCidrBlock"] = true, nil }

function asserts.AssertCreateVpnConnectionRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionRouteRequest to be of type 'table'")
	assert(struct["DestinationCidrBlock"], "Expected key DestinationCidrBlock to exist in table")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnConnectionRouteRequest[k], "CreateVpnConnectionRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionRouteRequest
-- <p>Contains the parameters for CreateVpnConnectionRoute.</p>
-- @param _VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- @param _DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer network.</p>
-- Required parameter: DestinationCidrBlock
-- Required parameter: VpnConnectionId
function M.CreateVpnConnectionRouteRequest(_VpnConnectionId, _DestinationCidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnConnectionRouteRequest")
	local t = { 
		["VpnConnectionId"] = _VpnConnectionId,
		["DestinationCidrBlock"] = _DestinationCidrBlock,
	}
	asserts.AssertCreateVpnConnectionRouteRequest(t)
	return t
end

keys.CreateVpnGatewayRequest = { ["DryRun"] = true, ["AvailabilityZone"] = true, ["Type"] = true, nil }

function asserts.AssertCreateVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnGatewayRequest to be of type 'table'")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnGatewayRequest[k], "CreateVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnGatewayRequest
-- <p>Contains the parameters for CreateVpnGateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone for the virtual private gateway.</p>
-- @param _Type [GatewayType] <p>The type of VPN connection this virtual private gateway supports.</p>
-- Required parameter: Type
function M.CreateVpnGatewayRequest(_DryRun, _AvailabilityZone, _Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnGatewayRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["AvailabilityZone"] = _AvailabilityZone,
		["Type"] = _Type,
	}
	asserts.AssertCreateVpnGatewayRequest(t)
	return t
end

keys.DescribeVpcPeeringConnectionsResult = { ["VpcPeeringConnections"] = true, nil }

function asserts.AssertDescribeVpcPeeringConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcPeeringConnectionsResult to be of type 'table'")
	if struct["VpcPeeringConnections"] then asserts.AssertVpcPeeringConnectionList(struct["VpcPeeringConnections"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcPeeringConnectionsResult[k], "DescribeVpcPeeringConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcPeeringConnectionsResult
-- <p>Contains the output of DescribeVpcPeeringConnections.</p>
-- @param _VpcPeeringConnections [VpcPeeringConnectionList] <p>Information about the VPC peering connections.</p>
function M.DescribeVpcPeeringConnectionsResult(_VpcPeeringConnections, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcPeeringConnectionsResult")
	local t = { 
		["VpcPeeringConnections"] = _VpcPeeringConnections,
	}
	asserts.AssertDescribeVpcPeeringConnectionsResult(t)
	return t
end

keys.CreateDhcpOptionsResult = { ["DhcpOptions"] = true, nil }

function asserts.AssertCreateDhcpOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDhcpOptionsResult to be of type 'table'")
	if struct["DhcpOptions"] then asserts.AssertDhcpOptions(struct["DhcpOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDhcpOptionsResult[k], "CreateDhcpOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDhcpOptionsResult
-- <p>Contains the output of CreateDhcpOptions.</p>
-- @param _DhcpOptions [DhcpOptions] <p>A set of DHCP options.</p>
function M.CreateDhcpOptionsResult(_DhcpOptions, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateDhcpOptionsResult")
	local t = { 
		["DhcpOptions"] = _DhcpOptions,
	}
	asserts.AssertCreateDhcpOptionsResult(t)
	return t
end

keys.DeleteKeyPairRequest = { ["KeyName"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteKeyPairRequest[k], "DeleteKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteKeyPairRequest
-- <p>Contains the parameters for DeleteKeyPair.</p>
-- @param _KeyName [String] <p>The name of the key pair.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: KeyName
function M.DeleteKeyPairRequest(_KeyName, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteKeyPairRequest")
	local t = { 
		["KeyName"] = _KeyName,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteKeyPairRequest(t)
	return t
end

keys.EventInformation = { ["InstanceId"] = true, ["EventSubType"] = true, ["EventDescription"] = true, nil }

function asserts.AssertEventInformation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EventInformation to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["EventSubType"] then asserts.AssertString(struct["EventSubType"]) end
	if struct["EventDescription"] then asserts.AssertString(struct["EventDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.EventInformation[k], "EventInformation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EventInformation
-- <p>Describes a Spot fleet event.</p>
-- @param _InstanceId [String] <p>The ID of the instance. This information is available only for <code>instanceChange</code> events.</p>
-- @param _EventSubType [String] <p>The event.</p> <p>The following are the <code>error</code> events.</p> <ul> <li> <p> <code>iamFleetRoleInvalid</code> - The Spot fleet did not have the required permissions either to launch or terminate an instance.</p> </li> <li> <p> <code>launchSpecTemporarilyBlacklisted</code> - The configuration is not valid and several attempts to launch instances have failed. For more information, see the description of the event.</p> </li> <li> <p> <code>spotFleetRequestConfigurationInvalid</code> - The configuration is not valid. For more information, see the description of the event.</p> </li> <li> <p> <code>spotInstanceCountLimitExceeded</code> - You've reached the limit on the number of Spot instances that you can launch.</p> </li> </ul> <p>The following are the <code>fleetRequestChange</code> events.</p> <ul> <li> <p> <code>active</code> - The Spot fleet has been validated and Amazon EC2 is attempting to maintain the target number of running Spot instances.</p> </li> <li> <p> <code>cancelled</code> - The Spot fleet is canceled and has no running Spot instances. The Spot fleet will be deleted two days after its instances were terminated.</p> </li> <li> <p> <code>cancelled_running</code> - The Spot fleet is canceled and will not launch additional Spot instances, but its existing Spot instances continue to run until they are interrupted or terminated.</p> </li> <li> <p> <code>cancelled_terminating</code> - The Spot fleet is canceled and its Spot instances are terminating.</p> </li> <li> <p> <code>expired</code> - The Spot fleet request has expired. A subsequent event indicates that the instances were terminated, if the request was created with <code>TerminateInstancesWithExpiration</code> set.</p> </li> <li> <p> <code>modify_in_progress</code> - A request to modify the Spot fleet request was accepted and is in progress.</p> </li> <li> <p> <code>modify_successful</code> - The Spot fleet request was modified.</p> </li> <li> <p> <code>price_update</code> - The bid price for a launch configuration was adjusted because it was too high. This change is permanent.</p> </li> <li> <p> <code>submitted</code> - The Spot fleet request is being evaluated and Amazon EC2 is preparing to launch the target number of Spot instances.</p> </li> </ul> <p>The following are the <code>instanceChange</code> events.</p> <ul> <li> <p> <code>launched</code> - A bid was fulfilled and a new instance was launched.</p> </li> <li> <p> <code>terminated</code> - An instance was terminated by the user.</p> </li> </ul>
-- @param _EventDescription [String] <p>The description of the event.</p>
function M.EventInformation(_InstanceId, _EventSubType, _EventDescription, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EventInformation")
	local t = { 
		["InstanceId"] = _InstanceId,
		["EventSubType"] = _EventSubType,
		["EventDescription"] = _EventDescription,
	}
	asserts.AssertEventInformation(t)
	return t
end

keys.TerminateInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertTerminateInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.TerminateInstancesRequest[k], "TerminateInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateInstancesRequest
-- <p>Contains the parameters for TerminateInstances.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Constraints: Up to 1000 instance IDs. We recommend breaking up this request into smaller batches.</p>
-- Required parameter: InstanceIds
function M.TerminateInstancesRequest(_DryRun, _InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TerminateInstancesRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["InstanceIds"] = _InstanceIds,
	}
	asserts.AssertTerminateInstancesRequest(t)
	return t
end

keys.CreateVpnConnectionResult = { ["VpnConnection"] = true, nil }

function asserts.AssertCreateVpnConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionResult to be of type 'table'")
	if struct["VpnConnection"] then asserts.AssertVpnConnection(struct["VpnConnection"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnConnectionResult[k], "CreateVpnConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionResult
-- <p>Contains the output of CreateVpnConnection.</p>
-- @param _VpnConnection [VpnConnection] <p>Information about the VPN connection.</p>
function M.CreateVpnConnectionResult(_VpnConnection, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpnConnectionResult")
	local t = { 
		["VpnConnection"] = _VpnConnection,
	}
	asserts.AssertCreateVpnConnectionResult(t)
	return t
end

keys.InstanceStatusDetails = { ["Status"] = true, ["ImpairedSince"] = true, ["Name"] = true, nil }

function asserts.AssertInstanceStatusDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusDetails to be of type 'table'")
	if struct["Status"] then asserts.AssertStatusType(struct["Status"]) end
	if struct["ImpairedSince"] then asserts.AssertDateTime(struct["ImpairedSince"]) end
	if struct["Name"] then asserts.AssertStatusName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatusDetails[k], "InstanceStatusDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusDetails
-- <p>Describes the instance status.</p>
-- @param _Status [StatusType] <p>The status.</p>
-- @param _ImpairedSince [DateTime] <p>The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.</p>
-- @param _Name [StatusName] <p>The type of instance status.</p>
function M.InstanceStatusDetails(_Status, _ImpairedSince, _Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStatusDetails")
	local t = { 
		["Status"] = _Status,
		["ImpairedSince"] = _ImpairedSince,
		["Name"] = _Name,
	}
	asserts.AssertInstanceStatusDetails(t)
	return t
end

keys.SlotStartTimeRangeRequest = { ["LatestTime"] = true, ["EarliestTime"] = true, nil }

function asserts.AssertSlotStartTimeRangeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SlotStartTimeRangeRequest to be of type 'table'")
	if struct["LatestTime"] then asserts.AssertDateTime(struct["LatestTime"]) end
	if struct["EarliestTime"] then asserts.AssertDateTime(struct["EarliestTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.SlotStartTimeRangeRequest[k], "SlotStartTimeRangeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SlotStartTimeRangeRequest
-- <p>Describes the time period for a Scheduled Instance to start its first schedule.</p>
-- @param _LatestTime [DateTime] <p>The latest date and time, in UTC, for the Scheduled Instance to start.</p>
-- @param _EarliestTime [DateTime] <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
function M.SlotStartTimeRangeRequest(_LatestTime, _EarliestTime, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SlotStartTimeRangeRequest")
	local t = { 
		["LatestTime"] = _LatestTime,
		["EarliestTime"] = _EarliestTime,
	}
	asserts.AssertSlotStartTimeRangeRequest(t)
	return t
end

keys.DescribeRouteTablesResult = { ["RouteTables"] = true, nil }

function asserts.AssertDescribeRouteTablesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRouteTablesResult to be of type 'table'")
	if struct["RouteTables"] then asserts.AssertRouteTableList(struct["RouteTables"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRouteTablesResult[k], "DescribeRouteTablesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRouteTablesResult
-- <p>Contains the output of DescribeRouteTables.</p>
-- @param _RouteTables [RouteTableList] <p>Information about one or more route tables.</p>
function M.DescribeRouteTablesResult(_RouteTables, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeRouteTablesResult")
	local t = { 
		["RouteTables"] = _RouteTables,
	}
	asserts.AssertDescribeRouteTablesResult(t)
	return t
end

keys.ReservedInstancesModification = { ["Status"] = true, ["ModificationResults"] = true, ["EffectiveDate"] = true, ["CreateDate"] = true, ["StatusMessage"] = true, ["ClientToken"] = true, ["ReservedInstancesModificationId"] = true, ["ReservedInstancesIds"] = true, ["UpdateDate"] = true, nil }

function asserts.AssertReservedInstancesModification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesModification to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["ModificationResults"] then asserts.AssertReservedInstancesModificationResultList(struct["ModificationResults"]) end
	if struct["EffectiveDate"] then asserts.AssertDateTime(struct["EffectiveDate"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ReservedInstancesModificationId"] then asserts.AssertString(struct["ReservedInstancesModificationId"]) end
	if struct["ReservedInstancesIds"] then asserts.AssertReservedIntancesIds(struct["ReservedInstancesIds"]) end
	if struct["UpdateDate"] then asserts.AssertDateTime(struct["UpdateDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesModification[k], "ReservedInstancesModification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesModification
-- <p>Describes a Reserved Instance modification.</p>
-- @param _Status [String] <p>The status of the Reserved Instances modification request.</p>
-- @param _ModificationResults [ReservedInstancesModificationResultList] <p>Contains target configurations along with their corresponding new Reserved Instance IDs.</p>
-- @param _EffectiveDate [DateTime] <p>The time for the modification to become effective.</p>
-- @param _CreateDate [DateTime] <p>The time when the modification request was created.</p>
-- @param _StatusMessage [String] <p>The reason for the status.</p>
-- @param _ClientToken [String] <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- @param _ReservedInstancesModificationId [String] <p>A unique ID for the Reserved Instance modification.</p>
-- @param _ReservedInstancesIds [ReservedIntancesIds] <p>The IDs of one or more Reserved Instances.</p>
-- @param _UpdateDate [DateTime] <p>The time when the modification request was last updated.</p>
function M.ReservedInstancesModification(_Status, _ModificationResults, _EffectiveDate, _CreateDate, _StatusMessage, _ClientToken, _ReservedInstancesModificationId, _ReservedInstancesIds, _UpdateDate, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesModification")
	local t = { 
		["Status"] = _Status,
		["ModificationResults"] = _ModificationResults,
		["EffectiveDate"] = _EffectiveDate,
		["CreateDate"] = _CreateDate,
		["StatusMessage"] = _StatusMessage,
		["ClientToken"] = _ClientToken,
		["ReservedInstancesModificationId"] = _ReservedInstancesModificationId,
		["ReservedInstancesIds"] = _ReservedInstancesIds,
		["UpdateDate"] = _UpdateDate,
	}
	asserts.AssertReservedInstancesModification(t)
	return t
end

keys.DescribeSpotFleetRequestHistoryRequest = { ["SpotFleetRequestId"] = true, ["DryRun"] = true, ["EventType"] = true, ["MaxResults"] = true, ["StartTime"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestHistoryRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["StartTime"], "Expected key StartTime to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["EventType"] then asserts.AssertEventType(struct["EventType"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestHistoryRequest[k], "DescribeSpotFleetRequestHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestHistoryRequest
-- <p>Contains the parameters for DescribeSpotFleetRequestHistory.</p>
-- @param _SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _EventType [EventType] <p>The type of events to describe. By default, all events are described.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @param _StartTime [DateTime] <p>The starting date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @param _NextToken [String] <p>The token for the next set of results.</p>
-- Required parameter: SpotFleetRequestId
-- Required parameter: StartTime
function M.DescribeSpotFleetRequestHistoryRequest(_SpotFleetRequestId, _DryRun, _EventType, _MaxResults, _StartTime, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotFleetRequestHistoryRequest")
	local t = { 
		["SpotFleetRequestId"] = _SpotFleetRequestId,
		["DryRun"] = _DryRun,
		["EventType"] = _EventType,
		["MaxResults"] = _MaxResults,
		["StartTime"] = _StartTime,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeSpotFleetRequestHistoryRequest(t)
	return t
end

keys.InstanceIpv6Address = { ["Ipv6Address"] = true, nil }

function asserts.AssertInstanceIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertString(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceIpv6Address[k], "InstanceIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceIpv6Address
-- <p>Describes an IPv6 address.</p>
-- @param _Ipv6Address [String] <p>The IPv6 address.</p>
function M.InstanceIpv6Address(_Ipv6Address, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceIpv6Address")
	local t = { 
		["Ipv6Address"] = _Ipv6Address,
	}
	asserts.AssertInstanceIpv6Address(t)
	return t
end

keys.Ipv6CidrBlock = { ["Ipv6CidrBlock"] = true, nil }

function asserts.AssertIpv6CidrBlock(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Ipv6CidrBlock to be of type 'table'")
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.Ipv6CidrBlock[k], "Ipv6CidrBlock contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Ipv6CidrBlock
-- <p>Describes an IPv6 CIDR block.</p>
-- @param _Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
function M.Ipv6CidrBlock(_Ipv6CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Ipv6CidrBlock")
	local t = { 
		["Ipv6CidrBlock"] = _Ipv6CidrBlock,
	}
	asserts.AssertIpv6CidrBlock(t)
	return t
end

keys.ModifyVpcEndpointRequest = { ["DryRun"] = true, ["AddRouteTableIds"] = true, ["ResetPolicy"] = true, ["RemoveRouteTableIds"] = true, ["PolicyDocument"] = true, ["VpcEndpointId"] = true, nil }

function asserts.AssertModifyVpcEndpointRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointRequest to be of type 'table'")
	assert(struct["VpcEndpointId"], "Expected key VpcEndpointId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AddRouteTableIds"] then asserts.AssertValueStringList(struct["AddRouteTableIds"]) end
	if struct["ResetPolicy"] then asserts.AssertBoolean(struct["ResetPolicy"]) end
	if struct["RemoveRouteTableIds"] then asserts.AssertValueStringList(struct["RemoveRouteTableIds"]) end
	if struct["PolicyDocument"] then asserts.AssertString(struct["PolicyDocument"]) end
	if struct["VpcEndpointId"] then asserts.AssertString(struct["VpcEndpointId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointRequest[k], "ModifyVpcEndpointRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointRequest
-- <p>Contains the parameters for ModifyVpcEndpoint.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _AddRouteTableIds [ValueStringList] <p>One or more route tables IDs to associate with the endpoint.</p>
-- @param _ResetPolicy [Boolean] <p>Specify <code>true</code> to reset the policy document to the default policy. The default policy allows access to the service.</p>
-- @param _RemoveRouteTableIds [ValueStringList] <p>One or more route table IDs to disassociate from the endpoint.</p>
-- @param _PolicyDocument [String] <p>A policy document to attach to the endpoint. The policy must be in valid JSON format.</p>
-- @param _VpcEndpointId [String] <p>The ID of the endpoint.</p>
-- Required parameter: VpcEndpointId
function M.ModifyVpcEndpointRequest(_DryRun, _AddRouteTableIds, _ResetPolicy, _RemoveRouteTableIds, _PolicyDocument, _VpcEndpointId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVpcEndpointRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["AddRouteTableIds"] = _AddRouteTableIds,
		["ResetPolicy"] = _ResetPolicy,
		["RemoveRouteTableIds"] = _RemoveRouteTableIds,
		["PolicyDocument"] = _PolicyDocument,
		["VpcEndpointId"] = _VpcEndpointId,
	}
	asserts.AssertModifyVpcEndpointRequest(t)
	return t
end

keys.ReservedInstancesListing = { ["ReservedInstancesId"] = true, ["Status"] = true, ["Tags"] = true, ["PriceSchedules"] = true, ["CreateDate"] = true, ["ClientToken"] = true, ["ReservedInstancesListingId"] = true, ["UpdateDate"] = true, ["InstanceCounts"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertReservedInstancesListing(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesListing to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["Status"] then asserts.AssertListingStatus(struct["Status"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["PriceSchedules"] then asserts.AssertPriceScheduleList(struct["PriceSchedules"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ReservedInstancesListingId"] then asserts.AssertString(struct["ReservedInstancesListingId"]) end
	if struct["UpdateDate"] then asserts.AssertDateTime(struct["UpdateDate"]) end
	if struct["InstanceCounts"] then asserts.AssertInstanceCountList(struct["InstanceCounts"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesListing[k], "ReservedInstancesListing contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesListing
-- <p>Describes a Reserved Instance listing.</p>
-- @param _ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- @param _Status [ListingStatus] <p>The status of the Reserved Instance listing.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the resource.</p>
-- @param _PriceSchedules [PriceScheduleList] <p>The price of the Reserved Instance listing.</p>
-- @param _CreateDate [DateTime] <p>The time the listing was created.</p>
-- @param _ClientToken [String] <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- @param _ReservedInstancesListingId [String] <p>The ID of the Reserved Instance listing.</p>
-- @param _UpdateDate [DateTime] <p>The last modified timestamp of the listing.</p>
-- @param _InstanceCounts [InstanceCountList] <p>The number of instances in this state.</p>
-- @param _StatusMessage [String] <p>The reason for the current status of the Reserved Instance listing. The response can be blank.</p>
function M.ReservedInstancesListing(_ReservedInstancesId, _Status, _Tags, _PriceSchedules, _CreateDate, _ClientToken, _ReservedInstancesListingId, _UpdateDate, _InstanceCounts, _StatusMessage, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesListing")
	local t = { 
		["ReservedInstancesId"] = _ReservedInstancesId,
		["Status"] = _Status,
		["Tags"] = _Tags,
		["PriceSchedules"] = _PriceSchedules,
		["CreateDate"] = _CreateDate,
		["ClientToken"] = _ClientToken,
		["ReservedInstancesListingId"] = _ReservedInstancesListingId,
		["UpdateDate"] = _UpdateDate,
		["InstanceCounts"] = _InstanceCounts,
		["StatusMessage"] = _StatusMessage,
	}
	asserts.AssertReservedInstancesListing(t)
	return t
end

keys.Route = { ["Origin"] = true, ["DestinationCidrBlock"] = true, ["EgressOnlyInternetGatewayId"] = true, ["DestinationPrefixListId"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["State"] = true, ["NatGatewayId"] = true, ["VpcPeeringConnectionId"] = true, ["GatewayId"] = true, ["DestinationIpv6CidrBlock"] = true, ["InstanceOwnerId"] = true, nil }

function asserts.AssertRoute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Route to be of type 'table'")
	if struct["Origin"] then asserts.AssertRouteOrigin(struct["Origin"]) end
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DestinationPrefixListId"] then asserts.AssertString(struct["DestinationPrefixListId"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["State"] then asserts.AssertRouteState(struct["State"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	if struct["InstanceOwnerId"] then asserts.AssertString(struct["InstanceOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.Route[k], "Route contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Route
-- <p>Describes a route in a route table.</p>
-- @param _Origin [RouteOrigin] <p>Describes how the route was created.</p> <ul> <li> <p> <code>CreateRouteTable</code> - The route was automatically created when the route table was created.</p> </li> <li> <p> <code>CreateRoute</code> - The route was manually added to the route table.</p> </li> <li> <p> <code>EnableVgwRoutePropagation</code> - The route was propagated by route propagation.</p> </li> </ul>
-- @param _DestinationCidrBlock [String] <p>The IPv4 CIDR block used for the destination match.</p>
-- @param _EgressOnlyInternetGatewayId [String] <p>The ID of the egress-only Internet gateway.</p>
-- @param _DestinationPrefixListId [String] <p>The prefix of the AWS service.</p>
-- @param _InstanceId [String] <p>The ID of a NAT instance in your VPC.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _State [RouteState] <p>The state of the route. The <code>blackhole</code> state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, or the specified NAT instance has been terminated).</p>
-- @param _NatGatewayId [String] <p>The ID of a NAT gateway.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- @param _GatewayId [String] <p>The ID of a gateway attached to your VPC.</p>
-- @param _DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR block used for the destination match.</p>
-- @param _InstanceOwnerId [String] <p>The AWS account ID of the owner of the instance.</p>
function M.Route(_Origin, _DestinationCidrBlock, _EgressOnlyInternetGatewayId, _DestinationPrefixListId, _InstanceId, _NetworkInterfaceId, _State, _NatGatewayId, _VpcPeeringConnectionId, _GatewayId, _DestinationIpv6CidrBlock, _InstanceOwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Route")
	local t = { 
		["Origin"] = _Origin,
		["DestinationCidrBlock"] = _DestinationCidrBlock,
		["EgressOnlyInternetGatewayId"] = _EgressOnlyInternetGatewayId,
		["DestinationPrefixListId"] = _DestinationPrefixListId,
		["InstanceId"] = _InstanceId,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["State"] = _State,
		["NatGatewayId"] = _NatGatewayId,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
		["GatewayId"] = _GatewayId,
		["DestinationIpv6CidrBlock"] = _DestinationIpv6CidrBlock,
		["InstanceOwnerId"] = _InstanceOwnerId,
	}
	asserts.AssertRoute(t)
	return t
end

keys.ProductCode = { ["ProductCodeId"] = true, ["ProductCodeType"] = true, nil }

function asserts.AssertProductCode(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProductCode to be of type 'table'")
	if struct["ProductCodeId"] then asserts.AssertString(struct["ProductCodeId"]) end
	if struct["ProductCodeType"] then asserts.AssertProductCodeValues(struct["ProductCodeType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ProductCode[k], "ProductCode contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProductCode
-- <p>Describes a product code.</p>
-- @param _ProductCodeId [String] <p>The product code.</p>
-- @param _ProductCodeType [ProductCodeValues] <p>The type of product code.</p>
function M.ProductCode(_ProductCodeId, _ProductCodeType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ProductCode")
	local t = { 
		["ProductCodeId"] = _ProductCodeId,
		["ProductCodeType"] = _ProductCodeType,
	}
	asserts.AssertProductCode(t)
	return t
end

keys.Ipv6Range = { ["CidrIpv6"] = true, nil }

function asserts.AssertIpv6Range(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Ipv6Range to be of type 'table'")
	if struct["CidrIpv6"] then asserts.AssertString(struct["CidrIpv6"]) end
	for k,_ in pairs(struct) do
		assert(keys.Ipv6Range[k], "Ipv6Range contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Ipv6Range
-- <p>[EC2-VPC only] Describes an IPv6 range.</p>
-- @param _CidrIpv6 [String] <p>The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix.</p>
function M.Ipv6Range(_CidrIpv6, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Ipv6Range")
	local t = { 
		["CidrIpv6"] = _CidrIpv6,
	}
	asserts.AssertIpv6Range(t)
	return t
end

keys.AcceptReservedInstancesExchangeQuoteResult = { ["ExchangeId"] = true, nil }

function asserts.AssertAcceptReservedInstancesExchangeQuoteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptReservedInstancesExchangeQuoteResult to be of type 'table'")
	if struct["ExchangeId"] then asserts.AssertString(struct["ExchangeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptReservedInstancesExchangeQuoteResult[k], "AcceptReservedInstancesExchangeQuoteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptReservedInstancesExchangeQuoteResult
-- <p>The result of the exchange and whether it was <code>successful</code>.</p>
-- @param _ExchangeId [String] <p>The ID of the successful exchange.</p>
function M.AcceptReservedInstancesExchangeQuoteResult(_ExchangeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AcceptReservedInstancesExchangeQuoteResult")
	local t = { 
		["ExchangeId"] = _ExchangeId,
	}
	asserts.AssertAcceptReservedInstancesExchangeQuoteResult(t)
	return t
end

keys.AssociateSubnetCidrBlockResult = { ["SubnetId"] = true, ["Ipv6CidrBlockAssociation"] = true, nil }

function asserts.AssertAssociateSubnetCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateSubnetCidrBlockResult to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertSubnetIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateSubnetCidrBlockResult[k], "AssociateSubnetCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateSubnetCidrBlockResult
--  
-- @param _SubnetId [String] <p>The ID of the subnet.</p>
-- @param _Ipv6CidrBlockAssociation [SubnetIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
function M.AssociateSubnetCidrBlockResult(_SubnetId, _Ipv6CidrBlockAssociation, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateSubnetCidrBlockResult")
	local t = { 
		["SubnetId"] = _SubnetId,
		["Ipv6CidrBlockAssociation"] = _Ipv6CidrBlockAssociation,
	}
	asserts.AssertAssociateSubnetCidrBlockResult(t)
	return t
end

keys.SpotPrice = { ["Timestamp"] = true, ["AvailabilityZone"] = true, ["InstanceType"] = true, ["ProductDescription"] = true, ["SpotPrice"] = true, nil }

function asserts.AssertSpotPrice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotPrice to be of type 'table'")
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotPrice[k], "SpotPrice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotPrice
-- <p>Describes the maximum hourly price (bid) for any Spot instance launched to fulfill the request.</p>
-- @param _Timestamp [DateTime] <p>The date and time the request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone.</p>
-- @param _InstanceType [InstanceType] <p>The instance type. Note that T2 and HS1 instance types are not supported.</p>
-- @param _ProductDescription [RIProductDescription] <p>A general description of the AMI.</p>
-- @param _SpotPrice [String] <p>The maximum price (bid) that you are willing to pay for a Spot instance.</p>
function M.SpotPrice(_Timestamp, _AvailabilityZone, _InstanceType, _ProductDescription, _SpotPrice, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotPrice")
	local t = { 
		["Timestamp"] = _Timestamp,
		["AvailabilityZone"] = _AvailabilityZone,
		["InstanceType"] = _InstanceType,
		["ProductDescription"] = _ProductDescription,
		["SpotPrice"] = _SpotPrice,
	}
	asserts.AssertSpotPrice(t)
	return t
end

keys.PrefixList = { ["PrefixListName"] = true, ["Cidrs"] = true, ["PrefixListId"] = true, nil }

function asserts.AssertPrefixList(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrefixList to be of type 'table'")
	if struct["PrefixListName"] then asserts.AssertString(struct["PrefixListName"]) end
	if struct["Cidrs"] then asserts.AssertValueStringList(struct["Cidrs"]) end
	if struct["PrefixListId"] then asserts.AssertString(struct["PrefixListId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrefixList[k], "PrefixList contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrefixList
-- <p>Describes prefixes for AWS services.</p>
-- @param _PrefixListName [String] <p>The name of the prefix.</p>
-- @param _Cidrs [ValueStringList] <p>The IP address range of the AWS service.</p>
-- @param _PrefixListId [String] <p>The ID of the prefix.</p>
function M.PrefixList(_PrefixListName, _Cidrs, _PrefixListId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PrefixList")
	local t = { 
		["PrefixListName"] = _PrefixListName,
		["Cidrs"] = _Cidrs,
		["PrefixListId"] = _PrefixListId,
	}
	asserts.AssertPrefixList(t)
	return t
end

keys.DeleteVpcEndpointsRequest = { ["VpcEndpointIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpcEndpointsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointsRequest to be of type 'table'")
	assert(struct["VpcEndpointIds"], "Expected key VpcEndpointIds to exist in table")
	if struct["VpcEndpointIds"] then asserts.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointsRequest[k], "DeleteVpcEndpointsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointsRequest
-- <p>Contains the parameters for DeleteVpcEndpoints.</p>
-- @param _VpcEndpointIds [ValueStringList] <p>One or more endpoint IDs.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcEndpointIds
function M.DeleteVpcEndpointsRequest(_VpcEndpointIds, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteVpcEndpointsRequest")
	local t = { 
		["VpcEndpointIds"] = _VpcEndpointIds,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteVpcEndpointsRequest(t)
	return t
end

keys.Image = { ["RootDeviceType"] = true, ["State"] = true, ["ImageLocation"] = true, ["RamdiskId"] = true, ["Public"] = true, ["ProductCodes"] = true, ["Description"] = true, ["Tags"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["ImageId"] = true, ["KernelId"] = true, ["Name"] = true, ["Hypervisor"] = true, ["BlockDeviceMappings"] = true, ["Architecture"] = true, ["ImageOwnerAlias"] = true, ["StateReason"] = true, ["RootDeviceName"] = true, ["ImageType"] = true, ["VirtualizationType"] = true, ["Platform"] = true, ["OwnerId"] = true, ["CreationDate"] = true, nil }

function asserts.AssertImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Image to be of type 'table'")
	if struct["RootDeviceType"] then asserts.AssertDeviceType(struct["RootDeviceType"]) end
	if struct["State"] then asserts.AssertImageState(struct["State"]) end
	if struct["ImageLocation"] then asserts.AssertString(struct["ImageLocation"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["Public"] then asserts.AssertBoolean(struct["Public"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["EnaSupport"] then asserts.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertString(struct["SriovNetSupport"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Hypervisor"] then asserts.AssertHypervisorType(struct["Hypervisor"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["ImageOwnerAlias"] then asserts.AssertString(struct["ImageOwnerAlias"]) end
	if struct["StateReason"] then asserts.AssertStateReason(struct["StateReason"]) end
	if struct["RootDeviceName"] then asserts.AssertString(struct["RootDeviceName"]) end
	if struct["ImageType"] then asserts.AssertImageTypeValues(struct["ImageType"]) end
	if struct["VirtualizationType"] then asserts.AssertVirtualizationType(struct["VirtualizationType"]) end
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["CreationDate"] then asserts.AssertString(struct["CreationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.Image[k], "Image contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Image
-- <p>Describes an image.</p>
-- @param _RootDeviceType [DeviceType] <p>The type of root device used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
-- @param _State [ImageState] <p>The current state of the AMI. If the state is <code>available</code>, the image is successfully registered and can be used to launch an instance.</p>
-- @param _ImageLocation [String] <p>The location of the AMI.</p>
-- @param _RamdiskId [String] <p>The RAM disk associated with the image, if any. Only applicable for machine images.</p>
-- @param _Public [Boolean] <p>Indicates whether the image has public launch permissions. The value is <code>true</code> if this image has public launch permissions or <code>false</code> if it has only implicit and explicit launch permissions.</p>
-- @param _ProductCodes [ProductCodeList] <p>Any product codes associated with the AMI.</p>
-- @param _Description [String] <p>The description of the AMI that was provided during image creation.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the image.</p>
-- @param _EnaSupport [Boolean] <p>Specifies whether enhanced networking with ENA is enabled.</p>
-- @param _SriovNetSupport [String] <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- @param _ImageId [String] <p>The ID of the AMI.</p>
-- @param _KernelId [String] <p>The kernel associated with the image, if any. Only applicable for machine images.</p>
-- @param _Name [String] <p>The name of the AMI that was provided during image creation.</p>
-- @param _Hypervisor [HypervisorType] <p>The hypervisor type of the image.</p>
-- @param _BlockDeviceMappings [BlockDeviceMappingList] <p>Any block device mapping entries.</p>
-- @param _Architecture [ArchitectureValues] <p>The architecture of the image.</p>
-- @param _ImageOwnerAlias [String] <p>The AWS account alias (for example, <code>amazon</code>, <code>self</code>) or the AWS account ID of the AMI owner.</p>
-- @param _StateReason [StateReason] <p>The reason for the state change.</p>
-- @param _RootDeviceName [String] <p>The device name of the root device (for example, <code>/dev/sda1</code> or <code>/dev/xvda</code>).</p>
-- @param _ImageType [ImageTypeValues] <p>The type of image.</p>
-- @param _VirtualizationType [VirtualizationType] <p>The type of virtualization of the AMI.</p>
-- @param _Platform [PlatformValues] <p>The value is <code>Windows</code> for Windows AMIs; otherwise blank.</p>
-- @param _OwnerId [String] <p>The AWS account ID of the image owner.</p>
-- @param _CreationDate [String] <p>The date and time the image was created.</p>
function M.Image(_RootDeviceType, _State, _ImageLocation, _RamdiskId, _Public, _ProductCodes, _Description, _Tags, _EnaSupport, _SriovNetSupport, _ImageId, _KernelId, _Name, _Hypervisor, _BlockDeviceMappings, _Architecture, _ImageOwnerAlias, _StateReason, _RootDeviceName, _ImageType, _VirtualizationType, _Platform, _OwnerId, _CreationDate, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Image")
	local t = { 
		["RootDeviceType"] = _RootDeviceType,
		["State"] = _State,
		["ImageLocation"] = _ImageLocation,
		["RamdiskId"] = _RamdiskId,
		["Public"] = _Public,
		["ProductCodes"] = _ProductCodes,
		["Description"] = _Description,
		["Tags"] = _Tags,
		["EnaSupport"] = _EnaSupport,
		["SriovNetSupport"] = _SriovNetSupport,
		["ImageId"] = _ImageId,
		["KernelId"] = _KernelId,
		["Name"] = _Name,
		["Hypervisor"] = _Hypervisor,
		["BlockDeviceMappings"] = _BlockDeviceMappings,
		["Architecture"] = _Architecture,
		["ImageOwnerAlias"] = _ImageOwnerAlias,
		["StateReason"] = _StateReason,
		["RootDeviceName"] = _RootDeviceName,
		["ImageType"] = _ImageType,
		["VirtualizationType"] = _VirtualizationType,
		["Platform"] = _Platform,
		["OwnerId"] = _OwnerId,
		["CreationDate"] = _CreationDate,
	}
	asserts.AssertImage(t)
	return t
end

keys.DetachNetworkInterfaceRequest = { ["DryRun"] = true, ["AttachmentId"] = true, ["Force"] = true, nil }

function asserts.AssertDetachNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachNetworkInterfaceRequest to be of type 'table'")
	assert(struct["AttachmentId"], "Expected key AttachmentId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachNetworkInterfaceRequest[k], "DetachNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachNetworkInterfaceRequest
-- <p>Contains the parameters for DetachNetworkInterface.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _AttachmentId [String] <p>The ID of the attachment.</p>
-- @param _Force [Boolean] <p>Specifies whether to force a detachment.</p>
-- Required parameter: AttachmentId
function M.DetachNetworkInterfaceRequest(_DryRun, _AttachmentId, _Force, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachNetworkInterfaceRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["AttachmentId"] = _AttachmentId,
		["Force"] = _Force,
	}
	asserts.AssertDetachNetworkInterfaceRequest(t)
	return t
end

keys.AttachNetworkInterfaceResult = { ["AttachmentId"] = true, nil }

function asserts.AssertAttachNetworkInterfaceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachNetworkInterfaceResult to be of type 'table'")
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachNetworkInterfaceResult[k], "AttachNetworkInterfaceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachNetworkInterfaceResult
-- <p>Contains the output of AttachNetworkInterface.</p>
-- @param _AttachmentId [String] <p>The ID of the network interface attachment.</p>
function M.AttachNetworkInterfaceResult(_AttachmentId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachNetworkInterfaceResult")
	local t = { 
		["AttachmentId"] = _AttachmentId,
	}
	asserts.AssertAttachNetworkInterfaceResult(t)
	return t
end

keys.DescribeReservedInstancesListingsResult = { ["ReservedInstancesListings"] = true, nil }

function asserts.AssertDescribeReservedInstancesListingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesListingsResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then asserts.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesListingsResult[k], "DescribeReservedInstancesListingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesListingsResult
-- <p>Contains the output of DescribeReservedInstancesListings.</p>
-- @param _ReservedInstancesListings [ReservedInstancesListingList] <p>Information about the Reserved Instance listing.</p>
function M.DescribeReservedInstancesListingsResult(_ReservedInstancesListings, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesListingsResult")
	local t = { 
		["ReservedInstancesListings"] = _ReservedInstancesListings,
	}
	asserts.AssertDescribeReservedInstancesListingsResult(t)
	return t
end

keys.DisassociateIamInstanceProfileRequest = { ["AssociationId"] = true, nil }

function asserts.AssertDisassociateIamInstanceProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateIamInstanceProfileRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateIamInstanceProfileRequest[k], "DisassociateIamInstanceProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateIamInstanceProfileRequest
--  
-- @param _AssociationId [String] <p>The ID of the IAM instance profile association.</p>
-- Required parameter: AssociationId
function M.DisassociateIamInstanceProfileRequest(_AssociationId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DisassociateIamInstanceProfileRequest")
	local t = { 
		["AssociationId"] = _AssociationId,
	}
	asserts.AssertDisassociateIamInstanceProfileRequest(t)
	return t
end

keys.AllocateAddressRequest = { ["Domain"] = true, ["DryRun"] = true, nil }

function asserts.AssertAllocateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateAddressRequest to be of type 'table'")
	if struct["Domain"] then asserts.AssertDomainType(struct["Domain"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateAddressRequest[k], "AllocateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateAddressRequest
-- <p>Contains the parameters for AllocateAddress.</p>
-- @param _Domain [DomainType] <p>Set to <code>vpc</code> to allocate the address for use with instances in a VPC.</p> <p>Default: The address is for use with instances in EC2-Classic.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
function M.AllocateAddressRequest(_Domain, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AllocateAddressRequest")
	local t = { 
		["Domain"] = _Domain,
		["DryRun"] = _DryRun,
	}
	asserts.AssertAllocateAddressRequest(t)
	return t
end

keys.DescribeIamInstanceProfileAssociationsResult = { ["IamInstanceProfileAssociations"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeIamInstanceProfileAssociationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIamInstanceProfileAssociationsResult to be of type 'table'")
	if struct["IamInstanceProfileAssociations"] then asserts.AssertIamInstanceProfileAssociationSet(struct["IamInstanceProfileAssociations"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIamInstanceProfileAssociationsResult[k], "DescribeIamInstanceProfileAssociationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIamInstanceProfileAssociationsResult
--  
-- @param _IamInstanceProfileAssociations [IamInstanceProfileAssociationSet] <p>Information about one or more IAM instance profile associations.</p>
-- @param _NextToken [NextToken] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeIamInstanceProfileAssociationsResult(_IamInstanceProfileAssociations, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIamInstanceProfileAssociationsResult")
	local t = { 
		["IamInstanceProfileAssociations"] = _IamInstanceProfileAssociations,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeIamInstanceProfileAssociationsResult(t)
	return t
end

keys.AttributeBooleanValue = { ["Value"] = true, nil }

function asserts.AssertAttributeBooleanValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttributeBooleanValue to be of type 'table'")
	if struct["Value"] then asserts.AssertBoolean(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttributeBooleanValue[k], "AttributeBooleanValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttributeBooleanValue
-- <p>Describes a value for a resource attribute that is a Boolean value.</p>
-- @param _Value [Boolean] <p>The attribute value. The valid values are <code>true</code> or <code>false</code>.</p>
function M.AttributeBooleanValue(_Value, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttributeBooleanValue")
	local t = { 
		["Value"] = _Value,
	}
	asserts.AssertAttributeBooleanValue(t)
	return t
end

keys.DescribeSnapshotAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertDescribeSnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["Attribute"] then asserts.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotAttributeRequest[k], "DescribeSnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotAttributeRequest
-- <p>Contains the parameters for DescribeSnapshotAttribute.</p>
-- @param _Attribute [SnapshotAttributeName] <p>The snapshot attribute you would like to view.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- Required parameter: Attribute
-- Required parameter: SnapshotId
function M.DescribeSnapshotAttributeRequest(_Attribute, _DryRun, _SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSnapshotAttributeRequest")
	local t = { 
		["Attribute"] = _Attribute,
		["DryRun"] = _DryRun,
		["SnapshotId"] = _SnapshotId,
	}
	asserts.AssertDescribeSnapshotAttributeRequest(t)
	return t
end

keys.DescribeAvailabilityZonesRequest = { ["DryRun"] = true, ["Filters"] = true, ["ZoneNames"] = true, nil }

function asserts.AssertDescribeAvailabilityZonesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailabilityZonesRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ZoneNames"] then asserts.AssertZoneNameStringList(struct["ZoneNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAvailabilityZonesRequest[k], "DescribeAvailabilityZonesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailabilityZonesRequest
-- <p>Contains the parameters for DescribeAvailabilityZones.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>message</code> - Information about the Availability Zone.</p> </li> <li> <p> <code>region-name</code> - The name of the region for the Availability Zone (for example, <code>us-east-1</code>).</p> </li> <li> <p> <code>state</code> - The state of the Availability Zone (<code>available</code> | <code>information</code> | <code>impaired</code> | <code>unavailable</code>).</p> </li> <li> <p> <code>zone-name</code> - The name of the Availability Zone (for example, <code>us-east-1a</code>).</p> </li> </ul>
-- @param _ZoneNames [ZoneNameStringList] <p>The names of one or more Availability Zones.</p>
function M.DescribeAvailabilityZonesRequest(_DryRun, _Filters, _ZoneNames, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeAvailabilityZonesRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
		["ZoneNames"] = _ZoneNames,
	}
	asserts.AssertDescribeAvailabilityZonesRequest(t)
	return t
end

keys.DetachVolumeRequest = { ["Device"] = true, ["InstanceId"] = true, ["DryRun"] = true, ["Force"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDetachVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Device"] then asserts.AssertString(struct["Device"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachVolumeRequest[k], "DetachVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachVolumeRequest
-- <p>Contains the parameters for DetachVolume.</p>
-- @param _Device [String] <p>The device name.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Force [Boolean] <p>Forces detachment if the previous detachment attempt did not occur cleanly (for example, logging into an instance, unmounting the volume, and detaching normally). This option can lead to data loss or a corrupted file system. Use this option only as a last resort to detach a volume from a failed instance. The instance won't have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures.</p>
-- @param _VolumeId [String] <p>The ID of the volume.</p>
-- Required parameter: VolumeId
function M.DetachVolumeRequest(_Device, _InstanceId, _DryRun, _Force, _VolumeId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DetachVolumeRequest")
	local t = { 
		["Device"] = _Device,
		["InstanceId"] = _InstanceId,
		["DryRun"] = _DryRun,
		["Force"] = _Force,
		["VolumeId"] = _VolumeId,
	}
	asserts.AssertDetachVolumeRequest(t)
	return t
end

keys.ResetInstanceAttributeRequest = { ["InstanceId"] = true, ["Attribute"] = true, ["DryRun"] = true, nil }

function asserts.AssertResetInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetInstanceAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then asserts.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetInstanceAttributeRequest[k], "ResetInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetInstanceAttributeRequest
-- <p>Contains the parameters for ResetInstanceAttribute.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _Attribute [InstanceAttributeName] <p>The attribute to reset.</p> <important> <p>You can only reset the following attributes: <code>kernel</code> | <code>ramdisk</code> | <code>sourceDestCheck</code>. To change an instance attribute, use <a>ModifyInstanceAttribute</a>.</p> </important>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: Attribute
-- Required parameter: InstanceId
function M.ResetInstanceAttributeRequest(_InstanceId, _Attribute, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ResetInstanceAttributeRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["Attribute"] = _Attribute,
		["DryRun"] = _DryRun,
	}
	asserts.AssertResetInstanceAttributeRequest(t)
	return t
end

keys.RestoreAddressToClassicRequest = { ["PublicIp"] = true, ["DryRun"] = true, nil }

function asserts.AssertRestoreAddressToClassicRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RestoreAddressToClassicRequest to be of type 'table'")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.RestoreAddressToClassicRequest[k], "RestoreAddressToClassicRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RestoreAddressToClassicRequest
-- <p>Contains the parameters for RestoreAddressToClassic.</p>
-- @param _PublicIp [String] <p>The Elastic IP address.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: PublicIp
function M.RestoreAddressToClassicRequest(_PublicIp, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RestoreAddressToClassicRequest")
	local t = { 
		["PublicIp"] = _PublicIp,
		["DryRun"] = _DryRun,
	}
	asserts.AssertRestoreAddressToClassicRequest(t)
	return t
end

keys.HistoryRecord = { ["EventType"] = true, ["EventInformation"] = true, ["Timestamp"] = true, nil }

function asserts.AssertHistoryRecord(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HistoryRecord to be of type 'table'")
	assert(struct["EventInformation"], "Expected key EventInformation to exist in table")
	assert(struct["EventType"], "Expected key EventType to exist in table")
	assert(struct["Timestamp"], "Expected key Timestamp to exist in table")
	if struct["EventType"] then asserts.AssertEventType(struct["EventType"]) end
	if struct["EventInformation"] then asserts.AssertEventInformation(struct["EventInformation"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	for k,_ in pairs(struct) do
		assert(keys.HistoryRecord[k], "HistoryRecord contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HistoryRecord
-- <p>Describes an event in the history of the Spot fleet request.</p>
-- @param _EventType [EventType] <p>The event type.</p> <ul> <li> <p> <code>error</code> - Indicates an error with the Spot fleet request.</p> </li> <li> <p> <code>fleetRequestChange</code> - Indicates a change in the status or configuration of the Spot fleet request.</p> </li> <li> <p> <code>instanceChange</code> - Indicates that an instance was launched or terminated.</p> </li> </ul>
-- @param _EventInformation [EventInformation] <p>Information about the event.</p>
-- @param _Timestamp [DateTime] <p>The date and time of the event, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- Required parameter: EventInformation
-- Required parameter: EventType
-- Required parameter: Timestamp
function M.HistoryRecord(_EventType, _EventInformation, _Timestamp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating HistoryRecord")
	local t = { 
		["EventType"] = _EventType,
		["EventInformation"] = _EventInformation,
		["Timestamp"] = _Timestamp,
	}
	asserts.AssertHistoryRecord(t)
	return t
end

keys.PrivateIpAddressSpecification = { ["Primary"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertPrivateIpAddressSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrivateIpAddressSpecification to be of type 'table'")
	assert(struct["PrivateIpAddress"], "Expected key PrivateIpAddress to exist in table")
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrivateIpAddressSpecification[k], "PrivateIpAddressSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrivateIpAddressSpecification
-- <p>Describes a secondary private IPv4 address for a network interface.</p>
-- @param _Primary [Boolean] <p>Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.</p>
-- @param _PrivateIpAddress [String] <p>The private IPv4 addresses.</p>
-- Required parameter: PrivateIpAddress
function M.PrivateIpAddressSpecification(_Primary, _PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating PrivateIpAddressSpecification")
	local t = { 
		["Primary"] = _Primary,
		["PrivateIpAddress"] = _PrivateIpAddress,
	}
	asserts.AssertPrivateIpAddressSpecification(t)
	return t
end

keys.AcceptReservedInstancesExchangeQuoteRequest = { ["ReservedInstanceIds"] = true, ["DryRun"] = true, ["TargetConfigurations"] = true, nil }

function asserts.AssertAcceptReservedInstancesExchangeQuoteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptReservedInstancesExchangeQuoteRequest to be of type 'table'")
	assert(struct["ReservedInstanceIds"], "Expected key ReservedInstanceIds to exist in table")
	if struct["ReservedInstanceIds"] then asserts.AssertReservedInstanceIdSet(struct["ReservedInstanceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TargetConfigurations"] then asserts.AssertTargetConfigurationRequestSet(struct["TargetConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptReservedInstancesExchangeQuoteRequest[k], "AcceptReservedInstancesExchangeQuoteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptReservedInstancesExchangeQuoteRequest
-- <p>Contains the parameters for accepting the quote.</p>
-- @param _ReservedInstanceIds [ReservedInstanceIdSet] <p>The IDs of the Convertible Reserved Instances to exchange for other Convertible Reserved Instances of the same or higher value.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _TargetConfigurations [TargetConfigurationRequestSet] <p>The configurations of the Convertible Reserved Instance offerings that you are purchasing in this exchange.</p>
-- Required parameter: ReservedInstanceIds
function M.AcceptReservedInstancesExchangeQuoteRequest(_ReservedInstanceIds, _DryRun, _TargetConfigurations, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AcceptReservedInstancesExchangeQuoteRequest")
	local t = { 
		["ReservedInstanceIds"] = _ReservedInstanceIds,
		["DryRun"] = _DryRun,
		["TargetConfigurations"] = _TargetConfigurations,
	}
	asserts.AssertAcceptReservedInstancesExchangeQuoteRequest(t)
	return t
end

keys.AttachVpnGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["VpnGatewayId"] = true, nil }

function asserts.AssertAttachVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVpnGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachVpnGatewayRequest[k], "AttachVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVpnGatewayRequest
-- <p>Contains the parameters for AttachVpnGateway.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required parameter: VpcId
-- Required parameter: VpnGatewayId
function M.AttachVpnGatewayRequest(_VpcId, _DryRun, _VpnGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachVpnGatewayRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
		["VpnGatewayId"] = _VpnGatewayId,
	}
	asserts.AssertAttachVpnGatewayRequest(t)
	return t
end

keys.CreateVpcEndpointRequest = { ["VpcId"] = true, ["DryRun"] = true, ["ServiceName"] = true, ["PolicyDocument"] = true, ["RouteTableIds"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateVpcEndpointRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointRequest to be of type 'table'")
	assert(struct["ServiceName"], "Expected key ServiceName to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ServiceName"] then asserts.AssertString(struct["ServiceName"]) end
	if struct["PolicyDocument"] then asserts.AssertString(struct["PolicyDocument"]) end
	if struct["RouteTableIds"] then asserts.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointRequest[k], "CreateVpcEndpointRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointRequest
-- <p>Contains the parameters for CreateVpcEndpoint.</p>
-- @param _VpcId [String] <p>The ID of the VPC in which the endpoint will be used.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _ServiceName [String] <p>The AWS service name, in the form <code>com.amazonaws.<i>region</i>.<i>service</i> </code>. To get a list of available services, use the <a>DescribeVpcEndpointServices</a> request.</p>
-- @param _PolicyDocument [String] <p>A policy to attach to the endpoint that controls access to the service. The policy must be in valid JSON format. If this parameter is not specified, we attach a default policy that allows full access to the service.</p>
-- @param _RouteTableIds [ValueStringList] <p>One or more route table IDs.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required parameter: ServiceName
-- Required parameter: VpcId
function M.CreateVpcEndpointRequest(_VpcId, _DryRun, _ServiceName, _PolicyDocument, _RouteTableIds, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcEndpointRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
		["ServiceName"] = _ServiceName,
		["PolicyDocument"] = _PolicyDocument,
		["RouteTableIds"] = _RouteTableIds,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertCreateVpcEndpointRequest(t)
	return t
end

keys.AssociateAddressRequest = { ["DryRun"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["PublicIp"] = true, ["AllowReassociation"] = true, ["AllocationId"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertAssociateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateAddressRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AllowReassociation"] then asserts.AssertBoolean(struct["AllowReassociation"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateAddressRequest[k], "AssociateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateAddressRequest
-- <p>Contains the parameters for AssociateAddress.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceId [String] <p>The ID of the instance. This is required for EC2-Classic. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. The operation fails if you specify an instance ID unless exactly one network interface is attached.</p>
-- @param _NetworkInterfaceId [String] <p>[EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID.</p>
-- @param _PublicIp [String] <p>The Elastic IP address. This is required for EC2-Classic.</p>
-- @param _AllowReassociation [Boolean] <p>[EC2-VPC] For a VPC in an EC2-Classic account, specify true to allow an Elastic IP address that is already associated with an instance or network interface to be reassociated with the specified instance or network interface. Otherwise, the operation fails. In a VPC in an EC2-VPC-only account, reassociation is automatic, therefore you can specify false to ensure the operation fails if the Elastic IP address is already associated with another resource.</p>
-- @param _AllocationId [String] <p>[EC2-VPC] The allocation ID. This is required for EC2-VPC.</p>
-- @param _PrivateIpAddress [String] <p>[EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.</p>
function M.AssociateAddressRequest(_DryRun, _InstanceId, _NetworkInterfaceId, _PublicIp, _AllowReassociation, _AllocationId, _PrivateIpAddress, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssociateAddressRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["InstanceId"] = _InstanceId,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["PublicIp"] = _PublicIp,
		["AllowReassociation"] = _AllowReassociation,
		["AllocationId"] = _AllocationId,
		["PrivateIpAddress"] = _PrivateIpAddress,
	}
	asserts.AssertAssociateAddressRequest(t)
	return t
end

keys.DeleteNatGatewayResult = { ["NatGatewayId"] = true, nil }

function asserts.AssertDeleteNatGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNatGatewayResult to be of type 'table'")
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNatGatewayResult[k], "DeleteNatGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNatGatewayResult
-- <p>Contains the output of DeleteNatGateway.</p>
-- @param _NatGatewayId [String] <p>The ID of the NAT gateway.</p>
function M.DeleteNatGatewayResult(_NatGatewayId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteNatGatewayResult")
	local t = { 
		["NatGatewayId"] = _NatGatewayId,
	}
	asserts.AssertDeleteNatGatewayResult(t)
	return t
end

keys.ImportImageTask = { ["Status"] = true, ["LicenseType"] = true, ["Description"] = true, ["Hypervisor"] = true, ["ImageId"] = true, ["Platform"] = true, ["Architecture"] = true, ["SnapshotDetails"] = true, ["Progress"] = true, ["StatusMessage"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportImageTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageTask to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["LicenseType"] then asserts.AssertString(struct["LicenseType"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Hypervisor"] then asserts.AssertString(struct["Hypervisor"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["Architecture"] then asserts.AssertString(struct["Architecture"]) end
	if struct["SnapshotDetails"] then asserts.AssertSnapshotDetailList(struct["SnapshotDetails"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportImageTask[k], "ImportImageTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageTask
-- <p>Describes an import image task.</p>
-- @param _Status [String] <p>A brief status for the import image task.</p>
-- @param _LicenseType [String] <p>The license type of the virtual machine.</p>
-- @param _Description [String] <p>A description of the import task.</p>
-- @param _Hypervisor [String] <p>The target hypervisor for the import task.</p> <p>Valid values: <code>xen</code> </p>
-- @param _ImageId [String] <p>The ID of the Amazon Machine Image (AMI) of the imported virtual machine.</p>
-- @param _Platform [String] <p>The description string for the import image task.</p>
-- @param _Architecture [String] <p>The architecture of the virtual machine.</p> <p>Valid values: <code>i386</code> | <code>x86_64</code> </p>
-- @param _SnapshotDetails [SnapshotDetailList] <p>Information about the snapshots.</p>
-- @param _Progress [String] <p>The percentage of progress of the import image task.</p>
-- @param _StatusMessage [String] <p>A descriptive status message for the import image task.</p>
-- @param _ImportTaskId [String] <p>The ID of the import image task.</p>
function M.ImportImageTask(_Status, _LicenseType, _Description, _Hypervisor, _ImageId, _Platform, _Architecture, _SnapshotDetails, _Progress, _StatusMessage, _ImportTaskId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportImageTask")
	local t = { 
		["Status"] = _Status,
		["LicenseType"] = _LicenseType,
		["Description"] = _Description,
		["Hypervisor"] = _Hypervisor,
		["ImageId"] = _ImageId,
		["Platform"] = _Platform,
		["Architecture"] = _Architecture,
		["SnapshotDetails"] = _SnapshotDetails,
		["Progress"] = _Progress,
		["StatusMessage"] = _StatusMessage,
		["ImportTaskId"] = _ImportTaskId,
	}
	asserts.AssertImportImageTask(t)
	return t
end

keys.DeregisterImageRequest = { ["DryRun"] = true, ["ImageId"] = true, nil }

function asserts.AssertDeregisterImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterImageRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterImageRequest[k], "DeregisterImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterImageRequest
-- <p>Contains the parameters for DeregisterImage.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _ImageId [String] <p>The ID of the AMI.</p>
-- Required parameter: ImageId
function M.DeregisterImageRequest(_DryRun, _ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeregisterImageRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["ImageId"] = _ImageId,
	}
	asserts.AssertDeregisterImageRequest(t)
	return t
end

keys.CreateInternetGatewayResult = { ["InternetGateway"] = true, nil }

function asserts.AssertCreateInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInternetGatewayResult to be of type 'table'")
	if struct["InternetGateway"] then asserts.AssertInternetGateway(struct["InternetGateway"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInternetGatewayResult[k], "CreateInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInternetGatewayResult
-- <p>Contains the output of CreateInternetGateway.</p>
-- @param _InternetGateway [InternetGateway] <p>Information about the Internet gateway.</p>
function M.CreateInternetGatewayResult(_InternetGateway, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateInternetGatewayResult")
	local t = { 
		["InternetGateway"] = _InternetGateway,
	}
	asserts.AssertCreateInternetGatewayResult(t)
	return t
end

keys.ReservedInstanceLimitPrice = { ["Amount"] = true, ["CurrencyCode"] = true, nil }

function asserts.AssertReservedInstanceLimitPrice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstanceLimitPrice to be of type 'table'")
	if struct["Amount"] then asserts.AssertDouble(struct["Amount"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstanceLimitPrice[k], "ReservedInstanceLimitPrice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstanceLimitPrice
-- <p>Describes the limit price of a Reserved Instance offering.</p>
-- @param _Amount [Double] <p>Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>limitPrice</code> amount is specified. At this time, the only supported currency is <code>USD</code>.</p>
function M.ReservedInstanceLimitPrice(_Amount, _CurrencyCode, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstanceLimitPrice")
	local t = { 
		["Amount"] = _Amount,
		["CurrencyCode"] = _CurrencyCode,
	}
	asserts.AssertReservedInstanceLimitPrice(t)
	return t
end

keys.DescribeInstanceStatusResult = { ["InstanceStatuses"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstanceStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceStatusResult to be of type 'table'")
	if struct["InstanceStatuses"] then asserts.AssertInstanceStatusList(struct["InstanceStatuses"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceStatusResult[k], "DescribeInstanceStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceStatusResult
-- <p>Contains the output of DescribeInstanceStatus.</p>
-- @param _InstanceStatuses [InstanceStatusList] <p>One or more instance status descriptions.</p>
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
function M.DescribeInstanceStatusResult(_InstanceStatuses, _NextToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeInstanceStatusResult")
	local t = { 
		["InstanceStatuses"] = _InstanceStatuses,
		["NextToken"] = _NextToken,
	}
	asserts.AssertDescribeInstanceStatusResult(t)
	return t
end

keys.RunScheduledInstancesResult = { ["InstanceIdSet"] = true, nil }

function asserts.AssertRunScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunScheduledInstancesResult to be of type 'table'")
	if struct["InstanceIdSet"] then asserts.AssertInstanceIdSet(struct["InstanceIdSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunScheduledInstancesResult[k], "RunScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunScheduledInstancesResult
-- <p>Contains the output of RunScheduledInstances.</p>
-- @param _InstanceIdSet [InstanceIdSet] <p>The IDs of the newly launched instances.</p>
function M.RunScheduledInstancesResult(_InstanceIdSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RunScheduledInstancesResult")
	local t = { 
		["InstanceIdSet"] = _InstanceIdSet,
	}
	asserts.AssertRunScheduledInstancesResult(t)
	return t
end

keys.GetConsoleOutputResult = { ["InstanceId"] = true, ["Output"] = true, ["Timestamp"] = true, nil }

function asserts.AssertGetConsoleOutputResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleOutputResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Output"] then asserts.AssertString(struct["Output"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleOutputResult[k], "GetConsoleOutputResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleOutputResult
-- <p>Contains the output of GetConsoleOutput.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _Output [String] <p>The console output, Base64-encoded. If using a command line tool, the tool decodes the output for you.</p>
-- @param _Timestamp [DateTime] <p>The time the output was last updated.</p>
function M.GetConsoleOutputResult(_InstanceId, _Output, _Timestamp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetConsoleOutputResult")
	local t = { 
		["InstanceId"] = _InstanceId,
		["Output"] = _Output,
		["Timestamp"] = _Timestamp,
	}
	asserts.AssertGetConsoleOutputResult(t)
	return t
end

keys.ClassicLinkInstance = { ["InstanceId"] = true, ["VpcId"] = true, ["Groups"] = true, ["Tags"] = true, nil }

function asserts.AssertClassicLinkInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLinkInstance to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClassicLinkInstance[k], "ClassicLinkInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLinkInstance
-- <p>Describes a linked EC2-Classic instance.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _Groups [GroupIdentifierList] <p>A list of security groups.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the instance.</p>
function M.ClassicLinkInstance(_InstanceId, _VpcId, _Groups, _Tags, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ClassicLinkInstance")
	local t = { 
		["InstanceId"] = _InstanceId,
		["VpcId"] = _VpcId,
		["Groups"] = _Groups,
		["Tags"] = _Tags,
	}
	asserts.AssertClassicLinkInstance(t)
	return t
end

keys.NetworkInterfaceAttachment = { ["Status"] = true, ["DeviceIndex"] = true, ["AttachTime"] = true, ["InstanceId"] = true, ["DeleteOnTermination"] = true, ["AttachmentId"] = true, ["InstanceOwnerId"] = true, nil }

function asserts.AssertNetworkInterfaceAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAttachment to be of type 'table'")
	if struct["Status"] then asserts.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	if struct["InstanceOwnerId"] then asserts.AssertString(struct["InstanceOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceAttachment[k], "NetworkInterfaceAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAttachment
-- <p>Describes a network interface attachment.</p>
-- @param _Status [AttachmentStatus] <p>The attachment state.</p>
-- @param _DeviceIndex [Integer] <p>The device index of the network interface attachment on the instance.</p>
-- @param _AttachTime [DateTime] <p>The timestamp indicating when the attachment initiated.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- @param _AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- @param _InstanceOwnerId [String] <p>The AWS account ID of the owner of the instance.</p>
function M.NetworkInterfaceAttachment(_Status, _DeviceIndex, _AttachTime, _InstanceId, _DeleteOnTermination, _AttachmentId, _InstanceOwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfaceAttachment")
	local t = { 
		["Status"] = _Status,
		["DeviceIndex"] = _DeviceIndex,
		["AttachTime"] = _AttachTime,
		["InstanceId"] = _InstanceId,
		["DeleteOnTermination"] = _DeleteOnTermination,
		["AttachmentId"] = _AttachmentId,
		["InstanceOwnerId"] = _InstanceOwnerId,
	}
	asserts.AssertNetworkInterfaceAttachment(t)
	return t
end

keys.ModifyNetworkInterfaceAttributeRequest = { ["SourceDestCheck"] = true, ["DryRun"] = true, ["Description"] = true, ["NetworkInterfaceId"] = true, ["Attachment"] = true, ["Groups"] = true, nil }

function asserts.AssertModifyNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["Attachment"] then asserts.AssertNetworkInterfaceAttachmentChanges(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyNetworkInterfaceAttributeRequest[k], "ModifyNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for ModifyNetworkInterfaceAttribute.</p>
-- @param _SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT. For more information, see <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html">NAT Instances</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Description [AttributeValue] <p>A description for the network interface.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _Attachment [NetworkInterfaceAttachmentChanges] <p>Information about the interface attachment. If modifying the 'delete on termination' attribute, you must specify the ID of the interface attachment.</p>
-- @param _Groups [SecurityGroupIdStringList] <p>Changes the security groups for the network interface. The new set of groups you specify replaces the current set. You must specify at least one group, even if it's just the default security group in the VPC. You must specify the ID of the security group, not the name.</p>
-- Required parameter: NetworkInterfaceId
function M.ModifyNetworkInterfaceAttributeRequest(_SourceDestCheck, _DryRun, _Description, _NetworkInterfaceId, _Attachment, _Groups, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyNetworkInterfaceAttributeRequest")
	local t = { 
		["SourceDestCheck"] = _SourceDestCheck,
		["DryRun"] = _DryRun,
		["Description"] = _Description,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["Attachment"] = _Attachment,
		["Groups"] = _Groups,
	}
	asserts.AssertModifyNetworkInterfaceAttributeRequest(t)
	return t
end

keys.InstanceStatus = { ["InstanceStatus"] = true, ["AvailabilityZone"] = true, ["InstanceId"] = true, ["InstanceState"] = true, ["Events"] = true, ["SystemStatus"] = true, nil }

function asserts.AssertInstanceStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatus to be of type 'table'")
	if struct["InstanceStatus"] then asserts.AssertInstanceStatusSummary(struct["InstanceStatus"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["InstanceState"] then asserts.AssertInstanceState(struct["InstanceState"]) end
	if struct["Events"] then asserts.AssertInstanceStatusEventList(struct["Events"]) end
	if struct["SystemStatus"] then asserts.AssertInstanceStatusSummary(struct["SystemStatus"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatus[k], "InstanceStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatus
-- <p>Describes the status of an instance.</p>
-- @param _InstanceStatus [InstanceStatusSummary] <p>Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone of the instance.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _InstanceState [InstanceState] <p>The intended state of the instance. <a>DescribeInstanceStatus</a> requires that an instance be in the <code>running</code> state.</p>
-- @param _Events [InstanceStatusEventList] <p>Any scheduled events associated with the instance.</p>
-- @param _SystemStatus [InstanceStatusSummary] <p>Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.</p>
function M.InstanceStatus(_InstanceStatus, _AvailabilityZone, _InstanceId, _InstanceState, _Events, _SystemStatus, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating InstanceStatus")
	local t = { 
		["InstanceStatus"] = _InstanceStatus,
		["AvailabilityZone"] = _AvailabilityZone,
		["InstanceId"] = _InstanceId,
		["InstanceState"] = _InstanceState,
		["Events"] = _Events,
		["SystemStatus"] = _SystemStatus,
	}
	asserts.AssertInstanceStatus(t)
	return t
end

keys.EgressOnlyInternetGateway = { ["EgressOnlyInternetGatewayId"] = true, ["Attachments"] = true, nil }

function asserts.AssertEgressOnlyInternetGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EgressOnlyInternetGateway to be of type 'table'")
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertEgressOnlyInternetGatewayId(struct["EgressOnlyInternetGatewayId"]) end
	if struct["Attachments"] then asserts.AssertInternetGatewayAttachmentList(struct["Attachments"]) end
	for k,_ in pairs(struct) do
		assert(keys.EgressOnlyInternetGateway[k], "EgressOnlyInternetGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EgressOnlyInternetGateway
-- <p>Describes an egress-only Internet gateway.</p>
-- @param _EgressOnlyInternetGatewayId [EgressOnlyInternetGatewayId] <p>The ID of the egress-only Internet gateway.</p>
-- @param _Attachments [InternetGatewayAttachmentList] <p>Information about the attachment of the egress-only Internet gateway.</p>
function M.EgressOnlyInternetGateway(_EgressOnlyInternetGatewayId, _Attachments, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EgressOnlyInternetGateway")
	local t = { 
		["EgressOnlyInternetGatewayId"] = _EgressOnlyInternetGatewayId,
		["Attachments"] = _Attachments,
	}
	asserts.AssertEgressOnlyInternetGateway(t)
	return t
end

keys.UnassignPrivateIpAddressesRequest = { ["NetworkInterfaceId"] = true, ["PrivateIpAddresses"] = true, nil }

function asserts.AssertUnassignPrivateIpAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignPrivateIpAddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	assert(struct["PrivateIpAddresses"], "Expected key PrivateIpAddresses to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressStringList(struct["PrivateIpAddresses"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnassignPrivateIpAddressesRequest[k], "UnassignPrivateIpAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignPrivateIpAddressesRequest
-- <p>Contains the parameters for UnassignPrivateIpAddresses.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _PrivateIpAddresses [PrivateIpAddressStringList] <p>The secondary private IP addresses to unassign from the network interface. You can specify this option multiple times to unassign more than one IP address.</p>
-- Required parameter: NetworkInterfaceId
-- Required parameter: PrivateIpAddresses
function M.UnassignPrivateIpAddressesRequest(_NetworkInterfaceId, _PrivateIpAddresses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating UnassignPrivateIpAddressesRequest")
	local t = { 
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["PrivateIpAddresses"] = _PrivateIpAddresses,
	}
	asserts.AssertUnassignPrivateIpAddressesRequest(t)
	return t
end

keys.Filter = { ["Values"] = true, ["Name"] = true, nil }

function asserts.AssertFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Filter to be of type 'table'")
	if struct["Values"] then asserts.AssertValueStringList(struct["Values"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.Filter[k], "Filter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Filter
-- <p>A filter name and value pair that is used to return a more specific list of results. Filters can be used to match a set of resources by various criteria, such as tags, attributes, or IDs.</p>
-- @param _Values [ValueStringList] <p>One or more filter values. Filter values are case-sensitive.</p>
-- @param _Name [String] <p>The name of the filter. Filter names are case-sensitive.</p>
function M.Filter(_Values, _Name, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Filter")
	local t = { 
		["Values"] = _Values,
		["Name"] = _Name,
	}
	asserts.AssertFilter(t)
	return t
end

keys.TargetReservationValue = { ["TargetConfiguration"] = true, ["ReservationValue"] = true, nil }

function asserts.AssertTargetReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetReservationValue to be of type 'table'")
	if struct["TargetConfiguration"] then asserts.AssertTargetConfiguration(struct["TargetConfiguration"]) end
	if struct["ReservationValue"] then asserts.AssertReservationValue(struct["ReservationValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetReservationValue[k], "TargetReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetReservationValue
-- <p>The total value of the new Convertible Reserved Instances.</p>
-- @param _TargetConfiguration [TargetConfiguration] <p>The configuration of the Convertible Reserved Instances that make up the exchange.</p>
-- @param _ReservationValue [ReservationValue] <p>The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of the list value, remaining upfront price, and additional upfront cost of the exchange.</p>
function M.TargetReservationValue(_TargetConfiguration, _ReservationValue, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating TargetReservationValue")
	local t = { 
		["TargetConfiguration"] = _TargetConfiguration,
		["ReservationValue"] = _ReservationValue,
	}
	asserts.AssertTargetReservationValue(t)
	return t
end

keys.ModifyIdFormatRequest = { ["UseLongIds"] = true, ["Resource"] = true, nil }

function asserts.AssertModifyIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyIdFormatRequest to be of type 'table'")
	assert(struct["Resource"], "Expected key Resource to exist in table")
	assert(struct["UseLongIds"], "Expected key UseLongIds to exist in table")
	if struct["UseLongIds"] then asserts.AssertBoolean(struct["UseLongIds"]) end
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyIdFormatRequest[k], "ModifyIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyIdFormatRequest
-- <p>Contains the parameters of ModifyIdFormat.</p>
-- @param _UseLongIds [Boolean] <p>Indicate whether the resource should use longer IDs (17-character IDs).</p>
-- @param _Resource [String] <p>The type of resource: <code>instance</code> | <code>reservation</code> | <code>snapshot</code> | <code>volume</code> </p>
-- Required parameter: Resource
-- Required parameter: UseLongIds
function M.ModifyIdFormatRequest(_UseLongIds, _Resource, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyIdFormatRequest")
	local t = { 
		["UseLongIds"] = _UseLongIds,
		["Resource"] = _Resource,
	}
	asserts.AssertModifyIdFormatRequest(t)
	return t
end

keys.DescribeIdentityIdFormatResult = { ["Statuses"] = true, nil }

function asserts.AssertDescribeIdentityIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdentityIdFormatResult to be of type 'table'")
	if struct["Statuses"] then asserts.AssertIdFormatList(struct["Statuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdentityIdFormatResult[k], "DescribeIdentityIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdentityIdFormatResult
-- <p>Contains the output of DescribeIdentityIdFormat.</p>
-- @param _Statuses [IdFormatList] <p>Information about the ID format for the resources.</p>
function M.DescribeIdentityIdFormatResult(_Statuses, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeIdentityIdFormatResult")
	local t = { 
		["Statuses"] = _Statuses,
	}
	asserts.AssertDescribeIdentityIdFormatResult(t)
	return t
end

keys.ImportVolumeResult = { ["ConversionTask"] = true, nil }

function asserts.AssertImportVolumeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeResult to be of type 'table'")
	if struct["ConversionTask"] then asserts.AssertConversionTask(struct["ConversionTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportVolumeResult[k], "ImportVolumeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeResult
-- <p>Contains the output for ImportVolume.</p>
-- @param _ConversionTask [ConversionTask] <p>Information about the conversion task.</p>
function M.ImportVolumeResult(_ConversionTask, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportVolumeResult")
	local t = { 
		["ConversionTask"] = _ConversionTask,
	}
	asserts.AssertImportVolumeResult(t)
	return t
end

keys.DescribeKeyPairsResult = { ["KeyPairs"] = true, nil }

function asserts.AssertDescribeKeyPairsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeKeyPairsResult to be of type 'table'")
	if struct["KeyPairs"] then asserts.AssertKeyPairList(struct["KeyPairs"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeKeyPairsResult[k], "DescribeKeyPairsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeKeyPairsResult
-- <p>Contains the output of DescribeKeyPairs.</p>
-- @param _KeyPairs [KeyPairList] <p>Information about one or more key pairs.</p>
function M.DescribeKeyPairsResult(_KeyPairs, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeKeyPairsResult")
	local t = { 
		["KeyPairs"] = _KeyPairs,
	}
	asserts.AssertDescribeKeyPairsResult(t)
	return t
end

keys.VolumeAttachment = { ["AttachTime"] = true, ["InstanceId"] = true, ["VolumeId"] = true, ["State"] = true, ["DeleteOnTermination"] = true, ["Device"] = true, nil }

function asserts.AssertVolumeAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeAttachment to be of type 'table'")
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["State"] then asserts.AssertVolumeAttachmentState(struct["State"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["Device"] then asserts.AssertString(struct["Device"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeAttachment[k], "VolumeAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeAttachment
-- <p>Describes volume attachment details.</p>
-- @param _AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _VolumeId [String] <p>The ID of the volume.</p>
-- @param _State [VolumeAttachmentState] <p>The attachment state of the volume.</p>
-- @param _DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- @param _Device [String] <p>The device name.</p>
function M.VolumeAttachment(_AttachTime, _InstanceId, _VolumeId, _State, _DeleteOnTermination, _Device, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating VolumeAttachment")
	local t = { 
		["AttachTime"] = _AttachTime,
		["InstanceId"] = _InstanceId,
		["VolumeId"] = _VolumeId,
		["State"] = _State,
		["DeleteOnTermination"] = _DeleteOnTermination,
		["Device"] = _Device,
	}
	asserts.AssertVolumeAttachment(t)
	return t
end

keys.DescribeReservedInstancesRequest = { ["OfferingType"] = true, ["OfferingClass"] = true, ["DryRun"] = true, ["ReservedInstancesIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeReservedInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesRequest to be of type 'table'")
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ReservedInstancesIds"] then asserts.AssertReservedInstancesIdStringList(struct["ReservedInstancesIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesRequest[k], "DescribeReservedInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesRequest
-- <p>Contains the parameters for DescribeReservedInstances.</p>
-- @param _OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the <code>Medium Utilization</code> Reserved Instance offering type.</p>
-- @param _OfferingClass [OfferingClassType] <p>Describes whether the Reserved Instance is Standard or Convertible.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _ReservedInstancesIds [ReservedInstancesIdStringList] <p>One or more Reserved Instance IDs.</p> <p>Default: Describes all your Reserved Instances, or only those otherwise specified.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be used.</p> </li> <li> <p> <code>duration</code> - The duration of the Reserved Instance (one year or three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p> </li> <li> <p> <code>end</code> - The time when the Reserved Instance expires (for example, 2015-08-07T11:54:42.000Z).</p> </li> <li> <p> <code>fixed-price</code> - The purchase price of the Reserved Instance (for example, 9800.0).</p> </li> <li> <p> <code>instance-type</code> - The instance type that is covered by the reservation.</p> </li> <li> <p> <code>scope</code> - The scope of the Reserved Instance (<code>Region</code> or <code>Availability Zone</code>).</p> </li> <li> <p> <code>product-description</code> - The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Windows</code> | <code>Windows (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> | <code>Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon VPC)</code>).</p> </li> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instance.</p> </li> <li> <p> <code>start</code> - The time at which the Reserved Instance purchase request was placed (for example, 2014-08-07T11:54:42.000Z).</p> </li> <li> <p> <code>state</code> - The state of the Reserved Instance (<code>payment-pending</code> | <code>active</code> | <code>payment-failed</code> | <code>retired</code>).</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for example, 0.84).</p> </li> </ul>
function M.DescribeReservedInstancesRequest(_OfferingType, _OfferingClass, _DryRun, _ReservedInstancesIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesRequest")
	local t = { 
		["OfferingType"] = _OfferingType,
		["OfferingClass"] = _OfferingClass,
		["DryRun"] = _DryRun,
		["ReservedInstancesIds"] = _ReservedInstancesIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeReservedInstancesRequest(t)
	return t
end

keys.CreateCustomerGatewayRequest = { ["PublicIp"] = true, ["BgpAsn"] = true, ["DryRun"] = true, ["Type"] = true, nil }

function asserts.AssertCreateCustomerGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCustomerGatewayRequest to be of type 'table'")
	assert(struct["BgpAsn"], "Expected key BgpAsn to exist in table")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["BgpAsn"] then asserts.AssertInteger(struct["BgpAsn"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCustomerGatewayRequest[k], "CreateCustomerGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCustomerGatewayRequest
-- <p>Contains the parameters for CreateCustomerGateway.</p>
-- @param _PublicIp [String] <p>The Internet-routable IP address for the customer gateway's outside interface. The address must be static.</p>
-- @param _BgpAsn [Integer] <p>For devices that support BGP, the customer gateway's BGP ASN.</p> <p>Default: 65000</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Type [GatewayType] <p>The type of VPN connection that this customer gateway supports (<code>ipsec.1</code>).</p>
-- Required parameter: BgpAsn
-- Required parameter: PublicIp
-- Required parameter: Type
function M.CreateCustomerGatewayRequest(_PublicIp, _BgpAsn, _DryRun, _Type, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateCustomerGatewayRequest")
	local t = { 
		["PublicIp"] = _PublicIp,
		["BgpAsn"] = _BgpAsn,
		["DryRun"] = _DryRun,
		["Type"] = _Type,
	}
	asserts.AssertCreateCustomerGatewayRequest(t)
	return t
end

keys.DeleteSecurityGroupRequest = { ["GroupName"] = true, ["DryRun"] = true, ["GroupId"] = true, nil }

function asserts.AssertDeleteSecurityGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSecurityGroupRequest to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSecurityGroupRequest[k], "DeleteSecurityGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSecurityGroupRequest
-- <p>Contains the parameters for DeleteSecurityGroup.</p>
-- @param _GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group. You can specify either the security group name or the security group ID.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _GroupId [String] <p>The ID of the security group. Required for a nondefault VPC.</p>
function M.DeleteSecurityGroupRequest(_GroupName, _DryRun, _GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteSecurityGroupRequest")
	local t = { 
		["GroupName"] = _GroupName,
		["DryRun"] = _DryRun,
		["GroupId"] = _GroupId,
	}
	asserts.AssertDeleteSecurityGroupRequest(t)
	return t
end

keys.NatGatewayAddress = { ["PublicIp"] = true, ["NetworkInterfaceId"] = true, ["AllocationId"] = true, ["PrivateIp"] = true, nil }

function asserts.AssertNatGatewayAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NatGatewayAddress to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PrivateIp"] then asserts.AssertString(struct["PrivateIp"]) end
	for k,_ in pairs(struct) do
		assert(keys.NatGatewayAddress[k], "NatGatewayAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NatGatewayAddress
-- <p>Describes the IP addresses and network interface associated with a NAT gateway.</p>
-- @param _PublicIp [String] <p>The Elastic IP address associated with the NAT gateway.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface associated with the NAT gateway.</p>
-- @param _AllocationId [String] <p>The allocation ID of the Elastic IP address that's associated with the NAT gateway.</p>
-- @param _PrivateIp [String] <p>The private IP address associated with the Elastic IP address.</p>
function M.NatGatewayAddress(_PublicIp, _NetworkInterfaceId, _AllocationId, _PrivateIp, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NatGatewayAddress")
	local t = { 
		["PublicIp"] = _PublicIp,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["AllocationId"] = _AllocationId,
		["PrivateIp"] = _PrivateIp,
	}
	asserts.AssertNatGatewayAddress(t)
	return t
end

keys.DescribeSnapshotAttributeResult = { ["ProductCodes"] = true, ["CreateVolumePermissions"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertDescribeSnapshotAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotAttributeResult to be of type 'table'")
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["CreateVolumePermissions"] then asserts.AssertCreateVolumePermissionList(struct["CreateVolumePermissions"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotAttributeResult[k], "DescribeSnapshotAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotAttributeResult
-- <p>Contains the output of DescribeSnapshotAttribute.</p>
-- @param _ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- @param _CreateVolumePermissions [CreateVolumePermissionList] <p>A list of permissions for creating volumes from the snapshot.</p>
-- @param _SnapshotId [String] <p>The ID of the EBS snapshot.</p>
function M.DescribeSnapshotAttributeResult(_ProductCodes, _CreateVolumePermissions, _SnapshotId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSnapshotAttributeResult")
	local t = { 
		["ProductCodes"] = _ProductCodes,
		["CreateVolumePermissions"] = _CreateVolumePermissions,
		["SnapshotId"] = _SnapshotId,
	}
	asserts.AssertDescribeSnapshotAttributeResult(t)
	return t
end

keys.ActiveInstance = { ["InstanceId"] = true, ["InstanceHealth"] = true, ["InstanceType"] = true, ["SpotInstanceRequestId"] = true, nil }

function asserts.AssertActiveInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ActiveInstance to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["InstanceHealth"] then asserts.AssertInstanceHealthStatus(struct["InstanceHealth"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ActiveInstance[k], "ActiveInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ActiveInstance
-- <p>Describes a running instance in a Spot fleet.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _InstanceHealth [InstanceHealthStatus] <p>The health status of the instance. If the status of either the instance status check or the system status check is <code>impaired</code>, the health status of the instance is <code>unhealthy</code>. Otherwise, the health status is <code>healthy</code>.</p>
-- @param _InstanceType [String] <p>The instance type.</p>
-- @param _SpotInstanceRequestId [String] <p>The ID of the Spot instance request.</p>
function M.ActiveInstance(_InstanceId, _InstanceHealth, _InstanceType, _SpotInstanceRequestId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ActiveInstance")
	local t = { 
		["InstanceId"] = _InstanceId,
		["InstanceHealth"] = _InstanceHealth,
		["InstanceType"] = _InstanceType,
		["SpotInstanceRequestId"] = _SpotInstanceRequestId,
	}
	asserts.AssertActiveInstance(t)
	return t
end

keys.ModifyVolumeRequest = { ["VolumeType"] = true, ["Iops"] = true, ["DryRun"] = true, ["VolumeId"] = true, ["Size"] = true, nil }

function asserts.AssertModifyVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["Size"] then asserts.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVolumeRequest[k], "ModifyVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeRequest
--  
-- @param _VolumeType [VolumeType] <p>Target EBS volume type of the volume to be modified</p> <p> The API does not support modifications for volume type <code>standard</code>. You also cannot change the type of a volume to <code>standard</code>. </p> <p>Default: If no type is specified, the existing type is retained. </p>
-- @param _Iops [Integer] <p>Target IOPS rate of the volume to be modified.</p> <p>Only valid for Provisioned IOPS SSD (<code>io1</code>) volumes. For more information about <code>io1</code> IOPS configuration, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops">http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops</a>.</p> <p>Default: If no IOPS value is specified, the existing value is retained. </p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VolumeId [String] 
-- @param _Size [Integer] <p>Target size in GiB of the volume to be modified. Target volume size must be greater than or equal to than the existing size of the volume. For information about available EBS volume sizes, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html</a>.</p> <p>Default: If no size is specified, the existing size is retained. </p>
-- Required parameter: VolumeId
function M.ModifyVolumeRequest(_VolumeType, _Iops, _DryRun, _VolumeId, _Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyVolumeRequest")
	local t = { 
		["VolumeType"] = _VolumeType,
		["Iops"] = _Iops,
		["DryRun"] = _DryRun,
		["VolumeId"] = _VolumeId,
		["Size"] = _Size,
	}
	asserts.AssertModifyVolumeRequest(t)
	return t
end

keys.RevokeSecurityGroupIngressRequest = { ["DryRun"] = true, ["GroupName"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertRevokeSecurityGroupIngressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RevokeSecurityGroupIngressRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RevokeSecurityGroupIngressRequest[k], "RevokeSecurityGroupIngressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RevokeSecurityGroupIngressRequest
-- <p>Contains the parameters for RevokeSecurityGroupIngress.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group.</p>
-- @param _CidrIp [String] <p>The CIDR IP address range. You can't specify this parameter when specifying a source security group.</p>
-- @param _IpPermissions [IpPermissionList] <p>A set of IP permissions. You can't specify a source security group and a CIDR IP address range.</p>
-- @param _FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. For the ICMP type number, use <code>-1</code> to specify all ICMP types.</p>
-- @param _SourceSecurityGroupOwnerId [String] <p>[EC2-Classic] The AWS account ID of the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
-- @param _SourceSecurityGroupName [String] <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. For EC2-VPC, the source security group must be in the same VPC. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
-- @param _ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP code number. For the ICMP code number, use <code>-1</code> to specify all ICMP codes for the ICMP type.</p>
-- @param _IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). Use <code>-1</code> to specify all.</p>
-- @param _GroupId [String] <p>The ID of the security group. Required for a security group in a nondefault VPC.</p>
function M.RevokeSecurityGroupIngressRequest(_DryRun, _GroupName, _CidrIp, _IpPermissions, _FromPort, _SourceSecurityGroupOwnerId, _SourceSecurityGroupName, _ToPort, _IpProtocol, _GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RevokeSecurityGroupIngressRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["GroupName"] = _GroupName,
		["CidrIp"] = _CidrIp,
		["IpPermissions"] = _IpPermissions,
		["FromPort"] = _FromPort,
		["SourceSecurityGroupOwnerId"] = _SourceSecurityGroupOwnerId,
		["SourceSecurityGroupName"] = _SourceSecurityGroupName,
		["ToPort"] = _ToPort,
		["IpProtocol"] = _IpProtocol,
		["GroupId"] = _GroupId,
	}
	asserts.AssertRevokeSecurityGroupIngressRequest(t)
	return t
end

keys.CreateSpotDatafeedSubscriptionResult = { ["SpotDatafeedSubscription"] = true, nil }

function asserts.AssertCreateSpotDatafeedSubscriptionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSpotDatafeedSubscriptionResult to be of type 'table'")
	if struct["SpotDatafeedSubscription"] then asserts.AssertSpotDatafeedSubscription(struct["SpotDatafeedSubscription"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSpotDatafeedSubscriptionResult[k], "CreateSpotDatafeedSubscriptionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSpotDatafeedSubscriptionResult
-- <p>Contains the output of CreateSpotDatafeedSubscription.</p>
-- @param _SpotDatafeedSubscription [SpotDatafeedSubscription] <p>The Spot instance data feed subscription.</p>
function M.CreateSpotDatafeedSubscriptionResult(_SpotDatafeedSubscription, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateSpotDatafeedSubscriptionResult")
	local t = { 
		["SpotDatafeedSubscription"] = _SpotDatafeedSubscription,
	}
	asserts.AssertCreateSpotDatafeedSubscriptionResult(t)
	return t
end

keys.DescribeClassicLinkInstancesRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["InstanceIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeClassicLinkInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeClassicLinkInstancesRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeClassicLinkInstancesRequest[k], "DescribeClassicLinkInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeClassicLinkInstancesRequest
-- <p>Contains the parameters for DescribeClassicLinkInstances.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the instance IDs parameter in the same request.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- @param _NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceIds [InstanceIdStringList] <p>One or more instance IDs. Must be instances linked to a VPC through ClassicLink.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>group-id</code> - The ID of a VPC security group that's associated with the instance.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC that the instance is linked to.</p> </li> </ul>
function M.DescribeClassicLinkInstancesRequest(_MaxResults, _NextToken, _DryRun, _InstanceIds, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeClassicLinkInstancesRequest")
	local t = { 
		["MaxResults"] = _MaxResults,
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["InstanceIds"] = _InstanceIds,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeClassicLinkInstancesRequest(t)
	return t
end

keys.DescribeReservedInstancesOfferingsRequest = { ["MaxInstanceCount"] = true, ["OfferingType"] = true, ["AvailabilityZone"] = true, ["DryRun"] = true, ["ProductDescription"] = true, ["IncludeMarketplace"] = true, ["ReservedInstancesOfferingIds"] = true, ["MaxResults"] = true, ["InstanceType"] = true, ["OfferingClass"] = true, ["Filters"] = true, ["MinDuration"] = true, ["InstanceTenancy"] = true, ["NextToken"] = true, ["MaxDuration"] = true, nil }

function asserts.AssertDescribeReservedInstancesOfferingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesOfferingsRequest to be of type 'table'")
	if struct["MaxInstanceCount"] then asserts.AssertInteger(struct["MaxInstanceCount"]) end
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["IncludeMarketplace"] then asserts.AssertBoolean(struct["IncludeMarketplace"]) end
	if struct["ReservedInstancesOfferingIds"] then asserts.AssertReservedInstancesOfferingIdStringList(struct["ReservedInstancesOfferingIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MinDuration"] then asserts.AssertLong(struct["MinDuration"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxDuration"] then asserts.AssertLong(struct["MaxDuration"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesOfferingsRequest[k], "DescribeReservedInstancesOfferingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesOfferingsRequest
-- <p>Contains the parameters for DescribeReservedInstancesOfferings.</p>
-- @param _MaxInstanceCount [Integer] <p>The maximum number of instances to filter when searching for offerings.</p> <p>Default: 20</p>
-- @param _OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the <code>Medium Utilization</code> Reserved Instance offering type. </p>
-- @param _AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the description are for use with Amazon VPC.</p>
-- @param _IncludeMarketplace [Boolean] <p>Include Reserved Instance Marketplace offerings in the response.</p>
-- @param _ReservedInstancesOfferingIds [ReservedInstancesOfferingIdStringList] <p>One or more Reserved Instances offering IDs.</p>
-- @param _MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. The maximum is 100.</p> <p>Default: 100</p>
-- @param _InstanceType [InstanceType] <p>The instance type that the reservation will cover (for example, <code>m1.small</code>). For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @param _OfferingClass [OfferingClassType] <p>The offering class of the Reserved Instance. Can be <code>standard</code> or <code>convertible</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be used.</p> </li> <li> <p> <code>duration</code> - The duration of the Reserved Instance (for example, one year or three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p> </li> <li> <p> <code>fixed-price</code> - The purchase price of the Reserved Instance (for example, 9800.0).</p> </li> <li> <p> <code>instance-type</code> - The instance type that is covered by the reservation.</p> </li> <li> <p> <code>marketplace</code> - Set to <code>true</code> to show only Reserved Instance Marketplace offerings. When this filter is not used, which is the default behavior, all offerings from both AWS and the Reserved Instance Marketplace are listed.</p> </li> <li> <p> <code>product-description</code> - The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC. (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Windows</code> | <code>Windows (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> | <code> Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon VPC)</code>) </p> </li> <li> <p> <code>reserved-instances-offering-id</code> - The Reserved Instances offering ID.</p> </li> <li> <p> <code>scope</code> - The scope of the Reserved Instance (<code>Availability Zone</code> or <code>Region</code>).</p> </li> <li> <p> <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for example, 0.84).</p> </li> </ul>
-- @param _MinDuration [Long] <p>The minimum duration (in seconds) to filter when searching for offerings.</p> <p>Default: 2592000 (1 month)</p>
-- @param _InstanceTenancy [Tenancy] <p>The tenancy of the instances covered by the reservation. A Reserved Instance with a tenancy of <code>dedicated</code> is applied to instances that run in a VPC on single-tenant hardware (i.e., Dedicated Instances).</p> <p> <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p> <p>Default: <code>default</code> </p>
-- @param _NextToken [String] <p>The token to retrieve the next page of results.</p>
-- @param _MaxDuration [Long] <p>The maximum duration (in seconds) to filter when searching for offerings.</p> <p>Default: 94608000 (3 years)</p>
function M.DescribeReservedInstancesOfferingsRequest(_MaxInstanceCount, _OfferingType, _AvailabilityZone, _DryRun, _ProductDescription, _IncludeMarketplace, _ReservedInstancesOfferingIds, _MaxResults, _InstanceType, _OfferingClass, _Filters, _MinDuration, _InstanceTenancy, _NextToken, _MaxDuration, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeReservedInstancesOfferingsRequest")
	local t = { 
		["MaxInstanceCount"] = _MaxInstanceCount,
		["OfferingType"] = _OfferingType,
		["AvailabilityZone"] = _AvailabilityZone,
		["DryRun"] = _DryRun,
		["ProductDescription"] = _ProductDescription,
		["IncludeMarketplace"] = _IncludeMarketplace,
		["ReservedInstancesOfferingIds"] = _ReservedInstancesOfferingIds,
		["MaxResults"] = _MaxResults,
		["InstanceType"] = _InstanceType,
		["OfferingClass"] = _OfferingClass,
		["Filters"] = _Filters,
		["MinDuration"] = _MinDuration,
		["InstanceTenancy"] = _InstanceTenancy,
		["NextToken"] = _NextToken,
		["MaxDuration"] = _MaxDuration,
	}
	asserts.AssertDescribeReservedInstancesOfferingsRequest(t)
	return t
end

keys.GetReservedInstancesExchangeQuoteResult = { ["CurrencyCode"] = true, ["ReservedInstanceValueSet"] = true, ["PaymentDue"] = true, ["TargetConfigurationValueSet"] = true, ["IsValidExchange"] = true, ["ValidationFailureReason"] = true, ["OutputReservedInstancesWillExpireAt"] = true, ["ReservedInstanceValueRollup"] = true, ["TargetConfigurationValueRollup"] = true, nil }

function asserts.AssertGetReservedInstancesExchangeQuoteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetReservedInstancesExchangeQuoteResult to be of type 'table'")
	if struct["CurrencyCode"] then asserts.AssertString(struct["CurrencyCode"]) end
	if struct["ReservedInstanceValueSet"] then asserts.AssertReservedInstanceReservationValueSet(struct["ReservedInstanceValueSet"]) end
	if struct["PaymentDue"] then asserts.AssertString(struct["PaymentDue"]) end
	if struct["TargetConfigurationValueSet"] then asserts.AssertTargetReservationValueSet(struct["TargetConfigurationValueSet"]) end
	if struct["IsValidExchange"] then asserts.AssertBoolean(struct["IsValidExchange"]) end
	if struct["ValidationFailureReason"] then asserts.AssertString(struct["ValidationFailureReason"]) end
	if struct["OutputReservedInstancesWillExpireAt"] then asserts.AssertDateTime(struct["OutputReservedInstancesWillExpireAt"]) end
	if struct["ReservedInstanceValueRollup"] then asserts.AssertReservationValue(struct["ReservedInstanceValueRollup"]) end
	if struct["TargetConfigurationValueRollup"] then asserts.AssertReservationValue(struct["TargetConfigurationValueRollup"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetReservedInstancesExchangeQuoteResult[k], "GetReservedInstancesExchangeQuoteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetReservedInstancesExchangeQuoteResult
-- <p>Contains the output of GetReservedInstancesExchangeQuote.</p>
-- @param _CurrencyCode [String] <p>The currency of the transaction.</p>
-- @param _ReservedInstanceValueSet [ReservedInstanceReservationValueSet] <p>The configuration of your Convertible Reserved Instances.</p>
-- @param _PaymentDue [String] <p>The total true upfront charge for the exchange.</p>
-- @param _TargetConfigurationValueSet [TargetReservationValueSet] <p>The values of the target Convertible Reserved Instances.</p>
-- @param _IsValidExchange [Boolean] <p>If <code>true</code>, the exchange is valid. If <code>false</code>, the exchange cannot be completed.</p>
-- @param _ValidationFailureReason [String] <p>Describes the reason why the exchange cannot be completed.</p>
-- @param _OutputReservedInstancesWillExpireAt [DateTime] <p>The new end date of the reservation term.</p>
-- @param _ReservedInstanceValueRollup [ReservationValue] <p>The cost associated with the Reserved Instance.</p>
-- @param _TargetConfigurationValueRollup [ReservationValue] <p>The cost associated with the Reserved Instance.</p>
function M.GetReservedInstancesExchangeQuoteResult(_CurrencyCode, _ReservedInstanceValueSet, _PaymentDue, _TargetConfigurationValueSet, _IsValidExchange, _ValidationFailureReason, _OutputReservedInstancesWillExpireAt, _ReservedInstanceValueRollup, _TargetConfigurationValueRollup, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetReservedInstancesExchangeQuoteResult")
	local t = { 
		["CurrencyCode"] = _CurrencyCode,
		["ReservedInstanceValueSet"] = _ReservedInstanceValueSet,
		["PaymentDue"] = _PaymentDue,
		["TargetConfigurationValueSet"] = _TargetConfigurationValueSet,
		["IsValidExchange"] = _IsValidExchange,
		["ValidationFailureReason"] = _ValidationFailureReason,
		["OutputReservedInstancesWillExpireAt"] = _OutputReservedInstancesWillExpireAt,
		["ReservedInstanceValueRollup"] = _ReservedInstanceValueRollup,
		["TargetConfigurationValueRollup"] = _TargetConfigurationValueRollup,
	}
	asserts.AssertGetReservedInstancesExchangeQuoteResult(t)
	return t
end

keys.CreateImageResult = { ["ImageId"] = true, nil }

function asserts.AssertCreateImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateImageResult to be of type 'table'")
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateImageResult[k], "CreateImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateImageResult
-- <p>Contains the output of CreateImage.</p>
-- @param _ImageId [String] <p>The ID of the new AMI.</p>
function M.CreateImageResult(_ImageId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateImageResult")
	local t = { 
		["ImageId"] = _ImageId,
	}
	asserts.AssertCreateImageResult(t)
	return t
end

keys.DhcpOptions = { ["Tags"] = true, ["DhcpConfigurations"] = true, ["DhcpOptionsId"] = true, nil }

function asserts.AssertDhcpOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DhcpOptions to be of type 'table'")
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["DhcpConfigurations"] then asserts.AssertDhcpConfigurationList(struct["DhcpConfigurations"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DhcpOptions[k], "DhcpOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DhcpOptions
-- <p>Describes a set of DHCP options.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the DHCP options set.</p>
-- @param _DhcpConfigurations [DhcpConfigurationList] <p>One or more DHCP options in the set.</p>
-- @param _DhcpOptionsId [String] <p>The ID of the set of DHCP options.</p>
function M.DhcpOptions(_Tags, _DhcpConfigurations, _DhcpOptionsId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DhcpOptions")
	local t = { 
		["Tags"] = _Tags,
		["DhcpConfigurations"] = _DhcpConfigurations,
		["DhcpOptionsId"] = _DhcpOptionsId,
	}
	asserts.AssertDhcpOptions(t)
	return t
end

keys.ReservedInstances = { ["ReservedInstancesId"] = true, ["OfferingType"] = true, ["AvailabilityZone"] = true, ["End"] = true, ["ProductDescription"] = true, ["Tags"] = true, ["Scope"] = true, ["UsagePrice"] = true, ["RecurringCharges"] = true, ["OfferingClass"] = true, ["Start"] = true, ["State"] = true, ["FixedPrice"] = true, ["CurrencyCode"] = true, ["Duration"] = true, ["InstanceTenancy"] = true, ["InstanceType"] = true, ["InstanceCount"] = true, nil }

function asserts.AssertReservedInstances(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstances to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["End"] then asserts.AssertDateTime(struct["End"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Scope"] then asserts.Assertscope(struct["Scope"]) end
	if struct["UsagePrice"] then asserts.AssertFloat(struct["UsagePrice"]) end
	if struct["RecurringCharges"] then asserts.AssertRecurringChargesList(struct["RecurringCharges"]) end
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Start"] then asserts.AssertDateTime(struct["Start"]) end
	if struct["State"] then asserts.AssertReservedInstanceState(struct["State"]) end
	if struct["FixedPrice"] then asserts.AssertFloat(struct["FixedPrice"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Duration"] then asserts.AssertLong(struct["Duration"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstances[k], "ReservedInstances contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstances
-- <p>Describes a Reserved Instance.</p>
-- @param _ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- @param _OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- @param _End [DateTime] <p>The time when the Reserved Instance expires.</p>
-- @param _ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the resource.</p>
-- @param _Scope [scope] <p>The scope of the Reserved Instance.</p>
-- @param _UsagePrice [Float] <p>The usage price of the Reserved Instance, per hour.</p>
-- @param _RecurringCharges [RecurringChargesList] <p>The recurring charge tag assigned to the resource.</p>
-- @param _OfferingClass [OfferingClassType] <p>The offering class of the Reserved Instance.</p>
-- @param _Start [DateTime] <p>The date and time the Reserved Instance started.</p>
-- @param _State [ReservedInstanceState] <p>The state of the Reserved Instance purchase.</p>
-- @param _FixedPrice [Float] <p>The purchase price of the Reserved Instance.</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>
-- @param _Duration [Long] <p>The duration of the Reserved Instance, in seconds.</p>
-- @param _InstanceTenancy [Tenancy] <p>The tenancy of the instance.</p>
-- @param _InstanceType [InstanceType] <p>The instance type on which the Reserved Instance can be used.</p>
-- @param _InstanceCount [Integer] <p>The number of reservations purchased.</p>
function M.ReservedInstances(_ReservedInstancesId, _OfferingType, _AvailabilityZone, _End, _ProductDescription, _Tags, _Scope, _UsagePrice, _RecurringCharges, _OfferingClass, _Start, _State, _FixedPrice, _CurrencyCode, _Duration, _InstanceTenancy, _InstanceType, _InstanceCount, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstances")
	local t = { 
		["ReservedInstancesId"] = _ReservedInstancesId,
		["OfferingType"] = _OfferingType,
		["AvailabilityZone"] = _AvailabilityZone,
		["End"] = _End,
		["ProductDescription"] = _ProductDescription,
		["Tags"] = _Tags,
		["Scope"] = _Scope,
		["UsagePrice"] = _UsagePrice,
		["RecurringCharges"] = _RecurringCharges,
		["OfferingClass"] = _OfferingClass,
		["Start"] = _Start,
		["State"] = _State,
		["FixedPrice"] = _FixedPrice,
		["CurrencyCode"] = _CurrencyCode,
		["Duration"] = _Duration,
		["InstanceTenancy"] = _InstanceTenancy,
		["InstanceType"] = _InstanceType,
		["InstanceCount"] = _InstanceCount,
	}
	asserts.AssertReservedInstances(t)
	return t
end

keys.DescribeCustomerGatewaysResult = { ["CustomerGateways"] = true, nil }

function asserts.AssertDescribeCustomerGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCustomerGatewaysResult to be of type 'table'")
	if struct["CustomerGateways"] then asserts.AssertCustomerGatewayList(struct["CustomerGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCustomerGatewaysResult[k], "DescribeCustomerGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCustomerGatewaysResult
-- <p>Contains the output of DescribeCustomerGateways.</p>
-- @param _CustomerGateways [CustomerGatewayList] <p>Information about one or more customer gateways.</p>
function M.DescribeCustomerGatewaysResult(_CustomerGateways, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeCustomerGatewaysResult")
	local t = { 
		["CustomerGateways"] = _CustomerGateways,
	}
	asserts.AssertDescribeCustomerGatewaysResult(t)
	return t
end

keys.AvailabilityZoneMessage = { ["Message"] = true, nil }

function asserts.AssertAvailabilityZoneMessage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailabilityZoneMessage to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	for k,_ in pairs(struct) do
		assert(keys.AvailabilityZoneMessage[k], "AvailabilityZoneMessage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailabilityZoneMessage
-- <p>Describes a message about an Availability Zone.</p>
-- @param _Message [String] <p>The message about the Availability Zone.</p>
function M.AvailabilityZoneMessage(_Message, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AvailabilityZoneMessage")
	local t = { 
		["Message"] = _Message,
	}
	asserts.AssertAvailabilityZoneMessage(t)
	return t
end

keys.GetConsoleScreenshotResult = { ["InstanceId"] = true, ["ImageData"] = true, nil }

function asserts.AssertGetConsoleScreenshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleScreenshotResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["ImageData"] then asserts.AssertString(struct["ImageData"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleScreenshotResult[k], "GetConsoleScreenshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleScreenshotResult
-- <p>Contains the output of the request.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _ImageData [String] <p>The data that comprises the image.</p>
function M.GetConsoleScreenshotResult(_InstanceId, _ImageData, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating GetConsoleScreenshotResult")
	local t = { 
		["InstanceId"] = _InstanceId,
		["ImageData"] = _ImageData,
	}
	asserts.AssertGetConsoleScreenshotResult(t)
	return t
end

keys.DescribeVpcPeeringConnectionsRequest = { ["VpcPeeringConnectionIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpcPeeringConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcPeeringConnectionsRequest to be of type 'table'")
	if struct["VpcPeeringConnectionIds"] then asserts.AssertValueStringList(struct["VpcPeeringConnectionIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcPeeringConnectionsRequest[k], "DescribeVpcPeeringConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcPeeringConnectionsRequest
-- <p>Contains the parameters for DescribeVpcPeeringConnections.</p>
-- @param _VpcPeeringConnectionIds [ValueStringList] <p>One or more VPC peering connection IDs.</p> <p>Default: Describes all your VPC peering connections.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>accepter-vpc-info.cidr-block</code> - The IPv4 CIDR block of the peer VPC.</p> </li> <li> <p> <code>accepter-vpc-info.owner-id</code> - The AWS account ID of the owner of the peer VPC.</p> </li> <li> <p> <code>accepter-vpc-info.vpc-id</code> - The ID of the peer VPC.</p> </li> <li> <p> <code>expiration-time</code> - The expiration date and time for the VPC peering connection.</p> </li> <li> <p> <code>requester-vpc-info.cidr-block</code> - The IPv4 CIDR block of the requester's VPC.</p> </li> <li> <p> <code>requester-vpc-info.owner-id</code> - The AWS account ID of the owner of the requester VPC.</p> </li> <li> <p> <code>requester-vpc-info.vpc-id</code> - The ID of the requester VPC.</p> </li> <li> <p> <code>status-code</code> - The status of the VPC peering connection (<code>pending-acceptance</code> | <code>failed</code> | <code>expired</code> | <code>provisioning</code> | <code>active</code> | <code>deleted</code> | <code>rejected</code>).</p> </li> <li> <p> <code>status-message</code> - A message that provides more information about the status of the VPC peering connection, if applicable.</p> </li> <li> <p> <code>tag</code>:<i>key</i>=<i>value</i> - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify <code>tag:Purpose</code> for the filter name and <code>X</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. This filter is independent of the <code>tag-value</code> filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the <code>tag</code>:<i>key</i>=<i>value</i> filter.</p> </li> <li> <p> <code>tag-value</code> - The value of a tag assigned to the resource. This filter is independent of the <code>tag-key</code> filter.</p> </li> <li> <p> <code>vpc-peering-connection-id</code> - The ID of the VPC peering connection.</p> </li> </ul>
function M.DescribeVpcPeeringConnectionsRequest(_VpcPeeringConnectionIds, _DryRun, _Filters, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcPeeringConnectionsRequest")
	local t = { 
		["VpcPeeringConnectionIds"] = _VpcPeeringConnectionIds,
		["DryRun"] = _DryRun,
		["Filters"] = _Filters,
	}
	asserts.AssertDescribeVpcPeeringConnectionsRequest(t)
	return t
end

keys.AuthorizeSecurityGroupEgressRequest = { ["DryRun"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertAuthorizeSecurityGroupEgressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizeSecurityGroupEgressRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthorizeSecurityGroupEgressRequest[k], "AuthorizeSecurityGroupEgressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizeSecurityGroupEgressRequest
-- <p>Contains the parameters for AuthorizeSecurityGroupEgress.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _CidrIp [String] <p>The CIDR IPv4 address range. We recommend that you specify the CIDR range in a set of IP permissions instead.</p>
-- @param _IpPermissions [IpPermissionList] <p>A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.</p>
-- @param _FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- @param _SourceSecurityGroupOwnerId [String] <p>The AWS account number for a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- @param _SourceSecurityGroupName [String] <p>The name of a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.</p>
-- @param _ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.</p>
-- @param _IpProtocol [String] <p>The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.</p>
-- @param _GroupId [String] <p>The ID of the security group.</p>
-- Required parameter: GroupId
function M.AuthorizeSecurityGroupEgressRequest(_DryRun, _CidrIp, _IpPermissions, _FromPort, _SourceSecurityGroupOwnerId, _SourceSecurityGroupName, _ToPort, _IpProtocol, _GroupId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AuthorizeSecurityGroupEgressRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["CidrIp"] = _CidrIp,
		["IpPermissions"] = _IpPermissions,
		["FromPort"] = _FromPort,
		["SourceSecurityGroupOwnerId"] = _SourceSecurityGroupOwnerId,
		["SourceSecurityGroupName"] = _SourceSecurityGroupName,
		["ToPort"] = _ToPort,
		["IpProtocol"] = _IpProtocol,
		["GroupId"] = _GroupId,
	}
	asserts.AssertAuthorizeSecurityGroupEgressRequest(t)
	return t
end

keys.DeleteCustomerGatewayRequest = { ["CustomerGatewayId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteCustomerGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteCustomerGatewayRequest to be of type 'table'")
	assert(struct["CustomerGatewayId"], "Expected key CustomerGatewayId to exist in table")
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteCustomerGatewayRequest[k], "DeleteCustomerGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteCustomerGatewayRequest
-- <p>Contains the parameters for DeleteCustomerGateway.</p>
-- @param _CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: CustomerGatewayId
function M.DeleteCustomerGatewayRequest(_CustomerGatewayId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DeleteCustomerGatewayRequest")
	local t = { 
		["CustomerGatewayId"] = _CustomerGatewayId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDeleteCustomerGatewayRequest(t)
	return t
end

keys.CreateReservedInstancesListingRequest = { ["ReservedInstancesId"] = true, ["PriceSchedules"] = true, ["InstanceCount"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateReservedInstancesListingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateReservedInstancesListingRequest to be of type 'table'")
	assert(struct["ClientToken"], "Expected key ClientToken to exist in table")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["PriceSchedules"], "Expected key PriceSchedules to exist in table")
	assert(struct["ReservedInstancesId"], "Expected key ReservedInstancesId to exist in table")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["PriceSchedules"] then asserts.AssertPriceScheduleSpecificationList(struct["PriceSchedules"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateReservedInstancesListingRequest[k], "CreateReservedInstancesListingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateReservedInstancesListingRequest
-- <p>Contains the parameters for CreateReservedInstancesListing.</p>
-- @param _ReservedInstancesId [String] <p>The ID of the active Standard Reserved Instance.</p>
-- @param _PriceSchedules [PriceScheduleSpecificationList] <p>A list specifying the price of the Standard Reserved Instance for each month remaining in the Reserved Instance term.</p>
-- @param _InstanceCount [Integer] <p>The number of instances that are a part of a Reserved Instance account to be listed in the Reserved Instance Marketplace. This number should be less than or equal to the instance count associated with the Reserved Instance ID specified in this call.</p>
-- @param _ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required parameter: ClientToken
-- Required parameter: InstanceCount
-- Required parameter: PriceSchedules
-- Required parameter: ReservedInstancesId
function M.CreateReservedInstancesListingRequest(_ReservedInstancesId, _PriceSchedules, _InstanceCount, _ClientToken, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateReservedInstancesListingRequest")
	local t = { 
		["ReservedInstancesId"] = _ReservedInstancesId,
		["PriceSchedules"] = _PriceSchedules,
		["InstanceCount"] = _InstanceCount,
		["ClientToken"] = _ClientToken,
	}
	asserts.AssertCreateReservedInstancesListingRequest(t)
	return t
end

keys.NetworkInterfaceAssociation = { ["PublicIp"] = true, ["AssociationId"] = true, ["PublicDnsName"] = true, ["AllocationId"] = true, ["IpOwnerId"] = true, nil }

function asserts.AssertNetworkInterfaceAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAssociation to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["PublicDnsName"] then asserts.AssertString(struct["PublicDnsName"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["IpOwnerId"] then asserts.AssertString(struct["IpOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceAssociation[k], "NetworkInterfaceAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAssociation
-- <p>Describes association information for an Elastic IP address (IPv4 only).</p>
-- @param _PublicIp [String] <p>The address of the Elastic IP address bound to the network interface.</p>
-- @param _AssociationId [String] <p>The association ID.</p>
-- @param _PublicDnsName [String] <p>The public DNS name.</p>
-- @param _AllocationId [String] <p>The allocation ID.</p>
-- @param _IpOwnerId [String] <p>The ID of the Elastic IP address owner.</p>
function M.NetworkInterfaceAssociation(_PublicIp, _AssociationId, _PublicDnsName, _AllocationId, _IpOwnerId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating NetworkInterfaceAssociation")
	local t = { 
		["PublicIp"] = _PublicIp,
		["AssociationId"] = _AssociationId,
		["PublicDnsName"] = _PublicDnsName,
		["AllocationId"] = _AllocationId,
		["IpOwnerId"] = _IpOwnerId,
	}
	asserts.AssertNetworkInterfaceAssociation(t)
	return t
end

keys.ReservedInstancesOffering = { ["OfferingClass"] = true, ["Marketplace"] = true, ["ProductDescription"] = true, ["CurrencyCode"] = true, ["PricingDetails"] = true, ["UsagePrice"] = true, ["RecurringCharges"] = true, ["OfferingType"] = true, ["AvailabilityZone"] = true, ["FixedPrice"] = true, ["Scope"] = true, ["Duration"] = true, ["InstanceTenancy"] = true, ["ReservedInstancesOfferingId"] = true, ["InstanceType"] = true, nil }

function asserts.AssertReservedInstancesOffering(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesOffering to be of type 'table'")
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Marketplace"] then asserts.AssertBoolean(struct["Marketplace"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["PricingDetails"] then asserts.AssertPricingDetailsList(struct["PricingDetails"]) end
	if struct["UsagePrice"] then asserts.AssertFloat(struct["UsagePrice"]) end
	if struct["RecurringCharges"] then asserts.AssertRecurringChargesList(struct["RecurringCharges"]) end
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["FixedPrice"] then asserts.AssertFloat(struct["FixedPrice"]) end
	if struct["Scope"] then asserts.Assertscope(struct["Scope"]) end
	if struct["Duration"] then asserts.AssertLong(struct["Duration"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["ReservedInstancesOfferingId"] then asserts.AssertString(struct["ReservedInstancesOfferingId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesOffering[k], "ReservedInstancesOffering contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesOffering
-- <p>Describes a Reserved Instance offering.</p>
-- @param _OfferingClass [OfferingClassType] <p>If <code>convertible</code> it can be exchanged for Reserved Instances of the same or higher monetary value, with different configurations. If <code>standard</code>, it is not possible to perform an exchange.</p>
-- @param _Marketplace [Boolean] <p>Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or AWS. If it's a Reserved Instance Marketplace offering, this is <code>true</code>.</p>
-- @param _ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description.</p>
-- @param _CurrencyCode [CurrencyCodeValues] <p>The currency of the Reserved Instance offering you are purchasing. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>
-- @param _PricingDetails [PricingDetailsList] <p>The pricing details of the Reserved Instance offering.</p>
-- @param _UsagePrice [Float] <p>The usage price of the Reserved Instance, per hour.</p>
-- @param _RecurringCharges [RecurringChargesList] <p>The recurring charge tag assigned to the resource.</p>
-- @param _OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- @param _FixedPrice [Float] <p>The purchase price of the Reserved Instance.</p>
-- @param _Scope [scope] <p>Whether the Reserved Instance is applied to instances in a region or an Availability Zone.</p>
-- @param _Duration [Long] <p>The duration of the Reserved Instance, in seconds.</p>
-- @param _InstanceTenancy [Tenancy] <p>The tenancy of the instance.</p>
-- @param _ReservedInstancesOfferingId [String] <p>The ID of the Reserved Instance offering. This is the offering ID used in <a>GetReservedInstancesExchangeQuote</a> to confirm that an exchange can be made.</p>
-- @param _InstanceType [InstanceType] <p>The instance type on which the Reserved Instance can be used.</p>
function M.ReservedInstancesOffering(_OfferingClass, _Marketplace, _ProductDescription, _CurrencyCode, _PricingDetails, _UsagePrice, _RecurringCharges, _OfferingType, _AvailabilityZone, _FixedPrice, _Scope, _Duration, _InstanceTenancy, _ReservedInstancesOfferingId, _InstanceType, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ReservedInstancesOffering")
	local t = { 
		["OfferingClass"] = _OfferingClass,
		["Marketplace"] = _Marketplace,
		["ProductDescription"] = _ProductDescription,
		["CurrencyCode"] = _CurrencyCode,
		["PricingDetails"] = _PricingDetails,
		["UsagePrice"] = _UsagePrice,
		["RecurringCharges"] = _RecurringCharges,
		["OfferingType"] = _OfferingType,
		["AvailabilityZone"] = _AvailabilityZone,
		["FixedPrice"] = _FixedPrice,
		["Scope"] = _Scope,
		["Duration"] = _Duration,
		["InstanceTenancy"] = _InstanceTenancy,
		["ReservedInstancesOfferingId"] = _ReservedInstancesOfferingId,
		["InstanceType"] = _InstanceType,
	}
	asserts.AssertReservedInstancesOffering(t)
	return t
end

keys.IpPermission = { ["PrefixListIds"] = true, ["FromPort"] = true, ["IpRanges"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["UserIdGroupPairs"] = true, ["Ipv6Ranges"] = true, nil }

function asserts.AssertIpPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IpPermission to be of type 'table'")
	if struct["PrefixListIds"] then asserts.AssertPrefixListIdList(struct["PrefixListIds"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["IpRanges"] then asserts.AssertIpRangeList(struct["IpRanges"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["UserIdGroupPairs"] then asserts.AssertUserIdGroupPairList(struct["UserIdGroupPairs"]) end
	if struct["Ipv6Ranges"] then asserts.AssertIpv6RangeList(struct["Ipv6Ranges"]) end
	for k,_ in pairs(struct) do
		assert(keys.IpPermission[k], "IpPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IpPermission
-- <p>Describes a security group rule.</p>
-- @param _PrefixListIds [PrefixListIdList] <p>(Valid for <a>AuthorizeSecurityGroupEgress</a>, <a>RevokeSecurityGroupEgress</a> and <a>DescribeSecurityGroups</a> only) One or more prefix list IDs for an AWS service. In an <a>AuthorizeSecurityGroupEgress</a> request, this is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.</p>
-- @param _FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of <code>-1</code> indicates all ICMP/ICMPv6 types.</p>
-- @param _IpRanges [IpRangeList] <p>One or more IPv4 ranges.</p>
-- @param _ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes for the specified ICMP type.</p>
-- @param _IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). </p> <p>[EC2-VPC only] Use <code>-1</code> to specify all protocols. When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>58</code> (ICMPv6) allows traffic on all ports, regardless of any port range you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For <code>58</code> (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed when authorizing rules. </p>
-- @param _UserIdGroupPairs [UserIdGroupPairList] <p>One or more security group and AWS account ID pairs.</p>
-- @param _Ipv6Ranges [Ipv6RangeList] <p>[EC2-VPC only] One or more IPv6 ranges.</p>
function M.IpPermission(_PrefixListIds, _FromPort, _IpRanges, _ToPort, _IpProtocol, _UserIdGroupPairs, _Ipv6Ranges, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating IpPermission")
	local t = { 
		["PrefixListIds"] = _PrefixListIds,
		["FromPort"] = _FromPort,
		["IpRanges"] = _IpRanges,
		["ToPort"] = _ToPort,
		["IpProtocol"] = _IpProtocol,
		["UserIdGroupPairs"] = _UserIdGroupPairs,
		["Ipv6Ranges"] = _Ipv6Ranges,
	}
	asserts.AssertIpPermission(t)
	return t
end

keys.MonitorInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertMonitorInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MonitorInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.MonitorInstancesRequest[k], "MonitorInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MonitorInstancesRequest
-- <p>Contains the parameters for MonitorInstances.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.MonitorInstancesRequest(_DryRun, _InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating MonitorInstancesRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["InstanceIds"] = _InstanceIds,
	}
	asserts.AssertMonitorInstancesRequest(t)
	return t
end

keys.AcceptVpcPeeringConnectionRequest = { ["DryRun"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertAcceptVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcPeeringConnectionRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptVpcPeeringConnectionRequest[k], "AcceptVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcPeeringConnectionRequest
-- <p>Contains the parameters for AcceptVpcPeeringConnection.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
function M.AcceptVpcPeeringConnectionRequest(_DryRun, _VpcPeeringConnectionId, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AcceptVpcPeeringConnectionRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["VpcPeeringConnectionId"] = _VpcPeeringConnectionId,
	}
	asserts.AssertAcceptVpcPeeringConnectionRequest(t)
	return t
end

keys.Volume = { ["AvailabilityZone"] = true, ["Attachments"] = true, ["Tags"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["VolumeId"] = true, ["State"] = true, ["KmsKeyId"] = true, ["SnapshotId"] = true, ["Iops"] = true, ["CreateTime"] = true, ["Size"] = true, nil }

function asserts.AssertVolume(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Volume to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Attachments"] then asserts.AssertVolumeAttachmentList(struct["Attachments"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["State"] then asserts.AssertVolumeState(struct["State"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["Size"] then asserts.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.Volume[k], "Volume contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Volume
-- <p>Describes a volume.</p>
-- @param _AvailabilityZone [String] <p>The Availability Zone for the volume.</p>
-- @param _Attachments [VolumeAttachmentList] <p>Information about the volume attachments.</p>
-- @param _Tags [TagList] <p>Any tags assigned to the volume.</p>
-- @param _Encrypted [Boolean] <p>Indicates whether the volume will be encrypted.</p>
-- @param _VolumeType [VolumeType] <p>The volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p>
-- @param _VolumeId [String] <p>The ID of the volume.</p>
-- @param _State [VolumeState] <p>The volume state.</p>
-- @param _KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the volume.</p>
-- @param _SnapshotId [String] <p>The snapshot from which the volume was created, if applicable.</p>
-- @param _Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For Provisioned IOPS SSD volumes, this represents the number of IOPS that are provisioned for the volume. For General Purpose SSD volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information on General Purpose SSD baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
-- @param _CreateTime [DateTime] <p>The time stamp when volume creation was initiated.</p>
-- @param _Size [Integer] <p>The size of the volume, in GiBs.</p>
function M.Volume(_AvailabilityZone, _Attachments, _Tags, _Encrypted, _VolumeType, _VolumeId, _State, _KmsKeyId, _SnapshotId, _Iops, _CreateTime, _Size, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating Volume")
	local t = { 
		["AvailabilityZone"] = _AvailabilityZone,
		["Attachments"] = _Attachments,
		["Tags"] = _Tags,
		["Encrypted"] = _Encrypted,
		["VolumeType"] = _VolumeType,
		["VolumeId"] = _VolumeId,
		["State"] = _State,
		["KmsKeyId"] = _KmsKeyId,
		["SnapshotId"] = _SnapshotId,
		["Iops"] = _Iops,
		["CreateTime"] = _CreateTime,
		["Size"] = _Size,
	}
	asserts.AssertVolume(t)
	return t
end

keys.CreateVpcResult = { ["Vpc"] = true, nil }

function asserts.AssertCreateVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcResult to be of type 'table'")
	if struct["Vpc"] then asserts.AssertVpc(struct["Vpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcResult[k], "CreateVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcResult
-- <p>Contains the output of CreateVpc.</p>
-- @param _Vpc [Vpc] <p>Information about the VPC.</p>
function M.CreateVpcResult(_Vpc, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcResult")
	local t = { 
		["Vpc"] = _Vpc,
	}
	asserts.AssertCreateVpcResult(t)
	return t
end

keys.EnableVpcClassicLinkRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertEnableVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkRequest[k], "EnableVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkRequest
-- <p>Contains the parameters for EnableVpcClassicLink.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: VpcId
function M.EnableVpcClassicLinkRequest(_VpcId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating EnableVpcClassicLinkRequest")
	local t = { 
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertEnableVpcClassicLinkRequest(t)
	return t
end

keys.DescribeVolumeStatusRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["VolumeIds"] = true, nil }

function asserts.AssertDescribeVolumeStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeStatusRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["VolumeIds"] then asserts.AssertVolumeIdStringList(struct["VolumeIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeStatusRequest[k], "DescribeVolumeStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeStatusRequest
-- <p>Contains the parameters for DescribeVolumeStatus.</p>
-- @param _NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeVolumeStatus</code> request. When the results of the request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _MaxResults [Integer] <p>The maximum number of volume results returned by <code>DescribeVolumeStatus</code> in paginated output. When this parameter is used, the request only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then <code>DescribeVolumeStatus</code> returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.</p>
-- @param _Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>action.code</code> - The action code for the event (for example, <code>enable-volume-io</code>).</p> </li> <li> <p> <code>action.description</code> - A description of the action.</p> </li> <li> <p> <code>action.event-id</code> - The event ID associated with the action.</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>event.description</code> - A description of the event.</p> </li> <li> <p> <code>event.event-id</code> - The event ID.</p> </li> <li> <p> <code>event.event-type</code> - The event type (for <code>io-enabled</code>: <code>passed</code> | <code>failed</code>; for <code>io-performance</code>: <code>io-performance:degraded</code> | <code>io-performance:severely-degraded</code> | <code>io-performance:stalled</code>).</p> </li> <li> <p> <code>event.not-after</code> - The latest end time for the event.</p> </li> <li> <p> <code>event.not-before</code> - The earliest start time for the event.</p> </li> <li> <p> <code>volume-status.details-name</code> - The cause for <code>volume-status.status</code> (<code>io-enabled</code> | <code>io-performance</code>).</p> </li> <li> <p> <code>volume-status.details-status</code> - The status of <code>volume-status.details-name</code> (for <code>io-enabled</code>: <code>passed</code> | <code>failed</code>; for <code>io-performance</code>: <code>normal</code> | <code>degraded</code> | <code>severely-degraded</code> | <code>stalled</code>).</p> </li> <li> <p> <code>volume-status.status</code> - The status of the volume (<code>ok</code> | <code>impaired</code> | <code>warning</code> | <code>insufficient-data</code>).</p> </li> </ul>
-- @param _VolumeIds [VolumeIdStringList] <p>One or more volume IDs.</p> <p>Default: Describes all your volumes.</p>
function M.DescribeVolumeStatusRequest(_NextToken, _DryRun, _MaxResults, _Filters, _VolumeIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVolumeStatusRequest")
	local t = { 
		["NextToken"] = _NextToken,
		["DryRun"] = _DryRun,
		["MaxResults"] = _MaxResults,
		["Filters"] = _Filters,
		["VolumeIds"] = _VolumeIds,
	}
	asserts.AssertDescribeVolumeStatusRequest(t)
	return t
end

keys.AssignPrivateIpAddressesRequest = { ["NetworkInterfaceId"] = true, ["SecondaryPrivateIpAddressCount"] = true, ["PrivateIpAddresses"] = true, ["AllowReassignment"] = true, nil }

function asserts.AssertAssignPrivateIpAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignPrivateIpAddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressStringList(struct["PrivateIpAddresses"]) end
	if struct["AllowReassignment"] then asserts.AssertBoolean(struct["AllowReassignment"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssignPrivateIpAddressesRequest[k], "AssignPrivateIpAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignPrivateIpAddressesRequest
-- <p>Contains the parameters for AssignPrivateIpAddresses.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary IP addresses to assign to the network interface. You can't specify this parameter when also specifying private IP addresses.</p>
-- @param _PrivateIpAddresses [PrivateIpAddressStringList] <p>One or more IP addresses to be assigned as a secondary private IP address to the network interface. You can't specify this parameter when also specifying a number of secondary IP addresses.</p> <p>If you don't specify an IP address, Amazon EC2 automatically selects an IP address within the subnet range.</p>
-- @param _AllowReassignment [Boolean] <p>Indicates whether to allow an IP address that is already assigned to another network interface or instance to be reassigned to the specified network interface.</p>
-- Required parameter: NetworkInterfaceId
function M.AssignPrivateIpAddressesRequest(_NetworkInterfaceId, _SecondaryPrivateIpAddressCount, _PrivateIpAddresses, _AllowReassignment, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AssignPrivateIpAddressesRequest")
	local t = { 
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["SecondaryPrivateIpAddressCount"] = _SecondaryPrivateIpAddressCount,
		["PrivateIpAddresses"] = _PrivateIpAddresses,
		["AllowReassignment"] = _AllowReassignment,
	}
	asserts.AssertAssignPrivateIpAddressesRequest(t)
	return t
end

keys.RequestSpotFleetRequest = { ["SpotFleetRequestConfig"] = true, ["DryRun"] = true, nil }

function asserts.AssertRequestSpotFleetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotFleetRequest to be of type 'table'")
	assert(struct["SpotFleetRequestConfig"], "Expected key SpotFleetRequestConfig to exist in table")
	if struct["SpotFleetRequestConfig"] then asserts.AssertSpotFleetRequestConfigData(struct["SpotFleetRequestConfig"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotFleetRequest[k], "RequestSpotFleetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotFleetRequest
-- <p>Contains the parameters for RequestSpotFleet.</p>
-- @param _SpotFleetRequestConfig [SpotFleetRequestConfigData] <p>The configuration for the Spot fleet request.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: SpotFleetRequestConfig
function M.RequestSpotFleetRequest(_SpotFleetRequestConfig, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RequestSpotFleetRequest")
	local t = { 
		["SpotFleetRequestConfig"] = _SpotFleetRequestConfig,
		["DryRun"] = _DryRun,
	}
	asserts.AssertRequestSpotFleetRequest(t)
	return t
end

keys.CreateVpcRequest = { ["AmazonProvidedIpv6CidrBlock"] = true, ["DryRun"] = true, ["InstanceTenancy"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertCreateVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcRequest to be of type 'table'")
	assert(struct["CidrBlock"], "Expected key CidrBlock to exist in table")
	if struct["AmazonProvidedIpv6CidrBlock"] then asserts.AssertBoolean(struct["AmazonProvidedIpv6CidrBlock"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcRequest[k], "CreateVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcRequest
-- <p>Contains the parameters for CreateVpc.</p>
-- @param _AmazonProvidedIpv6CidrBlock [Boolean] <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceTenancy [Tenancy] <p>The tenancy options for instances launched into the VPC. For <code>default</code>, instances are launched with shared tenancy by default. You can launch instances with any tenancy into a shared tenancy VPC. For <code>dedicated</code>, instances are launched as dedicated tenancy instances by default. You can only launch instances with a tenancy of <code>dedicated</code> or <code>host</code> into a dedicated tenancy VPC. </p> <p> <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p> <p>Default: <code>default</code> </p>
-- @param _CidrBlock [String] <p>The IPv4 network range for the VPC, in CIDR notation. For example, <code>10.0.0.0/16</code>.</p>
-- Required parameter: CidrBlock
function M.CreateVpcRequest(_AmazonProvidedIpv6CidrBlock, _DryRun, _InstanceTenancy, _CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateVpcRequest")
	local t = { 
		["AmazonProvidedIpv6CidrBlock"] = _AmazonProvidedIpv6CidrBlock,
		["DryRun"] = _DryRun,
		["InstanceTenancy"] = _InstanceTenancy,
		["CidrBlock"] = _CidrBlock,
	}
	asserts.AssertCreateVpcRequest(t)
	return t
end

keys.CancelSpotFleetRequestsError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsError to be of type 'table'")
	assert(struct["Code"], "Expected key Code to exist in table")
	assert(struct["Message"], "Expected key Message to exist in table")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertCancelBatchErrorCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsError[k], "CancelSpotFleetRequestsError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsError
-- <p>Describes a Spot fleet error.</p>
-- @param _Message [String] <p>The description for the error code.</p>
-- @param _Code [CancelBatchErrorCode] <p>The error code.</p>
-- Required parameter: Code
-- Required parameter: Message
function M.CancelSpotFleetRequestsError(_Message, _Code, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CancelSpotFleetRequestsError")
	local t = { 
		["Message"] = _Message,
		["Code"] = _Code,
	}
	asserts.AssertCancelSpotFleetRequestsError(t)
	return t
end

keys.ClassicLinkDnsSupport = { ["VpcId"] = true, ["ClassicLinkDnsSupported"] = true, nil }

function asserts.AssertClassicLinkDnsSupport(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLinkDnsSupport to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["ClassicLinkDnsSupported"] then asserts.AssertBoolean(struct["ClassicLinkDnsSupported"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClassicLinkDnsSupport[k], "ClassicLinkDnsSupport contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLinkDnsSupport
-- <p>Describes the ClassicLink DNS support status of a VPC.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _ClassicLinkDnsSupported [Boolean] <p>Indicates whether ClassicLink DNS support is enabled for the VPC.</p>
function M.ClassicLinkDnsSupport(_VpcId, _ClassicLinkDnsSupported, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ClassicLinkDnsSupport")
	local t = { 
		["VpcId"] = _VpcId,
		["ClassicLinkDnsSupported"] = _ClassicLinkDnsSupported,
	}
	asserts.AssertClassicLinkDnsSupport(t)
	return t
end

keys.RebootInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertRebootInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RebootInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.RebootInstancesRequest[k], "RebootInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RebootInstancesRequest
-- <p>Contains the parameters for RebootInstances.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required parameter: InstanceIds
function M.RebootInstancesRequest(_DryRun, _InstanceIds, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating RebootInstancesRequest")
	local t = { 
		["DryRun"] = _DryRun,
		["InstanceIds"] = _InstanceIds,
	}
	asserts.AssertRebootInstancesRequest(t)
	return t
end

keys.CreateNetworkAclEntryRequest = { ["IcmpTypeCode"] = true, ["NetworkAclId"] = true, ["RuleNumber"] = true, ["DryRun"] = true, ["Ipv6CidrBlock"] = true, ["Egress"] = true, ["RuleAction"] = true, ["PortRange"] = true, ["Protocol"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertCreateNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["Protocol"], "Expected key Protocol to exist in table")
	assert(struct["RuleAction"], "Expected key RuleAction to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["IcmpTypeCode"] then asserts.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then asserts.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then asserts.AssertPortRange(struct["PortRange"]) end
	if struct["Protocol"] then asserts.AssertString(struct["Protocol"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkAclEntryRequest[k], "CreateNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclEntryRequest
-- <p>Contains the parameters for CreateNetworkAclEntry.</p>
-- @param _IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
-- @param _NetworkAclId [String] <p>The ID of the network ACL.</p>
-- @param _RuleNumber [Integer] <p>The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number.</p> <p>Constraints: Positive integer from 1 to 32766. The range 32767 to 65535 is reserved for internal use.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @param _Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation (for example <code>2001:db8:1234:1a00::/64</code>).</p>
-- @param _Egress [Boolean] <p>Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet).</p>
-- @param _RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- @param _PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
-- @param _Protocol [String] <p>The protocol. A value of <code>-1</code> or <code>all</code> means all protocols. If you specify <code>all</code>, <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, or <code>icmp</code>, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol <code>58</code> (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
-- @param _CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation (for example <code>172.16.0.0/24</code>).</p>
-- Required parameter: Egress
-- Required parameter: NetworkAclId
-- Required parameter: Protocol
-- Required parameter: RuleAction
-- Required parameter: RuleNumber
function M.CreateNetworkAclEntryRequest(_IcmpTypeCode, _NetworkAclId, _RuleNumber, _DryRun, _Ipv6CidrBlock, _Egress, _RuleAction, _PortRange, _Protocol, _CidrBlock, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating CreateNetworkAclEntryRequest")
	local t = { 
		["IcmpTypeCode"] = _IcmpTypeCode,
		["NetworkAclId"] = _NetworkAclId,
		["RuleNumber"] = _RuleNumber,
		["DryRun"] = _DryRun,
		["Ipv6CidrBlock"] = _Ipv6CidrBlock,
		["Egress"] = _Egress,
		["RuleAction"] = _RuleAction,
		["PortRange"] = _PortRange,
		["Protocol"] = _Protocol,
		["CidrBlock"] = _CidrBlock,
	}
	asserts.AssertCreateNetworkAclEntryRequest(t)
	return t
end

keys.AttachNetworkInterfaceRequest = { ["InstanceId"] = true, ["DeviceIndex"] = true, ["NetworkInterfaceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertAttachNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachNetworkInterfaceRequest to be of type 'table'")
	assert(struct["DeviceIndex"], "Expected key DeviceIndex to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachNetworkInterfaceRequest[k], "AttachNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachNetworkInterfaceRequest
-- <p>Contains the parameters for AttachNetworkInterface.</p>
-- @param _InstanceId [String] <p>The ID of the instance.</p>
-- @param _DeviceIndex [Integer] <p>The index of the device for the network interface attachment.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: DeviceIndex
-- Required parameter: InstanceId
-- Required parameter: NetworkInterfaceId
function M.AttachNetworkInterfaceRequest(_InstanceId, _DeviceIndex, _NetworkInterfaceId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating AttachNetworkInterfaceRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["DeviceIndex"] = _DeviceIndex,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertAttachNetworkInterfaceRequest(t)
	return t
end

keys.ImportKeyPairResult = { ["KeyName"] = true, ["KeyFingerprint"] = true, nil }

function asserts.AssertImportKeyPairResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportKeyPairResult to be of type 'table'")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then asserts.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportKeyPairResult[k], "ImportKeyPairResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportKeyPairResult
-- <p>Contains the output of ImportKeyPair.</p>
-- @param _KeyName [String] <p>The key pair name you provided.</p>
-- @param _KeyFingerprint [String] <p>The MD5 public key fingerprint as specified in section 4 of RFC 4716.</p>
function M.ImportKeyPairResult(_KeyName, _KeyFingerprint, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ImportKeyPairResult")
	local t = { 
		["KeyName"] = _KeyName,
		["KeyFingerprint"] = _KeyFingerprint,
	}
	asserts.AssertImportKeyPairResult(t)
	return t
end

keys.DescribeSpotInstanceRequestsResult = { ["SpotInstanceRequests"] = true, nil }

function asserts.AssertDescribeSpotInstanceRequestsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotInstanceRequestsResult to be of type 'table'")
	if struct["SpotInstanceRequests"] then asserts.AssertSpotInstanceRequestList(struct["SpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotInstanceRequestsResult[k], "DescribeSpotInstanceRequestsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotInstanceRequestsResult
-- <p>Contains the output of DescribeSpotInstanceRequests.</p>
-- @param _SpotInstanceRequests [SpotInstanceRequestList] <p>One or more Spot instance requests.</p>
function M.DescribeSpotInstanceRequestsResult(_SpotInstanceRequests, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeSpotInstanceRequestsResult")
	local t = { 
		["SpotInstanceRequests"] = _SpotInstanceRequests,
	}
	asserts.AssertDescribeSpotInstanceRequestsResult(t)
	return t
end

keys.ClientData = { ["Comment"] = true, ["UploadSize"] = true, ["UploadEnd"] = true, ["UploadStart"] = true, nil }

function asserts.AssertClientData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClientData to be of type 'table'")
	if struct["Comment"] then asserts.AssertString(struct["Comment"]) end
	if struct["UploadSize"] then asserts.AssertDouble(struct["UploadSize"]) end
	if struct["UploadEnd"] then asserts.AssertDateTime(struct["UploadEnd"]) end
	if struct["UploadStart"] then asserts.AssertDateTime(struct["UploadStart"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClientData[k], "ClientData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClientData
-- <p>Describes the client-specific data.</p>
-- @param _Comment [String] <p>A user-defined comment about the disk upload.</p>
-- @param _UploadSize [Double] <p>The size of the uploaded disk image, in GiB.</p>
-- @param _UploadEnd [DateTime] <p>The time that the disk upload ends.</p>
-- @param _UploadStart [DateTime] <p>The time that the disk upload starts.</p>
function M.ClientData(_Comment, _UploadSize, _UploadEnd, _UploadStart, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ClientData")
	local t = { 
		["Comment"] = _Comment,
		["UploadSize"] = _UploadSize,
		["UploadEnd"] = _UploadEnd,
		["UploadStart"] = _UploadStart,
	}
	asserts.AssertClientData(t)
	return t
end

keys.DescribeNetworkInterfaceAttributeResult = { ["SourceDestCheck"] = true, ["NetworkInterfaceId"] = true, ["Attachment"] = true, ["Groups"] = true, ["Description"] = true, nil }

function asserts.AssertDescribeNetworkInterfaceAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfaceAttributeResult to be of type 'table'")
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["Attachment"] then asserts.AssertNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfaceAttributeResult[k], "DescribeNetworkInterfaceAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfaceAttributeResult
-- <p>Contains the output of DescribeNetworkInterfaceAttribute.</p>
-- @param _SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled.</p>
-- @param _NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @param _Attachment [NetworkInterfaceAttachment] <p>The attachment (if any) of the network interface.</p>
-- @param _Groups [GroupIdentifierList] <p>The security groups associated with the network interface.</p>
-- @param _Description [AttributeValue] <p>The description of the network interface.</p>
function M.DescribeNetworkInterfaceAttributeResult(_SourceDestCheck, _NetworkInterfaceId, _Attachment, _Groups, _Description, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeNetworkInterfaceAttributeResult")
	local t = { 
		["SourceDestCheck"] = _SourceDestCheck,
		["NetworkInterfaceId"] = _NetworkInterfaceId,
		["Attachment"] = _Attachment,
		["Groups"] = _Groups,
		["Description"] = _Description,
	}
	asserts.AssertDescribeNetworkInterfaceAttributeResult(t)
	return t
end

keys.ModifyInstancePlacementRequest = { ["InstanceId"] = true, ["Tenancy"] = true, ["HostId"] = true, ["Affinity"] = true, nil }

function asserts.AssertModifyInstancePlacementRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstancePlacementRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Tenancy"] then asserts.AssertHostTenancy(struct["Tenancy"]) end
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["Affinity"] then asserts.AssertAffinity(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstancePlacementRequest[k], "ModifyInstancePlacementRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstancePlacementRequest
-- <p>Contains the parameters for ModifyInstancePlacement.</p>
-- @param _InstanceId [String] <p>The ID of the instance that you are modifying.</p>
-- @param _Tenancy [HostTenancy] <p>The tenancy of the instance that you are modifying.</p>
-- @param _HostId [String] <p>The ID of the Dedicated Host that the instance will have affinity with.</p>
-- @param _Affinity [Affinity] <p>The new affinity setting for the instance.</p>
-- Required parameter: InstanceId
function M.ModifyInstancePlacementRequest(_InstanceId, _Tenancy, _HostId, _Affinity, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ModifyInstancePlacementRequest")
	local t = { 
		["InstanceId"] = _InstanceId,
		["Tenancy"] = _Tenancy,
		["HostId"] = _HostId,
		["Affinity"] = _Affinity,
	}
	asserts.AssertModifyInstancePlacementRequest(t)
	return t
end

keys.SpotFleetRequestConfig = { ["SpotFleetRequestState"] = true, ["SpotFleetRequestId"] = true, ["ActivityStatus"] = true, ["CreateTime"] = true, ["SpotFleetRequestConfig"] = true, nil }

function asserts.AssertSpotFleetRequestConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetRequestConfig to be of type 'table'")
	assert(struct["CreateTime"], "Expected key CreateTime to exist in table")
	assert(struct["SpotFleetRequestConfig"], "Expected key SpotFleetRequestConfig to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["SpotFleetRequestState"], "Expected key SpotFleetRequestState to exist in table")
	if struct["SpotFleetRequestState"] then asserts.AssertBatchState(struct["SpotFleetRequestState"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["ActivityStatus"] then asserts.AssertActivityStatus(struct["ActivityStatus"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["SpotFleetRequestConfig"] then asserts.AssertSpotFleetRequestConfigData(struct["SpotFleetRequestConfig"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetRequestConfig[k], "SpotFleetRequestConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetRequestConfig
-- <p>Describes a Spot fleet request.</p>
-- @param _SpotFleetRequestState [BatchState] <p>The state of the Spot fleet request.</p>
-- @param _SpotFleetRequestId [String] <p>The ID of the Spot fleet request.</p>
-- @param _ActivityStatus [ActivityStatus] <p>The progress of the Spot fleet request. If there is an error, the status is <code>error</code>. After all bids are placed, the status is <code>pending_fulfillment</code>. If the size of the fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>. If the size of the fleet is decreased, the status is <code>pending_termination</code> while Spot instances are terminating.</p>
-- @param _CreateTime [DateTime] <p>The creation date and time of the request.</p>
-- @param _SpotFleetRequestConfig [SpotFleetRequestConfigData] <p>Information about the configuration of the Spot fleet request.</p>
-- Required parameter: CreateTime
-- Required parameter: SpotFleetRequestConfig
-- Required parameter: SpotFleetRequestId
-- Required parameter: SpotFleetRequestState
function M.SpotFleetRequestConfig(_SpotFleetRequestState, _SpotFleetRequestId, _ActivityStatus, _CreateTime, _SpotFleetRequestConfig, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating SpotFleetRequestConfig")
	local t = { 
		["SpotFleetRequestState"] = _SpotFleetRequestState,
		["SpotFleetRequestId"] = _SpotFleetRequestId,
		["ActivityStatus"] = _ActivityStatus,
		["CreateTime"] = _CreateTime,
		["SpotFleetRequestConfig"] = _SpotFleetRequestConfig,
	}
	asserts.AssertSpotFleetRequestConfig(t)
	return t
end

keys.ExportToS3TaskSpecification = { ["S3Bucket"] = true, ["DiskImageFormat"] = true, ["S3Prefix"] = true, ["ContainerFormat"] = true, nil }

function asserts.AssertExportToS3TaskSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportToS3TaskSpecification to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["DiskImageFormat"] then asserts.AssertDiskImageFormat(struct["DiskImageFormat"]) end
	if struct["S3Prefix"] then asserts.AssertString(struct["S3Prefix"]) end
	if struct["ContainerFormat"] then asserts.AssertContainerFormat(struct["ContainerFormat"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExportToS3TaskSpecification[k], "ExportToS3TaskSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportToS3TaskSpecification
-- <p>Describes an instance export task.</p>
-- @param _S3Bucket [String] <p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>
-- @param _DiskImageFormat [DiskImageFormat] <p>The format for the exported image.</p>
-- @param _S3Prefix [String] <p>The image is written to a single object in the S3 bucket at the S3 key s3prefix + exportTaskId + '.' + diskImageFormat.</p>
-- @param _ContainerFormat [ContainerFormat] <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>
function M.ExportToS3TaskSpecification(_S3Bucket, _DiskImageFormat, _S3Prefix, _ContainerFormat, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating ExportToS3TaskSpecification")
	local t = { 
		["S3Bucket"] = _S3Bucket,
		["DiskImageFormat"] = _DiskImageFormat,
		["S3Prefix"] = _S3Prefix,
		["ContainerFormat"] = _ContainerFormat,
	}
	asserts.AssertExportToS3TaskSpecification(t)
	return t
end

keys.DescribeHostReservationOfferingsResult = { ["NextToken"] = true, ["OfferingSet"] = true, nil }

function asserts.AssertDescribeHostReservationOfferingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationOfferingsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["OfferingSet"] then asserts.AssertHostOfferingSet(struct["OfferingSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationOfferingsResult[k], "DescribeHostReservationOfferingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationOfferingsResult
--  
-- @param _NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @param _OfferingSet [HostOfferingSet] <p>Information about the offerings.</p>
function M.DescribeHostReservationOfferingsResult(_NextToken, _OfferingSet, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeHostReservationOfferingsResult")
	local t = { 
		["NextToken"] = _NextToken,
		["OfferingSet"] = _OfferingSet,
	}
	asserts.AssertDescribeHostReservationOfferingsResult(t)
	return t
end

keys.DescribeVpcAttributeRequest = { ["Attribute"] = true, ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeVpcAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["Attribute"] then asserts.AssertVpcAttributeName(struct["Attribute"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcAttributeRequest[k], "DescribeVpcAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcAttributeRequest
-- <p>Contains the parameters for DescribeVpcAttribute.</p>
-- @param _Attribute [VpcAttributeName] <p>The VPC attribute.</p>
-- @param _VpcId [String] <p>The ID of the VPC.</p>
-- @param _DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required parameter: Attribute
-- Required parameter: VpcId
function M.DescribeVpcAttributeRequest(_Attribute, _VpcId, _DryRun, ...)
	assert(select("#", ...) == 0, "Too many arguments when creating DescribeVpcAttributeRequest")
	local t = { 
		["Attribute"] = _Attribute,
		["VpcId"] = _VpcId,
		["DryRun"] = _DryRun,
	}
	asserts.AssertDescribeVpcAttributeRequest(t)
	return t
end

function asserts.AssertEgressOnlyInternetGatewayId(str)
	assert(str)
	assert(type(str) == "string", "Expected EgressOnlyInternetGatewayId to be of type 'string'")
end

--  
function M.EgressOnlyInternetGatewayId(str)
	asserts.AssertEgressOnlyInternetGatewayId(str)
	return str
end

function asserts.AssertIpv6Address(str)
	assert(str)
	assert(type(str) == "string", "Expected Ipv6Address to be of type 'string'")
end

--  
function M.Ipv6Address(str)
	asserts.AssertIpv6Address(str)
	return str
end

function asserts.AssertVolumeModificationState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeModificationState to be of type 'string'")
end

--  
function M.VolumeModificationState(str)
	asserts.AssertVolumeModificationState(str)
	return str
end

function asserts.AssertVpnState(str)
	assert(str)
	assert(type(str) == "string", "Expected VpnState to be of type 'string'")
end

--  
function M.VpnState(str)
	asserts.AssertVpnState(str)
	return str
end

function asserts.AssertSubnetState(str)
	assert(str)
	assert(type(str) == "string", "Expected SubnetState to be of type 'string'")
end

--  
function M.SubnetState(str)
	asserts.AssertSubnetState(str)
	return str
end

function asserts.AssertOfferingTypeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected OfferingTypeValues to be of type 'string'")
end

--  
function M.OfferingTypeValues(str)
	asserts.AssertOfferingTypeValues(str)
	return str
end

function asserts.AssertState(str)
	assert(str)
	assert(type(str) == "string", "Expected State to be of type 'string'")
end

--  
function M.State(str)
	asserts.AssertState(str)
	return str
end

function asserts.AssertSpotInstanceState(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotInstanceState to be of type 'string'")
end

--  
function M.SpotInstanceState(str)
	asserts.AssertSpotInstanceState(str)
	return str
end

function asserts.AssertEventCode(str)
	assert(str)
	assert(type(str) == "string", "Expected EventCode to be of type 'string'")
end

--  
function M.EventCode(str)
	asserts.AssertEventCode(str)
	return str
end

function asserts.AssertMonitoringState(str)
	assert(str)
	assert(type(str) == "string", "Expected MonitoringState to be of type 'string'")
end

--  
function M.MonitoringState(str)
	asserts.AssertMonitoringState(str)
	return str
end

function asserts.AssertVpcState(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcState to be of type 'string'")
end

--  
function M.VpcState(str)
	asserts.AssertVpcState(str)
	return str
end

function asserts.AssertSubnetCidrBlockStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected SubnetCidrBlockStateCode to be of type 'string'")
end

--  
function M.SubnetCidrBlockStateCode(str)
	asserts.AssertSubnetCidrBlockStateCode(str)
	return str
end

function asserts.AssertRouteState(str)
	assert(str)
	assert(type(str) == "string", "Expected RouteState to be of type 'string'")
end

--  
function M.RouteState(str)
	asserts.AssertRouteState(str)
	return str
end

function asserts.AssertVpcCidrBlockStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcCidrBlockStateCode to be of type 'string'")
end

--  
function M.VpcCidrBlockStateCode(str)
	asserts.AssertVpcCidrBlockStateCode(str)
	return str
end

function asserts.AssertPlacementGroupState(str)
	assert(str)
	assert(type(str) == "string", "Expected PlacementGroupState to be of type 'string'")
end

--  
function M.PlacementGroupState(str)
	asserts.AssertPlacementGroupState(str)
	return str
end

function asserts.AssertPlatformValues(str)
	assert(str)
	assert(type(str) == "string", "Expected PlatformValues to be of type 'string'")
end

--  
function M.PlatformValues(str)
	asserts.AssertPlatformValues(str)
	return str
end

function asserts.AssertStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected Status to be of type 'string'")
end

--  
function M.Status(str)
	asserts.AssertStatus(str)
	return str
end

function asserts.AssertEventType(str)
	assert(str)
	assert(type(str) == "string", "Expected EventType to be of type 'string'")
end

--  
function M.EventType(str)
	asserts.AssertEventType(str)
	return str
end

function asserts.AssertNetworkInterfaceType(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceType to be of type 'string'")
end

--  
function M.NetworkInterfaceType(str)
	asserts.AssertNetworkInterfaceType(str)
	return str
end

function asserts.AssertVolumeState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeState to be of type 'string'")
end

--  
function M.VolumeState(str)
	asserts.AssertVolumeState(str)
	return str
end

function asserts.Assertscope(str)
	assert(str)
	assert(type(str) == "string", "Expected scope to be of type 'string'")
end

--  
function M.scope(str)
	asserts.Assertscope(str)
	return str
end

function asserts.AssertReportStatusType(str)
	assert(str)
	assert(type(str) == "string", "Expected ReportStatusType to be of type 'string'")
end

--  
function M.ReportStatusType(str)
	asserts.AssertReportStatusType(str)
	return str
end

function asserts.AssertInstanceLifecycleType(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceLifecycleType to be of type 'string'")
end

--  
function M.InstanceLifecycleType(str)
	asserts.AssertInstanceLifecycleType(str)
	return str
end

function asserts.AssertSpotInstanceType(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotInstanceType to be of type 'string'")
end

--  
function M.SpotInstanceType(str)
	asserts.AssertSpotInstanceType(str)
	return str
end

function asserts.AssertReservedInstanceState(str)
	assert(str)
	assert(type(str) == "string", "Expected ReservedInstanceState to be of type 'string'")
end

--  
function M.ReservedInstanceState(str)
	asserts.AssertReservedInstanceState(str)
	return str
end

function asserts.AssertPlacementStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected PlacementStrategy to be of type 'string'")
end

--  
function M.PlacementStrategy(str)
	asserts.AssertPlacementStrategy(str)
	return str
end

function asserts.AssertNextToken(str)
	assert(str)
	assert(type(str) == "string", "Expected NextToken to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.NextToken(str)
	asserts.AssertNextToken(str)
	return str
end

function asserts.AssertVpcPeeringConnectionStateReasonCode(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcPeeringConnectionStateReasonCode to be of type 'string'")
end

--  
function M.VpcPeeringConnectionStateReasonCode(str)
	asserts.AssertVpcPeeringConnectionStateReasonCode(str)
	return str
end

function asserts.AssertSnapshotState(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotState to be of type 'string'")
end

--  
function M.SnapshotState(str)
	asserts.AssertSnapshotState(str)
	return str
end

function asserts.AssertFleetType(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetType to be of type 'string'")
end

--  
function M.FleetType(str)
	asserts.AssertFleetType(str)
	return str
end

function asserts.AssertString(str)
	assert(str)
	assert(type(str) == "string", "Expected String to be of type 'string'")
end

--  
function M.String(str)
	asserts.AssertString(str)
	return str
end

function asserts.AssertListingStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ListingStatus to be of type 'string'")
end

--  
function M.ListingStatus(str)
	asserts.AssertListingStatus(str)
	return str
end

function asserts.AssertSnapshotAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotAttributeName to be of type 'string'")
end

--  
function M.SnapshotAttributeName(str)
	asserts.AssertSnapshotAttributeName(str)
	return str
end

function asserts.AssertInstanceHealthStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceHealthStatus to be of type 'string'")
end

--  
function M.InstanceHealthStatus(str)
	asserts.AssertInstanceHealthStatus(str)
	return str
end

function asserts.AssertNetworkInterfaceAttribute(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceAttribute to be of type 'string'")
end

--  
function M.NetworkInterfaceAttribute(str)
	asserts.AssertNetworkInterfaceAttribute(str)
	return str
end

function asserts.AssertVirtualizationType(str)
	assert(str)
	assert(type(str) == "string", "Expected VirtualizationType to be of type 'string'")
end

--  
function M.VirtualizationType(str)
	asserts.AssertVirtualizationType(str)
	return str
end

function asserts.AssertVolumeAttachmentState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeAttachmentState to be of type 'string'")
end

--  
function M.VolumeAttachmentState(str)
	asserts.AssertVolumeAttachmentState(str)
	return str
end

function asserts.AssertInstanceType(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceType to be of type 'string'")
end

--  
function M.InstanceType(str)
	asserts.AssertInstanceType(str)
	return str
end

function asserts.AssertShutdownBehavior(str)
	assert(str)
	assert(type(str) == "string", "Expected ShutdownBehavior to be of type 'string'")
end

--  
function M.ShutdownBehavior(str)
	asserts.AssertShutdownBehavior(str)
	return str
end

function asserts.AssertInstanceAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceAttributeName to be of type 'string'")
end

--  
function M.InstanceAttributeName(str)
	asserts.AssertInstanceAttributeName(str)
	return str
end

function asserts.AssertActivityStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ActivityStatus to be of type 'string'")
end

--  
function M.ActivityStatus(str)
	asserts.AssertActivityStatus(str)
	return str
end

function asserts.AssertPaymentOption(str)
	assert(str)
	assert(type(str) == "string", "Expected PaymentOption to be of type 'string'")
end

--  
function M.PaymentOption(str)
	asserts.AssertPaymentOption(str)
	return str
end

function asserts.AssertVolumeType(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeType to be of type 'string'")
end

--  
function M.VolumeType(str)
	asserts.AssertVolumeType(str)
	return str
end

function asserts.AssertCancelBatchErrorCode(str)
	assert(str)
	assert(type(str) == "string", "Expected CancelBatchErrorCode to be of type 'string'")
end

--  
function M.CancelBatchErrorCode(str)
	asserts.AssertCancelBatchErrorCode(str)
	return str
end

function asserts.AssertImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageAttributeName to be of type 'string'")
end

--  
function M.ImageAttributeName(str)
	asserts.AssertImageAttributeName(str)
	return str
end

function asserts.AssertBundleTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected BundleTaskState to be of type 'string'")
end

--  
function M.BundleTaskState(str)
	asserts.AssertBundleTaskState(str)
	return str
end

function asserts.AssertAvailabilityZoneState(str)
	assert(str)
	assert(type(str) == "string", "Expected AvailabilityZoneState to be of type 'string'")
end

--  
function M.AvailabilityZoneState(str)
	asserts.AssertAvailabilityZoneState(str)
	return str
end

function asserts.AssertHostTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected HostTenancy to be of type 'string'")
end

--  
function M.HostTenancy(str)
	asserts.AssertHostTenancy(str)
	return str
end

function asserts.AssertDomainType(str)
	assert(str)
	assert(type(str) == "string", "Expected DomainType to be of type 'string'")
end

--  
function M.DomainType(str)
	asserts.AssertDomainType(str)
	return str
end

function asserts.AssertCancelSpotInstanceRequestState(str)
	assert(str)
	assert(type(str) == "string", "Expected CancelSpotInstanceRequestState to be of type 'string'")
end

--  
function M.CancelSpotInstanceRequestState(str)
	asserts.AssertCancelSpotInstanceRequestState(str)
	return str
end

function asserts.AssertArchitectureValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ArchitectureValues to be of type 'string'")
end

--  
function M.ArchitectureValues(str)
	asserts.AssertArchitectureValues(str)
	return str
end

function asserts.AssertAllocationState(str)
	assert(str)
	assert(type(str) == "string", "Expected AllocationState to be of type 'string'")
end

--  
function M.AllocationState(str)
	asserts.AssertAllocationState(str)
	return str
end

function asserts.AssertIamInstanceProfileAssociationState(str)
	assert(str)
	assert(type(str) == "string", "Expected IamInstanceProfileAssociationState to be of type 'string'")
end

--  
function M.IamInstanceProfileAssociationState(str)
	asserts.AssertIamInstanceProfileAssociationState(str)
	return str
end

function asserts.AssertResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceType to be of type 'string'")
end

--  
function M.ResourceType(str)
	asserts.AssertResourceType(str)
	return str
end

function asserts.AssertRouteOrigin(str)
	assert(str)
	assert(type(str) == "string", "Expected RouteOrigin to be of type 'string'")
end

--  
function M.RouteOrigin(str)
	asserts.AssertRouteOrigin(str)
	return str
end

function asserts.AssertOfferingClassType(str)
	assert(str)
	assert(type(str) == "string", "Expected OfferingClassType to be of type 'string'")
end

--  
function M.OfferingClassType(str)
	asserts.AssertOfferingClassType(str)
	return str
end

function asserts.AssertSummaryStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected SummaryStatus to be of type 'string'")
end

--  
function M.SummaryStatus(str)
	asserts.AssertSummaryStatus(str)
	return str
end

function asserts.AssertExcessCapacityTerminationPolicy(str)
	assert(str)
	assert(type(str) == "string", "Expected ExcessCapacityTerminationPolicy to be of type 'string'")
end

--  
function M.ExcessCapacityTerminationPolicy(str)
	asserts.AssertExcessCapacityTerminationPolicy(str)
	return str
end

function asserts.AssertAccountAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected AccountAttributeName to be of type 'string'")
end

--  
function M.AccountAttributeName(str)
	asserts.AssertAccountAttributeName(str)
	return str
end

function asserts.AssertMoveStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected MoveStatus to be of type 'string'")
end

--  
function M.MoveStatus(str)
	asserts.AssertMoveStatus(str)
	return str
end

function asserts.AssertVpcAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcAttributeName to be of type 'string'")
end

--  
function M.VpcAttributeName(str)
	asserts.AssertVpcAttributeName(str)
	return str
end

function asserts.AssertTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected Tenancy to be of type 'string'")
end

--  
function M.Tenancy(str)
	asserts.AssertTenancy(str)
	return str
end

function asserts.AssertVolumeStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeStatusName to be of type 'string'")
end

--  
function M.VolumeStatusName(str)
	asserts.AssertVolumeStatusName(str)
	return str
end

function asserts.AssertVolumeStatusInfoStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeStatusInfoStatus to be of type 'string'")
end

--  
function M.VolumeStatusInfoStatus(str)
	asserts.AssertVolumeStatusInfoStatus(str)
	return str
end

function asserts.AssertDeviceType(str)
	assert(str)
	assert(type(str) == "string", "Expected DeviceType to be of type 'string'")
end

--  
function M.DeviceType(str)
	asserts.AssertDeviceType(str)
	return str
end

function asserts.AssertOperationType(str)
	assert(str)
	assert(type(str) == "string", "Expected OperationType to be of type 'string'")
end

--  
function M.OperationType(str)
	asserts.AssertOperationType(str)
	return str
end

function asserts.AssertResetImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ResetImageAttributeName to be of type 'string'")
end

--  
function M.ResetImageAttributeName(str)
	asserts.AssertResetImageAttributeName(str)
	return str
end

function asserts.AssertInstanceStateName(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceStateName to be of type 'string'")
end

--  
function M.InstanceStateName(str)
	asserts.AssertInstanceStateName(str)
	return str
end

function asserts.AssertDiskImageFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected DiskImageFormat to be of type 'string'")
end

--  
function M.DiskImageFormat(str)
	asserts.AssertDiskImageFormat(str)
	return str
end

function asserts.AssertBatchState(str)
	assert(str)
	assert(type(str) == "string", "Expected BatchState to be of type 'string'")
end

--  
function M.BatchState(str)
	asserts.AssertBatchState(str)
	return str
end

function asserts.AssertProductCodeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ProductCodeValues to be of type 'string'")
end

--  
function M.ProductCodeValues(str)
	asserts.AssertProductCodeValues(str)
	return str
end

function asserts.AssertRuleAction(str)
	assert(str)
	assert(type(str) == "string", "Expected RuleAction to be of type 'string'")
end

--  
function M.RuleAction(str)
	asserts.AssertRuleAction(str)
	return str
end

function asserts.AssertHypervisorType(str)
	assert(str)
	assert(type(str) == "string", "Expected HypervisorType to be of type 'string'")
end

--  
function M.HypervisorType(str)
	asserts.AssertHypervisorType(str)
	return str
end

function asserts.AssertGatewayType(str)
	assert(str)
	assert(type(str) == "string", "Expected GatewayType to be of type 'string'")
end

--  
function M.GatewayType(str)
	asserts.AssertGatewayType(str)
	return str
end

function asserts.AssertCurrencyCodeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected CurrencyCodeValues to be of type 'string'")
end

--  
function M.CurrencyCodeValues(str)
	asserts.AssertCurrencyCodeValues(str)
	return str
end

function asserts.AssertStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusName to be of type 'string'")
end

--  
function M.StatusName(str)
	asserts.AssertStatusName(str)
	return str
end

function asserts.AssertReservationState(str)
	assert(str)
	assert(type(str) == "string", "Expected ReservationState to be of type 'string'")
end

--  
function M.ReservationState(str)
	asserts.AssertReservationState(str)
	return str
end

function asserts.AssertStatusType(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusType to be of type 'string'")
end

--  
function M.StatusType(str)
	asserts.AssertStatusType(str)
	return str
end

function asserts.AssertVpnStaticRouteSource(str)
	assert(str)
	assert(type(str) == "string", "Expected VpnStaticRouteSource to be of type 'string'")
end

--  
function M.VpnStaticRouteSource(str)
	asserts.AssertVpnStaticRouteSource(str)
	return str
end

function asserts.AssertAllocationStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected AllocationStrategy to be of type 'string'")
end

--  
function M.AllocationStrategy(str)
	asserts.AssertAllocationStrategy(str)
	return str
end

function asserts.AssertExportEnvironment(str)
	assert(str)
	assert(type(str) == "string", "Expected ExportEnvironment to be of type 'string'")
end

--  
function M.ExportEnvironment(str)
	asserts.AssertExportEnvironment(str)
	return str
end

function asserts.AssertTelemetryStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected TelemetryStatus to be of type 'string'")
end

--  
function M.TelemetryStatus(str)
	asserts.AssertTelemetryStatus(str)
	return str
end

function asserts.AssertAttachmentStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected AttachmentStatus to be of type 'string'")
end

--  
function M.AttachmentStatus(str)
	asserts.AssertAttachmentStatus(str)
	return str
end

function asserts.AssertRecurringChargeFrequency(str)
	assert(str)
	assert(type(str) == "string", "Expected RecurringChargeFrequency to be of type 'string'")
end

--  
function M.RecurringChargeFrequency(str)
	asserts.AssertRecurringChargeFrequency(str)
	return str
end

function asserts.AssertDatafeedSubscriptionState(str)
	assert(str)
	assert(type(str) == "string", "Expected DatafeedSubscriptionState to be of type 'string'")
end

--  
function M.DatafeedSubscriptionState(str)
	asserts.AssertDatafeedSubscriptionState(str)
	return str
end

function asserts.AssertVolumeAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeAttributeName to be of type 'string'")
end

--  
function M.VolumeAttributeName(str)
	asserts.AssertVolumeAttributeName(str)
	return str
end

function asserts.AssertTrafficType(str)
	assert(str)
	assert(type(str) == "string", "Expected TrafficType to be of type 'string'")
end

--  
function M.TrafficType(str)
	asserts.AssertTrafficType(str)
	return str
end

function asserts.AssertContainerFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected ContainerFormat to be of type 'string'")
end

--  
function M.ContainerFormat(str)
	asserts.AssertContainerFormat(str)
	return str
end

function asserts.AssertListingState(str)
	assert(str)
	assert(type(str) == "string", "Expected ListingState to be of type 'string'")
end

--  
function M.ListingState(str)
	asserts.AssertListingState(str)
	return str
end

function asserts.AssertImageState(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageState to be of type 'string'")
end

--  
function M.ImageState(str)
	asserts.AssertImageState(str)
	return str
end

function asserts.AssertImageTypeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageTypeValues to be of type 'string'")
end

--  
function M.ImageTypeValues(str)
	asserts.AssertImageTypeValues(str)
	return str
end

function asserts.AssertNatGatewayState(str)
	assert(str)
	assert(type(str) == "string", "Expected NatGatewayState to be of type 'string'")
end

--  
function M.NatGatewayState(str)
	asserts.AssertNatGatewayState(str)
	return str
end

function asserts.AssertRIProductDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected RIProductDescription to be of type 'string'")
end

--  
function M.RIProductDescription(str)
	asserts.AssertRIProductDescription(str)
	return str
end

function asserts.AssertNetworkInterfaceStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceStatus to be of type 'string'")
end

--  
function M.NetworkInterfaceStatus(str)
	asserts.AssertNetworkInterfaceStatus(str)
	return str
end

function asserts.AssertAffinity(str)
	assert(str)
	assert(type(str) == "string", "Expected Affinity to be of type 'string'")
end

--  
function M.Affinity(str)
	asserts.AssertAffinity(str)
	return str
end

function asserts.AssertFlowLogsResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected FlowLogsResourceType to be of type 'string'")
end

--  
function M.FlowLogsResourceType(str)
	asserts.AssertFlowLogsResourceType(str)
	return str
end

function asserts.AssertPermissionGroup(str)
	assert(str)
	assert(type(str) == "string", "Expected PermissionGroup to be of type 'string'")
end

--  
function M.PermissionGroup(str)
	asserts.AssertPermissionGroup(str)
	return str
end

function asserts.AssertExportTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected ExportTaskState to be of type 'string'")
end

--  
function M.ExportTaskState(str)
	asserts.AssertExportTaskState(str)
	return str
end

function asserts.AssertFpgaImageStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected FpgaImageStateCode to be of type 'string'")
end

--  
function M.FpgaImageStateCode(str)
	asserts.AssertFpgaImageStateCode(str)
	return str
end

function asserts.AssertReportInstanceReasonCodes(str)
	assert(str)
	assert(type(str) == "string", "Expected ReportInstanceReasonCodes to be of type 'string'")
end

--  
function M.ReportInstanceReasonCodes(str)
	asserts.AssertReportInstanceReasonCodes(str)
	return str
end

function asserts.AssertConversionTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected ConversionTaskState to be of type 'string'")
end

--  
function M.ConversionTaskState(str)
	asserts.AssertConversionTaskState(str)
	return str
end

function asserts.AssertAutoPlacement(str)
	assert(str)
	assert(type(str) == "string", "Expected AutoPlacement to be of type 'string'")
end

--  
function M.AutoPlacement(str)
	asserts.AssertAutoPlacement(str)
	return str
end

function asserts.AssertFloat(float)
	assert(float)
	assert(type(float) == "number", "Expected Float to be of type 'number'")
end

function M.Float(float)
	asserts.AssertFloat(float)
	return float
end

function asserts.AssertDouble(double)
	assert(double)
	assert(type(double) == "number", "Expected Double to be of type 'number'")
end

function M.Double(double)
	asserts.AssertDouble(double)
	return double
end

function asserts.AssertLong(long)
	assert(long)
	assert(type(long) == "number", "Expected Long to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.Long(long)
	asserts.AssertLong(long)
	return long
end

function asserts.AssertInteger(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected Integer to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.Integer(integer)
	asserts.AssertInteger(integer)
	return integer
end

function asserts.AssertMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 255, "Expected integer to be max 255")
	assert(integer >= 5, "Expected integer to be min 5")
end

function M.MaxResults(integer)
	asserts.AssertMaxResults(integer)
	return integer
end

function asserts.AssertBoolean(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Boolean to be of type 'boolean'")
end

function M.Boolean(boolean)
	asserts.AssertBoolean(boolean)
	return boolean
end

function asserts.AssertDateTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected DateTime to be of type 'string'")
end

function M.DateTime(timestamp)
	asserts.AssertDateTime(timestamp)
	return timestamp
end

function asserts.AssertBlob(blob)
	assert(blob)
	assert(type(string) == "string", "Expected Blob to be of type 'string'")
end

function M.Blob(blob)
	asserts.AssertBlob(blob)
	return blob
end

function asserts.AssertOccurrenceDaySet(list)
	assert(list)
	assert(type(list) == "table", "Expected OccurrenceDaySet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInteger(v)
	end
end

--  
-- List of Integer objects
function M.OccurrenceDaySet(list)
	asserts.AssertOccurrenceDaySet(list)
	return list
end

function asserts.AssertInstanceStatusEventList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusEventList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStatusEvent(v)
	end
end

--  
-- List of InstanceStatusEvent objects
function M.InstanceStatusEventList(list)
	asserts.AssertInstanceStatusEventList(list)
	return list
end

function asserts.AssertInstanceStatusDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStatusDetails(v)
	end
end

--  
-- List of InstanceStatusDetails objects
function M.InstanceStatusDetailsList(list)
	asserts.AssertInstanceStatusDetailsList(list)
	return list
end

function asserts.AssertAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAddress(v)
	end
end

--  
-- List of Address objects
function M.AddressList(list)
	asserts.AssertAddressList(list)
	return list
end

function asserts.AssertResponseHostIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ResponseHostIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResponseHostIdSet(list)
	asserts.AssertResponseHostIdSet(list)
	return list
end

function asserts.AssertReservedInstancesModificationResultList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationResultList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesModificationResult(v)
	end
end

--  
-- List of ReservedInstancesModificationResult objects
function M.ReservedInstancesModificationResultList(list)
	asserts.AssertReservedInstancesModificationResultList(list)
	return list
end

function asserts.AssertPriceScheduleList(list)
	assert(list)
	assert(type(list) == "table", "Expected PriceScheduleList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPriceSchedule(v)
	end
end

--  
-- List of PriceSchedule objects
function M.PriceScheduleList(list)
	asserts.AssertPriceScheduleList(list)
	return list
end

function asserts.AssertStaleSecurityGroupSet(list)
	assert(list)
	assert(type(list) == "table", "Expected StaleSecurityGroupSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertStaleSecurityGroup(v)
	end
end

--  
-- List of StaleSecurityGroup objects
function M.StaleSecurityGroupSet(list)
	asserts.AssertStaleSecurityGroupSet(list)
	return list
end

function asserts.AssertCustomerGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected CustomerGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCustomerGateway(v)
	end
end

--  
-- List of CustomerGateway objects
function M.CustomerGatewayList(list)
	asserts.AssertCustomerGatewayList(list)
	return list
end

function asserts.AssertUserIdGroupPairSet(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdGroupPairSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUserIdGroupPair(v)
	end
end

--  
-- List of UserIdGroupPair objects
function M.UserIdGroupPairSet(list)
	asserts.AssertUserIdGroupPairSet(list)
	return list
end

function asserts.AssertUnsuccessfulItemSet(list)
	assert(list)
	assert(type(list) == "table", "Expected UnsuccessfulItemSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUnsuccessfulItem(v)
	end
end

--  
-- List of UnsuccessfulItem objects
function M.UnsuccessfulItemSet(list)
	asserts.AssertUnsuccessfulItemSet(list)
	return list
end

function asserts.AssertRouteList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRoute(v)
	end
end

--  
-- List of Route objects
function M.RouteList(list)
	asserts.AssertRouteList(list)
	return list
end

function asserts.AssertGroupIds(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIds to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupIds(list)
	asserts.AssertGroupIds(list)
	return list
end

function asserts.AssertSubnetIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SubnetIdStringList(list)
	asserts.AssertSubnetIdStringList(list)
	return list
end

function asserts.AssertTagSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTagSpecification(v)
	end
end

--  
-- List of TagSpecification objects
function M.TagSpecificationList(list)
	asserts.AssertTagSpecificationList(list)
	return list
end

function asserts.AssertSubnetList(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSubnet(v)
	end
end

--  
-- List of Subnet objects
function M.SubnetList(list)
	asserts.AssertSubnetList(list)
	return list
end

function asserts.AssertNetworkInterfaceList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterface(v)
	end
end

--  
-- List of NetworkInterface objects
function M.NetworkInterfaceList(list)
	asserts.AssertNetworkInterfaceList(list)
	return list
end

function asserts.AssertIpv6RangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6RangeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpv6Range(v)
	end
end

--  
-- List of Ipv6Range objects
function M.Ipv6RangeList(list)
	asserts.AssertIpv6RangeList(list)
	return list
end

function asserts.AssertPurchaseSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchaseSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPurchase(v)
	end
end

--  
-- List of Purchase objects
function M.PurchaseSet(list)
	asserts.AssertPurchaseSet(list)
	return list
end

function asserts.AssertImportInstanceVolumeDetailSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportInstanceVolumeDetailSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImportInstanceVolumeDetailItem(v)
	end
end

--  
-- List of ImportInstanceVolumeDetailItem objects
function M.ImportInstanceVolumeDetailSet(list)
	asserts.AssertImportInstanceVolumeDetailSet(list)
	return list
end

function asserts.AssertPlacementGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected PlacementGroupList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPlacementGroup(v)
	end
end

--  
-- List of PlacementGroup objects
function M.PlacementGroupList(list)
	asserts.AssertPlacementGroupList(list)
	return list
end

function asserts.AssertVpcAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcAttachment(v)
	end
end

--  
-- List of VpcAttachment objects
function M.VpcAttachmentList(list)
	asserts.AssertVpcAttachmentList(list)
	return list
end

function asserts.AssertDiskImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected DiskImageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDiskImage(v)
	end
end

--  
-- List of DiskImage objects
function M.DiskImageList(list)
	asserts.AssertDiskImageList(list)
	return list
end

function asserts.AssertReservedInstancesModificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesModification(v)
	end
end

--  
-- List of ReservedInstancesModification objects
function M.ReservedInstancesModificationList(list)
	asserts.AssertReservedInstancesModificationList(list)
	return list
end

function asserts.AssertSecurityGroupIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SecurityGroupIdStringList(list)
	asserts.AssertSecurityGroupIdStringList(list)
	return list
end

function asserts.AssertRestorableByStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected RestorableByStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RestorableByStringList(list)
	asserts.AssertRestorableByStringList(list)
	return list
end

function asserts.AssertNatGatewayAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected NatGatewayAddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNatGatewayAddress(v)
	end
end

--  
-- List of NatGatewayAddress objects
function M.NatGatewayAddressList(list)
	asserts.AssertNatGatewayAddressList(list)
	return list
end

function asserts.AssertCancelSpotFleetRequestsErrorSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelSpotFleetRequestsErrorSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCancelSpotFleetRequestsErrorItem(v)
	end
end

--  
-- List of CancelSpotFleetRequestsErrorItem objects
function M.CancelSpotFleetRequestsErrorSet(list)
	asserts.AssertCancelSpotFleetRequestsErrorSet(list)
	return list
end

function asserts.AssertInstanceIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIpv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceIpv6Address(v)
	end
end

--  
-- List of InstanceIpv6Address objects
function M.InstanceIpv6AddressList(list)
	asserts.AssertInstanceIpv6AddressList(list)
	return list
end

function asserts.AssertPropagatingVgwList(list)
	assert(list)
	assert(type(list) == "table", "Expected PropagatingVgwList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPropagatingVgw(v)
	end
end

--  
-- List of PropagatingVgw objects
function M.PropagatingVgwList(list)
	asserts.AssertPropagatingVgwList(list)
	return list
end

function asserts.AssertValueStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ValueStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ValueStringList(list)
	asserts.AssertValueStringList(list)
	return list
end

function asserts.AssertBlockDeviceMappingRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected BlockDeviceMappingRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertBlockDeviceMapping(v)
	end
end

--  
-- List of BlockDeviceMapping objects
function M.BlockDeviceMappingRequestList(list)
	asserts.AssertBlockDeviceMappingRequestList(list)
	return list
end

function asserts.AssertNewDhcpConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected NewDhcpConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNewDhcpConfiguration(v)
	end
end

--  
-- List of NewDhcpConfiguration objects
function M.NewDhcpConfigurationList(list)
	asserts.AssertNewDhcpConfigurationList(list)
	return list
end

function asserts.AssertVolumeStatusActionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusActionsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusAction(v)
	end
end

--  
-- List of VolumeStatusAction objects
function M.VolumeStatusActionsList(list)
	asserts.AssertVolumeStatusActionsList(list)
	return list
end

function asserts.AssertInternetGatewayAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected InternetGatewayAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInternetGatewayAttachment(v)
	end
end

--  
-- List of InternetGatewayAttachment objects
function M.InternetGatewayAttachmentList(list)
	asserts.AssertInternetGatewayAttachmentList(list)
	return list
end

function asserts.AssertInstancePrivateIpAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstancePrivateIpAddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstancePrivateIpAddress(v)
	end
end

--  
-- List of InstancePrivateIpAddress objects
function M.InstancePrivateIpAddressList(list)
	asserts.AssertInstancePrivateIpAddressList(list)
	return list
end

function asserts.AssertFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected FilterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFilter(v)
	end
end

--  
-- List of Filter objects
function M.FilterList(list)
	asserts.AssertFilterList(list)
	return list
end

function asserts.AssertInstanceMonitoringList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceMonitoringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceMonitoring(v)
	end
end

--  
-- List of InstanceMonitoring objects
function M.InstanceMonitoringList(list)
	asserts.AssertInstanceMonitoringList(list)
	return list
end

function asserts.AssertUnsuccessfulItemList(list)
	assert(list)
	assert(type(list) == "table", "Expected UnsuccessfulItemList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUnsuccessfulItem(v)
	end
end

--  
-- List of UnsuccessfulItem objects
function M.UnsuccessfulItemList(list)
	asserts.AssertUnsuccessfulItemList(list)
	return list
end

function asserts.AssertImportSnapshotTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportSnapshotTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImportSnapshotTask(v)
	end
end

--  
-- List of ImportSnapshotTask objects
function M.ImportSnapshotTaskList(list)
	asserts.AssertImportSnapshotTaskList(list)
	return list
end

function asserts.AssertPurchaseRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchaseRequestSet to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertPurchaseRequest(v)
	end
end

--  
-- List of PurchaseRequest objects
function M.PurchaseRequestSet(list)
	asserts.AssertPurchaseRequestSet(list)
	return list
end

function asserts.AssertScheduledInstancesBlockDeviceMappingSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesBlockDeviceMappingSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesBlockDeviceMapping(v)
	end
end

--  
-- List of ScheduledInstancesBlockDeviceMapping objects
function M.ScheduledInstancesBlockDeviceMappingSet(list)
	asserts.AssertScheduledInstancesBlockDeviceMappingSet(list)
	return list
end

function asserts.AssertVpnGatewayIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnGatewayIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpnGatewayIdStringList(list)
	asserts.AssertVpnGatewayIdStringList(list)
	return list
end

function asserts.AssertSubnetIpv6CidrBlockAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetIpv6CidrBlockAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSubnetIpv6CidrBlockAssociation(v)
	end
end

--  
-- List of SubnetIpv6CidrBlockAssociation objects
function M.SubnetIpv6CidrBlockAssociationSet(list)
	asserts.AssertSubnetIpv6CidrBlockAssociationSet(list)
	return list
end

function asserts.AssertOwnerStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected OwnerStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.OwnerStringList(list)
	asserts.AssertOwnerStringList(list)
	return list
end

function asserts.AssertEgressOnlyInternetGatewayIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected EgressOnlyInternetGatewayIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertEgressOnlyInternetGatewayId(v)
	end
end

--  
-- List of EgressOnlyInternetGatewayId objects
function M.EgressOnlyInternetGatewayIdList(list)
	asserts.AssertEgressOnlyInternetGatewayIdList(list)
	return list
end

function asserts.AssertScheduledInstanceIdRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceIdRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ScheduledInstanceIdRequestSet(list)
	asserts.AssertScheduledInstanceIdRequestSet(list)
	return list
end

function asserts.AssertInstanceCountList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceCountList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceCount(v)
	end
end

--  
-- List of InstanceCount objects
function M.InstanceCountList(list)
	asserts.AssertInstanceCountList(list)
	return list
end

function asserts.AssertImportTaskIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportTaskIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ImportTaskIdList(list)
	asserts.AssertImportTaskIdList(list)
	return list
end

function asserts.AssertZoneNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ZoneNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ZoneNameStringList(list)
	asserts.AssertZoneNameStringList(list)
	return list
end

function asserts.AssertGroupIdentifierList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIdentifierList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertGroupIdentifier(v)
	end
end

--  
-- List of GroupIdentifier objects
function M.GroupIdentifierList(list)
	asserts.AssertGroupIdentifierList(list)
	return list
end

function asserts.AssertBillingProductList(list)
	assert(list)
	assert(type(list) == "table", "Expected BillingProductList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.BillingProductList(list)
	asserts.AssertBillingProductList(list)
	return list
end

function asserts.AssertSecurityGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SecurityGroupStringList(list)
	asserts.AssertSecurityGroupStringList(list)
	return list
end

function asserts.AssertLaunchSpecsList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchSpecsList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertSpotFleetLaunchSpecification(v)
	end
end

--  
-- List of SpotFleetLaunchSpecification objects
function M.LaunchSpecsList(list)
	asserts.AssertLaunchSpecsList(list)
	return list
end

function asserts.AssertSpotInstanceRequestIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotInstanceRequestIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SpotInstanceRequestIdList(list)
	asserts.AssertSpotInstanceRequestIdList(list)
	return list
end

function asserts.AssertVpcEndpointSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcEndpointSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcEndpoint(v)
	end
end

--  
-- List of VpcEndpoint objects
function M.VpcEndpointSet(list)
	asserts.AssertVpcEndpointSet(list)
	return list
end

function asserts.AssertCancelledSpotInstanceRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelledSpotInstanceRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCancelledSpotInstanceRequest(v)
	end
end

--  
-- List of CancelledSpotInstanceRequest objects
function M.CancelledSpotInstanceRequestList(list)
	asserts.AssertCancelledSpotInstanceRequestList(list)
	return list
end

function asserts.AssertDhcpOptionsIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpOptionsIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.DhcpOptionsIdStringList(list)
	asserts.AssertDhcpOptionsIdStringList(list)
	return list
end

function asserts.AssertTagDescriptionList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagDescriptionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTagDescription(v)
	end
end

--  
-- List of TagDescription objects
function M.TagDescriptionList(list)
	asserts.AssertTagDescriptionList(list)
	return list
end

function asserts.AssertIpRangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected IpRangeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpRange(v)
	end
end

--  
-- List of IpRange objects
function M.IpRangeList(list)
	asserts.AssertIpRangeList(list)
	return list
end

function asserts.AssertImageDiskContainerList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageDiskContainerList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImageDiskContainer(v)
	end
end

--  
-- List of ImageDiskContainer objects
function M.ImageDiskContainerList(list)
	asserts.AssertImageDiskContainerList(list)
	return list
end

function asserts.AssertNetworkInterfacePrivateIpAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfacePrivateIpAddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterfacePrivateIpAddress(v)
	end
end

--  
-- List of NetworkInterfacePrivateIpAddress objects
function M.NetworkInterfacePrivateIpAddressList(list)
	asserts.AssertNetworkInterfacePrivateIpAddressList(list)
	return list
end

function asserts.AssertHostReservationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostReservationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHostReservation(v)
	end
end

--  
-- List of HostReservation objects
function M.HostReservationSet(list)
	asserts.AssertHostReservationSet(list)
	return list
end

function asserts.AssertNetworkAclEntryList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclEntryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkAclEntry(v)
	end
end

--  
-- List of NetworkAclEntry objects
function M.NetworkAclEntryList(list)
	asserts.AssertNetworkAclEntryList(list)
	return list
end

function asserts.AssertRequestHostIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected RequestHostIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RequestHostIdSet(list)
	asserts.AssertRequestHostIdSet(list)
	return list
end

function asserts.AssertReservedInstancesOfferingList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesOfferingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesOffering(v)
	end
end

--  
-- List of ReservedInstancesOffering objects
function M.ReservedInstancesOfferingList(list)
	asserts.AssertReservedInstancesOfferingList(list)
	return list
end

function asserts.AssertIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.Ipv6AddressList(list)
	asserts.AssertIpv6AddressList(list)
	return list
end

function asserts.AssertInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstance(v)
	end
end

--  
-- List of Instance objects
function M.InstanceList(list)
	asserts.AssertInstanceList(list)
	return list
end

function asserts.AssertVpcClassicLinkIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcClassicLinkIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpcClassicLinkIdList(list)
	asserts.AssertVpcClassicLinkIdList(list)
	return list
end

function asserts.AssertVolumeIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VolumeIdStringList(list)
	asserts.AssertVolumeIdStringList(list)
	return list
end

function asserts.AssertInstanceBlockDeviceMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceBlockDeviceMappingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceBlockDeviceMapping(v)
	end
end

--  
-- List of InstanceBlockDeviceMapping objects
function M.InstanceBlockDeviceMappingList(list)
	asserts.AssertInstanceBlockDeviceMappingList(list)
	return list
end

function asserts.AssertVpnConnectionIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnConnectionIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpnConnectionIdStringList(list)
	asserts.AssertVpnConnectionIdStringList(list)
	return list
end

function asserts.AssertUserGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.UserGroupStringList(list)
	asserts.AssertUserGroupStringList(list)
	return list
end

function asserts.AssertExportTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExportTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertExportTask(v)
	end
end

--  
-- List of ExportTask objects
function M.ExportTaskList(list)
	asserts.AssertExportTaskList(list)
	return list
end

function asserts.AssertVolumeList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolume(v)
	end
end

--  
-- List of Volume objects
function M.VolumeList(list)
	asserts.AssertVolumeList(list)
	return list
end

function asserts.AssertRegionList(list)
	assert(list)
	assert(type(list) == "table", "Expected RegionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRegion(v)
	end
end

--  
-- List of Region objects
function M.RegionList(list)
	asserts.AssertRegionList(list)
	return list
end

function asserts.AssertVolumeModificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeModificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeModification(v)
	end
end

--  
-- List of VolumeModification objects
function M.VolumeModificationList(list)
	asserts.AssertVolumeModificationList(list)
	return list
end

function asserts.AssertResponseHostIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResponseHostIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResponseHostIdList(list)
	asserts.AssertResponseHostIdList(list)
	return list
end

function asserts.AssertVpcPeeringConnectionList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcPeeringConnectionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcPeeringConnection(v)
	end
end

--  
-- List of VpcPeeringConnection objects
function M.VpcPeeringConnectionList(list)
	asserts.AssertVpcPeeringConnectionList(list)
	return list
end

function asserts.AssertProductCodeStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductCodeStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ProductCodeStringList(list)
	asserts.AssertProductCodeStringList(list)
	return list
end

function asserts.AssertFpgaImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected FpgaImageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFpgaImage(v)
	end
end

--  
-- List of FpgaImage objects
function M.FpgaImageList(list)
	asserts.AssertFpgaImageList(list)
	return list
end

function asserts.AssertBundleTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected BundleTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertBundleTask(v)
	end
end

--  
-- List of BundleTask objects
function M.BundleTaskList(list)
	asserts.AssertBundleTaskList(list)
	return list
end

function asserts.AssertAvailabilityZoneMessageList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailabilityZoneMessageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAvailabilityZoneMessage(v)
	end
end

--  
-- List of AvailabilityZoneMessage objects
function M.AvailabilityZoneMessageList(list)
	asserts.AssertAvailabilityZoneMessageList(list)
	return list
end

function asserts.AssertPricingDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected PricingDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPricingDetail(v)
	end
end

--  
-- List of PricingDetail objects
function M.PricingDetailsList(list)
	asserts.AssertPricingDetailsList(list)
	return list
end

function asserts.AssertHistoryRecords(list)
	assert(list)
	assert(type(list) == "table", "Expected HistoryRecords to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHistoryRecord(v)
	end
end

--  
-- List of HistoryRecord objects
function M.HistoryRecords(list)
	asserts.AssertHistoryRecords(list)
	return list
end

function asserts.AssertInstanceStateChangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStateChangeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStateChange(v)
	end
end

--  
-- List of InstanceStateChange objects
function M.InstanceStateChangeList(list)
	asserts.AssertInstanceStateChangeList(list)
	return list
end

function asserts.AssertReservationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservation(v)
	end
end

--  
-- List of Reservation objects
function M.ReservationList(list)
	asserts.AssertReservationList(list)
	return list
end

function asserts.AssertHostList(list)
	assert(list)
	assert(type(list) == "table", "Expected HostList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHost(v)
	end
end

--  
-- List of Host objects
function M.HostList(list)
	asserts.AssertHostList(list)
	return list
end

function asserts.AssertPrivateIpAddressStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PrivateIpAddressStringList(list)
	asserts.AssertPrivateIpAddressStringList(list)
	return list
end

function asserts.AssertNetworkInterfaceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.NetworkInterfaceIdList(list)
	asserts.AssertNetworkInterfaceIdList(list)
	return list
end

function asserts.AssertPurchasedScheduledInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchasedScheduledInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstance(v)
	end
end

--  
-- List of ScheduledInstance objects
function M.PurchasedScheduledInstanceSet(list)
	asserts.AssertPurchasedScheduledInstanceSet(list)
	return list
end

function asserts.AssertKeyNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected KeyNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.KeyNameStringList(list)
	asserts.AssertKeyNameStringList(list)
	return list
end

function asserts.AssertBundleIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected BundleIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.BundleIdStringList(list)
	asserts.AssertBundleIdStringList(list)
	return list
end

function asserts.AssertInstanceIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.InstanceIdStringList(list)
	asserts.AssertInstanceIdStringList(list)
	return list
end

function asserts.AssertRouteTableList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteTableList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRouteTable(v)
	end
end

--  
-- List of RouteTable objects
function M.RouteTableList(list)
	asserts.AssertRouteTableList(list)
	return list
end

function asserts.AssertIdFormatList(list)
	assert(list)
	assert(type(list) == "table", "Expected IdFormatList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIdFormat(v)
	end
end

--  
-- List of IdFormat objects
function M.IdFormatList(list)
	asserts.AssertIdFormatList(list)
	return list
end

function asserts.AssertRequestHostIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected RequestHostIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RequestHostIdList(list)
	asserts.AssertRequestHostIdList(list)
	return list
end

function asserts.AssertKeyPairList(list)
	assert(list)
	assert(type(list) == "table", "Expected KeyPairList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertKeyPairInfo(v)
	end
end

--  
-- List of KeyPairInfo objects
function M.KeyPairList(list)
	asserts.AssertKeyPairList(list)
	return list
end

function asserts.AssertScheduledInstancesSecurityGroupIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesSecurityGroupIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ScheduledInstancesSecurityGroupIdSet(list)
	asserts.AssertScheduledInstancesSecurityGroupIdSet(list)
	return list
end

function asserts.AssertSnapshotIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SnapshotIdStringList(list)
	asserts.AssertSnapshotIdStringList(list)
	return list
end

function asserts.AssertProductCodeList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductCodeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertProductCode(v)
	end
end

--  
-- List of ProductCode objects
function M.ProductCodeList(list)
	asserts.AssertProductCodeList(list)
	return list
end

function asserts.AssertCancelSpotFleetRequestsSuccessSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelSpotFleetRequestsSuccessSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCancelSpotFleetRequestsSuccessItem(v)
	end
end

--  
-- List of CancelSpotFleetRequestsSuccessItem objects
function M.CancelSpotFleetRequestsSuccessSet(list)
	asserts.AssertCancelSpotFleetRequestsSuccessSet(list)
	return list
end

function asserts.AssertAvailabilityZoneList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailabilityZoneList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAvailabilityZone(v)
	end
end

--  
-- List of AvailabilityZone objects
function M.AvailabilityZoneList(list)
	asserts.AssertAvailabilityZoneList(list)
	return list
end

function asserts.AssertFlowLogSet(list)
	assert(list)
	assert(type(list) == "table", "Expected FlowLogSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFlowLog(v)
	end
end

--  
-- List of FlowLog objects
function M.FlowLogSet(list)
	asserts.AssertFlowLogSet(list)
	return list
end

function asserts.AssertDhcpConfigurationValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpConfigurationValueList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAttributeValue(v)
	end
end

--  
-- List of AttributeValue objects
function M.DhcpConfigurationValueList(list)
	asserts.AssertDhcpConfigurationValueList(list)
	return list
end

function asserts.AssertImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImage(v)
	end
end

--  
-- List of Image objects
function M.ImageList(list)
	asserts.AssertImageList(list)
	return list
end

function asserts.AssertRecurringChargesList(list)
	assert(list)
	assert(type(list) == "table", "Expected RecurringChargesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRecurringCharge(v)
	end
end

--  
-- List of RecurringCharge objects
function M.RecurringChargesList(list)
	asserts.AssertRecurringChargesList(list)
	return list
end

function asserts.AssertHostReservationIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostReservationIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.HostReservationIdSet(list)
	asserts.AssertHostReservationIdSet(list)
	return list
end

function asserts.AssertClassicLinkInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected ClassicLinkInstanceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertClassicLinkInstance(v)
	end
end

--  
-- List of ClassicLinkInstance objects
function M.ClassicLinkInstanceList(list)
	asserts.AssertClassicLinkInstanceList(list)
	return list
end

function asserts.AssertVpcClassicLinkList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcClassicLinkList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcClassicLink(v)
	end
end

--  
-- List of VpcClassicLink objects
function M.VpcClassicLinkList(list)
	asserts.AssertVpcClassicLinkList(list)
	return list
end

function asserts.AssertSpotFleetRequestConfigSet(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotFleetRequestConfigSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotFleetRequestConfig(v)
	end
end

--  
-- List of SpotFleetRequestConfig objects
function M.SpotFleetRequestConfigSet(list)
	asserts.AssertSpotFleetRequestConfigSet(list)
	return list
end

function asserts.AssertTargetReservationValueSet(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetReservationValueSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTargetReservationValue(v)
	end
end

--  
-- List of TargetReservationValue objects
function M.TargetReservationValueSet(list)
	asserts.AssertTargetReservationValueSet(list)
	return list
end

function asserts.AssertPrivateIpAddressConfigSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressConfigSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesPrivateIpAddressConfig(v)
	end
end

--  
-- List of ScheduledInstancesPrivateIpAddressConfig objects
function M.PrivateIpAddressConfigSet(list)
	asserts.AssertPrivateIpAddressConfigSet(list)
	return list
end

function asserts.AssertInstanceTypeList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceTypeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceType(v)
	end
end

--  
-- List of InstanceType objects
function M.InstanceTypeList(list)
	asserts.AssertInstanceTypeList(list)
	return list
end

function asserts.AssertVpnConnectionList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnConnectionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnConnection(v)
	end
end

--  
-- List of VpnConnection objects
function M.VpnConnectionList(list)
	asserts.AssertVpnConnectionList(list)
	return list
end

function asserts.AssertDhcpConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDhcpConfiguration(v)
	end
end

--  
-- List of DhcpConfiguration objects
function M.DhcpConfigurationList(list)
	asserts.AssertDhcpConfigurationList(list)
	return list
end

function asserts.AssertNetworkAclAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkAclAssociation(v)
	end
end

--  
-- List of NetworkAclAssociation objects
function M.NetworkAclAssociationList(list)
	asserts.AssertNetworkAclAssociationList(list)
	return list
end

function asserts.AssertScheduledInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstance(v)
	end
end

--  
-- List of ScheduledInstance objects
function M.ScheduledInstanceSet(list)
	asserts.AssertScheduledInstanceSet(list)
	return list
end

function asserts.AssertExportTaskIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExportTaskIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ExportTaskIdStringList(list)
	asserts.AssertExportTaskIdStringList(list)
	return list
end

function asserts.AssertInstanceIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.InstanceIdSet(list)
	asserts.AssertInstanceIdSet(list)
	return list
end

function asserts.AssertAccountAttributeList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAccountAttribute(v)
	end
end

--  
-- List of AccountAttribute objects
function M.AccountAttributeList(list)
	asserts.AssertAccountAttributeList(list)
	return list
end

function asserts.AssertDescribeConversionTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected DescribeConversionTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertConversionTask(v)
	end
end

--  
-- List of ConversionTask objects
function M.DescribeConversionTaskList(list)
	asserts.AssertDescribeConversionTaskList(list)
	return list
end

function asserts.AssertReasonCodesList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReasonCodesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReportInstanceReasonCodes(v)
	end
end

--  
-- List of ReportInstanceReasonCodes objects
function M.ReasonCodesList(list)
	asserts.AssertReasonCodesList(list)
	return list
end

function asserts.AssertAccountAttributeValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeValueList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAccountAttributeValue(v)
	end
end

--  
-- List of AccountAttributeValue objects
function M.AccountAttributeValueList(list)
	asserts.AssertAccountAttributeValueList(list)
	return list
end

function asserts.AssertReservedInstanceIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstanceIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstanceIdSet(list)
	asserts.AssertReservedInstanceIdSet(list)
	return list
end

function asserts.AssertInstanceNetworkInterfaceList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceNetworkInterfaceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceNetworkInterface(v)
	end
end

--  
-- List of InstanceNetworkInterface objects
function M.InstanceNetworkInterfaceList(list)
	asserts.AssertInstanceNetworkInterfaceList(list)
	return list
end

function asserts.AssertAssociationIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.AssociationIdList(list)
	asserts.AssertAssociationIdList(list)
	return list
end

function asserts.AssertDhcpOptionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpOptionsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDhcpOptions(v)
	end
end

--  
-- List of DhcpOptions objects
function M.DhcpOptionsList(list)
	asserts.AssertDhcpOptionsList(list)
	return list
end

function asserts.AssertAllocationIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AllocationIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.AllocationIdList(list)
	asserts.AssertAllocationIdList(list)
	return list
end

function asserts.AssertEgressOnlyInternetGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected EgressOnlyInternetGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertEgressOnlyInternetGateway(v)
	end
end

--  
-- List of EgressOnlyInternetGateway objects
function M.EgressOnlyInternetGatewayList(list)
	asserts.AssertEgressOnlyInternetGatewayList(list)
	return list
end

function asserts.AssertExecutableByStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExecutableByStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ExecutableByStringList(list)
	asserts.AssertExecutableByStringList(list)
	return list
end

function asserts.AssertRouteTableAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteTableAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRouteTableAssociation(v)
	end
end

--  
-- List of RouteTableAssociation objects
function M.RouteTableAssociationList(list)
	asserts.AssertRouteTableAssociationList(list)
	return list
end

function asserts.AssertImportImageTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportImageTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImportImageTask(v)
	end
end

--  
-- List of ImportImageTask objects
function M.ImportImageTaskList(list)
	asserts.AssertImportImageTaskList(list)
	return list
end

function asserts.AssertInternetGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected InternetGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInternetGateway(v)
	end
end

--  
-- List of InternetGateway objects
function M.InternetGatewayList(list)
	asserts.AssertInternetGatewayList(list)
	return list
end

function asserts.AssertPublicIpStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PublicIpStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PublicIpStringList(list)
	asserts.AssertPublicIpStringList(list)
	return list
end

function asserts.AssertScheduledInstancesNetworkInterfaceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesNetworkInterfaceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesNetworkInterface(v)
	end
end

--  
-- List of ScheduledInstancesNetworkInterface objects
function M.ScheduledInstancesNetworkInterfaceSet(list)
	asserts.AssertScheduledInstancesNetworkInterfaceSet(list)
	return list
end

function asserts.AssertReservedInstancesConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesConfiguration(v)
	end
end

--  
-- List of ReservedInstancesConfiguration objects
function M.ReservedInstancesConfigurationList(list)
	asserts.AssertReservedInstancesConfigurationList(list)
	return list
end

function asserts.AssertSnapshotDetailList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotDetailList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSnapshotDetail(v)
	end
end

--  
-- List of SnapshotDetail objects
function M.SnapshotDetailList(list)
	asserts.AssertSnapshotDetailList(list)
	return list
end

function asserts.AssertNatGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected NatGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNatGateway(v)
	end
end

--  
-- List of NatGateway objects
function M.NatGatewayList(list)
	asserts.AssertNatGatewayList(list)
	return list
end

function asserts.AssertConversionIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ConversionIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ConversionIdStringList(list)
	asserts.AssertConversionIdStringList(list)
	return list
end

function asserts.AssertVpnStaticRouteList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnStaticRouteList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnStaticRoute(v)
	end
end

--  
-- List of VpnStaticRoute objects
function M.VpnStaticRouteList(list)
	asserts.AssertVpnStaticRouteList(list)
	return list
end

function asserts.AssertFpgaImageIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected FpgaImageIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.FpgaImageIdList(list)
	asserts.AssertFpgaImageIdList(list)
	return list
end

function asserts.AssertInstanceNetworkInterfaceSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceNetworkInterfaceSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceNetworkInterfaceSpecification(v)
	end
end

--  
-- List of InstanceNetworkInterfaceSpecification objects
function M.InstanceNetworkInterfaceSpecificationList(list)
	asserts.AssertInstanceNetworkInterfaceSpecificationList(list)
	return list
end

function asserts.AssertReservedInstancesIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesIdStringList(list)
	asserts.AssertReservedInstancesIdStringList(list)
	return list
end

function asserts.AssertInstanceBlockDeviceMappingSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceBlockDeviceMappingSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceBlockDeviceMappingSpecification(v)
	end
end

--  
-- List of InstanceBlockDeviceMappingSpecification objects
function M.InstanceBlockDeviceMappingSpecificationList(list)
	asserts.AssertInstanceBlockDeviceMappingSpecificationList(list)
	return list
end

function asserts.AssertReservedInstancesOfferingIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesOfferingIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesOfferingIdStringList(list)
	asserts.AssertReservedInstancesOfferingIdStringList(list)
	return list
end

function asserts.AssertTargetConfigurationRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetConfigurationRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTargetConfigurationRequest(v)
	end
end

--  
-- List of TargetConfigurationRequest objects
function M.TargetConfigurationRequestSet(list)
	asserts.AssertTargetConfigurationRequestSet(list)
	return list
end

function asserts.AssertUserIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.UserIdStringList(list)
	asserts.AssertUserIdStringList(list)
	return list
end

function asserts.AssertVolumeStatusDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusDetails(v)
	end
end

--  
-- List of VolumeStatusDetails objects
function M.VolumeStatusDetailsList(list)
	asserts.AssertVolumeStatusDetailsList(list)
	return list
end

function asserts.AssertLaunchPermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchPermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchPermission(v)
	end
end

--  
-- List of LaunchPermission objects
function M.LaunchPermissionList(list)
	asserts.AssertLaunchPermissionList(list)
	return list
end

function asserts.AssertRegionNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected RegionNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RegionNameStringList(list)
	asserts.AssertRegionNameStringList(list)
	return list
end

function asserts.AssertUserIdGroupPairList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdGroupPairList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUserIdGroupPair(v)
	end
end

--  
-- List of UserIdGroupPair objects
function M.UserIdGroupPairList(list)
	asserts.AssertUserIdGroupPairList(list)
	return list
end

function asserts.AssertVolumeStatusList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusItem(v)
	end
end

--  
-- List of VolumeStatusItem objects
function M.VolumeStatusList(list)
	asserts.AssertVolumeStatusList(list)
	return list
end

function asserts.AssertVpcIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpcIdStringList(list)
	asserts.AssertVpcIdStringList(list)
	return list
end

function asserts.AssertStaleIpPermissionSet(list)
	assert(list)
	assert(type(list) == "table", "Expected StaleIpPermissionSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertStaleIpPermission(v)
	end
end

--  
-- List of StaleIpPermission objects
function M.StaleIpPermissionSet(list)
	asserts.AssertStaleIpPermissionSet(list)
	return list
end

function asserts.AssertResourceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResourceIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResourceIdList(list)
	asserts.AssertResourceIdList(list)
	return list
end

function asserts.AssertSecurityGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityGroup(v)
	end
end

--  
-- List of SecurityGroup objects
function M.SecurityGroupList(list)
	asserts.AssertSecurityGroupList(list)
	return list
end

function asserts.AssertSnapshotList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSnapshot(v)
	end
end

--  
-- List of Snapshot objects
function M.SnapshotList(list)
	asserts.AssertSnapshotList(list)
	return list
end

function asserts.AssertPrefixListSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrefixList(v)
	end
end

--  
-- List of PrefixList objects
function M.PrefixListSet(list)
	asserts.AssertPrefixListSet(list)
	return list
end

function asserts.AssertIpv6CidrBlockSet(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6CidrBlockSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpv6CidrBlock(v)
	end
end

--  
-- List of Ipv6CidrBlock objects
function M.Ipv6CidrBlockSet(list)
	asserts.AssertIpv6CidrBlockSet(list)
	return list
end

function asserts.AssertPrefixListIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PrefixListIdSet(list)
	asserts.AssertPrefixListIdSet(list)
	return list
end

function asserts.AssertCustomerGatewayIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected CustomerGatewayIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.CustomerGatewayIdStringList(list)
	asserts.AssertCustomerGatewayIdStringList(list)
	return list
end

function asserts.AssertActiveInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ActiveInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertActiveInstance(v)
	end
end

--  
-- List of ActiveInstance objects
function M.ActiveInstanceSet(list)
	asserts.AssertActiveInstanceSet(list)
	return list
end

function asserts.AssertIamInstanceProfileAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected IamInstanceProfileAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIamInstanceProfileAssociation(v)
	end
end

--  
-- List of IamInstanceProfileAssociation objects
function M.IamInstanceProfileAssociationSet(list)
	asserts.AssertIamInstanceProfileAssociationSet(list)
	return list
end

function asserts.AssertIpRanges(list)
	assert(list)
	assert(type(list) == "table", "Expected IpRanges to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.IpRanges(list)
	asserts.AssertIpRanges(list)
	return list
end

function asserts.AssertGroupNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupNameStringList(list)
	asserts.AssertGroupNameStringList(list)
	return list
end

function asserts.AssertGroupIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupIdStringList(list)
	asserts.AssertGroupIdStringList(list)
	return list
end

function asserts.AssertProductDescriptionList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductDescriptionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ProductDescriptionList(list)
	asserts.AssertProductDescriptionList(list)
	return list
end

function asserts.AssertAvailableInstanceCapacityList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailableInstanceCapacityList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceCapacity(v)
	end
end

--  
-- List of InstanceCapacity objects
function M.AvailableInstanceCapacityList(list)
	asserts.AssertAvailableInstanceCapacityList(list)
	return list
end

function asserts.AssertReservedIntancesIds(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedIntancesIds to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesId(v)
	end
end

--  
-- List of ReservedInstancesId objects
function M.ReservedIntancesIds(list)
	asserts.AssertReservedIntancesIds(list)
	return list
end

function asserts.AssertScheduledInstanceAvailabilitySet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceAvailabilitySet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstanceAvailability(v)
	end
end

--  
-- List of ScheduledInstanceAvailability objects
function M.ScheduledInstanceAvailabilitySet(list)
	asserts.AssertScheduledInstanceAvailabilitySet(list)
	return list
end

function asserts.AssertScheduledInstancesIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesIpv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesIpv6Address(v)
	end
end

--  
-- List of ScheduledInstancesIpv6Address objects
function M.ScheduledInstancesIpv6AddressList(list)
	asserts.AssertScheduledInstancesIpv6AddressList(list)
	return list
end

function asserts.AssertPlacementGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PlacementGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PlacementGroupStringList(list)
	asserts.AssertPlacementGroupStringList(list)
	return list
end

function asserts.AssertAccountAttributeNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAccountAttributeName(v)
	end
end

--  
-- List of AccountAttributeName objects
function M.AccountAttributeNameStringList(list)
	asserts.AssertAccountAttributeNameStringList(list)
	return list
end

function asserts.AssertNetworkInterfaceIpv6AddressesList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceIpv6AddressesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterfaceIpv6Address(v)
	end
end

--  
-- List of NetworkInterfaceIpv6Address objects
function M.NetworkInterfaceIpv6AddressesList(list)
	asserts.AssertNetworkInterfaceIpv6AddressesList(list)
	return list
end

function asserts.AssertPriceScheduleSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected PriceScheduleSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPriceScheduleSpecification(v)
	end
end

--  
-- List of PriceScheduleSpecification objects
function M.PriceScheduleSpecificationList(list)
	asserts.AssertPriceScheduleSpecificationList(list)
	return list
end

function asserts.AssertPrivateIpAddressSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrivateIpAddressSpecification(v)
	end
end

--  
-- List of PrivateIpAddressSpecification objects
function M.PrivateIpAddressSpecificationList(list)
	asserts.AssertPrivateIpAddressSpecificationList(list)
	return list
end

function asserts.AssertVpcList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpc(v)
	end
end

--  
-- List of Vpc objects
function M.VpcList(list)
	asserts.AssertVpcList(list)
	return list
end

function asserts.AssertImageIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ImageIdStringList(list)
	asserts.AssertImageIdStringList(list)
	return list
end

function asserts.AssertBlockDeviceMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected BlockDeviceMappingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertBlockDeviceMapping(v)
	end
end

--  
-- List of BlockDeviceMapping objects
function M.BlockDeviceMappingList(list)
	asserts.AssertBlockDeviceMappingList(list)
	return list
end

function asserts.AssertSpotInstanceRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotInstanceRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotInstanceRequest(v)
	end
end

--  
-- List of SpotInstanceRequest objects
function M.SpotInstanceRequestList(list)
	asserts.AssertSpotInstanceRequestList(list)
	return list
end

function asserts.AssertReservedInstancesModificationIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesModificationIdStringList(list)
	asserts.AssertReservedInstancesModificationIdStringList(list)
	return list
end

function asserts.AssertClassicLinkDnsSupportList(list)
	assert(list)
	assert(type(list) == "table", "Expected ClassicLinkDnsSupportList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertClassicLinkDnsSupport(v)
	end
end

--  
-- List of ClassicLinkDnsSupport objects
function M.ClassicLinkDnsSupportList(list)
	asserts.AssertClassicLinkDnsSupportList(list)
	return list
end

function asserts.AssertHostOfferingSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostOfferingSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHostOffering(v)
	end
end

--  
-- List of HostOffering objects
function M.HostOfferingSet(list)
	asserts.AssertHostOfferingSet(list)
	return list
end

function asserts.AssertMovingAddressStatusSet(list)
	assert(list)
	assert(type(list) == "table", "Expected MovingAddressStatusSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMovingAddressStatus(v)
	end
end

--  
-- List of MovingAddressStatus objects
function M.MovingAddressStatusSet(list)
	asserts.AssertMovingAddressStatusSet(list)
	return list
end

function asserts.AssertInstanceStatusList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStatus(v)
	end
end

--  
-- List of InstanceStatus objects
function M.InstanceStatusList(list)
	asserts.AssertInstanceStatusList(list)
	return list
end

function asserts.AssertSpotPriceHistoryList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotPriceHistoryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotPrice(v)
	end
end

--  
-- List of SpotPrice objects
function M.SpotPriceHistoryList(list)
	asserts.AssertSpotPriceHistoryList(list)
	return list
end

function asserts.AssertCreateVolumePermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected CreateVolumePermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCreateVolumePermission(v)
	end
end

--  
-- List of CreateVolumePermission objects
function M.CreateVolumePermissionList(list)
	asserts.AssertCreateVolumePermissionList(list)
	return list
end

function asserts.AssertNetworkAclList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkAcl(v)
	end
end

--  
-- List of NetworkAcl objects
function M.NetworkAclList(list)
	asserts.AssertNetworkAclList(list)
	return list
end

function asserts.AssertVpnGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnGateway(v)
	end
end

--  
-- List of VpnGateway objects
function M.VpnGatewayList(list)
	asserts.AssertVpnGatewayList(list)
	return list
end

function asserts.AssertReservedInstanceReservationValueSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstanceReservationValueSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstanceReservationValue(v)
	end
end

--  
-- List of ReservedInstanceReservationValue objects
function M.ReservedInstanceReservationValueSet(list)
	asserts.AssertReservedInstanceReservationValueSet(list)
	return list
end

function asserts.AssertVolumeAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeAttachment(v)
	end
end

--  
-- List of VolumeAttachment objects
function M.VolumeAttachmentList(list)
	asserts.AssertVolumeAttachmentList(list)
	return list
end

function asserts.AssertReservedInstancesListingList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesListingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesListing(v)
	end
end

--  
-- List of ReservedInstancesListing objects
function M.ReservedInstancesListingList(list)
	asserts.AssertReservedInstancesListingList(list)
	return list
end

function asserts.AssertPrefixListIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrefixListId(v)
	end
end

--  
-- List of PrefixListId objects
function M.PrefixListIdList(list)
	asserts.AssertPrefixListIdList(list)
	return list
end

function asserts.AssertOccurrenceDayRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected OccurrenceDayRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInteger(v)
	end
end

--  
-- List of Integer objects
function M.OccurrenceDayRequestSet(list)
	asserts.AssertOccurrenceDayRequestSet(list)
	return list
end

function asserts.AssertHostInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected HostInstanceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHostInstance(v)
	end
end

--  
-- List of HostInstance objects
function M.HostInstanceList(list)
	asserts.AssertHostInstanceList(list)
	return list
end

function asserts.AssertVolumeStatusEventsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusEventsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusEvent(v)
	end
end

--  
-- List of VolumeStatusEvent objects
function M.VolumeStatusEventsList(list)
	asserts.AssertVolumeStatusEventsList(list)
	return list
end

function asserts.AssertIpPermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected IpPermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpPermission(v)
	end
end

--  
-- List of IpPermission objects
function M.IpPermissionList(list)
	asserts.AssertIpPermissionList(list)
	return list
end

function asserts.AssertSecurityGroupReferences(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupReferences to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityGroupReference(v)
	end
end

--  
-- List of SecurityGroupReference objects
function M.SecurityGroupReferences(list)
	asserts.AssertSecurityGroupReferences(list)
	return list
end

function asserts.AssertVpcIpv6CidrBlockAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcIpv6CidrBlockAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcIpv6CidrBlockAssociation(v)
	end
end

--  
-- List of VpcIpv6CidrBlockAssociation objects
function M.VpcIpv6CidrBlockAssociationSet(list)
	asserts.AssertVpcIpv6CidrBlockAssociationSet(list)
	return list
end

function asserts.AssertReservedInstancesList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstances(v)
	end
end

--  
-- List of ReservedInstances objects
function M.ReservedInstancesList(list)
	asserts.AssertReservedInstancesList(list)
	return list
end

function asserts.AssertTagList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTag(v)
	end
end

--  
-- List of Tag objects
function M.TagList(list)
	asserts.AssertTagList(list)
	return list
end

function asserts.AssertVgwTelemetryList(list)
	assert(list)
	assert(type(list) == "table", "Expected VgwTelemetryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVgwTelemetry(v)
	end
end

--  
-- List of VgwTelemetry objects
function M.VgwTelemetryList(list)
	asserts.AssertVgwTelemetryList(list)
	return list
end


local headers = require "aws-sdk.core.headers"
local content_type = require "aws-sdk.core.content_type"
local scheme_mapper = require "aws-sdk.core.scheme_mapper"
local request_handlers = require "aws-sdk.core.request_handlers"

local uri = ""


local function endpoint_for_region(region, use_dualstack)
	if not use_dualstack then
		if region == "us-east-1" then
			return "ec2.amazonaws.com"
		end
	end
	local ss = { "ec2" }
	if use_dualstack then
		ss[#ss + 1] = "dualstack"
	end
	ss[#ss + 1] = region
	ss[#ss + 1] = "amazonaws.com"
	if region == "cn-north-1" then
		ss[#ss + 1] = "cn"
	end
	return table.concat(ss, ".")
end


function M.init(config)
	assert(config, "You must provide a config table")
	uri = scheme_mapper.from_string(config.scheme) .. "://"
	uri = uri .. config.endpoint_override or endpoint_for_region(config.region, config.use_dualstack)
end


--
-- OPERATIONS
--
--- Call DeleteTags asynchronously, invoking a callback when done
-- @param DeleteTagsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteTagsAsync(DeleteTagsRequest, cb)
	assert(DeleteTagsRequest, "You must provide a DeleteTagsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteTags",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteTagsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteTags synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteTagsRequest
-- @return response
-- @return error_message
function M.DeleteTagsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteTagsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetSnapshotAttribute asynchronously, invoking a callback when done
-- @param ResetSnapshotAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetSnapshotAttributeAsync(ResetSnapshotAttributeRequest, cb)
	assert(ResetSnapshotAttributeRequest, "You must provide a ResetSnapshotAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ResetSnapshotAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ResetSnapshotAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ResetSnapshotAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetSnapshotAttributeRequest
-- @return response
-- @return error_message
function M.ResetSnapshotAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetSnapshotAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeCustomerGateways asynchronously, invoking a callback when done
-- @param DescribeCustomerGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeCustomerGatewaysAsync(DescribeCustomerGatewaysRequest, cb)
	assert(DescribeCustomerGatewaysRequest, "You must provide a DescribeCustomerGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeCustomerGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeCustomerGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeCustomerGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeCustomerGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeCustomerGatewaysSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeCustomerGatewaysAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVpcClassicLinkDnsSupport asynchronously, invoking a callback when done
-- @param EnableVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVpcClassicLinkDnsSupportAsync(EnableVpcClassicLinkDnsSupportRequest, cb)
	assert(EnableVpcClassicLinkDnsSupportRequest, "You must provide a EnableVpcClassicLinkDnsSupportRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".EnableVpcClassicLinkDnsSupport",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", EnableVpcClassicLinkDnsSupportRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVpcClassicLinkDnsSupport synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVpcClassicLinkDnsSupportRequest
-- @return response
-- @return error_message
function M.EnableVpcClassicLinkDnsSupportSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVpcClassicLinkDnsSupportAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkAcls asynchronously, invoking a callback when done
-- @param DescribeNetworkAclsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNetworkAclsAsync(DescribeNetworkAclsRequest, cb)
	assert(DescribeNetworkAclsRequest, "You must provide a DescribeNetworkAclsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeNetworkAcls",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeNetworkAclsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkAcls synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkAclsRequest
-- @return response
-- @return error_message
function M.DescribeNetworkAclsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkAclsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImageAttribute asynchronously, invoking a callback when done
-- @param DescribeImageAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImageAttributeAsync(DescribeImageAttributeRequest, cb)
	assert(DescribeImageAttributeRequest, "You must provide a DescribeImageAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeImageAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeImageAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImageAttributeRequest
-- @return response
-- @return error_message
function M.DescribeImageAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImageAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelConversionTask asynchronously, invoking a callback when done
-- @param CancelConversionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelConversionTaskAsync(CancelConversionRequest, cb)
	assert(CancelConversionRequest, "You must provide a CancelConversionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelConversionTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelConversionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CancelConversionTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelConversionRequest
-- @return response
-- @return error_message
function M.CancelConversionTaskSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelConversionTaskAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelImportTask asynchronously, invoking a callback when done
-- @param CancelImportTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelImportTaskAsync(CancelImportTaskRequest, cb)
	assert(CancelImportTaskRequest, "You must provide a CancelImportTaskRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelImportTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelImportTaskRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CancelImportTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelImportTaskRequest
-- @return response
-- @return error_message
function M.CancelImportTaskSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelImportTaskAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpnConnectionRoute asynchronously, invoking a callback when done
-- @param CreateVpnConnectionRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpnConnectionRouteAsync(CreateVpnConnectionRouteRequest, cb)
	assert(CreateVpnConnectionRouteRequest, "You must provide a CreateVpnConnectionRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpnConnectionRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpnConnectionRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpnConnectionRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpnConnectionRouteRequest
-- @return response
-- @return error_message
function M.CreateVpnConnectionRouteSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpnConnectionRouteAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeRouteTables asynchronously, invoking a callback when done
-- @param DescribeRouteTablesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeRouteTablesAsync(DescribeRouteTablesRequest, cb)
	assert(DescribeRouteTablesRequest, "You must provide a DescribeRouteTablesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeRouteTables",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeRouteTablesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeRouteTables synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeRouteTablesRequest
-- @return response
-- @return error_message
function M.DescribeRouteTablesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeRouteTablesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetImageAttribute asynchronously, invoking a callback when done
-- @param ResetImageAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetImageAttributeAsync(ResetImageAttributeRequest, cb)
	assert(ResetImageAttributeRequest, "You must provide a ResetImageAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ResetImageAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ResetImageAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ResetImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetImageAttributeRequest
-- @return response
-- @return error_message
function M.ResetImageAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetImageAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateRouteTable asynchronously, invoking a callback when done
-- @param CreateRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateRouteTableAsync(CreateRouteTableRequest, cb)
	assert(CreateRouteTableRequest, "You must provide a CreateRouteTableRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateRouteTableRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateRouteTableRequest
-- @return response
-- @return error_message
function M.CreateRouteTableSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateRouteTableAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceRouteTableAssociation asynchronously, invoking a callback when done
-- @param ReplaceRouteTableAssociationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceRouteTableAssociationAsync(ReplaceRouteTableAssociationRequest, cb)
	assert(ReplaceRouteTableAssociationRequest, "You must provide a ReplaceRouteTableAssociationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceRouteTableAssociation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceRouteTableAssociationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceRouteTableAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceRouteTableAssociationRequest
-- @return response
-- @return error_message
function M.ReplaceRouteTableAssociationSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceRouteTableAssociationAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpcEndpoint asynchronously, invoking a callback when done
-- @param CreateVpcEndpointRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpcEndpointAsync(CreateVpcEndpointRequest, cb)
	assert(CreateVpcEndpointRequest, "You must provide a CreateVpcEndpointRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpcEndpoint",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpcEndpointRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpcEndpoint synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcEndpointRequest
-- @return response
-- @return error_message
function M.CreateVpcEndpointSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcEndpointAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterImage asynchronously, invoking a callback when done
-- @param RegisterImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RegisterImageAsync(RegisterImageRequest, cb)
	assert(RegisterImageRequest, "You must provide a RegisterImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RegisterImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RegisterImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterImageRequest
-- @return response
-- @return error_message
function M.RegisterImageSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterImageAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateDhcpOptions asynchronously, invoking a callback when done
-- @param AssociateDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateDhcpOptionsAsync(AssociateDhcpOptionsRequest, cb)
	assert(AssociateDhcpOptionsRequest, "You must provide a AssociateDhcpOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateDhcpOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateDhcpOptionsRequest
-- @return response
-- @return error_message
function M.AssociateDhcpOptionsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateDhcpOptionsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportKeyPair asynchronously, invoking a callback when done
-- @param ImportKeyPairRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportKeyPairAsync(ImportKeyPairRequest, cb)
	assert(ImportKeyPairRequest, "You must provide a ImportKeyPairRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportKeyPair",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportKeyPairRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ImportKeyPair synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportKeyPairRequest
-- @return response
-- @return error_message
function M.ImportKeyPairSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportKeyPairAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAvailabilityZones asynchronously, invoking a callback when done
-- @param DescribeAvailabilityZonesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeAvailabilityZonesAsync(DescribeAvailabilityZonesRequest, cb)
	assert(DescribeAvailabilityZonesRequest, "You must provide a DescribeAvailabilityZonesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeAvailabilityZones",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeAvailabilityZonesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAvailabilityZones synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAvailabilityZonesRequest
-- @return response
-- @return error_message
function M.DescribeAvailabilityZonesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAvailabilityZonesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RequestSpotInstances asynchronously, invoking a callback when done
-- @param RequestSpotInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RequestSpotInstancesAsync(RequestSpotInstancesRequest, cb)
	assert(RequestSpotInstancesRequest, "You must provide a RequestSpotInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RequestSpotInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RequestSpotInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RequestSpotInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RequestSpotInstancesRequest
-- @return response
-- @return error_message
function M.RequestSpotInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RequestSpotInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpnGateways asynchronously, invoking a callback when done
-- @param DescribeVpnGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpnGatewaysAsync(DescribeVpnGatewaysRequest, cb)
	assert(DescribeVpnGatewaysRequest, "You must provide a DescribeVpnGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpnGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpnGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpnGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpnGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeVpnGatewaysSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpnGatewaysAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AcceptVpcPeeringConnection asynchronously, invoking a callback when done
-- @param AcceptVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AcceptVpcPeeringConnectionAsync(AcceptVpcPeeringConnectionRequest, cb)
	assert(AcceptVpcPeeringConnectionRequest, "You must provide a AcceptVpcPeeringConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AcceptVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AcceptVpcPeeringConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AcceptVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AcceptVpcPeeringConnectionRequest
-- @return response
-- @return error_message
function M.AcceptVpcPeeringConnectionSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AcceptVpcPeeringConnectionAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstancesModifications asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesModificationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesModificationsAsync(DescribeReservedInstancesModificationsRequest, cb)
	assert(DescribeReservedInstancesModificationsRequest, "You must provide a DescribeReservedInstancesModificationsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesModifications",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeReservedInstancesModificationsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstancesModifications synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesModificationsRequest
-- @return response
-- @return error_message
function M.DescribeReservedInstancesModificationsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesModificationsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetPasswordData asynchronously, invoking a callback when done
-- @param GetPasswordDataRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetPasswordDataAsync(GetPasswordDataRequest, cb)
	assert(GetPasswordDataRequest, "You must provide a GetPasswordDataRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetPasswordData",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetPasswordDataRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call GetPasswordData synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetPasswordDataRequest
-- @return response
-- @return error_message
function M.GetPasswordDataSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetPasswordDataAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImportSnapshotTasks asynchronously, invoking a callback when done
-- @param DescribeImportSnapshotTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImportSnapshotTasksAsync(DescribeImportSnapshotTasksRequest, cb)
	assert(DescribeImportSnapshotTasksRequest, "You must provide a DescribeImportSnapshotTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeImportSnapshotTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeImportSnapshotTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImportSnapshotTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImportSnapshotTasksRequest
-- @return response
-- @return error_message
function M.DescribeImportSnapshotTasksSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImportSnapshotTasksAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call UnassignIpv6Addresses asynchronously, invoking a callback when done
-- @param UnassignIpv6AddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.UnassignIpv6AddressesAsync(UnassignIpv6AddressesRequest, cb)
	assert(UnassignIpv6AddressesRequest, "You must provide a UnassignIpv6AddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".UnassignIpv6Addresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", UnassignIpv6AddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call UnassignIpv6Addresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UnassignIpv6AddressesRequest
-- @return response
-- @return error_message
function M.UnassignIpv6AddressesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UnassignIpv6AddressesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpnConnection asynchronously, invoking a callback when done
-- @param DeleteVpnConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpnConnectionAsync(DeleteVpnConnectionRequest, cb)
	assert(DeleteVpnConnectionRequest, "You must provide a DeleteVpnConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpnConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpnConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpnConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpnConnectionRequest
-- @return response
-- @return error_message
function M.DeleteVpnConnectionSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpnConnectionAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachVpnGateway asynchronously, invoking a callback when done
-- @param AttachVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachVpnGatewayAsync(AttachVpnGatewayRequest, cb)
	assert(AttachVpnGatewayRequest, "You must provide a AttachVpnGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachVpnGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AttachVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachVpnGatewayRequest
-- @return response
-- @return error_message
function M.AttachVpnGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachVpnGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportImage asynchronously, invoking a callback when done
-- @param ImportImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportImageAsync(ImportImageRequest, cb)
	assert(ImportImageRequest, "You must provide a ImportImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ImportImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportImageRequest
-- @return response
-- @return error_message
function M.ImportImageSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportImageAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAddresses asynchronously, invoking a callback when done
-- @param DescribeAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeAddressesAsync(DescribeAddressesRequest, cb)
	assert(DescribeAddressesRequest, "You must provide a DescribeAddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeAddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAddressesRequest
-- @return response
-- @return error_message
function M.DescribeAddressesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAddressesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateIamInstanceProfile asynchronously, invoking a callback when done
-- @param DisassociateIamInstanceProfileRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateIamInstanceProfileAsync(DisassociateIamInstanceProfileRequest, cb)
	assert(DisassociateIamInstanceProfileRequest, "You must provide a DisassociateIamInstanceProfileRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateIamInstanceProfile",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateIamInstanceProfileRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateIamInstanceProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateIamInstanceProfileRequest
-- @return response
-- @return error_message
function M.DisassociateIamInstanceProfileSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateIamInstanceProfileAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateIamInstanceProfile asynchronously, invoking a callback when done
-- @param AssociateIamInstanceProfileRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateIamInstanceProfileAsync(AssociateIamInstanceProfileRequest, cb)
	assert(AssociateIamInstanceProfileRequest, "You must provide a AssociateIamInstanceProfileRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateIamInstanceProfile",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateIamInstanceProfileRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateIamInstanceProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateIamInstanceProfileRequest
-- @return response
-- @return error_message
function M.AssociateIamInstanceProfileSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateIamInstanceProfileAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call PurchaseHostReservation asynchronously, invoking a callback when done
-- @param PurchaseHostReservationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.PurchaseHostReservationAsync(PurchaseHostReservationRequest, cb)
	assert(PurchaseHostReservationRequest, "You must provide a PurchaseHostReservationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".PurchaseHostReservation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", PurchaseHostReservationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call PurchaseHostReservation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PurchaseHostReservationRequest
-- @return response
-- @return error_message
function M.PurchaseHostReservationSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PurchaseHostReservationAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call BundleInstance asynchronously, invoking a callback when done
-- @param BundleInstanceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.BundleInstanceAsync(BundleInstanceRequest, cb)
	assert(BundleInstanceRequest, "You must provide a BundleInstanceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".BundleInstance",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", BundleInstanceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call BundleInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param BundleInstanceRequest
-- @return response
-- @return error_message
function M.BundleInstanceSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.BundleInstanceAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstances asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesAsync(DescribeReservedInstancesRequest, cb)
	assert(DescribeReservedInstancesRequest, "You must provide a DescribeReservedInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeReservedInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesRequest
-- @return response
-- @return error_message
function M.DescribeReservedInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkAcl asynchronously, invoking a callback when done
-- @param CreateNetworkAclRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNetworkAclAsync(CreateNetworkAclRequest, cb)
	assert(CreateNetworkAclRequest, "You must provide a CreateNetworkAclRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateNetworkAcl",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateNetworkAclRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkAcl synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkAclRequest
-- @return response
-- @return error_message
function M.CreateNetworkAclSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkAclAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateImage asynchronously, invoking a callback when done
-- @param CreateImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateImageAsync(CreateImageRequest, cb)
	assert(CreateImageRequest, "You must provide a CreateImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateImageRequest
-- @return response
-- @return error_message
function M.CreateImageSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateImageAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyHosts asynchronously, invoking a callback when done
-- @param ModifyHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyHostsAsync(ModifyHostsRequest, cb)
	assert(ModifyHostsRequest, "You must provide a ModifyHostsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyHostsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyHostsRequest
-- @return response
-- @return error_message
function M.ModifyHostsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyHostsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RebootInstances asynchronously, invoking a callback when done
-- @param RebootInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RebootInstancesAsync(RebootInstancesRequest, cb)
	assert(RebootInstancesRequest, "You must provide a RebootInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RebootInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RebootInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RebootInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RebootInstancesRequest
-- @return response
-- @return error_message
function M.RebootInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RebootInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpoints asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcEndpointsAsync(DescribeVpcEndpointsRequest, cb)
	assert(DescribeVpcEndpointsRequest, "You must provide a DescribeVpcEndpointsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpoints",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcEndpointsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpoints synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointsRequest
-- @return response
-- @return error_message
function M.DescribeVpcEndpointsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyIdentityIdFormat asynchronously, invoking a callback when done
-- @param ModifyIdentityIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyIdentityIdFormatAsync(ModifyIdentityIdFormatRequest, cb)
	assert(ModifyIdentityIdFormatRequest, "You must provide a ModifyIdentityIdFormatRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyIdentityIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyIdentityIdFormatRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyIdentityIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyIdentityIdFormatRequest
-- @return response
-- @return error_message
function M.ModifyIdentityIdFormatSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyIdentityIdFormatAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotFleetRequestHistory asynchronously, invoking a callback when done
-- @param DescribeSpotFleetRequestHistoryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotFleetRequestHistoryAsync(DescribeSpotFleetRequestHistoryRequest, cb)
	assert(DescribeSpotFleetRequestHistoryRequest, "You must provide a DescribeSpotFleetRequestHistoryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetRequestHistory",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotFleetRequestHistoryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotFleetRequestHistory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotFleetRequestHistoryRequest
-- @return response
-- @return error_message
function M.DescribeSpotFleetRequestHistorySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotFleetRequestHistoryAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call PurchaseScheduledInstances asynchronously, invoking a callback when done
-- @param PurchaseScheduledInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.PurchaseScheduledInstancesAsync(PurchaseScheduledInstancesRequest, cb)
	assert(PurchaseScheduledInstancesRequest, "You must provide a PurchaseScheduledInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".PurchaseScheduledInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", PurchaseScheduledInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call PurchaseScheduledInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PurchaseScheduledInstancesRequest
-- @return response
-- @return error_message
function M.PurchaseScheduledInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PurchaseScheduledInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceIamInstanceProfileAssociation asynchronously, invoking a callback when done
-- @param ReplaceIamInstanceProfileAssociationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceIamInstanceProfileAssociationAsync(ReplaceIamInstanceProfileAssociationRequest, cb)
	assert(ReplaceIamInstanceProfileAssociationRequest, "You must provide a ReplaceIamInstanceProfileAssociationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceIamInstanceProfileAssociation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceIamInstanceProfileAssociationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceIamInstanceProfileAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceIamInstanceProfileAssociationRequest
-- @return response
-- @return error_message
function M.ReplaceIamInstanceProfileAssociationSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceIamInstanceProfileAssociationAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachVolume asynchronously, invoking a callback when done
-- @param DetachVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachVolumeAsync(DetachVolumeRequest, cb)
	assert(DetachVolumeRequest, "You must provide a DetachVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DetachVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachVolumeRequest
-- @return response
-- @return error_message
function M.DetachVolumeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachVolumeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIamInstanceProfileAssociations asynchronously, invoking a callback when done
-- @param DescribeIamInstanceProfileAssociationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeIamInstanceProfileAssociationsAsync(DescribeIamInstanceProfileAssociationsRequest, cb)
	assert(DescribeIamInstanceProfileAssociationsRequest, "You must provide a DescribeIamInstanceProfileAssociationsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeIamInstanceProfileAssociations",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeIamInstanceProfileAssociationsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIamInstanceProfileAssociations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIamInstanceProfileAssociationsRequest
-- @return response
-- @return error_message
function M.DescribeIamInstanceProfileAssociationsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIamInstanceProfileAssociationsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssignPrivateIpAddresses asynchronously, invoking a callback when done
-- @param AssignPrivateIpAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssignPrivateIpAddressesAsync(AssignPrivateIpAddressesRequest, cb)
	assert(AssignPrivateIpAddressesRequest, "You must provide a AssignPrivateIpAddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssignPrivateIpAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssignPrivateIpAddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AssignPrivateIpAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssignPrivateIpAddressesRequest
-- @return response
-- @return error_message
function M.AssignPrivateIpAddressesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssignPrivateIpAddressesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelExportTask asynchronously, invoking a callback when done
-- @param CancelExportTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelExportTaskAsync(CancelExportTaskRequest, cb)
	assert(CancelExportTaskRequest, "You must provide a CancelExportTaskRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelExportTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelExportTaskRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CancelExportTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelExportTaskRequest
-- @return response
-- @return error_message
function M.CancelExportTaskSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelExportTaskAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachVpnGateway asynchronously, invoking a callback when done
-- @param DetachVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachVpnGatewayAsync(DetachVpnGatewayRequest, cb)
	assert(DetachVpnGatewayRequest, "You must provide a DetachVpnGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachVpnGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DetachVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachVpnGatewayRequest
-- @return response
-- @return error_message
function M.DetachVpnGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachVpnGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcAttribute asynchronously, invoking a callback when done
-- @param DescribeVpcAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcAttributeAsync(DescribeVpcAttributeRequest, cb)
	assert(DescribeVpcAttributeRequest, "You must provide a DescribeVpcAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcAttributeRequest
-- @return response
-- @return error_message
function M.DescribeVpcAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelBundleTask asynchronously, invoking a callback when done
-- @param CancelBundleTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelBundleTaskAsync(CancelBundleTaskRequest, cb)
	assert(CancelBundleTaskRequest, "You must provide a CancelBundleTaskRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelBundleTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelBundleTaskRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CancelBundleTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelBundleTaskRequest
-- @return response
-- @return error_message
function M.CancelBundleTaskSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelBundleTaskAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNatGateways asynchronously, invoking a callback when done
-- @param DescribeNatGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNatGatewaysAsync(DescribeNatGatewaysRequest, cb)
	assert(DescribeNatGatewaysRequest, "You must provide a DescribeNatGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeNatGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeNatGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNatGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNatGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeNatGatewaysSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNatGatewaysAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateSubnetCidrBlock asynchronously, invoking a callback when done
-- @param DisassociateSubnetCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateSubnetCidrBlockAsync(DisassociateSubnetCidrBlockRequest, cb)
	assert(DisassociateSubnetCidrBlockRequest, "You must provide a DisassociateSubnetCidrBlockRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateSubnetCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateSubnetCidrBlockRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateSubnetCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateSubnetCidrBlockRequest
-- @return response
-- @return error_message
function M.DisassociateSubnetCidrBlockSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateSubnetCidrBlockAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpcPeeringConnection asynchronously, invoking a callback when done
-- @param CreateVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpcPeeringConnectionAsync(CreateVpcPeeringConnectionRequest, cb)
	assert(CreateVpcPeeringConnectionRequest, "You must provide a CreateVpcPeeringConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpcPeeringConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcPeeringConnectionRequest
-- @return response
-- @return error_message
function M.CreateVpcPeeringConnectionSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcPeeringConnectionAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyIdFormat asynchronously, invoking a callback when done
-- @param ModifyIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyIdFormatAsync(ModifyIdFormatRequest, cb)
	assert(ModifyIdFormatRequest, "You must provide a ModifyIdFormatRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyIdFormatRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyIdFormatRequest
-- @return response
-- @return error_message
function M.ModifyIdFormatSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyIdFormatAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotFleetRequests asynchronously, invoking a callback when done
-- @param DescribeSpotFleetRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotFleetRequestsAsync(DescribeSpotFleetRequestsRequest, cb)
	assert(DescribeSpotFleetRequestsRequest, "You must provide a DescribeSpotFleetRequestsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotFleetRequestsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotFleetRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotFleetRequestsRequest
-- @return response
-- @return error_message
function M.DescribeSpotFleetRequestsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotFleetRequestsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AllocateHosts asynchronously, invoking a callback when done
-- @param AllocateHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AllocateHostsAsync(AllocateHostsRequest, cb)
	assert(AllocateHostsRequest, "You must provide a AllocateHostsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AllocateHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AllocateHostsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AllocateHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AllocateHostsRequest
-- @return response
-- @return error_message
function M.AllocateHostsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AllocateHostsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkAcl asynchronously, invoking a callback when done
-- @param DeleteNetworkAclRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNetworkAclAsync(DeleteNetworkAclRequest, cb)
	assert(DeleteNetworkAclRequest, "You must provide a DeleteNetworkAclRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteNetworkAcl",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteNetworkAclRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkAcl synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkAclRequest
-- @return response
-- @return error_message
function M.DeleteNetworkAclSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkAclAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetHostReservationPurchasePreview asynchronously, invoking a callback when done
-- @param GetHostReservationPurchasePreviewRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetHostReservationPurchasePreviewAsync(GetHostReservationPurchasePreviewRequest, cb)
	assert(GetHostReservationPurchasePreviewRequest, "You must provide a GetHostReservationPurchasePreviewRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetHostReservationPurchasePreview",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetHostReservationPurchasePreviewRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call GetHostReservationPurchasePreview synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetHostReservationPurchasePreviewRequest
-- @return response
-- @return error_message
function M.GetHostReservationPurchasePreviewSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetHostReservationPurchasePreviewAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CopyImage asynchronously, invoking a callback when done
-- @param CopyImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CopyImageAsync(CopyImageRequest, cb)
	assert(CopyImageRequest, "You must provide a CopyImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CopyImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CopyImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CopyImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CopyImageRequest
-- @return response
-- @return error_message
function M.CopyImageSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CopyImageAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSnapshot asynchronously, invoking a callback when done
-- @param CreateSnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSnapshotAsync(CreateSnapshotRequest, cb)
	assert(CreateSnapshotRequest, "You must provide a CreateSnapshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateSnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateSnapshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSnapshotRequest
-- @return response
-- @return error_message
function M.CreateSnapshotSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSnapshotAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSubnet asynchronously, invoking a callback when done
-- @param CreateSubnetRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSubnetAsync(CreateSubnetRequest, cb)
	assert(CreateSubnetRequest, "You must provide a CreateSubnetRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateSubnet",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateSubnetRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSubnet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSubnetRequest
-- @return response
-- @return error_message
function M.CreateSubnetSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSubnetAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RequestSpotFleet asynchronously, invoking a callback when done
-- @param RequestSpotFleetRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RequestSpotFleetAsync(RequestSpotFleetRequest, cb)
	assert(RequestSpotFleetRequest, "You must provide a RequestSpotFleetRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RequestSpotFleet",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RequestSpotFleetRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RequestSpotFleet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RequestSpotFleetRequest
-- @return response
-- @return error_message
function M.RequestSpotFleetSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RequestSpotFleetAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyImageAttribute asynchronously, invoking a callback when done
-- @param ModifyImageAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyImageAttributeAsync(ModifyImageAttributeRequest, cb)
	assert(ModifyImageAttributeRequest, "You must provide a ModifyImageAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyImageAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyImageAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyImageAttributeRequest
-- @return response
-- @return error_message
function M.ModifyImageAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyImageAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateSubnetCidrBlock asynchronously, invoking a callback when done
-- @param AssociateSubnetCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateSubnetCidrBlockAsync(AssociateSubnetCidrBlockRequest, cb)
	assert(AssociateSubnetCidrBlockRequest, "You must provide a AssociateSubnetCidrBlockRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateSubnetCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateSubnetCidrBlockRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateSubnetCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateSubnetCidrBlockRequest
-- @return response
-- @return error_message
function M.AssociateSubnetCidrBlockSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateSubnetCidrBlockAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call StartInstances asynchronously, invoking a callback when done
-- @param StartInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.StartInstancesAsync(StartInstancesRequest, cb)
	assert(StartInstancesRequest, "You must provide a StartInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".StartInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", StartInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call StartInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StartInstancesRequest
-- @return response
-- @return error_message
function M.StartInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StartInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotInstanceRequests asynchronously, invoking a callback when done
-- @param DescribeSpotInstanceRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotInstanceRequestsAsync(DescribeSpotInstanceRequestsRequest, cb)
	assert(DescribeSpotInstanceRequestsRequest, "You must provide a DescribeSpotInstanceRequestsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotInstanceRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotInstanceRequestsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotInstanceRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotInstanceRequestsRequest
-- @return response
-- @return error_message
function M.DescribeSpotInstanceRequestsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotInstanceRequestsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableVgwRoutePropagation asynchronously, invoking a callback when done
-- @param DisableVgwRoutePropagationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisableVgwRoutePropagationAsync(DisableVgwRoutePropagationRequest, cb)
	assert(DisableVgwRoutePropagationRequest, "You must provide a DisableVgwRoutePropagationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisableVgwRoutePropagation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisableVgwRoutePropagationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DisableVgwRoutePropagation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableVgwRoutePropagationRequest
-- @return response
-- @return error_message
function M.DisableVgwRoutePropagationSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableVgwRoutePropagationAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcs asynchronously, invoking a callback when done
-- @param DescribeVpcsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcsAsync(DescribeVpcsRequest, cb)
	assert(DescribeVpcsRequest, "You must provide a DescribeVpcsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcsRequest
-- @return response
-- @return error_message
function M.DescribeVpcsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateAddress asynchronously, invoking a callback when done
-- @param DisassociateAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateAddressAsync(DisassociateAddressRequest, cb)
	assert(DisassociateAddressRequest, "You must provide a DisassociateAddressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateAddressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateAddressRequest
-- @return response
-- @return error_message
function M.DisassociateAddressSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateAddressAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifySnapshotAttribute asynchronously, invoking a callback when done
-- @param ModifySnapshotAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifySnapshotAttributeAsync(ModifySnapshotAttributeRequest, cb)
	assert(ModifySnapshotAttributeRequest, "You must provide a ModifySnapshotAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifySnapshotAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifySnapshotAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifySnapshotAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifySnapshotAttributeRequest
-- @return response
-- @return error_message
function M.ModifySnapshotAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifySnapshotAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call MoveAddressToVpc asynchronously, invoking a callback when done
-- @param MoveAddressToVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.MoveAddressToVpcAsync(MoveAddressToVpcRequest, cb)
	assert(MoveAddressToVpcRequest, "You must provide a MoveAddressToVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".MoveAddressToVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", MoveAddressToVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call MoveAddressToVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param MoveAddressToVpcRequest
-- @return response
-- @return error_message
function M.MoveAddressToVpcSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.MoveAddressToVpcAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpc asynchronously, invoking a callback when done
-- @param CreateVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpcAsync(CreateVpcRequest, cb)
	assert(CreateVpcRequest, "You must provide a CreateVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcRequest
-- @return response
-- @return error_message
function M.CreateVpcSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpointServices asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointServicesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcEndpointServicesAsync(DescribeVpcEndpointServicesRequest, cb)
	assert(DescribeVpcEndpointServicesRequest, "You must provide a DescribeVpcEndpointServicesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpointServices",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcEndpointServicesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpointServices synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointServicesRequest
-- @return response
-- @return error_message
function M.DescribeVpcEndpointServicesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointServicesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelSpotFleetRequests asynchronously, invoking a callback when done
-- @param CancelSpotFleetRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelSpotFleetRequestsAsync(CancelSpotFleetRequestsRequest, cb)
	assert(CancelSpotFleetRequestsRequest, "You must provide a CancelSpotFleetRequestsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelSpotFleetRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelSpotFleetRequestsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CancelSpotFleetRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelSpotFleetRequestsRequest
-- @return response
-- @return error_message
function M.CancelSpotFleetRequestsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelSpotFleetRequestsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call UnmonitorInstances asynchronously, invoking a callback when done
-- @param UnmonitorInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.UnmonitorInstancesAsync(UnmonitorInstancesRequest, cb)
	assert(UnmonitorInstancesRequest, "You must provide a UnmonitorInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".UnmonitorInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", UnmonitorInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call UnmonitorInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UnmonitorInstancesRequest
-- @return response
-- @return error_message
function M.UnmonitorInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UnmonitorInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSubnet asynchronously, invoking a callback when done
-- @param DeleteSubnetRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSubnetAsync(DeleteSubnetRequest, cb)
	assert(DeleteSubnetRequest, "You must provide a DeleteSubnetRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteSubnet",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteSubnetRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSubnet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSubnetRequest
-- @return response
-- @return error_message
function M.DeleteSubnetSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSubnetAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreatePlacementGroup asynchronously, invoking a callback when done
-- @param CreatePlacementGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreatePlacementGroupAsync(CreatePlacementGroupRequest, cb)
	assert(CreatePlacementGroupRequest, "You must provide a CreatePlacementGroupRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreatePlacementGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreatePlacementGroupRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreatePlacementGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreatePlacementGroupRequest
-- @return response
-- @return error_message
function M.CreatePlacementGroupSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreatePlacementGroupAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CopySnapshot asynchronously, invoking a callback when done
-- @param CopySnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CopySnapshotAsync(CopySnapshotRequest, cb)
	assert(CopySnapshotRequest, "You must provide a CopySnapshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CopySnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CopySnapshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CopySnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CopySnapshotRequest
-- @return response
-- @return error_message
function M.CopySnapshotSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CopySnapshotAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableVpcClassicLinkDnsSupport asynchronously, invoking a callback when done
-- @param DisableVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisableVpcClassicLinkDnsSupportAsync(DisableVpcClassicLinkDnsSupportRequest, cb)
	assert(DisableVpcClassicLinkDnsSupportRequest, "You must provide a DisableVpcClassicLinkDnsSupportRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisableVpcClassicLinkDnsSupport",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisableVpcClassicLinkDnsSupportRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DisableVpcClassicLinkDnsSupport synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableVpcClassicLinkDnsSupportRequest
-- @return response
-- @return error_message
function M.DisableVpcClassicLinkDnsSupportSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableVpcClassicLinkDnsSupportAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeHostReservationOfferings asynchronously, invoking a callback when done
-- @param DescribeHostReservationOfferingsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeHostReservationOfferingsAsync(DescribeHostReservationOfferingsRequest, cb)
	assert(DescribeHostReservationOfferingsRequest, "You must provide a DescribeHostReservationOfferingsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeHostReservationOfferings",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeHostReservationOfferingsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeHostReservationOfferings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeHostReservationOfferingsRequest
-- @return response
-- @return error_message
function M.DescribeHostReservationOfferingsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeHostReservationOfferingsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumesModifications asynchronously, invoking a callback when done
-- @param DescribeVolumesModificationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumesModificationsAsync(DescribeVolumesModificationsRequest, cb)
	assert(DescribeVolumesModificationsRequest, "You must provide a DescribeVolumesModificationsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVolumesModifications",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVolumesModificationsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumesModifications synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumesModificationsRequest
-- @return response
-- @return error_message
function M.DescribeVolumesModificationsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumesModificationsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateVpcCidrBlock asynchronously, invoking a callback when done
-- @param AssociateVpcCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateVpcCidrBlockAsync(AssociateVpcCidrBlockRequest, cb)
	assert(AssociateVpcCidrBlockRequest, "You must provide a AssociateVpcCidrBlockRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateVpcCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateVpcCidrBlockRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateVpcCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateVpcCidrBlockRequest
-- @return response
-- @return error_message
function M.AssociateVpcCidrBlockSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateVpcCidrBlockAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateAddress asynchronously, invoking a callback when done
-- @param AssociateAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateAddressAsync(AssociateAddressRequest, cb)
	assert(AssociateAddressRequest, "You must provide a AssociateAddressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateAddressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateAddressRequest
-- @return response
-- @return error_message
function M.AssociateAddressSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateAddressAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteCustomerGateway asynchronously, invoking a callback when done
-- @param DeleteCustomerGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteCustomerGatewayAsync(DeleteCustomerGatewayRequest, cb)
	assert(DeleteCustomerGatewayRequest, "You must provide a DeleteCustomerGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteCustomerGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteCustomerGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteCustomerGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteCustomerGatewayRequest
-- @return response
-- @return error_message
function M.DeleteCustomerGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteCustomerGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateInternetGateway asynchronously, invoking a callback when done
-- @param CreateInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateInternetGatewayAsync(CreateInternetGatewayRequest, cb)
	assert(CreateInternetGatewayRequest, "You must provide a CreateInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateInternetGatewayRequest
-- @return response
-- @return error_message
function M.CreateInternetGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateInternetGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachClassicLinkVpc asynchronously, invoking a callback when done
-- @param AttachClassicLinkVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachClassicLinkVpcAsync(AttachClassicLinkVpcRequest, cb)
	assert(AttachClassicLinkVpcRequest, "You must provide a AttachClassicLinkVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachClassicLinkVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachClassicLinkVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AttachClassicLinkVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachClassicLinkVpcRequest
-- @return response
-- @return error_message
function M.AttachClassicLinkVpcSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachClassicLinkVpcAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotPriceHistory asynchronously, invoking a callback when done
-- @param DescribeSpotPriceHistoryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotPriceHistoryAsync(DescribeSpotPriceHistoryRequest, cb)
	assert(DescribeSpotPriceHistoryRequest, "You must provide a DescribeSpotPriceHistoryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotPriceHistory",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotPriceHistoryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotPriceHistory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotPriceHistoryRequest
-- @return response
-- @return error_message
function M.DescribeSpotPriceHistorySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotPriceHistoryAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeDhcpOptions asynchronously, invoking a callback when done
-- @param DescribeDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeDhcpOptionsAsync(DescribeDhcpOptionsRequest, cb)
	assert(DescribeDhcpOptionsRequest, "You must provide a DescribeDhcpOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeDhcpOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeDhcpOptionsRequest
-- @return response
-- @return error_message
function M.DescribeDhcpOptionsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeDhcpOptionsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpcPeeringConnection asynchronously, invoking a callback when done
-- @param DeleteVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpcPeeringConnectionAsync(DeleteVpcPeeringConnectionRequest, cb)
	assert(DeleteVpcPeeringConnectionRequest, "You must provide a DeleteVpcPeeringConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpcPeeringConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcPeeringConnectionRequest
-- @return response
-- @return error_message
function M.DeleteVpcPeeringConnectionSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcPeeringConnectionAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFlowLogs asynchronously, invoking a callback when done
-- @param DescribeFlowLogsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeFlowLogsAsync(DescribeFlowLogsRequest, cb)
	assert(DescribeFlowLogsRequest, "You must provide a DescribeFlowLogsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeFlowLogs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeFlowLogsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFlowLogs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFlowLogsRequest
-- @return response
-- @return error_message
function M.DescribeFlowLogsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFlowLogsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkAclEntry asynchronously, invoking a callback when done
-- @param CreateNetworkAclEntryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNetworkAclEntryAsync(CreateNetworkAclEntryRequest, cb)
	assert(CreateNetworkAclEntryRequest, "You must provide a CreateNetworkAclEntryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateNetworkAclEntry",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateNetworkAclEntryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkAclEntry synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkAclEntryRequest
-- @return response
-- @return error_message
function M.CreateNetworkAclEntrySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkAclEntryAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReleaseHosts asynchronously, invoking a callback when done
-- @param ReleaseHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReleaseHostsAsync(ReleaseHostsRequest, cb)
	assert(ReleaseHostsRequest, "You must provide a ReleaseHostsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReleaseHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReleaseHostsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ReleaseHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReleaseHostsRequest
-- @return response
-- @return error_message
function M.ReleaseHostsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReleaseHostsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RestoreAddressToClassic asynchronously, invoking a callback when done
-- @param RestoreAddressToClassicRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RestoreAddressToClassicAsync(RestoreAddressToClassicRequest, cb)
	assert(RestoreAddressToClassicRequest, "You must provide a RestoreAddressToClassicRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RestoreAddressToClassic",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RestoreAddressToClassicRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RestoreAddressToClassic synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RestoreAddressToClassicRequest
-- @return response
-- @return error_message
function M.RestoreAddressToClassicSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RestoreAddressToClassicAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkInterface asynchronously, invoking a callback when done
-- @param CreateNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNetworkInterfaceAsync(CreateNetworkInterfaceRequest, cb)
	assert(CreateNetworkInterfaceRequest, "You must provide a CreateNetworkInterfaceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateNetworkInterfaceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkInterfaceRequest
-- @return response
-- @return error_message
function M.CreateNetworkInterfaceSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkInterfaceAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeRegions asynchronously, invoking a callback when done
-- @param DescribeRegionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeRegionsAsync(DescribeRegionsRequest, cb)
	assert(DescribeRegionsRequest, "You must provide a DescribeRegionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeRegions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeRegionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeRegions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeRegionsRequest
-- @return response
-- @return error_message
function M.DescribeRegionsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeRegionsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RevokeSecurityGroupIngress asynchronously, invoking a callback when done
-- @param RevokeSecurityGroupIngressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RevokeSecurityGroupIngressAsync(RevokeSecurityGroupIngressRequest, cb)
	assert(RevokeSecurityGroupIngressRequest, "You must provide a RevokeSecurityGroupIngressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RevokeSecurityGroupIngress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RevokeSecurityGroupIngressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RevokeSecurityGroupIngress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RevokeSecurityGroupIngressRequest
-- @return response
-- @return error_message
function M.RevokeSecurityGroupIngressSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RevokeSecurityGroupIngressAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call UnassignPrivateIpAddresses asynchronously, invoking a callback when done
-- @param UnassignPrivateIpAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.UnassignPrivateIpAddressesAsync(UnassignPrivateIpAddressesRequest, cb)
	assert(UnassignPrivateIpAddressesRequest, "You must provide a UnassignPrivateIpAddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".UnassignPrivateIpAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", UnassignPrivateIpAddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call UnassignPrivateIpAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UnassignPrivateIpAddressesRequest
-- @return response
-- @return error_message
function M.UnassignPrivateIpAddressesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UnassignPrivateIpAddressesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachInternetGateway asynchronously, invoking a callback when done
-- @param AttachInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachInternetGatewayAsync(AttachInternetGatewayRequest, cb)
	assert(AttachInternetGatewayRequest, "You must provide a AttachInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AttachInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachInternetGatewayRequest
-- @return response
-- @return error_message
function M.AttachInternetGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachInternetGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateInstanceExportTask asynchronously, invoking a callback when done
-- @param CreateInstanceExportTaskRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateInstanceExportTaskAsync(CreateInstanceExportTaskRequest, cb)
	assert(CreateInstanceExportTaskRequest, "You must provide a CreateInstanceExportTaskRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateInstanceExportTask",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateInstanceExportTaskRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateInstanceExportTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateInstanceExportTaskRequest
-- @return response
-- @return error_message
function M.CreateInstanceExportTaskSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateInstanceExportTaskAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteDhcpOptions asynchronously, invoking a callback when done
-- @param DeleteDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteDhcpOptionsAsync(DeleteDhcpOptionsRequest, cb)
	assert(DeleteDhcpOptionsRequest, "You must provide a DeleteDhcpOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteDhcpOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteDhcpOptionsRequest
-- @return response
-- @return error_message
function M.DeleteDhcpOptionsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteDhcpOptionsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetNetworkInterfaceAttribute asynchronously, invoking a callback when done
-- @param ResetNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetNetworkInterfaceAttributeAsync(ResetNetworkInterfaceAttributeRequest, cb)
	assert(ResetNetworkInterfaceAttributeRequest, "You must provide a ResetNetworkInterfaceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ResetNetworkInterfaceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ResetNetworkInterfaceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ResetNetworkInterfaceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetNetworkInterfaceAttributeRequest
-- @return response
-- @return error_message
function M.ResetNetworkInterfaceAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetNetworkInterfaceAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyReservedInstances asynchronously, invoking a callback when done
-- @param ModifyReservedInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyReservedInstancesAsync(ModifyReservedInstancesRequest, cb)
	assert(ModifyReservedInstancesRequest, "You must provide a ModifyReservedInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyReservedInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyReservedInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyReservedInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyReservedInstancesRequest
-- @return response
-- @return error_message
function M.ModifyReservedInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyReservedInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachNetworkInterface asynchronously, invoking a callback when done
-- @param DetachNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachNetworkInterfaceAsync(DetachNetworkInterfaceRequest, cb)
	assert(DetachNetworkInterfaceRequest, "You must provide a DetachNetworkInterfaceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachNetworkInterfaceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DetachNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachNetworkInterfaceRequest
-- @return response
-- @return error_message
function M.DetachNetworkInterfaceSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachNetworkInterfaceAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImportImageTasks asynchronously, invoking a callback when done
-- @param DescribeImportImageTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImportImageTasksAsync(DescribeImportImageTasksRequest, cb)
	assert(DescribeImportImageTasksRequest, "You must provide a DescribeImportImageTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeImportImageTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeImportImageTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImportImageTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImportImageTasksRequest
-- @return response
-- @return error_message
function M.DescribeImportImageTasksSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImportImageTasksAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotFleetInstances asynchronously, invoking a callback when done
-- @param DescribeSpotFleetInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotFleetInstancesAsync(DescribeSpotFleetInstancesRequest, cb)
	assert(DescribeSpotFleetInstancesRequest, "You must provide a DescribeSpotFleetInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotFleetInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotFleetInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotFleetInstancesRequest
-- @return response
-- @return error_message
function M.DescribeSpotFleetInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotFleetInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVpcClassicLink asynchronously, invoking a callback when done
-- @param EnableVpcClassicLinkRequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVpcClassicLinkAsync(EnableVpcClassicLinkRequest, cb)
	assert(EnableVpcClassicLinkRequest, "You must provide a EnableVpcClassicLinkRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".EnableVpcClassicLink",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", EnableVpcClassicLinkRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVpcClassicLink synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVpcClassicLinkRequest
-- @return response
-- @return error_message
function M.EnableVpcClassicLinkSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVpcClassicLinkAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateFlowLogs asynchronously, invoking a callback when done
-- @param CreateFlowLogsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateFlowLogsAsync(CreateFlowLogsRequest, cb)
	assert(CreateFlowLogsRequest, "You must provide a CreateFlowLogsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateFlowLogs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateFlowLogsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateFlowLogs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateFlowLogsRequest
-- @return response
-- @return error_message
function M.CreateFlowLogsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateFlowLogsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateVpcCidrBlock asynchronously, invoking a callback when done
-- @param DisassociateVpcCidrBlockRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateVpcCidrBlockAsync(DisassociateVpcCidrBlockRequest, cb)
	assert(DisassociateVpcCidrBlockRequest, "You must provide a DisassociateVpcCidrBlockRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateVpcCidrBlock",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateVpcCidrBlockRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateVpcCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateVpcCidrBlockRequest
-- @return response
-- @return error_message
function M.DisassociateVpcCidrBlockSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateVpcCidrBlockAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumeStatus asynchronously, invoking a callback when done
-- @param DescribeVolumeStatusRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumeStatusAsync(DescribeVolumeStatusRequest, cb)
	assert(DescribeVolumeStatusRequest, "You must provide a DescribeVolumeStatusRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVolumeStatus",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVolumeStatusRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumeStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumeStatusRequest
-- @return response
-- @return error_message
function M.DescribeVolumeStatusSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumeStatusAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeHosts asynchronously, invoking a callback when done
-- @param DescribeHostsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeHostsAsync(DescribeHostsRequest, cb)
	assert(DescribeHostsRequest, "You must provide a DescribeHostsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeHosts",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeHostsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeHostsRequest
-- @return response
-- @return error_message
function M.DescribeHostsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeHostsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcPeeringConnections asynchronously, invoking a callback when done
-- @param DescribeVpcPeeringConnectionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcPeeringConnectionsAsync(DescribeVpcPeeringConnectionsRequest, cb)
	assert(DescribeVpcPeeringConnectionsRequest, "You must provide a DescribeVpcPeeringConnectionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcPeeringConnections",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcPeeringConnectionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcPeeringConnections synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcPeeringConnectionsRequest
-- @return response
-- @return error_message
function M.DescribeVpcPeeringConnectionsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcPeeringConnectionsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumes asynchronously, invoking a callback when done
-- @param DescribeVolumesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumesAsync(DescribeVolumesRequest, cb)
	assert(DescribeVolumesRequest, "You must provide a DescribeVolumesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVolumes",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVolumesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumes synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumesRequest
-- @return response
-- @return error_message
function M.DescribeVolumesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkInterface asynchronously, invoking a callback when done
-- @param DeleteNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNetworkInterfaceAsync(DeleteNetworkInterfaceRequest, cb)
	assert(DeleteNetworkInterfaceRequest, "You must provide a DeleteNetworkInterfaceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteNetworkInterfaceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkInterfaceRequest
-- @return response
-- @return error_message
function M.DeleteNetworkInterfaceSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkInterfaceAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpnConnections asynchronously, invoking a callback when done
-- @param DescribeVpnConnectionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpnConnectionsAsync(DescribeVpnConnectionsRequest, cb)
	assert(DescribeVpnConnectionsRequest, "You must provide a DescribeVpnConnectionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpnConnections",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpnConnectionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpnConnections synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpnConnectionsRequest
-- @return response
-- @return error_message
function M.DescribeVpnConnectionsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpnConnectionsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpcEndpoints asynchronously, invoking a callback when done
-- @param DeleteVpcEndpointsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpcEndpointsAsync(DeleteVpcEndpointsRequest, cb)
	assert(DeleteVpcEndpointsRequest, "You must provide a DeleteVpcEndpointsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpcEndpoints",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpcEndpointsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpcEndpoints synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcEndpointsRequest
-- @return response
-- @return error_message
function M.DeleteVpcEndpointsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcEndpointsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumeAttribute asynchronously, invoking a callback when done
-- @param DescribeVolumeAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVolumeAttributeAsync(DescribeVolumeAttributeRequest, cb)
	assert(DescribeVolumeAttributeRequest, "You must provide a DescribeVolumeAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVolumeAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVolumeAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumeAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumeAttributeRequest
-- @return response
-- @return error_message
function M.DescribeVolumeAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumeAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteKeyPair asynchronously, invoking a callback when done
-- @param DeleteKeyPairRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteKeyPairAsync(DeleteKeyPairRequest, cb)
	assert(DeleteKeyPairRequest, "You must provide a DeleteKeyPairRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteKeyPair",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteKeyPairRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteKeyPair synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteKeyPairRequest
-- @return response
-- @return error_message
function M.DeleteKeyPairSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteKeyPairAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNatGateway asynchronously, invoking a callback when done
-- @param DeleteNatGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNatGatewayAsync(DeleteNatGatewayRequest, cb)
	assert(DeleteNatGatewayRequest, "You must provide a DeleteNatGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteNatGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteNatGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNatGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNatGatewayRequest
-- @return response
-- @return error_message
function M.DeleteNatGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNatGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyInstancePlacement asynchronously, invoking a callback when done
-- @param ModifyInstancePlacementRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyInstancePlacementAsync(ModifyInstancePlacementRequest, cb)
	assert(ModifyInstancePlacementRequest, "You must provide a ModifyInstancePlacementRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyInstancePlacement",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyInstancePlacementRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyInstancePlacement synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyInstancePlacementRequest
-- @return response
-- @return error_message
function M.ModifyInstancePlacementSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyInstancePlacementAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceNetworkAclEntry asynchronously, invoking a callback when done
-- @param ReplaceNetworkAclEntryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceNetworkAclEntryAsync(ReplaceNetworkAclEntryRequest, cb)
	assert(ReplaceNetworkAclEntryRequest, "You must provide a ReplaceNetworkAclEntryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceNetworkAclEntry",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceNetworkAclEntryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceNetworkAclEntry synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceNetworkAclEntryRequest
-- @return response
-- @return error_message
function M.ReplaceNetworkAclEntrySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceNetworkAclEntryAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateEgressOnlyInternetGateway asynchronously, invoking a callback when done
-- @param CreateEgressOnlyInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateEgressOnlyInternetGatewayAsync(CreateEgressOnlyInternetGatewayRequest, cb)
	assert(CreateEgressOnlyInternetGatewayRequest, "You must provide a CreateEgressOnlyInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateEgressOnlyInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateEgressOnlyInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateEgressOnlyInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateEgressOnlyInternetGatewayRequest
-- @return response
-- @return error_message
function M.CreateEgressOnlyInternetGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateEgressOnlyInternetGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteInternetGateway asynchronously, invoking a callback when done
-- @param DeleteInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteInternetGatewayAsync(DeleteInternetGatewayRequest, cb)
	assert(DeleteInternetGatewayRequest, "You must provide a DeleteInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteInternetGatewayRequest
-- @return response
-- @return error_message
function M.DeleteInternetGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteInternetGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVolume asynchronously, invoking a callback when done
-- @param CreateVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVolumeAsync(CreateVolumeRequest, cb)
	assert(CreateVolumeRequest, "You must provide a CreateVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVolumeRequest
-- @return response
-- @return error_message
function M.CreateVolumeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVolumeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RunInstances asynchronously, invoking a callback when done
-- @param RunInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RunInstancesAsync(RunInstancesRequest, cb)
	assert(RunInstancesRequest, "You must provide a RunInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RunInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RunInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RunInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RunInstancesRequest
-- @return response
-- @return error_message
function M.RunInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RunInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeScheduledInstances asynchronously, invoking a callback when done
-- @param DescribeScheduledInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeScheduledInstancesAsync(DescribeScheduledInstancesRequest, cb)
	assert(DescribeScheduledInstancesRequest, "You must provide a DescribeScheduledInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeScheduledInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeScheduledInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeScheduledInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeScheduledInstancesRequest
-- @return response
-- @return error_message
function M.DescribeScheduledInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeScheduledInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteRoute asynchronously, invoking a callback when done
-- @param DeleteRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteRouteAsync(DeleteRouteRequest, cb)
	assert(DeleteRouteRequest, "You must provide a DeleteRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteRouteRequest
-- @return response
-- @return error_message
function M.DeleteRouteSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteRouteAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableVpcClassicLink asynchronously, invoking a callback when done
-- @param DisableVpcClassicLinkRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisableVpcClassicLinkAsync(DisableVpcClassicLinkRequest, cb)
	assert(DisableVpcClassicLinkRequest, "You must provide a DisableVpcClassicLinkRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisableVpcClassicLink",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisableVpcClassicLinkRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DisableVpcClassicLink synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableVpcClassicLinkRequest
-- @return response
-- @return error_message
function M.DisableVpcClassicLinkSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableVpcClassicLinkAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachNetworkInterface asynchronously, invoking a callback when done
-- @param AttachNetworkInterfaceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachNetworkInterfaceAsync(AttachNetworkInterfaceRequest, cb)
	assert(AttachNetworkInterfaceRequest, "You must provide a AttachNetworkInterfaceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachNetworkInterface",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachNetworkInterfaceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AttachNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachNetworkInterfaceRequest
-- @return response
-- @return error_message
function M.AttachNetworkInterfaceSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachNetworkInterfaceAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNatGateway asynchronously, invoking a callback when done
-- @param CreateNatGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateNatGatewayAsync(CreateNatGatewayRequest, cb)
	assert(CreateNatGatewayRequest, "You must provide a CreateNatGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateNatGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateNatGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNatGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNatGatewayRequest
-- @return response
-- @return error_message
function M.CreateNatGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNatGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpnConnectionRoute asynchronously, invoking a callback when done
-- @param DeleteVpnConnectionRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpnConnectionRouteAsync(DeleteVpnConnectionRouteRequest, cb)
	assert(DeleteVpnConnectionRouteRequest, "You must provide a DeleteVpnConnectionRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpnConnectionRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpnConnectionRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpnConnectionRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpnConnectionRouteRequest
-- @return response
-- @return error_message
function M.DeleteVpnConnectionRouteSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpnConnectionRouteAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelSpotInstanceRequests asynchronously, invoking a callback when done
-- @param CancelSpotInstanceRequestsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelSpotInstanceRequestsAsync(CancelSpotInstanceRequestsRequest, cb)
	assert(CancelSpotInstanceRequestsRequest, "You must provide a CancelSpotInstanceRequestsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelSpotInstanceRequests",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelSpotInstanceRequestsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CancelSpotInstanceRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelSpotInstanceRequestsRequest
-- @return response
-- @return error_message
function M.CancelSpotInstanceRequestsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelSpotInstanceRequestsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateKeyPair asynchronously, invoking a callback when done
-- @param CreateKeyPairRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateKeyPairAsync(CreateKeyPairRequest, cb)
	assert(CreateKeyPairRequest, "You must provide a CreateKeyPairRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateKeyPair",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateKeyPairRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateKeyPair synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateKeyPairRequest
-- @return response
-- @return error_message
function M.CreateKeyPairSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateKeyPairAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkInterfaceAttribute asynchronously, invoking a callback when done
-- @param DescribeNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNetworkInterfaceAttributeAsync(DescribeNetworkInterfaceAttributeRequest, cb)
	assert(DescribeNetworkInterfaceAttributeRequest, "You must provide a DescribeNetworkInterfaceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeNetworkInterfaceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeNetworkInterfaceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkInterfaceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkInterfaceAttributeRequest
-- @return response
-- @return error_message
function M.DescribeNetworkInterfaceAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkInterfaceAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIdFormat asynchronously, invoking a callback when done
-- @param DescribeIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeIdFormatAsync(DescribeIdFormatRequest, cb)
	assert(DescribeIdFormatRequest, "You must provide a DescribeIdFormatRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeIdFormatRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIdFormatRequest
-- @return response
-- @return error_message
function M.DescribeIdFormatSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIdFormatAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSnapshot asynchronously, invoking a callback when done
-- @param DeleteSnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSnapshotAsync(DeleteSnapshotRequest, cb)
	assert(DeleteSnapshotRequest, "You must provide a DeleteSnapshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteSnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteSnapshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSnapshotRequest
-- @return response
-- @return error_message
function M.DeleteSnapshotSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSnapshotAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMovingAddresses asynchronously, invoking a callback when done
-- @param DescribeMovingAddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeMovingAddressesAsync(DescribeMovingAddressesRequest, cb)
	assert(DescribeMovingAddressesRequest, "You must provide a DescribeMovingAddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeMovingAddresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeMovingAddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMovingAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMovingAddressesRequest
-- @return response
-- @return error_message
function M.DescribeMovingAddressesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMovingAddressesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstanceAttribute asynchronously, invoking a callback when done
-- @param DescribeInstanceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInstanceAttributeAsync(DescribeInstanceAttributeRequest, cb)
	assert(DescribeInstanceAttributeRequest, "You must provide a DescribeInstanceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeInstanceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeInstanceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstanceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstanceAttributeRequest
-- @return response
-- @return error_message
function M.DescribeInstanceAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstanceAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeregisterImage asynchronously, invoking a callback when done
-- @param DeregisterImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeregisterImageAsync(DeregisterImageRequest, cb)
	assert(DeregisterImageRequest, "You must provide a DeregisterImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeregisterImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeregisterImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeregisterImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeregisterImageRequest
-- @return response
-- @return error_message
function M.DeregisterImageSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeregisterImageAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpnGateway asynchronously, invoking a callback when done
-- @param DeleteVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpnGatewayAsync(DeleteVpnGatewayRequest, cb)
	assert(DeleteVpnGatewayRequest, "You must provide a DeleteVpnGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpnGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpnGatewayRequest
-- @return response
-- @return error_message
function M.DeleteVpnGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpnGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReportInstanceStatus asynchronously, invoking a callback when done
-- @param ReportInstanceStatusRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReportInstanceStatusAsync(ReportInstanceStatusRequest, cb)
	assert(ReportInstanceStatusRequest, "You must provide a ReportInstanceStatusRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReportInstanceStatus",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReportInstanceStatusRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ReportInstanceStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReportInstanceStatusRequest
-- @return response
-- @return error_message
function M.ReportInstanceStatusSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReportInstanceStatusAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelReservedInstancesListing asynchronously, invoking a callback when done
-- @param CancelReservedInstancesListingRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CancelReservedInstancesListingAsync(CancelReservedInstancesListingRequest, cb)
	assert(CancelReservedInstancesListingRequest, "You must provide a CancelReservedInstancesListingRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CancelReservedInstancesListing",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CancelReservedInstancesListingRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CancelReservedInstancesListing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelReservedInstancesListingRequest
-- @return response
-- @return error_message
function M.CancelReservedInstancesListingSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelReservedInstancesListingAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePrefixLists asynchronously, invoking a callback when done
-- @param DescribePrefixListsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribePrefixListsAsync(DescribePrefixListsRequest, cb)
	assert(DescribePrefixListsRequest, "You must provide a DescribePrefixListsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribePrefixLists",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribePrefixListsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePrefixLists synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePrefixListsRequest
-- @return response
-- @return error_message
function M.DescribePrefixListsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePrefixListsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSnapshotAttribute asynchronously, invoking a callback when done
-- @param DescribeSnapshotAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSnapshotAttributeAsync(DescribeSnapshotAttributeRequest, cb)
	assert(DescribeSnapshotAttributeRequest, "You must provide a DescribeSnapshotAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSnapshotAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSnapshotAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSnapshotAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSnapshotAttributeRequest
-- @return response
-- @return error_message
function M.DescribeSnapshotAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSnapshotAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call PurchaseReservedInstancesOffering asynchronously, invoking a callback when done
-- @param PurchaseReservedInstancesOfferingRequest
-- @param cb Callback function accepting two args: response, error_message
function M.PurchaseReservedInstancesOfferingAsync(PurchaseReservedInstancesOfferingRequest, cb)
	assert(PurchaseReservedInstancesOfferingRequest, "You must provide a PurchaseReservedInstancesOfferingRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".PurchaseReservedInstancesOffering",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", PurchaseReservedInstancesOfferingRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call PurchaseReservedInstancesOffering synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PurchaseReservedInstancesOfferingRequest
-- @return response
-- @return error_message
function M.PurchaseReservedInstancesOfferingSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PurchaseReservedInstancesOfferingAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifySubnetAttribute asynchronously, invoking a callback when done
-- @param ModifySubnetAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifySubnetAttributeAsync(ModifySubnetAttributeRequest, cb)
	assert(ModifySubnetAttributeRequest, "You must provide a ModifySubnetAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifySubnetAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifySubnetAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifySubnetAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifySubnetAttributeRequest
-- @return response
-- @return error_message
function M.ModifySubnetAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifySubnetAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkInterfaces asynchronously, invoking a callback when done
-- @param DescribeNetworkInterfacesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeNetworkInterfacesAsync(DescribeNetworkInterfacesRequest, cb)
	assert(DescribeNetworkInterfacesRequest, "You must provide a DescribeNetworkInterfacesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeNetworkInterfaces",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeNetworkInterfacesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkInterfaces synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkInterfacesRequest
-- @return response
-- @return error_message
function M.DescribeNetworkInterfacesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkInterfacesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ConfirmProductInstance asynchronously, invoking a callback when done
-- @param ConfirmProductInstanceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ConfirmProductInstanceAsync(ConfirmProductInstanceRequest, cb)
	assert(ConfirmProductInstanceRequest, "You must provide a ConfirmProductInstanceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ConfirmProductInstance",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ConfirmProductInstanceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ConfirmProductInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ConfirmProductInstanceRequest
-- @return response
-- @return error_message
function M.ConfirmProductInstanceSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ConfirmProductInstanceAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeExportTasks asynchronously, invoking a callback when done
-- @param DescribeExportTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeExportTasksAsync(DescribeExportTasksRequest, cb)
	assert(DescribeExportTasksRequest, "You must provide a DescribeExportTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeExportTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeExportTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeExportTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeExportTasksRequest
-- @return response
-- @return error_message
function M.DescribeExportTasksSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeExportTasksAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachInternetGateway asynchronously, invoking a callback when done
-- @param DetachInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachInternetGatewayAsync(DetachInternetGatewayRequest, cb)
	assert(DetachInternetGatewayRequest, "You must provide a DetachInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DetachInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachInternetGatewayRequest
-- @return response
-- @return error_message
function M.DetachInternetGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachInternetGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkAclEntry asynchronously, invoking a callback when done
-- @param DeleteNetworkAclEntryRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteNetworkAclEntryAsync(DeleteNetworkAclEntryRequest, cb)
	assert(DeleteNetworkAclEntryRequest, "You must provide a DeleteNetworkAclEntryRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteNetworkAclEntry",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteNetworkAclEntryRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkAclEntry synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkAclEntryRequest
-- @return response
-- @return error_message
function M.DeleteNetworkAclEntrySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkAclEntryAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateFpgaImage asynchronously, invoking a callback when done
-- @param CreateFpgaImageRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateFpgaImageAsync(CreateFpgaImageRequest, cb)
	assert(CreateFpgaImageRequest, "You must provide a CreateFpgaImageRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateFpgaImage",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateFpgaImageRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateFpgaImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateFpgaImageRequest
-- @return response
-- @return error_message
function M.CreateFpgaImageSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateFpgaImageAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateCustomerGateway asynchronously, invoking a callback when done
-- @param CreateCustomerGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateCustomerGatewayAsync(CreateCustomerGatewayRequest, cb)
	assert(CreateCustomerGatewayRequest, "You must provide a CreateCustomerGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateCustomerGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateCustomerGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateCustomerGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateCustomerGatewayRequest
-- @return response
-- @return error_message
function M.CreateCustomerGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateCustomerGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetInstanceAttribute asynchronously, invoking a callback when done
-- @param ResetInstanceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ResetInstanceAttributeAsync(ResetInstanceAttributeRequest, cb)
	assert(ResetInstanceAttributeRequest, "You must provide a ResetInstanceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ResetInstanceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ResetInstanceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ResetInstanceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetInstanceAttributeRequest
-- @return response
-- @return error_message
function M.ResetInstanceAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetInstanceAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSecurityGroup asynchronously, invoking a callback when done
-- @param CreateSecurityGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSecurityGroupAsync(CreateSecurityGroupRequest, cb)
	assert(CreateSecurityGroupRequest, "You must provide a CreateSecurityGroupRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateSecurityGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateSecurityGroupRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSecurityGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSecurityGroupRequest
-- @return response
-- @return error_message
function M.CreateSecurityGroupSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSecurityGroupAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInternetGateways asynchronously, invoking a callback when done
-- @param DescribeInternetGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInternetGatewaysAsync(DescribeInternetGatewaysRequest, cb)
	assert(DescribeInternetGatewaysRequest, "You must provide a DescribeInternetGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeInternetGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeInternetGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInternetGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInternetGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeInternetGatewaysSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInternetGatewaysAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyNetworkInterfaceAttribute asynchronously, invoking a callback when done
-- @param ModifyNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyNetworkInterfaceAttributeAsync(ModifyNetworkInterfaceAttributeRequest, cb)
	assert(ModifyNetworkInterfaceAttributeRequest, "You must provide a ModifyNetworkInterfaceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyNetworkInterfaceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyNetworkInterfaceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyNetworkInterfaceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyNetworkInterfaceAttributeRequest
-- @return response
-- @return error_message
function M.ModifyNetworkInterfaceAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyNetworkInterfaceAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachVolume asynchronously, invoking a callback when done
-- @param AttachVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AttachVolumeAsync(AttachVolumeRequest, cb)
	assert(AttachVolumeRequest, "You must provide a AttachVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AttachVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AttachVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AttachVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachVolumeRequest
-- @return response
-- @return error_message
function M.AttachVolumeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachVolumeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSnapshots asynchronously, invoking a callback when done
-- @param DescribeSnapshotsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSnapshotsAsync(DescribeSnapshotsRequest, cb)
	assert(DescribeSnapshotsRequest, "You must provide a DescribeSnapshotsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSnapshots",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSnapshotsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSnapshots synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSnapshotsRequest
-- @return response
-- @return error_message
function M.DescribeSnapshotsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSnapshotsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call TerminateInstances asynchronously, invoking a callback when done
-- @param TerminateInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.TerminateInstancesAsync(TerminateInstancesRequest, cb)
	assert(TerminateInstancesRequest, "You must provide a TerminateInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".TerminateInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", TerminateInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call TerminateInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param TerminateInstancesRequest
-- @return response
-- @return error_message
function M.TerminateInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.TerminateInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AcceptReservedInstancesExchangeQuote asynchronously, invoking a callback when done
-- @param AcceptReservedInstancesExchangeQuoteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AcceptReservedInstancesExchangeQuoteAsync(AcceptReservedInstancesExchangeQuoteRequest, cb)
	assert(AcceptReservedInstancesExchangeQuoteRequest, "You must provide a AcceptReservedInstancesExchangeQuoteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AcceptReservedInstancesExchangeQuote",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AcceptReservedInstancesExchangeQuoteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AcceptReservedInstancesExchangeQuote synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AcceptReservedInstancesExchangeQuoteRequest
-- @return response
-- @return error_message
function M.AcceptReservedInstancesExchangeQuoteSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AcceptReservedInstancesExchangeQuoteAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSpotDatafeedSubscription asynchronously, invoking a callback when done
-- @param DeleteSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSpotDatafeedSubscriptionAsync(DeleteSpotDatafeedSubscriptionRequest, cb)
	assert(DeleteSpotDatafeedSubscriptionRequest, "You must provide a DeleteSpotDatafeedSubscriptionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteSpotDatafeedSubscription",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteSpotDatafeedSubscriptionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSpotDatafeedSubscription synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSpotDatafeedSubscriptionRequest
-- @return response
-- @return error_message
function M.DeleteSpotDatafeedSubscriptionSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSpotDatafeedSubscriptionAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeletePlacementGroup asynchronously, invoking a callback when done
-- @param DeletePlacementGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeletePlacementGroupAsync(DeletePlacementGroupRequest, cb)
	assert(DeletePlacementGroupRequest, "You must provide a DeletePlacementGroupRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeletePlacementGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeletePlacementGroupRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeletePlacementGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeletePlacementGroupRequest
-- @return response
-- @return error_message
function M.DeletePlacementGroupSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeletePlacementGroupAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteRouteTable asynchronously, invoking a callback when done
-- @param DeleteRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteRouteTableAsync(DeleteRouteTableRequest, cb)
	assert(DeleteRouteTableRequest, "You must provide a DeleteRouteTableRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteRouteTableRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteRouteTableRequest
-- @return response
-- @return error_message
function M.DeleteRouteTableSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteRouteTableAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeKeyPairs asynchronously, invoking a callback when done
-- @param DescribeKeyPairsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeKeyPairsAsync(DescribeKeyPairsRequest, cb)
	assert(DescribeKeyPairsRequest, "You must provide a DescribeKeyPairsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeKeyPairs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeKeyPairsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeKeyPairs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeKeyPairsRequest
-- @return response
-- @return error_message
function M.DescribeKeyPairsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeKeyPairsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeStaleSecurityGroups asynchronously, invoking a callback when done
-- @param DescribeStaleSecurityGroupsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeStaleSecurityGroupsAsync(DescribeStaleSecurityGroupsRequest, cb)
	assert(DescribeStaleSecurityGroupsRequest, "You must provide a DescribeStaleSecurityGroupsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeStaleSecurityGroups",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeStaleSecurityGroupsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeStaleSecurityGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeStaleSecurityGroupsRequest
-- @return response
-- @return error_message
function M.DescribeStaleSecurityGroupsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeStaleSecurityGroupsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstancesOfferings asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesOfferingsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesOfferingsAsync(DescribeReservedInstancesOfferingsRequest, cb)
	assert(DescribeReservedInstancesOfferingsRequest, "You must provide a DescribeReservedInstancesOfferingsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesOfferings",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeReservedInstancesOfferingsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstancesOfferings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesOfferingsRequest
-- @return response
-- @return error_message
function M.DescribeReservedInstancesOfferingsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesOfferingsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetConsoleScreenshot asynchronously, invoking a callback when done
-- @param GetConsoleScreenshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetConsoleScreenshotAsync(GetConsoleScreenshotRequest, cb)
	assert(GetConsoleScreenshotRequest, "You must provide a GetConsoleScreenshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetConsoleScreenshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetConsoleScreenshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call GetConsoleScreenshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetConsoleScreenshotRequest
-- @return response
-- @return error_message
function M.GetConsoleScreenshotSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetConsoleScreenshotAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAccountAttributes asynchronously, invoking a callback when done
-- @param DescribeAccountAttributesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeAccountAttributesAsync(DescribeAccountAttributesRequest, cb)
	assert(DescribeAccountAttributesRequest, "You must provide a DescribeAccountAttributesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeAccountAttributes",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeAccountAttributesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAccountAttributes synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAccountAttributesRequest
-- @return response
-- @return error_message
function M.DescribeAccountAttributesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAccountAttributesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssignIpv6Addresses asynchronously, invoking a callback when done
-- @param AssignIpv6AddressesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssignIpv6AddressesAsync(AssignIpv6AddressesRequest, cb)
	assert(AssignIpv6AddressesRequest, "You must provide a AssignIpv6AddressesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssignIpv6Addresses",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssignIpv6AddressesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AssignIpv6Addresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssignIpv6AddressesRequest
-- @return response
-- @return error_message
function M.AssignIpv6AddressesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssignIpv6AddressesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AuthorizeSecurityGroupEgress asynchronously, invoking a callback when done
-- @param AuthorizeSecurityGroupEgressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AuthorizeSecurityGroupEgressAsync(AuthorizeSecurityGroupEgressRequest, cb)
	assert(AuthorizeSecurityGroupEgressRequest, "You must provide a AuthorizeSecurityGroupEgressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AuthorizeSecurityGroupEgress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AuthorizeSecurityGroupEgressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AuthorizeSecurityGroupEgress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AuthorizeSecurityGroupEgressRequest
-- @return response
-- @return error_message
function M.AuthorizeSecurityGroupEgressSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AuthorizeSecurityGroupEgressAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AllocateAddress asynchronously, invoking a callback when done
-- @param AllocateAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AllocateAddressAsync(AllocateAddressRequest, cb)
	assert(AllocateAddressRequest, "You must provide a AllocateAddressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AllocateAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AllocateAddressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AllocateAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AllocateAddressRequest
-- @return response
-- @return error_message
function M.AllocateAddressSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AllocateAddressAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AuthorizeSecurityGroupIngress asynchronously, invoking a callback when done
-- @param AuthorizeSecurityGroupIngressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AuthorizeSecurityGroupIngressAsync(AuthorizeSecurityGroupIngressRequest, cb)
	assert(AuthorizeSecurityGroupIngressRequest, "You must provide a AuthorizeSecurityGroupIngressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AuthorizeSecurityGroupIngress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AuthorizeSecurityGroupIngressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AuthorizeSecurityGroupIngress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AuthorizeSecurityGroupIngressRequest
-- @return response
-- @return error_message
function M.AuthorizeSecurityGroupIngressSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AuthorizeSecurityGroupIngressAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSpotDatafeedSubscription asynchronously, invoking a callback when done
-- @param CreateSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateSpotDatafeedSubscriptionAsync(CreateSpotDatafeedSubscriptionRequest, cb)
	assert(CreateSpotDatafeedSubscriptionRequest, "You must provide a CreateSpotDatafeedSubscriptionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateSpotDatafeedSubscription",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateSpotDatafeedSubscriptionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSpotDatafeedSubscription synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSpotDatafeedSubscriptionRequest
-- @return response
-- @return error_message
function M.CreateSpotDatafeedSubscriptionSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSpotDatafeedSubscriptionAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportInstance asynchronously, invoking a callback when done
-- @param ImportInstanceRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportInstanceAsync(ImportInstanceRequest, cb)
	assert(ImportInstanceRequest, "You must provide a ImportInstanceRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportInstance",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportInstanceRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ImportInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportInstanceRequest
-- @return response
-- @return error_message
function M.ImportInstanceSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportInstanceAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call StopInstances asynchronously, invoking a callback when done
-- @param StopInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.StopInstancesAsync(StopInstancesRequest, cb)
	assert(StopInstancesRequest, "You must provide a StopInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".StopInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", StopInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call StopInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StopInstancesRequest
-- @return response
-- @return error_message
function M.StopInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StopInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReleaseAddress asynchronously, invoking a callback when done
-- @param ReleaseAddressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReleaseAddressAsync(ReleaseAddressRequest, cb)
	assert(ReleaseAddressRequest, "You must provide a ReleaseAddressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReleaseAddress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReleaseAddressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ReleaseAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReleaseAddressRequest
-- @return response
-- @return error_message
function M.ReleaseAddressSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReleaseAddressAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFpgaImages asynchronously, invoking a callback when done
-- @param DescribeFpgaImagesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeFpgaImagesAsync(DescribeFpgaImagesRequest, cb)
	assert(DescribeFpgaImagesRequest, "You must provide a DescribeFpgaImagesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeFpgaImages",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeFpgaImagesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFpgaImages synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFpgaImagesRequest
-- @return response
-- @return error_message
function M.DescribeFpgaImagesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFpgaImagesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RejectVpcPeeringConnection asynchronously, invoking a callback when done
-- @param RejectVpcPeeringConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RejectVpcPeeringConnectionAsync(RejectVpcPeeringConnectionRequest, cb)
	assert(RejectVpcPeeringConnectionRequest, "You must provide a RejectVpcPeeringConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RejectVpcPeeringConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RejectVpcPeeringConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RejectVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RejectVpcPeeringConnectionRequest
-- @return response
-- @return error_message
function M.RejectVpcPeeringConnectionSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RejectVpcPeeringConnectionAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call MonitorInstances asynchronously, invoking a callback when done
-- @param MonitorInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.MonitorInstancesAsync(MonitorInstancesRequest, cb)
	assert(MonitorInstancesRequest, "You must provide a MonitorInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".MonitorInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", MonitorInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call MonitorInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param MonitorInstancesRequest
-- @return response
-- @return error_message
function M.MonitorInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.MonitorInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImages asynchronously, invoking a callback when done
-- @param DescribeImagesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeImagesAsync(DescribeImagesRequest, cb)
	assert(DescribeImagesRequest, "You must provide a DescribeImagesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeImages",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeImagesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImages synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImagesRequest
-- @return response
-- @return error_message
function M.DescribeImagesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImagesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateRouteTable asynchronously, invoking a callback when done
-- @param DisassociateRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DisassociateRouteTableAsync(DisassociateRouteTableRequest, cb)
	assert(DisassociateRouteTableRequest, "You must provide a DisassociateRouteTableRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DisassociateRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DisassociateRouteTableRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateRouteTableRequest
-- @return response
-- @return error_message
function M.DisassociateRouteTableSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateRouteTableAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceRoute asynchronously, invoking a callback when done
-- @param ReplaceRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceRouteAsync(ReplaceRouteRequest, cb)
	assert(ReplaceRouteRequest, "You must provide a ReplaceRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceRouteRequest
-- @return response
-- @return error_message
function M.ReplaceRouteSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceRouteAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateRouteTable asynchronously, invoking a callback when done
-- @param AssociateRouteTableRequest
-- @param cb Callback function accepting two args: response, error_message
function M.AssociateRouteTableAsync(AssociateRouteTableRequest, cb)
	assert(AssociateRouteTableRequest, "You must provide a AssociateRouteTableRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".AssociateRouteTable",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", AssociateRouteTableRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateRouteTableRequest
-- @return response
-- @return error_message
function M.AssociateRouteTableSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateRouteTableAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpc asynchronously, invoking a callback when done
-- @param DeleteVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVpcAsync(DeleteVpcRequest, cb)
	assert(DeleteVpcRequest, "You must provide a DeleteVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcRequest
-- @return response
-- @return error_message
function M.DeleteVpcSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotDatafeedSubscription asynchronously, invoking a callback when done
-- @param DescribeSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSpotDatafeedSubscriptionAsync(DescribeSpotDatafeedSubscriptionRequest, cb)
	assert(DescribeSpotDatafeedSubscriptionRequest, "You must provide a DescribeSpotDatafeedSubscriptionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSpotDatafeedSubscription",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSpotDatafeedSubscriptionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotDatafeedSubscription synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotDatafeedSubscriptionRequest
-- @return response
-- @return error_message
function M.DescribeSpotDatafeedSubscriptionSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotDatafeedSubscriptionAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePlacementGroups asynchronously, invoking a callback when done
-- @param DescribePlacementGroupsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribePlacementGroupsAsync(DescribePlacementGroupsRequest, cb)
	assert(DescribePlacementGroupsRequest, "You must provide a DescribePlacementGroupsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribePlacementGroups",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribePlacementGroupsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePlacementGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePlacementGroupsRequest
-- @return response
-- @return error_message
function M.DescribePlacementGroupsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePlacementGroupsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstances asynchronously, invoking a callback when done
-- @param DescribeInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInstancesAsync(DescribeInstancesRequest, cb)
	assert(DescribeInstancesRequest, "You must provide a DescribeInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstancesRequest
-- @return response
-- @return error_message
function M.DescribeInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateRoute asynchronously, invoking a callback when done
-- @param CreateRouteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateRouteAsync(CreateRouteRequest, cb)
	assert(CreateRouteRequest, "You must provide a CreateRouteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateRoute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateRouteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateRouteRequest
-- @return response
-- @return error_message
function M.CreateRouteSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateRouteAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteEgressOnlyInternetGateway asynchronously, invoking a callback when done
-- @param DeleteEgressOnlyInternetGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteEgressOnlyInternetGatewayAsync(DeleteEgressOnlyInternetGatewayRequest, cb)
	assert(DeleteEgressOnlyInternetGatewayRequest, "You must provide a DeleteEgressOnlyInternetGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteEgressOnlyInternetGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteEgressOnlyInternetGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteEgressOnlyInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteEgressOnlyInternetGatewayRequest
-- @return response
-- @return error_message
function M.DeleteEgressOnlyInternetGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteEgressOnlyInternetGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSecurityGroups asynchronously, invoking a callback when done
-- @param DescribeSecurityGroupsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSecurityGroupsAsync(DescribeSecurityGroupsRequest, cb)
	assert(DescribeSecurityGroupsRequest, "You must provide a DescribeSecurityGroupsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSecurityGroups",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSecurityGroupsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSecurityGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSecurityGroupsRequest
-- @return response
-- @return error_message
function M.DescribeSecurityGroupsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSecurityGroupsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateDhcpOptions asynchronously, invoking a callback when done
-- @param CreateDhcpOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateDhcpOptionsAsync(CreateDhcpOptionsRequest, cb)
	assert(CreateDhcpOptionsRequest, "You must provide a CreateDhcpOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateDhcpOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateDhcpOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateDhcpOptionsRequest
-- @return response
-- @return error_message
function M.CreateDhcpOptionsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateDhcpOptionsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RevokeSecurityGroupEgress asynchronously, invoking a callback when done
-- @param RevokeSecurityGroupEgressRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RevokeSecurityGroupEgressAsync(RevokeSecurityGroupEgressRequest, cb)
	assert(RevokeSecurityGroupEgressRequest, "You must provide a RevokeSecurityGroupEgressRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RevokeSecurityGroupEgress",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RevokeSecurityGroupEgressRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RevokeSecurityGroupEgress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RevokeSecurityGroupEgressRequest
-- @return response
-- @return error_message
function M.RevokeSecurityGroupEgressSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RevokeSecurityGroupEgressAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpnGateway asynchronously, invoking a callback when done
-- @param CreateVpnGatewayRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpnGatewayAsync(CreateVpnGatewayRequest, cb)
	assert(CreateVpnGatewayRequest, "You must provide a CreateVpnGatewayRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpnGateway",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpnGatewayRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpnGatewayRequest
-- @return response
-- @return error_message
function M.CreateVpnGatewaySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpnGatewayAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeBundleTasks asynchronously, invoking a callback when done
-- @param DescribeBundleTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeBundleTasksAsync(DescribeBundleTasksRequest, cb)
	assert(DescribeBundleTasksRequest, "You must provide a DescribeBundleTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeBundleTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeBundleTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeBundleTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeBundleTasksRequest
-- @return response
-- @return error_message
function M.DescribeBundleTasksSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeBundleTasksAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstancesListings asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesListingsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeReservedInstancesListingsAsync(DescribeReservedInstancesListingsRequest, cb)
	assert(DescribeReservedInstancesListingsRequest, "You must provide a DescribeReservedInstancesListingsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesListings",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeReservedInstancesListingsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstancesListings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesListingsRequest
-- @return response
-- @return error_message
function M.DescribeReservedInstancesListingsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesListingsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetReservedInstancesExchangeQuote asynchronously, invoking a callback when done
-- @param GetReservedInstancesExchangeQuoteRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetReservedInstancesExchangeQuoteAsync(GetReservedInstancesExchangeQuoteRequest, cb)
	assert(GetReservedInstancesExchangeQuoteRequest, "You must provide a GetReservedInstancesExchangeQuoteRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetReservedInstancesExchangeQuote",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetReservedInstancesExchangeQuoteRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call GetReservedInstancesExchangeQuote synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetReservedInstancesExchangeQuoteRequest
-- @return response
-- @return error_message
function M.GetReservedInstancesExchangeQuoteSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetReservedInstancesExchangeQuoteAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeClassicLinkInstances asynchronously, invoking a callback when done
-- @param DescribeClassicLinkInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeClassicLinkInstancesAsync(DescribeClassicLinkInstancesRequest, cb)
	assert(DescribeClassicLinkInstancesRequest, "You must provide a DescribeClassicLinkInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeClassicLinkInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeClassicLinkInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeClassicLinkInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeClassicLinkInstancesRequest
-- @return response
-- @return error_message
function M.DescribeClassicLinkInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeClassicLinkInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifySpotFleetRequest asynchronously, invoking a callback when done
-- @param ModifySpotFleetRequestRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifySpotFleetRequestAsync(ModifySpotFleetRequestRequest, cb)
	assert(ModifySpotFleetRequestRequest, "You must provide a ModifySpotFleetRequestRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifySpotFleetRequest",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifySpotFleetRequestRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifySpotFleetRequest synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifySpotFleetRequestRequest
-- @return response
-- @return error_message
function M.ModifySpotFleetRequestSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifySpotFleetRequestAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVolume asynchronously, invoking a callback when done
-- @param DeleteVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteVolumeAsync(DeleteVolumeRequest, cb)
	assert(DeleteVolumeRequest, "You must provide a DeleteVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVolumeRequest
-- @return response
-- @return error_message
function M.DeleteVolumeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVolumeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeConversionTasks asynchronously, invoking a callback when done
-- @param DescribeConversionTasksRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeConversionTasksAsync(DescribeConversionTasksRequest, cb)
	assert(DescribeConversionTasksRequest, "You must provide a DescribeConversionTasksRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeConversionTasks",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeConversionTasksRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeConversionTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeConversionTasksRequest
-- @return response
-- @return error_message
function M.DescribeConversionTasksSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeConversionTasksAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcClassicLinkDnsSupport asynchronously, invoking a callback when done
-- @param DescribeVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcClassicLinkDnsSupportAsync(DescribeVpcClassicLinkDnsSupportRequest, cb)
	assert(DescribeVpcClassicLinkDnsSupportRequest, "You must provide a DescribeVpcClassicLinkDnsSupportRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcClassicLinkDnsSupport",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcClassicLinkDnsSupportRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcClassicLinkDnsSupport synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcClassicLinkDnsSupportRequest
-- @return response
-- @return error_message
function M.DescribeVpcClassicLinkDnsSupportSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcClassicLinkDnsSupportAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSecurityGroup asynchronously, invoking a callback when done
-- @param DeleteSecurityGroupRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteSecurityGroupAsync(DeleteSecurityGroupRequest, cb)
	assert(DeleteSecurityGroupRequest, "You must provide a DeleteSecurityGroupRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteSecurityGroup",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteSecurityGroupRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSecurityGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSecurityGroupRequest
-- @return response
-- @return error_message
function M.DeleteSecurityGroupSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSecurityGroupAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSubnets asynchronously, invoking a callback when done
-- @param DescribeSubnetsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSubnetsAsync(DescribeSubnetsRequest, cb)
	assert(DescribeSubnetsRequest, "You must provide a DescribeSubnetsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSubnets",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSubnetsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSubnets synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSubnetsRequest
-- @return response
-- @return error_message
function M.DescribeSubnetsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSubnetsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcClassicLink asynchronously, invoking a callback when done
-- @param DescribeVpcClassicLinkRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeVpcClassicLinkAsync(DescribeVpcClassicLinkRequest, cb)
	assert(DescribeVpcClassicLinkRequest, "You must provide a DescribeVpcClassicLinkRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeVpcClassicLink",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeVpcClassicLinkRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcClassicLink synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcClassicLinkRequest
-- @return response
-- @return error_message
function M.DescribeVpcClassicLinkSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcClassicLinkAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIdentityIdFormat asynchronously, invoking a callback when done
-- @param DescribeIdentityIdFormatRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeIdentityIdFormatAsync(DescribeIdentityIdFormatRequest, cb)
	assert(DescribeIdentityIdFormatRequest, "You must provide a DescribeIdentityIdFormatRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeIdentityIdFormat",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeIdentityIdFormatRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIdentityIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIdentityIdFormatRequest
-- @return response
-- @return error_message
function M.DescribeIdentityIdFormatSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIdentityIdFormatAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcPeeringConnectionOptions asynchronously, invoking a callback when done
-- @param ModifyVpcPeeringConnectionOptionsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVpcPeeringConnectionOptionsAsync(ModifyVpcPeeringConnectionOptionsRequest, cb)
	assert(ModifyVpcPeeringConnectionOptionsRequest, "You must provide a ModifyVpcPeeringConnectionOptionsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVpcPeeringConnectionOptions",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVpcPeeringConnectionOptionsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcPeeringConnectionOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcPeeringConnectionOptionsRequest
-- @return response
-- @return error_message
function M.ModifyVpcPeeringConnectionOptionsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcPeeringConnectionOptionsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVolumeAttribute asynchronously, invoking a callback when done
-- @param ModifyVolumeAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVolumeAttributeAsync(ModifyVolumeAttributeRequest, cb)
	assert(ModifyVolumeAttributeRequest, "You must provide a ModifyVolumeAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVolumeAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVolumeAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVolumeAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVolumeAttributeRequest
-- @return response
-- @return error_message
function M.ModifyVolumeAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVolumeAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportVolume asynchronously, invoking a callback when done
-- @param ImportVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportVolumeAsync(ImportVolumeRequest, cb)
	assert(ImportVolumeRequest, "You must provide a ImportVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ImportVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportVolumeRequest
-- @return response
-- @return error_message
function M.ImportVolumeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportVolumeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportSnapshot asynchronously, invoking a callback when done
-- @param ImportSnapshotRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ImportSnapshotAsync(ImportSnapshotRequest, cb)
	assert(ImportSnapshotRequest, "You must provide a ImportSnapshotRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ImportSnapshot",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ImportSnapshotRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ImportSnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportSnapshotRequest
-- @return response
-- @return error_message
function M.ImportSnapshotSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportSnapshotAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call GetConsoleOutput asynchronously, invoking a callback when done
-- @param GetConsoleOutputRequest
-- @param cb Callback function accepting two args: response, error_message
function M.GetConsoleOutputAsync(GetConsoleOutputRequest, cb)
	assert(GetConsoleOutputRequest, "You must provide a GetConsoleOutputRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".GetConsoleOutput",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", GetConsoleOutputRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call GetConsoleOutput synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetConsoleOutputRequest
-- @return response
-- @return error_message
function M.GetConsoleOutputSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetConsoleOutputAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeTags asynchronously, invoking a callback when done
-- @param DescribeTagsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeTagsAsync(DescribeTagsRequest, cb)
	assert(DescribeTagsRequest, "You must provide a DescribeTagsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeTags",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeTagsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeTags synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeTagsRequest
-- @return response
-- @return error_message
function M.DescribeTagsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeTagsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVgwRoutePropagation asynchronously, invoking a callback when done
-- @param EnableVgwRoutePropagationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVgwRoutePropagationAsync(EnableVgwRoutePropagationRequest, cb)
	assert(EnableVgwRoutePropagationRequest, "You must provide a EnableVgwRoutePropagationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".EnableVgwRoutePropagation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", EnableVgwRoutePropagationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVgwRoutePropagation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVgwRoutePropagationRequest
-- @return response
-- @return error_message
function M.EnableVgwRoutePropagationSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVgwRoutePropagationAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcEndpoint asynchronously, invoking a callback when done
-- @param ModifyVpcEndpointRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVpcEndpointAsync(ModifyVpcEndpointRequest, cb)
	assert(ModifyVpcEndpointRequest, "You must provide a ModifyVpcEndpointRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVpcEndpoint",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVpcEndpointRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcEndpoint synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcEndpointRequest
-- @return response
-- @return error_message
function M.ModifyVpcEndpointSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcEndpointAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstanceStatus asynchronously, invoking a callback when done
-- @param DescribeInstanceStatusRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeInstanceStatusAsync(DescribeInstanceStatusRequest, cb)
	assert(DescribeInstanceStatusRequest, "You must provide a DescribeInstanceStatusRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeInstanceStatus",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeInstanceStatusRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstanceStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstanceStatusRequest
-- @return response
-- @return error_message
function M.DescribeInstanceStatusSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstanceStatusAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcAttribute asynchronously, invoking a callback when done
-- @param ModifyVpcAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVpcAttributeAsync(ModifyVpcAttributeRequest, cb)
	assert(ModifyVpcAttributeRequest, "You must provide a ModifyVpcAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVpcAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVpcAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcAttributeRequest
-- @return response
-- @return error_message
function M.ModifyVpcAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVolumeIO asynchronously, invoking a callback when done
-- @param EnableVolumeIORequest
-- @param cb Callback function accepting two args: response, error_message
function M.EnableVolumeIOAsync(EnableVolumeIORequest, cb)
	assert(EnableVolumeIORequest, "You must provide a EnableVolumeIORequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".EnableVolumeIO",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", EnableVolumeIORequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVolumeIO synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVolumeIORequest
-- @return response
-- @return error_message
function M.EnableVolumeIOSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVolumeIOAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateTags asynchronously, invoking a callback when done
-- @param CreateTagsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateTagsAsync(CreateTagsRequest, cb)
	assert(CreateTagsRequest, "You must provide a CreateTagsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateTags",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateTagsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateTags synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateTagsRequest
-- @return response
-- @return error_message
function M.CreateTagsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateTagsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSecurityGroupReferences asynchronously, invoking a callback when done
-- @param DescribeSecurityGroupReferencesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeSecurityGroupReferencesAsync(DescribeSecurityGroupReferencesRequest, cb)
	assert(DescribeSecurityGroupReferencesRequest, "You must provide a DescribeSecurityGroupReferencesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeSecurityGroupReferences",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeSecurityGroupReferencesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSecurityGroupReferences synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSecurityGroupReferencesRequest
-- @return response
-- @return error_message
function M.DescribeSecurityGroupReferencesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSecurityGroupReferencesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteFlowLogs asynchronously, invoking a callback when done
-- @param DeleteFlowLogsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DeleteFlowLogsAsync(DeleteFlowLogsRequest, cb)
	assert(DeleteFlowLogsRequest, "You must provide a DeleteFlowLogsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DeleteFlowLogs",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DeleteFlowLogsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteFlowLogs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteFlowLogsRequest
-- @return response
-- @return error_message
function M.DeleteFlowLogsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteFlowLogsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceNetworkAclAssociation asynchronously, invoking a callback when done
-- @param ReplaceNetworkAclAssociationRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ReplaceNetworkAclAssociationAsync(ReplaceNetworkAclAssociationRequest, cb)
	assert(ReplaceNetworkAclAssociationRequest, "You must provide a ReplaceNetworkAclAssociationRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ReplaceNetworkAclAssociation",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ReplaceNetworkAclAssociationRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceNetworkAclAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceNetworkAclAssociationRequest
-- @return response
-- @return error_message
function M.ReplaceNetworkAclAssociationSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceNetworkAclAssociationAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpnConnection asynchronously, invoking a callback when done
-- @param CreateVpnConnectionRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateVpnConnectionAsync(CreateVpnConnectionRequest, cb)
	assert(CreateVpnConnectionRequest, "You must provide a CreateVpnConnectionRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateVpnConnection",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateVpnConnectionRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpnConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpnConnectionRequest
-- @return response
-- @return error_message
function M.CreateVpnConnectionSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpnConnectionAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachClassicLinkVpc asynchronously, invoking a callback when done
-- @param DetachClassicLinkVpcRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DetachClassicLinkVpcAsync(DetachClassicLinkVpcRequest, cb)
	assert(DetachClassicLinkVpcRequest, "You must provide a DetachClassicLinkVpcRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DetachClassicLinkVpc",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DetachClassicLinkVpcRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DetachClassicLinkVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachClassicLinkVpcRequest
-- @return response
-- @return error_message
function M.DetachClassicLinkVpcSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachClassicLinkVpcAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateReservedInstancesListing asynchronously, invoking a callback when done
-- @param CreateReservedInstancesListingRequest
-- @param cb Callback function accepting two args: response, error_message
function M.CreateReservedInstancesListingAsync(CreateReservedInstancesListingRequest, cb)
	assert(CreateReservedInstancesListingRequest, "You must provide a CreateReservedInstancesListingRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".CreateReservedInstancesListing",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", CreateReservedInstancesListingRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call CreateReservedInstancesListing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateReservedInstancesListingRequest
-- @return response
-- @return error_message
function M.CreateReservedInstancesListingSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateReservedInstancesListingAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeHostReservations asynchronously, invoking a callback when done
-- @param DescribeHostReservationsRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeHostReservationsAsync(DescribeHostReservationsRequest, cb)
	assert(DescribeHostReservationsRequest, "You must provide a DescribeHostReservationsRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeHostReservations",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeHostReservationsRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeHostReservations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeHostReservationsRequest
-- @return response
-- @return error_message
function M.DescribeHostReservationsSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeHostReservationsAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeEgressOnlyInternetGateways asynchronously, invoking a callback when done
-- @param DescribeEgressOnlyInternetGatewaysRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeEgressOnlyInternetGatewaysAsync(DescribeEgressOnlyInternetGatewaysRequest, cb)
	assert(DescribeEgressOnlyInternetGatewaysRequest, "You must provide a DescribeEgressOnlyInternetGatewaysRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeEgressOnlyInternetGateways",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeEgressOnlyInternetGatewaysRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeEgressOnlyInternetGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeEgressOnlyInternetGatewaysRequest
-- @return response
-- @return error_message
function M.DescribeEgressOnlyInternetGatewaysSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeEgressOnlyInternetGatewaysAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyInstanceAttribute asynchronously, invoking a callback when done
-- @param ModifyInstanceAttributeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyInstanceAttributeAsync(ModifyInstanceAttributeRequest, cb)
	assert(ModifyInstanceAttributeRequest, "You must provide a ModifyInstanceAttributeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyInstanceAttribute",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyInstanceAttributeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyInstanceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyInstanceAttributeRequest
-- @return response
-- @return error_message
function M.ModifyInstanceAttributeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyInstanceAttributeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVolume asynchronously, invoking a callback when done
-- @param ModifyVolumeRequest
-- @param cb Callback function accepting two args: response, error_message
function M.ModifyVolumeAsync(ModifyVolumeRequest, cb)
	assert(ModifyVolumeRequest, "You must provide a ModifyVolumeRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".ModifyVolume",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", ModifyVolumeRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVolumeRequest
-- @return response
-- @return error_message
function M.ModifyVolumeSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVolumeAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call RunScheduledInstances asynchronously, invoking a callback when done
-- @param RunScheduledInstancesRequest
-- @param cb Callback function accepting two args: response, error_message
function M.RunScheduledInstancesAsync(RunScheduledInstancesRequest, cb)
	assert(RunScheduledInstancesRequest, "You must provide a RunScheduledInstancesRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".RunScheduledInstances",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", RunScheduledInstancesRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call RunScheduledInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RunScheduledInstancesRequest
-- @return response
-- @return error_message
function M.RunScheduledInstancesSync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RunScheduledInstancesAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeScheduledInstanceAvailability asynchronously, invoking a callback when done
-- @param DescribeScheduledInstanceAvailabilityRequest
-- @param cb Callback function accepting two args: response, error_message
function M.DescribeScheduledInstanceAvailabilityAsync(DescribeScheduledInstanceAvailabilityRequest, cb)
	assert(DescribeScheduledInstanceAvailabilityRequest, "You must provide a DescribeScheduledInstanceAvailabilityRequest")
	local headers = {
		[headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[headers.AMZ_TARGET_HEADER] = ".DescribeScheduledInstanceAvailability",
	}

	local request_handler, err = request_handlers.from_http_method("POST")
	if request_handler then
		request_handler(uri .. "/", DescribeScheduledInstanceAvailabilityRequest, headers, M.metadata, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeScheduledInstanceAvailability synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeScheduledInstanceAvailabilityRequest
-- @return response
-- @return error_message
function M.DescribeScheduledInstanceAvailabilitySync(...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeScheduledInstanceAvailabilityAsync(..., function(response, error_message)
		assert(coroutine.resume(co, response, error_message))
	end)
	return coroutine.yield()
end


return M
